// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Angstrom__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom = [0];
   runtime.caml_register_global(0, Angstrom, "Angstrom__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__More
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Angstrom_More = [0];
   runtime.caml_register_global(0, Angstrom_More, "Angstrom__More");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Exported_state
//# unitInfo: Requires: Stdlib, Stdlib__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ": ",
    cst$0 = " > ",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    _a_ = [1, "incomplete input"];
   function state_to_option(x){
    switch(x[0]){
      case 0:
       return 0;
      case 1:
       var v = x[2]; return [0, v];
      default: return 0;
    }
   }
   function fail_to_string(marks, err){
    var
     _b_ = caml_call2(Stdlib[28], cst, err),
     _c_ = caml_call2(Stdlib_String[7], cst$0, marks);
    return caml_call2(Stdlib[28], _c_, _b_);
   }
   function state_to_result(x){
    switch(x[0]){
      case 0:
       return _a_;
      case 1:
       var v = x[2]; return [0, v];
      default:
       var err = x[3], marks = x[2]; return [1, fail_to_string(marks, err)];
    }
   }
   var
    Angstrom_Exported_state =
      [0, state_to_option, fail_to_string, state_to_result];
   runtime.caml_register_global
    (5, Angstrom_Exported_state, "Angstrom__Exported_state");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Input
//# unitInfo: Requires: Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_input_ml = "lib/input.ml",
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Bigstringaf = global_data.Bigstringaf,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, cst_lib_input_ml, 60, 2],
    _b_ = [0, cst_lib_input_ml, 59, 2];
   function create(buffer, off, len, committed_bytes){
    return [0, committed_bytes, committed_bytes, off, len, buffer];
   }
   function length(t){return t[2] + t[4] | 0;}
   function client_committed_bytes(t){return t[2];}
   function parser_committed_bytes(t){return t[1];}
   function bytes_for_client_to_commit(t){return t[1] - t[2] | 0;}
   function parser_uncommitted_bytes(t){
    var _f_ = bytes_for_client_to_commit(t);
    return t[4] - _f_ | 0;
   }
   function invariant(t){
    var _c_ = length(t), _d_ = parser_uncommitted_bytes(t);
    if((t[1] + _d_ | 0) !== _c_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var _e_ = bytes_for_client_to_commit(t);
    if((t[1] - t[2] | 0) === _e_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function offset_in_buffer(t, pos){return (t[3] + pos | 0) - t[2] | 0;}
   function apply(t, pos, len, f){
    var off = offset_in_buffer(t, pos);
    return caml_call3(f, t[5], off, len);
   }
   function unsafe_get_char(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_ba_get_1(t[5], off);
   }
   function unsafe_get_int16_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[30], t[5], off);
   }
   function unsafe_get_int32_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[36], t[5], off);
   }
   function unsafe_get_int64_le(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[40], t[5], off);
   }
   function unsafe_get_int16_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[31], t[5], off);
   }
   function unsafe_get_int32_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[37], t[5], off);
   }
   function unsafe_get_int64_be(t, pos){
    var off = offset_in_buffer(t, pos);
    return caml_call2(Bigstringaf[41], t[5], off);
   }
   function count_while(t, pos, f){
    var
     buffer = t[5],
     off = offset_in_buffer(t, pos),
     i = [0, off],
     limit = t[3] + t[4] | 0;
    for(;;){
     if(i[1] < limit && caml_call1(f, caml_ba_get_1(buffer, i[1]))){i[1]++; continue;}
     return i[1] - off | 0;
    }
   }
   function commit(t, pos){t[1] = pos; return 0;}
   var
    Angstrom_Input =
      [0,
       create,
       length,
       client_committed_bytes,
       parser_committed_bytes,
       parser_uncommitted_bytes,
       bytes_for_client_to_commit,
       unsafe_get_char,
       unsafe_get_int16_le,
       unsafe_get_int32_le,
       unsafe_get_int64_le,
       unsafe_get_int16_be,
       unsafe_get_int32_be,
       unsafe_get_int64_be,
       count_while,
       apply,
       commit,
       invariant];
   runtime.caml_register_global(4, Angstrom_Input, "Angstrom__Input");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Parser
//# unitInfo: Requires: Angstrom__Exported_state, Angstrom__Input, Bigstringaf, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    State = [0];
   function fail_k(input, pos, param, marks, msg){
    return [3, pos - caml_call1(Angstrom_Input[3], input) | 0, marks, msg];
   }
   function succeed_k(input, pos, param, v){
    return [2, pos - caml_call1(Angstrom_Input[3], input) | 0, v];
   }
   function to_exported_state(param){
    var param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var match = param$0[1], continue$0 = match[2], committed = match[1];
        return [0,
                [0,
                 committed,
                 function(bs, off, len, more){
                  return to_exported_state
                          (caml_call4(continue$0, bs, off, len, more));
                 }]];
       case 1:
        var x = param$0[1], _c_ = runtime.caml_obj_tag(x);
        a:
        if(250 === _c_)
         var param$1 = x[1];
        else{
         if(246 !== _c_ && 244 !== _c_){var param$1 = x; break a;}
         var param$1 = caml_call1(CamlinternalLazy[2], x);
        }
        param$0 = param$1;
        break;
       case 2:
        var x$0 = param$0[2], i = param$0[1]; return [1, i, x$0];
       default:
        var s = param$0[3], sl = param$0[2], i$0 = param$0[1];
        return [2, i$0, sl, s];
     }
   }
   function parse(p){
    var input = caml_call4(Angstrom_Input[1], Bigstringaf[2], 0, 0, 0);
    return to_exported_state(caml_call5(p[1], input, 0, 1, fail_k, succeed_k));
   }
   function parse_bigstring(p, input){
    var
     _a_ = caml_call1(Bigstringaf[6], input),
     input$0 = caml_call4(Angstrom_Input[1], input, 0, _a_, 0),
     _b_ =
       to_exported_state(caml_call5(p[1], input$0, 0, 0, fail_k, succeed_k));
    return caml_call1(Angstrom_Exported_state[3], _b_);
   }
   function return$0(v){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4(succ, input, pos, more, v);
            }];
   }
   function fail(msg){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call5(fail, input, pos, more, 0, msg);
            }];
   }
   function symbol_bind(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call5
                      (caml_call1(f, v)[1], input, pos, more, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol_map(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, v){
              return caml_call4(succ, input, pos, more, caml_call1(f, v));
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol(f, m){return symbol_map(m, f);}
   function symbol$0(f, m){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, f){
              function succ1(input1, pos1, more1, m){
               return caml_call4(succ, input1, pos1, more1, caml_call1(f, m));
              }
              return caml_call5(m[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(f[1], input, pos, more, fail, succ0);
            }];
   }
   function lift(f, m){return symbol_map(m, f);}
   function lift2(f, m1, m2){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               return caml_call4
                       (succ, input2, pos2, more2, caml_call2(f, m1, m2));
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift3(f, m1, m2, m3){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                return caml_call4
                        (succ, input3, pos3, more3, caml_call3(f, m1, m2, m3));
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function lift4(f, m1, m2, m3, m4){
    return [0,
            function(input, pos, more, fail, succ){
             function succ1(input1, pos1, more1, m1){
              function succ2(input2, pos2, more2, m2){
               function succ3(input3, pos3, more3, m3){
                function succ4(input4, pos4, more4, m4){
                 return caml_call4
                         (succ, input4, pos4, more4, caml_call4(f, m1, m2, m3, m4));
                }
                return caml_call5(m4[1], input3, pos3, more3, fail, succ4);
               }
               return caml_call5(m3[1], input2, pos2, more2, fail, succ3);
              }
              return caml_call5(m2[1], input1, pos1, more1, fail, succ2);
             }
             return caml_call5(m1[1], input, pos, more, fail, succ1);
            }];
   }
   function symbol$1(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, pos, more, param){
              return caml_call5(b[1], input, pos, more, fail, succ);
             }
             return caml_call5(a[1], input, pos, more, fail, succ$0);
            }];
   }
   function symbol$2(a, b){
    return [0,
            function(input, pos, more, fail, succ){
             function succ0(input0, pos0, more0, x){
              function succ1(input1, pos1, more1, param){
               return caml_call4(succ, input1, pos1, more1, x);
              }
              return caml_call5(b[1], input0, pos0, more0, fail, succ1);
             }
             return caml_call5(a[1], input, pos, more, fail, succ0);
            }];
   }
   var
    Monad =
      [0,
       return$0,
       fail,
       symbol_bind,
       symbol_map,
       symbol,
       symbol$0,
       lift,
       lift2,
       lift3,
       lift4,
       symbol$1,
       symbol$2];
   function symbol$3(p, mark){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos, more, marks, msg){
              return caml_call5(fail, input, pos, more, [0, mark, marks], msg);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   function symbol$4(p, q){
    return [0,
            function(input, pos, more, fail, succ){
             function fail$0(input, pos$0, more$0, marks, msg){
              return pos < caml_call1(Angstrom_Input[4], input)
                      ? caml_call5(fail, input, pos$0, more, marks, msg)
                      : caml_call5(q[1], input, pos, more$0, fail, succ);
             }
             return caml_call5(p[1], input, pos, more, fail$0, succ);
            }];
   }
   var
    Choice = [0, symbol$3, symbol$4],
    return$1 = Monad[1],
    fail$0 = Monad[2],
    symbol_bind$0 = Monad[3];
   function symbol_map$0(m, f){
    return caml_call2
            (symbol_bind$0,
             m,
             function(x){return caml_call1(return$1, caml_call1(f, x));});
   }
   function symbol$5(f, m){return symbol_map$0(m, f);}
   function symbol$6(f, m){
    return caml_call2
            (symbol_bind$0, f, function(f){return symbol_map$0(m, f);});
   }
   function lift2$0(f, m1, m2){return symbol$6(symbol_map$0(m1, f), m2);}
   function lift3$0(f, m1, m2, m3){
    return symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3);
   }
   function lift4$0(f, m1, m2, m3, m4){
    return symbol$6(symbol$6(symbol$6(symbol_map$0(m1, f), m2), m3), m4);
   }
   function symbol$7(a, b){
    return caml_call2(symbol_bind$0, a, function(param){return b;});
   }
   function symbol$8(a, b){
    return caml_call2
            (symbol_bind$0,
             a,
             function(x){return symbol_map$0(b, function(param){return x;});});
   }
   var
    Monad_use_for_debugging =
      [0,
       return$1,
       fail$0,
       symbol_bind$0,
       symbol_map$0,
       symbol$5,
       symbol$6,
       symbol_map$0,
       lift2$0,
       lift3$0,
       lift4$0,
       symbol$7,
       symbol$8],
    Angstrom_Parser =
      [0,
       State,
       fail_k,
       succeed_k,
       to_exported_state,
       parse,
       parse_bigstring,
       Monad,
       Choice,
       Monad_use_for_debugging];
   runtime.caml_register_global(4, Angstrom_Parser, "Angstrom__Parser");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom__Buffering
//# unitInfo: Requires: Bigstringaf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lib_buffering_ml = "lib/buffering.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Bigstringaf = global_data.Bigstringaf,
    _a_ = [0, cst_lib_buffering_ml, 8, 2],
    _b_ = [0, cst_lib_buffering_ml, 7, 2],
    _c_ = [0, cst_lib_buffering_ml, 47, 2],
    _d_ = [0, cst_lib_buffering_ml, 46, 2],
    _e_ = [0, cst_lib_buffering_ml, 54, 2],
    _f_ = [0, cst_lib_buffering_ml, 53, 2],
    _g_ = [0, cst_lib_buffering_ml, 64, 2],
    _h_ = [0, cst_lib_buffering_ml, 79, 2];
   function of_bigstring(off, len, buf){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    if((len - off | 0) <= caml_call1(Bigstringaf[6], buf))
     return [0, buf, off, len];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function create(len){
    return of_bigstring(0, 0, caml_call1(Bigstringaf[1], len));
   }
   function writable_space(t){
    var _m_ = t[3];
    return caml_call1(Bigstringaf[6], t[1]) - _m_ | 0;
   }
   function ensure(t, to_copy){
    var
     _k_ = t[2] + t[3] | 0,
     _l_ = (caml_call1(Bigstringaf[6], t[1]) - _k_ | 0) < to_copy ? 1 : 0;
    if(! _l_) return _l_;
    if(to_copy <= writable_space(t)){
     caml_call5(Bigstringaf[44], t[1], t[2], t[1], 0, t[3]);
     t[2] = 0;
     return;
    }
    var
     old_len = caml_call1(Bigstringaf[6], t[1]),
     new_len = [0, old_len],
     space = writable_space(t);
    for(;;){
     if(((space + new_len[1] | 0) - old_len | 0) >= to_copy){
      var new_buf = caml_call1(Bigstringaf[1], new_len[1]);
      caml_call5(Bigstringaf[44], t[1], t[2], new_buf, 0, t[3]);
      t[1] = new_buf;
      t[2] = 0;
      return;
     }
     new_len[1] = (3 * new_len[1] | 0) / 2 | 0;
    }
   }
   function write_pos(t){return t[2] + t[3] | 0;}
   function feed_string(t, off, len, str){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    if((len - off | 0) > caml_ml_string_length(str))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    ensure(t, len);
    var _j_ = write_pos(t);
    caml_call5(Bigstringaf[45], str, off, t[1], _j_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_bigstring(t, off, len, b){
    if(0 > off)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    if((len - off | 0) > caml_call1(Bigstringaf[6], b))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    ensure(t, len);
    var _i_ = write_pos(t);
    caml_call5(Bigstringaf[44], b, off, t[1], _i_, len);
    t[3] = t[3] + len | 0;
    return 0;
   }
   function feed_input(t, param){
    if(608227697 <= param[1]){
     var b = param[2];
     return feed_bigstring(t, 0, caml_call1(Bigstringaf[6], b), b);
    }
    var s = param[2];
    return feed_string(t, 0, caml_ml_string_length(s), s);
   }
   function shift(t, n){
    if(n > t[3])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    t[2] = t[2] + n | 0;
    t[3] = t[3] - n | 0;
    return 0;
   }
   function for_reading(param){
    var buf = param[1], off = param[2], len = param[3];
    return caml_call3(Bigstringaf[5], buf, off, len);
   }
   function unconsumed(opt, param){
    var
     shift = opt ? opt[1] : 0,
     buf = param[1],
     off = param[2],
     len = param[3];
    if(shift <= len) return [0, buf, off + shift | 0, len - shift | 0];
    throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
   }
   function of_unconsumed(param){
    var len = param[3], off = param[2], buf = param[1];
    return [0, buf, off, len];
   }
   var
    Angstrom_Buffering =
      [0,
       create,
       of_bigstring,
       feed_string,
       feed_bigstring,
       feed_input,
       shift,
       for_reading,
       unconsumed,
       of_unconsumed];
   runtime.caml_register_global(10, Angstrom_Buffering, "Angstrom__Buffering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Angstrom
//# unitInfo: Requires: Angstrom__Buffering, Angstrom__Exported_state, Angstrom__Input, Angstrom__Parser, Bigstringaf, CamlinternalLazy, Stdlib, Stdlib__Char, Stdlib__Int32, Stdlib__Int64, Stdlib__List, Stdlib__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_count_while1$1 = "count_while1",
    cst_not_enough_input$1 = "not enough input",
    cst_satisfy = "satisfy: ",
    cst_satisfy_C = "satisfy: %C",
    caml_int32_float_of_bits = runtime.caml_int32_float_of_bits,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\r\n",
    Stdlib = global_data.Stdlib,
    Angstrom_Input = global_data.Angstrom__Input,
    Bigstringaf = global_data.Bigstringaf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom_Buffering = global_data.Angstrom__Buffering,
    Angstrom_Parser = global_data.Angstrom__Parser,
    Angstrom_Exported_state = global_data.Angstrom__Exported_state,
    Stdlib_Sys = global_data.Stdlib__Sys,
    parse = Angstrom_Parser[5],
    parse_bigstring = Angstrom_Parser[6],
    state_to_option = Angstrom_Exported_state[1],
    fail_to_string = Angstrom_Exported_state[2],
    state_to_result = Angstrom_Exported_state[3],
    _a_ = Angstrom_Parser[7],
    return$0 = _a_[1],
    fail = _a_[2],
    symbol_bind = _a_[3],
    symbol_map = _a_[4],
    symbol = _a_[5],
    symbol$0 = _a_[6],
    lift = _a_[7],
    lift2 = _a_[8],
    lift3 = _a_[9],
    lift4 = _a_[10],
    symbol$1 = _a_[11],
    symbol$2 = _a_[12],
    include = Angstrom_Parser[8],
    symbol$3 = include[1],
    symbol$4 = include[2],
    cst_parse_invalid_argument_ini =
      "parse: invalid argument, initial_buffer_size < 1",
    _b_ = [1, "incomplete input"],
    cst_prompt_input_shrunk = "prompt: input shrunk!",
    cst_not_enough_input = cst_not_enough_input$1,
    cst_not_enough_input$0 = cst_not_enough_input$1;
   function from_unbuffered_state(f, buffering, param){
    switch(param[0]){
      case 0:
       var p = param[1]; return [0, caml_call1(f, p)];
      case 1:
       var
        v = param[2],
        consumed = param[1],
        unconsumed =
          caml_call2(Angstrom_Buffering[8], [0, consumed], buffering);
       return [1, unconsumed, v];
      default:
       var
        msg = param[3],
        marks = param[2],
        consumed$0 = param[1],
        unconsumed$0 =
          caml_call2(Angstrom_Buffering[8], [0, consumed$0], buffering);
       return [2, unconsumed$0, marks, msg];
    }
   }
   function parse$0(opt, p){
    var initial_buffer_size = opt ? opt[1] : 4096;
    if(initial_buffer_size < 1)
     caml_call1(Stdlib[2], cst_parse_invalid_argument_ini);
    var buffering = caml_call1(Angstrom_Buffering[1], initial_buffer_size);
    function f(p, input){
     caml_call2(Angstrom_Buffering[6], buffering, p[1]);
     var
      more =
        typeof input === "number"
         ? 0
         : (caml_call2(Angstrom_Buffering[5], buffering, input), 1),
      for_reading = caml_call1(Angstrom_Buffering[7], buffering),
      _M_ = caml_call1(Bigstringaf[6], for_reading);
     return from_unbuffered_state
             (f, buffering, caml_call4(p[2], for_reading, 0, _M_, more));
    }
    return from_unbuffered_state(f, buffering, caml_call1(parse, p));
   }
   function feed(state, input){
    switch(state[0]){
      case 0:
       var k = state[1]; return caml_call1(k, input);
      case 1:
       var v = state[2], unconsumed = state[1];
       if(typeof input === "number") return state;
       var buffering = caml_call1(Angstrom_Buffering[9], unconsumed);
       caml_call2(Angstrom_Buffering[5], buffering, input);
       return [1, caml_call2(Angstrom_Buffering[8], 0, buffering), v];
      default:
       var msg = state[3], marks = state[2], unconsumed$0 = state[1];
       if(typeof input === "number") return state;
       var buffering$0 = caml_call1(Angstrom_Buffering[9], unconsumed$0);
       caml_call2(Angstrom_Buffering[5], buffering$0, input);
       return [2,
               caml_call2(Angstrom_Buffering[8], 0, buffering$0),
               marks,
               msg];
    }
   }
   function state_to_option$0(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var v = param[2]; return [0, v];
      default: return 0;
    }
   }
   function state_to_result$0(param){
    switch(param[0]){
      case 0:
       return _b_;
      case 1:
       var v = param[2]; return [0, v];
      default:
       var msg = param[3], marks = param[2];
       return [1, caml_call2(fail_to_string, marks, msg)];
    }
   }
   function state_to_unconsumed(param){
    if(0 === param[0]) return 0;
    var unconsumed = param[1];
    return [0, unconsumed];
   }
   function prompt(input, pos, fail, succ){
    var
     parser_uncommitted_bytes = caml_call1(Angstrom_Input[5], input),
     parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
    function continue$0(input, off, len, more){
     if(len < parser_uncommitted_bytes)
      caml_call1(Stdlib[2], cst_prompt_input_shrunk);
     var
      input$0 =
        caml_call4(Angstrom_Input[1], input, off, len, parser_committed_bytes);
     return len === parser_uncommitted_bytes
             ? more
               ? prompt(input$0, pos, fail, succ)
               : caml_call3(fail, input$0, pos, 0)
             : caml_call3(succ, input$0, pos, more);
    }
    return [0, [0, caml_call1(Angstrom_Input[6], input), continue$0]];
   }
   var
    demand_input =
      [0,
       function(input, pos, more, fail, succ){
        if(! more)
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input$0);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail$0(input, pos, more){
         return caml_call5(fail, input, pos, more, 0, cst_not_enough_input);
        }
        return prompt(input, pos, fail$0, succ$0);
       }];
   function ensure_suspended(n, input, pos, more, fail, succ){
    var go = [];
    caml_update_dummy
     (go,
      [0,
       function(input, pos, more, fail, succ){
        return (pos + n | 0) <= caml_call1(Angstrom_Input[2], input)
                ? caml_call4(succ, input, pos, more, 0)
                : caml_call5
                  (caml_call2(symbol$1, demand_input, go)[1],
                   input,
                   pos,
                   more,
                   fail,
                   succ);
       }]);
    return caml_call5
            (caml_call2(symbol$1, demand_input, go)[1],
             input,
             pos,
             more,
             fail,
             succ);
   }
   function unsafe_apply(len, f){
    return [0,
            function(input, pos, more, fail, succ){
             return caml_call4
                     (succ,
                      input,
                      pos + len | 0,
                      more,
                      caml_call4(Angstrom_Input[15], input, pos, len, f));
            }];
   }
   function ensure(n, p){
    return [0,
            function(input, pos, more, fail, succ){
             if((pos + n | 0) <= caml_call1(Angstrom_Input[2], input))
              return caml_call5(p[1], input, pos, more, fail, succ);
             function succ$0(input, pos, more, param){
              return caml_call5(p[1], input, pos, more, fail, succ);
             }
             return ensure_suspended(n, input, pos, more, fail, succ$0);
            }];
   }
   var
    at_end_of_input =
      [0,
       function(input, pos, more, param, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4(succ, input, pos, more, 0);
        if(! more) return caml_call4(succ, input, pos, more, 1);
        function succ$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        function fail(input, pos, more){
         return caml_call4(succ, input, pos, more, 1);
        }
        return prompt(input, pos, fail, succ$0);
       }],
    cst_end_of_input = "end_of_input",
    end_of_input =
      caml_call2
       (symbol_bind,
        at_end_of_input,
        function(param){
         return param
                 ? caml_call1(return$0, 0)
                 : caml_call1(fail, cst_end_of_input);
        }),
    cst_advance = "advance";
   function advance(n){
    if(0 > n) return caml_call1(fail, cst_advance);
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call4(succ, input, pos + n | 0, more, 0);
        }];
    return ensure(n, p);
   }
   var
    pos =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4(succ, input, pos, more, pos);
       }],
    available =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call1(Angstrom_Input[2], input) - pos | 0);
       }],
    commit =
      [0,
       function(input, pos, more, fail, succ){
        caml_call2(Angstrom_Input[16], input, pos);
        return caml_call4(succ, input, pos, more, 0);
       }];
   function unsafe_lookahead(p){
    return [0,
            function(input, pos, more, fail, succ){
             function succ$0(input, param, more, v){
              return caml_call4(succ, input, pos, more, v);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   var
    peek_char =
      [0,
       function(input, pos, more, fail, succ){
        if(pos < caml_call1(Angstrom_Input[2], input))
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        if(0 === more) return caml_call4(succ, input, pos, more, 0);
        function succ$0(input, pos, more){
         return caml_call4
                 (succ,
                  input,
                  pos,
                  more,
                  [0, caml_call2(Angstrom_Input[7], input, pos)]);
        }
        function fail$0(input, pos, more){
         return caml_call4(succ, input, pos, more, 0);
        }
        return prompt(input, pos, fail$0, succ$0);
       }],
    peek_char_fail = [];
   caml_update_dummy
    (peek_char_fail,
     [0,
      function(input, pos, more, fail, succ){
       if(pos < caml_call1(Angstrom_Input[2], input))
        return caml_call4
                (succ,
                 input,
                 pos,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       function succ$0(input, pos, more, param){
        return caml_call5(peek_char_fail[1], input, pos, more, fail, succ);
       }
       return ensure_suspended(1, input, pos, more, fail, succ$0);
      }]);
   var
    _c_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _d_ = [0, [11, cst_satisfy, [1, 0]], cst_satisfy_C],
    _e_ = [0, [11, "char ", [1, 0]], "char %C"],
    _f_ = [0, [11, "not char ", [1, 0]], "not char %C"];
   function satisfy(f){
    return [0,
            function(input, pos, more, fail, succ){
             if(pos >= caml_call1(Angstrom_Input[2], input)){
              var
               succ$0 =
                 function(input, pos, more, param){
                  var c = caml_call2(Angstrom_Input[7], input, pos);
                  if(caml_call1(f, c))
                   return caml_call4(succ, input, pos + 1 | 0, more, c);
                  var _L_ = caml_call4(fail, input, pos, more, 0);
                  return caml_call3(Stdlib_Printf[10], _L_, _d_, c);
                 };
              return ensure_suspended(1, input, pos, more, fail, succ$0);
             }
             var c = caml_call2(Angstrom_Input[7], input, pos);
             if(caml_call1(f, c))
              return caml_call4(succ, input, pos + 1 | 0, more, c);
             var _K_ = caml_call4(fail, input, pos, more, 0);
             return caml_call3(Stdlib_Printf[10], _K_, _c_, c);
            }];
   }
   function char$0(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[7], input, pos) === c
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _e_, c));
        }];
    return ensure(1, p);
   }
   function not_char(c){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c$0 = caml_call2(Angstrom_Input[7], input, pos);
         return c !== c$0
                 ? caml_call4(succ, input, pos + 1 | 0, more, c$0)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _f_, c));
        }];
    return ensure(1, p);
   }
   var
    p =
      [0,
       function(input, pos, more, fail, succ){
        return caml_call4
                (succ,
                 input,
                 pos + 1 | 0,
                 more,
                 caml_call2(Angstrom_Input[7], input, pos));
       }],
    any_char = ensure(1, p),
    _g_ = [0, [11, "int8 ", [4, 0, 0, 0, 0]], "int8 %d"];
   function int8(i){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var c = caml_call2(Angstrom_Input[7], input, pos);
         return c === (i & 255)
                 ? caml_call4(succ, input, pos + 1 | 0, more, c)
                 : caml_call5
                   (fail,
                    input,
                    pos,
                    more,
                    0,
                    caml_call2(Stdlib_Printf[4], _g_, i));
        }];
    return ensure(1, p);
   }
   var
    p$0 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c);
       }],
    any_uint8 = ensure(1, p$0),
    s = Stdlib_Sys[10] - 8 | 0,
    p$1 =
      [0,
       function(input, pos, more, fail, succ){
        var c = caml_call2(Angstrom_Input[7], input, pos);
        return caml_call4(succ, input, pos + 1 | 0, more, c << s >> s);
       }],
    any_int8 = ensure(1, p$1),
    cst_skip = "skip",
    cst_count_while1 = cst_count_while1$1,
    cst_count_while1$0 = cst_count_while1$1,
    _h_ = [1, "string"],
    cst_take_n_0 = "take: n < 0",
    cst_take_bigstring_n_0 = "take_bigstring: n < 0",
    cst_no_more_choices = "no more choices",
    cst_Angstrom_fix_direct_not_se = "Angstrom.fix_direct not set";
   function skip(f){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call1(f, caml_call2(Angstrom_Input[7], input, pos))
                 ? caml_call4(succ, input, pos + 1 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_skip);
        }];
    return ensure(1, p);
   }
   function count_while(init, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos + init | 0, f),
              input_len = caml_call1(Angstrom_Input[2], input),
              init$0 = init + len | 0;
             if((pos + init$0 | 0) >= input_len && 0 !== more){
              var
               succ$0 =
                 function(input, pos, more){
                  return count_while(init$0, f, with_buffer)[1].call
                          (null, input, pos, more, fail, succ);
                 },
               fail$0 =
                 function(input, pos, more){
                  return caml_call4
                          (succ,
                           input,
                           pos + init$0 | 0,
                           more,
                           caml_call4
                            (Angstrom_Input[15], input, pos, init$0, with_buffer));
                 };
              return prompt(input, pos, fail$0, succ$0);
             }
             return caml_call4
                     (succ,
                      input,
                      pos + init$0 | 0,
                      more,
                      caml_call4
                       (Angstrom_Input[15], input, pos, init$0, with_buffer));
            }];
   }
   function count_while1(f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              len = caml_call3(Angstrom_Input[14], input, pos, f),
              input_len = caml_call1(Angstrom_Input[2], input);
             if(1 <= len){
              if((pos + len | 0) >= input_len && 0 !== more){
               var
                succ$0 =
                  function(input, pos, more){
                   return count_while(len, f, with_buffer)[1].call
                           (null, input, pos, more, fail, succ);
                  },
                fail$0 =
                  function(input, pos, more){
                   return caml_call4
                           (succ,
                            input,
                            pos + len | 0,
                            more,
                            caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
                  };
               return prompt(input, pos, fail$0, succ$0);
              }
              return caml_call4
                      (succ,
                       input,
                       pos + len | 0,
                       more,
                       caml_call4(Angstrom_Input[15], input, pos, len, with_buffer));
             }
             if(pos >= input_len && 0 !== more){
              var
               succ$1 =
                 function(input, pos, more){
                  return count_while1(f, with_buffer)[1].call
                          (null, input, pos, more, fail, succ);
                 },
               fail$1 =
                 function(input, pos, more){
                  return caml_call5
                          (fail, input, pos, more, 0, cst_count_while1$0);
                 };
              return prompt(input, pos, fail$1, succ$1);
             }
             return caml_call5(fail, input, pos, more, 0, cst_count_while1);
            }];
   }
   function string(f, s){
    var len = caml_ml_string_length(s);
    function f$0(buffer, off, len){
     var i = [0, 0];
     for(;;){
      if(i[1] < len){
       var
        _I_ = caml_call1(f, runtime.caml_string_unsafe_get(s, i[1])),
        _J_ = caml_call1(f, runtime.caml_ba_get_1(buffer, off + i[1] | 0));
       if(caml_call2(Stdlib_Char[6], _J_, _I_)){i[1]++; continue;}
      }
      return len === i[1]
              ? [0, caml_call3(Bigstringaf[7], buffer, off, len)]
              : _h_;
     }
    }
    return ensure
            (len,
             [0,
              function(input, pos, more, fail, succ){
               var
                match = caml_call4(Angstrom_Input[15], input, pos, len, f$0);
               if(0 === match[0]){
                var x = match[1];
                return caml_call4(succ, input, pos + len | 0, more, x);
               }
               var e = match[1];
               return caml_call5(fail, input, pos, more, 0, e);
              }]);
   }
   function string$0(s){return string(function(x){return x;}, s);}
   function string_ci(s){return string(Stdlib_Char[3], s);}
   function skip_while(f){
    return count_while(0, f, function(_H_, _G_, param){return 0;});
   }
   function take(n){
    if(0 > n) return caml_call1(fail, cst_take_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[7]));
   }
   function take_bigstring(n){
    if(0 > n) return caml_call1(fail, cst_take_bigstring_n_0);
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, Bigstringaf[4]));
   }
   function take_bigstring_while(f){return count_while(0, f, Bigstringaf[4]);}
   function take_bigstring_while1(f){return count_while1(f, Bigstringaf[4]);}
   function take_bigstring_till(f){
    return take_bigstring_while(function(c){return 1 - caml_call1(f, c);});
   }
   function peek_string(n){return unsafe_lookahead(take(n));}
   function take_while(f){return count_while(0, f, Bigstringaf[7]);}
   function take_while1(f){return count_while1(f, Bigstringaf[7]);}
   function take_till(f){
    return take_while(function(c){return 1 - caml_call1(f, c);});
   }
   function choice(opt, ps){
    var
     failure_msg = opt ? opt[1] : cst_no_more_choices,
     _F_ = caml_call1(fail, failure_msg);
    return caml_call3(Stdlib_List[27], symbol$4, ps, _F_);
   }
   var
    notset =
      [0,
       function(buf, pos, more, fail, succ){
        return caml_call1(Stdlib[2], cst_Angstrom_fix_direct_not_se);
       }];
   function fix_direct(f){
    var p = [], r = [];
    caml_update_dummy(p, [0, notset]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        return caml_call5(p[1][1], buf, pos, more, fail, succ);
       }]);
    p[1] = caml_call1(f, r);
    return r;
   }
   function fix_lazy(max_steps, f){
    var steps = [0, max_steps], p = [], r = [];
    caml_update_dummy(p, [246, function(_E_){return caml_call1(f, r);}]);
    caml_update_dummy
     (r,
      [0,
       function(buf, pos, more, fail, succ){
        steps[1]--;
        if(0 > steps[1]){
         steps[1] = max_steps;
         return [1,
                 [246,
                  function(_B_){
                   var _C_ = caml_obj_tag(p);
                   a:
                   if(250 === _C_)
                    var _D_ = p[1];
                   else{
                    if(246 !== _C_ && 244 !== _C_){var _D_ = p; break a;}
                    var _D_ = caml_call1(CamlinternalLazy[2], p);
                   }
                   return caml_call5(_D_[1], buf, pos, more, fail, succ);
                  }]];
        }
        var _z_ = caml_obj_tag(p);
        a:
        if(250 === _z_)
         var _A_ = p[1];
        else{
         if(246 !== _z_ && 244 !== _z_){var _A_ = p; break a;}
         var _A_ = caml_call1(CamlinternalLazy[2], p);
        }
        return caml_call5(_A_[1], buf, pos, more, fail, succ);
       }]);
    return r;
   }
   var
    _i_ = Stdlib_Sys[5],
    cst_LE_int64 = "LE.int64",
    cst_LE_int32 = "LE.int32",
    cst_LE_int16 = "LE.int16",
    cst_BE_int64 = "BE.int64",
    cst_BE_int32 = "BE.int32",
    cst_BE_int16 = "BE.int16",
    cst_consumed_parser_committed = "consumed: parser committed",
    cst_count_n_0 = "count: n < 0",
    cst_end_of_line = "end_of_line",
    fix =
      typeof _i_ === "number"
       ? _i_ ? fix_direct : fix_direct
       : function(f){return fix_lazy(20, f);};
   function option(x, p){
    return caml_call2(symbol$4, p, caml_call1(return$0, x));
   }
   function cons(x, xs){return [0, x, xs];}
   function list(ps){
    if(! ps) return caml_call1(return$0, 0);
    var ps$0 = ps[2], p = ps[1];
    return caml_call3(lift2, cons, p, list(ps$0));
   }
   function count(n, p){
    if(0 > n) return caml_call1(fail, cst_count_n_0);
    function loop(n){
     return 0 === n
             ? caml_call1(return$0, 0)
             : caml_call3(lift2, cons, p, loop(n - 1 | 0));
    }
    return loop(n);
   }
   function many(p){
    return fix
            (function(m){
              var _y_ = caml_call1(return$0, 0);
              return caml_call2(symbol$4, caml_call3(lift2, cons, p, m), _y_);
             });
   }
   function many1(p){return caml_call3(lift2, cons, p, many(p));}
   function many_till(p, t){
    return fix
            (function(m){
              var _x_ = caml_call3(lift2, cons, p, m);
              return caml_call2
                      (symbol$4,
                       caml_call2(symbol$1, t, caml_call1(return$0, 0)),
                       _x_);
             });
   }
   function sep_by1(s, p){
    return fix
            (function(m){
              var _w_ = caml_call1(return$0, 0);
              return caml_call3
                      (lift2,
                       cons,
                       p,
                       caml_call2(symbol$4, caml_call2(symbol$1, s, m), _w_));
             });
   }
   function sep_by(s, p){
    var _u_ = caml_call1(return$0, 0), _v_ = caml_call1(return$0, 0);
    return caml_call2
            (symbol$4,
             caml_call3
              (lift2,
               cons,
               p,
               caml_call2
                (symbol$4, caml_call2(symbol$1, s, sep_by1(s, p)), _v_)),
             _u_);
   }
   function skip_many(p){
    return fix
            (function(m){
              var _t_ = caml_call1(return$0, 0);
              return caml_call2
                      (symbol_bind,
                       caml_call2
                        (symbol$4,
                         caml_call2(symbol_map, p, function(param){return 1;}),
                         _t_),
                       function(param){return param ? m : caml_call1(return$0, 0);});
             });
   }
   function skip_many1(p){return caml_call2(symbol$1, p, skip_many(p));}
   var
    _j_ = caml_call1(return$0, 0),
    _k_ = caml_call2(symbol$1, string$0(cst), _j_),
    _l_ = caml_call1(return$0, 0),
    end_of_line =
      caml_call2
       (symbol$3,
        caml_call2(symbol$4, caml_call2(symbol$1, char$0(10), _l_), _k_),
        cst_end_of_line);
   function scan(state, f, with_buffer){
    return [0,
            function(input, pos, more, fail, succ){
             var
              state$0 = [0, state],
              parser =
                caml_call2
                 (symbol_map,
                  count_while
                   (0,
                    function(c){
                     var match = caml_call2(f, state$0[1], c);
                     if(! match) return 0;
                     var state = match[1];
                     state$0[1] = state;
                     return 1;
                    },
                    with_buffer),
                  function(x){return [0, x, state$0[1]];});
             return caml_call5(parser[1], input, pos, more, fail, succ);
            }];
   }
   function scan$0(state, f){return scan(state, f, Bigstringaf[7]);}
   function scan_state(state, f){
    return caml_call2
            (symbol_map,
             scan(state, f, function(_s_, _r_, param){return 0;}),
             function(param){var state = param[2]; return state;});
   }
   function scan_string(state, f){
    return caml_call2
            (symbol_map, scan$0(state, f), function(_q_){return _q_[1];});
   }
   function consume_with(p, f){
    return [0,
            function(input, pos, more, fail, succ){
             var
              parser_committed_bytes = caml_call1(Angstrom_Input[4], input);
             function succ$0(input, pos$0, more, param){
              if
               (parser_committed_bytes
                !== caml_call1(Angstrom_Input[4], input))
               return caml_call5
                       (fail, input, pos$0, more, 0, cst_consumed_parser_committed);
              var
               len = pos$0 - pos | 0,
               consumed = caml_call4(Angstrom_Input[15], input, pos, len, f);
              return caml_call4(succ, input, pos$0, more, consumed);
             }
             return caml_call5(p[1], input, pos, more, fail, succ$0);
            }];
   }
   function consumed(p){return consume_with(p, Bigstringaf[7]);}
   function consumed_bigstring(p){return consume_with(p, Bigstringaf[4]);}
   function both(a, b){
    return caml_call3(lift2, function(a, b){return [0, a, b];}, a, b);
   }
   function map(t, f){return caml_call2(symbol_map, t, f);}
   function bind(t, f){return caml_call2(symbol_bind, t, f);}
   function map2(a, b, f){return caml_call3(lift2, f, a, b);}
   function map3(a, b, c, f){return caml_call4(lift3, f, a, b, c);}
   function map4(a, b, c, d, f){return caml_call5(lift4, f, a, b, c, d);}
   var
    Let_syntax = [0, return$0, map, bind, both, map2, map3, map4],
    Let_syntax$0 = [0, return$0, symbol_map, symbol_bind, Let_syntax];
   function int16(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[11], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int16);
        }];
    return ensure(2, p);
   }
   function int32(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _p_ = caml_call2(Angstrom_Input[12], input, pos);
         return caml_call2(Stdlib_Int32[17], _p_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int32);
        }];
    return ensure(4, p);
   }
   function int64(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _o_ = caml_call2(Angstrom_Input[13], input, pos);
         return caml_call2(Stdlib_Int64[17], _o_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_BE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[31], bs, off);
          })),
    any_int16 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[33], bs, off);
          })),
    any_int32 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[37], bs, off);
          })),
    any_int64 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[41], bs, off);
          })),
    any_float =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[37], bs, off));
          })),
    any_double =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[41], bs, off));
          }));
   function int16$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         return caml_call2(Angstrom_Input[8], input, pos) === (n & 65535)
                 ? caml_call4(succ, input, pos + 2 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int16);
        }];
    return ensure(2, p);
   }
   function int32$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _n_ = caml_call2(Angstrom_Input[9], input, pos);
         return caml_call2(Stdlib_Int32[17], _n_, n)
                 ? caml_call4(succ, input, pos + 4 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int32);
        }];
    return ensure(4, p);
   }
   function int64$0(n){
    var
     p =
       [0,
        function(input, pos, more, fail, succ){
         var _m_ = caml_call2(Angstrom_Input[10], input, pos);
         return caml_call2(Stdlib_Int64[17], _m_, n)
                 ? caml_call4(succ, input, pos + 8 | 0, more, 0)
                 : caml_call5(fail, input, pos, more, 0, cst_LE_int64);
        }];
    return ensure(8, p);
   }
   var
    any_uint16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[30], bs, off);
          })),
    any_int16$0 =
      ensure
       (2,
        unsafe_apply
         (2,
          function(bs, off, param){
           return caml_call2(Bigstringaf[32], bs, off);
          })),
    any_int32$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_call2(Bigstringaf[36], bs, off);
          })),
    any_int64$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_call2(Bigstringaf[40], bs, off);
          })),
    any_float$0 =
      ensure
       (4,
        unsafe_apply
         (4,
          function(bs, off, param){
           return caml_int32_float_of_bits
                   (caml_call2(Bigstringaf[36], bs, off));
          })),
    any_double$0 =
      ensure
       (8,
        unsafe_apply
         (8,
          function(bs, off, param){
           return caml_int64_float_of_bits
                   (caml_call2(Bigstringaf[40], bs, off));
          }));
   function take$0(n, f){
    var n$0 = caml_call2(Stdlib[17], n, 0);
    return ensure(n$0, unsafe_apply(n$0, f));
   }
   function peek(n, f){return unsafe_lookahead(take$0(n, f));}
   function take_while$0(check, f){return count_while(0, check, f);}
   function take_while1$0(check, f){return count_while1(check, f);}
   function take_till$0(check, f){
    return take_while$0(function(c){return 1 - caml_call1(check, c);}, f);
   }
   var Consume = [0];
   function parse_bigstring$0(consume, p, bs){
    var p$0 = consume ? caml_call2(symbol$2, p, end_of_input) : p;
    return caml_call2(parse_bigstring, p$0, bs);
   }
   function parse_string(consume, p, s){
    var len = caml_ml_string_length(s), bs = caml_call1(Bigstringaf[1], len);
    caml_call5(Bigstringaf[45], s, 0, bs, 0, len);
    return parse_bigstring$0(consume, p, bs);
   }
   var
    Angstrom =
      [0,
       peek_char,
       peek_char_fail,
       peek_string,
       char$0,
       not_char,
       any_char,
       satisfy,
       string$0,
       string_ci,
       skip,
       skip_while,
       take,
       take_while,
       take_while1,
       take_till,
       consumed,
       take_bigstring,
       take_bigstring_while,
       take_bigstring_while1,
       take_bigstring_till,
       consumed_bigstring,
       advance,
       end_of_line,
       at_end_of_input,
       end_of_input,
       scan$0,
       scan_state,
       scan_string,
       int8,
       any_uint8,
       any_int8,
       [0,
        int16,
        int32,
        int64,
        any_int16,
        any_int32,
        any_int64,
        any_uint16,
        any_float,
        any_double],
       [0,
        int16$0,
        int32$0,
        int64$0,
        any_int16$0,
        any_int32$0,
        any_int64$0,
        any_uint16$0,
        any_float$0,
        any_double$0],
       option,
       both,
       list,
       count,
       many,
       many1,
       many_till,
       sep_by,
       sep_by1,
       skip_many,
       skip_many1,
       fix,
       fix_lazy,
       symbol$4,
       choice,
       symbol$3,
       commit,
       return$0,
       fail,
       symbol_bind,
       bind,
       symbol_map,
       symbol$0,
       symbol,
       symbol$1,
       symbol$2,
       lift,
       lift2,
       lift3,
       lift4,
       map,
       map2,
       map3,
       map4,
       Let_syntax$0,
       symbol_map,
       symbol_bind,
       both,
       [0, take$0, take_while$0, take_while1$0, take_till$0, peek],
       Consume,
       parse_bigstring$0,
       parse_string,
       [0,
        parse$0,
        feed,
        state_to_option$0,
        state_to_result$0,
        state_to_unconsumed],
       [0, parse, state_to_option, state_to_result],
       pos,
       available];
   runtime.caml_register_global(43, Angstrom, "Angstrom");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5nc3Ryb20uY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJBbmdzdHJvbSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJBbmdzdHJvbV9Nb3JlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxnQkFBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwyIiwiZiIsImEwIiwiYTEiLCJnbG9iYWxfZGF0YSIsImNzdCIsIlN0ZGxpYiIsIlN0ZGxpYl9TdHJpbmciLCJzdGF0ZV90b19vcHRpb24iLCJ4IiwidiIsImZhaWxfdG9fc3RyaW5nIiwibWFya3MiLCJlcnIiLCJzdGF0ZV90b19yZXN1bHQiLCJBbmdzdHJvbV9FeHBvcnRlZF9zdGF0ZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL2FuZ3N0cm9tL2V4cG9ydGVkX3N0YXRlLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBO0FBQUEsWUFBQUMsZ0JBQUFDO0FBQUFBLElDVXdCO0FBQUE7QUFBQSxPQUdOO0FBQUE7QUFBQSxXQUFBQyxJQUhNLE1BQ047QUFBQSxlQUNBO0FBQUE7QUFBQSxHQUNJO0FBQUEsWUFBQUMsZUFBQUMsT0FBQUM7QUFBQUE7QUFBQUEsS0FBQSxNQUdRO0FBQUEsV0FBNUI7QUFBQSxJQUF5Qix1Q0FBYTtBQUFBO0FBQUEsWUFBQUMsZ0JBQUFMO0FBQUFBLElBRWhCO0FBQUE7QUFBQSxPQUVHO0FBQUE7QUFBQSxXQUFBQyxJQUZILE1BQ0c7QUFBQTtBQUFBLFdBQUFHLE1BREgsTUFBQUQsUUFBQSxNQUdTLHNDQUEwQjtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFHO0FBQUFBLE1EckIzRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwidHlwZSAnYSBzdGF0ZSA9XG4gIHwgUGFydGlhbCBvZiAnYSBwYXJ0aWFsXG4gIHwgRG9uZSAgICBvZiBpbnQgKiAnYVxuICB8IEZhaWwgICAgb2YgaW50ICogc3RyaW5nIGxpc3QgKiBzdHJpbmdcblxuYW5kICdhIHBhcnRpYWwgPVxuICB7IGNvbW1pdHRlZCA6IGludFxuICA7IGNvbnRpbnVlICA6IEJpZ3N0cmluZ2FmLnQgLT4gb2ZmOmludCAtPiBsZW46aW50IC0+IE1vcmUudCAtPiAnYSBzdGF0ZSB9XG5cblxubGV0IHN0YXRlX3RvX29wdGlvbiB4ID0gbWF0Y2ggeCB3aXRoXG4gIHwgRG9uZShfLCB2KSAtPiBTb21lIHZcbiAgfCBGYWlsIF8gICAgIC0+IE5vbmVcbiAgfCBQYXJ0aWFsIF8gIC0+IE5vbmVcblxubGV0IGZhaWxfdG9fc3RyaW5nIG1hcmtzIGVyciA9XG4gIFN0cmluZy5jb25jYXQgXCIgPiBcIiBtYXJrcyBeIFwiOiBcIiBeIGVyclxuXG5sZXQgc3RhdGVfdG9fcmVzdWx0IHggPSBtYXRjaCB4IHdpdGhcbiAgfCBEb25lKF8sIHYpICAgICAgICAgIC0+IE9rIHZcbiAgfCBQYXJ0aWFsIF8gICAgICAgICAgIC0+IEVycm9yIFwiaW5jb21wbGV0ZSBpbnB1dFwiXG4gIHwgRmFpbChfLCBtYXJrcywgZXJyKSAtPiBFcnJvciAoZmFpbF90b19zdHJpbmcgbWFya3MgZXJyKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfbGliX2lucHV0X21sIiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkJpZ3N0cmluZ2FmIiwiQXNzZXJ0X2ZhaWx1cmUiLCJjcmVhdGUiLCJidWZmZXIiLCJvZmYiLCJsZW4iLCJjb21taXR0ZWRfYnl0ZXMiLCJsZW5ndGgiLCJ0IiwiY2xpZW50X2NvbW1pdHRlZF9ieXRlcyIsInBhcnNlcl9jb21taXR0ZWRfYnl0ZXMiLCJieXRlc19mb3JfY2xpZW50X3RvX2NvbW1pdCIsInBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyIsImludmFyaWFudCIsIm9mZnNldF9pbl9idWZmZXIiLCJwb3MiLCJhcHBseSIsInVuc2FmZV9nZXRfY2hhciIsInVuc2FmZV9nZXRfaW50MTZfbGUiLCJ1bnNhZmVfZ2V0X2ludDMyX2xlIiwidW5zYWZlX2dldF9pbnQ2NF9sZSIsInVuc2FmZV9nZXRfaW50MTZfYmUiLCJ1bnNhZmVfZ2V0X2ludDMyX2JlIiwidW5zYWZlX2dldF9pbnQ2NF9iZSIsImNvdW50X3doaWxlIiwiaSIsImxpbWl0IiwiY29tbWl0IiwiQW5nc3Ryb21fSW5wdXQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9hbmdzdHJvbS9pbnB1dC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsT0FBQUMsUUFBQUMsS0FBQUMsS0FBQUM7QUFBQUEsSUMwQ0U7QUFBQSxHQUlVO0FBQUEsWUFBQUMsT0FBQUMsR0FFbUIsdUJBQWdDO0FBQUEsWUFBQUMsdUJBQUFELEdBQ2hDLFlBQXdCO0FBQUEsWUFBQUUsdUJBQUFGLEdBQ3hCLFlBQXdCO0FBQUEsWUFBQUcsMkJBQUFILEdBRW5CLHVCQUM2QjtBQUFBLFlBQUFJLHlCQUFBSjtBQUFBQSxRQUFBLE1BRXhCO0FBQUEsSUFBNEI7QUFBQTtBQUFBLFlBQUFLLFVBQUFMO0FBQUFBLFFBQUEsTUFHSCxpQkFBN0I7QUFBQSxJQUFIO0FBQUE7QUFBQSxjQUNnQztBQUFBLElBQWhDO0FBQUE7QUFBQSxHQUE4RDtBQUFBLFlBQUFNLGlCQUFBTixHQUFBTyxLQUk5RixtQ0FBc0M7QUFBQSxZQUFBQyxNQUFBUixHQUFBTyxLQUFBVixLQUFBWjtBQUFBQSxRQUFBVyxNQUc1QjtBQUFBLElBQ1Ysb0NBQW9CO0FBQUE7QUFBQSxZQUFBYSxnQkFBQVQsR0FBQU87QUFBQUEsUUFBQVgsTUFHVjtBQUFBLElBQ1YsK0JBQW1DO0FBQUE7QUFBQSxZQUFBYyxvQkFBQVYsR0FBQU87QUFBQUEsUUFBQVgsTUFHekI7QUFBQSxJQUNWLDZDQUE0QztBQUFBO0FBQUEsWUFBQWUsb0JBQUFYLEdBQUFPO0FBQUFBLFFBQUFYLE1BR2xDO0FBQUEsSUFDViw2Q0FBNEM7QUFBQTtBQUFBLFlBQUFnQixvQkFBQVosR0FBQU87QUFBQUEsUUFBQVgsTUFHbEM7QUFBQSxJQUNWLDZDQUE0QztBQUFBO0FBQUEsWUFBQWlCLG9CQUFBYixHQUFBTztBQUFBQSxRQUFBWCxNQUdsQztBQUFBLElBQ1YsNkNBQTRDO0FBQUE7QUFBQSxZQUFBa0Isb0JBQUFkLEdBQUFPO0FBQUFBLFFBQUFYLE1BR2xDO0FBQUEsSUFDViw2Q0FBNEM7QUFBQTtBQUFBLFlBQUFtQixvQkFBQWYsR0FBQU87QUFBQUEsUUFBQVgsTUFHbEM7QUFBQSxJQUNWLDZDQUE0QztBQUFBO0FBQUEsWUFBQW9CLFlBQUFoQixHQUFBTyxLQUFBdEI7QUFBQUE7QUFBQUEsS0FBQVUsU0FHNUM7QUFBQSxLQUFBQyxNQUNhO0FBQUEsS0FBQXFCLElBQ2I7QUFBQSxLQUFBQyxRQUNBO0FBQUEsSUFDQTtBQUFBLHdCQUFvQixjQUFFLDhCQUNwQjtBQUFBLEtBRUY7QUFBQTtBQUFBLEdBQVE7QUFBQSxZQUFBQyxPQUFBbkIsR0FBQU8sS0FJUixxQkFBK0I7QUFBQTtBQUFBLElBQUFhO0FBQUFBLE1EN0dqQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ29weXJpZ2h0IChjKSAyMDE3IEluaGFiaXRlZCBUeXBlIExMQy5cblxuICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgaGlzIGNvbnRyaWJ1dG9yc1xuICAgICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICAgICAgIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1NcbiAgICBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICAgIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkVcbiAgICBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbiAgICBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG4gICAgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAgICBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAgICBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsXG4gICAgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOXG4gICAgQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gICAgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qKVxuXG50eXBlIHQgPVxuICB7IG11dGFibGUgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA6IGludFxuICA7IGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgICAgICAgICA6IGludFxuICA7IG9mZiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGludFxuICA7IGxlbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGludFxuICA7IGJ1ZmZlciAgICAgICAgICAgICAgICAgICAgICAgICA6IEJpZ3N0cmluZ2FmLnRcbiAgfVxuXG5sZXQgY3JlYXRlIGJ1ZmZlciB+b2ZmIH5sZW4gfmNvbW1pdHRlZF9ieXRlcyA9XG4gIHsgcGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA9IGNvbW1pdHRlZF9ieXRlc1xuICA7IGNsaWVudF9jb21taXR0ZWRfYnl0ZXMgPSBjb21taXR0ZWRfYnl0ZXNcbiAgOyBvZmZcbiAgOyBsZW5cbiAgOyBidWZmZXIgfVxuXG5sZXQgbGVuZ3RoICAgICAgICAgICAgICAgICB0ID0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzICsgdC5sZW5cbmxldCBjbGllbnRfY29tbWl0dGVkX2J5dGVzIHQgPSB0LmNsaWVudF9jb21taXR0ZWRfYnl0ZXNcbmxldCBwYXJzZXJfY29tbWl0dGVkX2J5dGVzIHQgPSB0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXNcblxubGV0IGNvbW1pdHRlZF9ieXRlc19kaXNjcmVwYW5jeSB0ID0gdC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIC0gdC5jbGllbnRfY29tbWl0dGVkX2J5dGVzXG5sZXQgYnl0ZXNfZm9yX2NsaWVudF90b19jb21taXQgIHQgPSBjb21taXR0ZWRfYnl0ZXNfZGlzY3JlcGFuY3kgdFxuXG5sZXQgcGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIHQgPSB0LmxlbiAtIGJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0IHRcblxubGV0IGludmFyaWFudCB0ID1cbiAgYXNzZXJ0IChwYXJzZXJfY29tbWl0dGVkX2J5dGVzIHQgKyBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdCA9IGxlbmd0aCB0KTtcbiAgYXNzZXJ0IChwYXJzZXJfY29tbWl0dGVkX2J5dGVzIHQgLSBjbGllbnRfY29tbWl0dGVkX2J5dGVzICAgdCA9IGJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0IHQpO1xuOztcblxubGV0IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgPVxuICB0Lm9mZiArIHBvcyAtIHQuY2xpZW50X2NvbW1pdHRlZF9ieXRlc1xuXG5sZXQgYXBwbHkgdCBwb3MgbGVuIH5mID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgZiB0LmJ1ZmZlciB+b2ZmIH5sZW5cblxubGV0IHVuc2FmZV9nZXRfY2hhciB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDE2X2xlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9sZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MzJfbGUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2xlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQ2NF9sZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfbGUgdC5idWZmZXIgb2ZmXG5cbmxldCB1bnNhZmVfZ2V0X2ludDE2X2JlIHQgcG9zID1cbiAgbGV0IG9mZiA9IG9mZnNldF9pbl9idWZmZXIgdCBwb3MgaW5cbiAgQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9iZSB0LmJ1ZmZlciBvZmZcblxubGV0IHVuc2FmZV9nZXRfaW50MzJfYmUgdCBwb3MgPVxuICBsZXQgb2ZmID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIHQuYnVmZmVyIG9mZlxuXG5sZXQgdW5zYWZlX2dldF9pbnQ2NF9iZSB0IHBvcyA9XG4gIGxldCBvZmYgPSBvZmZzZXRfaW5fYnVmZmVyIHQgcG9zIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfYmUgdC5idWZmZXIgb2ZmXG5cbmxldCBjb3VudF93aGlsZSB0IHBvcyB+ZiA9XG4gIGxldCBidWZmZXIgPSB0LmJ1ZmZlciBpblxuICBsZXQgb2ZmICAgID0gb2Zmc2V0X2luX2J1ZmZlciB0IHBvcyBpblxuICBsZXQgaSAgICAgID0gcmVmIG9mZiBpblxuICBsZXQgbGltaXQgID0gdC5vZmYgKyB0LmxlbiBpblxuICB3aGlsZSAhaSA8IGxpbWl0ICYmIGYgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXQgYnVmZmVyICFpKSBkb1xuICAgIGluY3IgaVxuICBkb25lO1xuICAhaSAtIG9mZlxuOztcblxubGV0IGNvbW1pdCB0IHBvcyA9XG4gIHQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyA8LSBwb3Ncbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJDYW1saW50ZXJuYWxMYXp5IiwiQW5nc3Ryb21fSW5wdXQiLCJCaWdzdHJpbmdhZiIsIkFuZ3N0cm9tX0V4cG9ydGVkX3N0YXRlIiwiU3RhdGUiLCJmYWlsX2siLCJpbnB1dCIsInBvcyIsInBhcmFtIiwibWFya3MiLCJtc2ciLCJzdWNjZWVkX2siLCJ2IiwidG9fZXhwb3J0ZWRfc3RhdGUiLCJtYXRjaCIsImNvbnRpbnVlIiwiY29tbWl0dGVkIiwiYnMiLCJvZmYiLCJsZW4iLCJtb3JlIiwieCIsImkiLCJzIiwic2wiLCJwYXJzZSIsInAiLCJwYXJzZV9iaWdzdHJpbmciLCJyZXR1cm4iLCJmYWlsIiwic3VjYyIsInN5bWJvbF9iaW5kIiwic3ltYm9sX21hcCIsInN5bWJvbCIsIm0iLCJzdWNjMCIsImlucHV0MCIsInBvczAiLCJtb3JlMCIsInN1Y2MxIiwiaW5wdXQxIiwicG9zMSIsIm1vcmUxIiwibGlmdCIsImxpZnQyIiwibTEiLCJtMiIsInN1Y2MyIiwiaW5wdXQyIiwicG9zMiIsIm1vcmUyIiwibGlmdDMiLCJtMyIsInN1Y2MzIiwiaW5wdXQzIiwicG9zMyIsIm1vcmUzIiwibGlmdDQiLCJtNCIsInN1Y2M0IiwiaW5wdXQ0IiwicG9zNCIsIm1vcmU0IiwiYSIsImIiLCJNb25hZCIsIm1hcmsiLCJxIiwiQ2hvaWNlIiwiTW9uYWRfdXNlX2Zvcl9kZWJ1Z2dpbmciLCJBbmdzdHJvbV9QYXJzZXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9hbmdzdHJvbS9wYXJzZXIubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLFlBQUFDLE9BQUFDLE9BQUFDLEtBQUFDLE9BQUFDLE9BQUFDO0FBQUFBLElDcUJtQixzRUFBa0M7QUFBQSxHQUFhO0FBQUEsWUFBQUMsVUFBQUwsT0FBQUMsS0FBQUMsT0FBQUk7QUFBQUEsSUFFL0MsNkRBQWtDO0FBQUEsR0FBSTtBQUFBLFlBQUFDLGtCQUFBTDtBQUFBQSxRQUFBQSxVQUU3QjtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFNLFFBQUEsWUFBQUMsYUFBQSxVQUFBQyxZQUFBO0FBQUEsUUFFdkI7QUFBQTtBQUFBO0FBQUEsMEJBQUFDLElBQUFDLEtBQUFDLEtBQUFDO0FBQUFBLGtCQUl3QixPQUE0QjtBQUFBLDJCQUE1QiwyQ0FBNEI7QUFBQSxvQkFKcEQ7QUFBQTtBQUFBLFlBQUFDLElBRnVCLGtCQVNSO0FBQUE7QUFBQTtBQUFBLGFBQUFiLFVBQUE7QUFBQTtBQUFBLDRDQUFBQSxVQUFBO0FBQUEsYUFBQUEsVUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQWEsTUFUUSxZQUFBQyxJQUFBLFlBT0o7QUFBQTtBQUFBLFlBQUFDLElBUEksWUFBQUMsS0FBQSxZQUFBRixNQUFBO0FBQUEsUUFRQztBQUFBO0FBQUEsR0FDdUI7QUFBQSxZQUFBRyxNQUFBQztBQUFBQSxRQUFBcEIsUUFHdEM7QUFBQSxJQUNNLE9BQTJDLGtCQUEzQyxpREFBMkM7QUFBQTtBQUFBLFlBQUFxQixnQkFBQUQsR0FBQXBCO0FBQUFBO0FBQUFBLEtBQUEsTUFHQztBQUFBLEtBQUFBLFVBQWxEO0FBQUE7QUFBQSxPQUNtQixrQkFBbUI7QUFBQSxJQUEwQztBQUFBO0FBQUEsWUFBQXNCLFNBQUFoQjtBQUFBQSxJQUkxRjtBQUFBLHFCQUFBTixPQUFBQyxLQUFBYSxNQUFBUyxNQUFBQztBQUFBQSxhQUNFLDRDQUFxQjtBQUFBLGNBRHZCO0FBQUEsR0FFQztBQUFBLFlBQUFELEtBQUFuQjtBQUFBQSxJQUdEO0FBQUEscUJBQUFKLE9BQUFDLEtBQUFhLE1BQUFTLE1BQUFDO0FBQUFBLGFBQ0UsaURBQTBCO0FBQUEsY0FENUI7QUFBQSxHQUVDO0FBQUEsWUFBQUMsWUFBQUwsR0FBQXJDO0FBQUFBLElBR0Q7QUFBQSxxQkFBQWlCLE9BQUFDLEtBQUFhLE1BQUFTLE1BQUFDO0FBQUFBLHNCQUFBQSxPQUFBeEIsT0FBQUMsS0FBQWEsTUFBQVI7QUFBQUEsY0FDa0MsT0FBSztBQUFBLHVCQUFMLGtEQUFxQztBQUFBO0FBQUEsYUFDckUsdURBQStCO0FBQUEsY0FGakM7QUFBQSxHQUdDO0FBQUEsWUFBQW9CLFdBQUFOLEdBQUFyQztBQUFBQSxJQUdEO0FBQUEscUJBQUFpQixPQUFBQyxLQUFBYSxNQUFBUyxNQUFBQztBQUFBQSxzQkFBQUEsT0FBQXhCLE9BQUFDLEtBQUFhLE1BQUFSO0FBQUFBLGNBQ3lELE9BQUssbUNBQUwsaUJBQUs7QUFBQTtBQUFBLGFBQzVELHVEQUErQjtBQUFBLGNBRmpDO0FBQUEsR0FHQztBQUFBLFlBQUFxQixPQUFBNUMsR0FBQTZDLEdBR0QsdUJBQU87QUFBQSxZQUFBRCxTQUFBNUMsR0FBQTZDO0FBQUFBLElBSVA7QUFBQSxxQkFBQTVCLE9BQUFDLEtBQUFhLE1BQUFTLE1BQUFDO0FBQUFBLHNCQUFBSyxNQUFBQyxRQUFBQyxNQUFBQyxPQUFBakQ7QUFBQUEsdUJBQUFrRCxNQUFBQyxRQUFBQyxNQUFBQyxPQUFBUjtBQUFBQSxlQUUyRCxPQUFLLHNDQUFMLGlCQUFLO0FBQUE7QUFBQSxjQUM1RCx5REFBa0M7QUFBQTtBQUFBLGFBRXBDLHNEQUErQjtBQUFBLGNBTGpDO0FBQUEsR0FLbUM7QUFBQSxZQUFBUyxLQUFBdEQsR0FBQTZDLEdBVG5DLHVCQVlPO0FBQUEsWUFBQVUsTUFBQXZELEdBQUF3RCxJQUFBQztBQUFBQSxJQUdQO0FBQUEscUJBQUF4QyxPQUFBQyxLQUFBYSxNQUFBUyxNQUFBQztBQUFBQSxzQkFBQVMsTUFBQUMsUUFBQUMsTUFBQUMsT0FBQUc7QUFBQUEsdUJBQUFFLE1BQUFDLFFBQUFDLE1BQUFDLE9BQUFKO0FBQUFBLGVBRTRELE9BQVM7QUFBQSxtREFBVCxzQkFBUztBQUFBO0FBQUEsY0FDakUsMERBQW1DO0FBQUE7QUFBQSxhQUVyQyx1REFBZ0M7QUFBQSxjQUxsQztBQUFBLEdBS29DO0FBQUEsWUFBQUssTUFBQTlELEdBQUF3RCxJQUFBQyxJQUFBTTtBQUFBQSxJQUdwQztBQUFBLHFCQUFBOUMsT0FBQUMsS0FBQWEsTUFBQVMsTUFBQUM7QUFBQUEsc0JBQUFTLE1BQUFDLFFBQUFDLE1BQUFDLE9BQUFHO0FBQUFBLHVCQUFBRSxNQUFBQyxRQUFBQyxNQUFBQyxPQUFBSjtBQUFBQSx3QkFBQU8sTUFBQUMsUUFBQUMsTUFBQUMsT0FBQUo7QUFBQUEsZ0JBSStCLE9BQVk7QUFBQSxvREFBWiwwQkFBWTtBQUFBO0FBQUEsZUFDckMsMERBQW1DO0FBQUE7QUFBQSxjQUNyQywwREFBbUM7QUFBQTtBQUFBLGFBRXJDLHVEQUFnQztBQUFBLGNBUmxDO0FBQUEsR0FRb0M7QUFBQSxZQUFBSyxNQUFBcEUsR0FBQXdELElBQUFDLElBQUFNLElBQUFNO0FBQUFBLElBR3BDO0FBQUEscUJBQUFwRCxPQUFBQyxLQUFBYSxNQUFBUyxNQUFBQztBQUFBQSxzQkFBQVMsTUFBQUMsUUFBQUMsTUFBQUMsT0FBQUc7QUFBQUEsdUJBQUFFLE1BQUFDLFFBQUFDLE1BQUFDLE9BQUFKO0FBQUFBLHdCQUFBTyxNQUFBQyxRQUFBQyxNQUFBQyxPQUFBSjtBQUFBQSx5QkFBQU8sTUFBQUMsUUFBQUMsTUFBQUMsT0FBQUo7QUFBQUEsaUJBS2lDLE9BQWU7QUFBQSxxREFBZiw4QkFBZTtBQUFBO0FBQUEsZ0JBQ3hDLDBEQUFtQztBQUFBO0FBQUEsZUFDckMsMERBQW1DO0FBQUE7QUFBQSxjQUNyQywwREFBbUM7QUFBQTtBQUFBLGFBRXJDLHVEQUFnQztBQUFBLGNBVmxDO0FBQUEsR0FVb0M7QUFBQSxZQUFBekIsU0FBQThCLEdBQUFDO0FBQUFBLElBSXBDO0FBQUEscUJBQUExRCxPQUFBQyxLQUFBYSxNQUFBUyxNQUFBQztBQUFBQSxzQkFBQUEsT0FBQXhCLE9BQUFDLEtBQUFhLE1BQUFaO0FBQUFBLGNBQ2tDLHFEQUFpQztBQUFBO0FBQUEsYUFDakUsdURBQStCO0FBQUEsY0FGakM7QUFBQSxHQUdDO0FBQUEsWUFBQXlCLFNBQUE4QixHQUFBQztBQUFBQSxJQUlEO0FBQUEscUJBQUExRCxPQUFBQyxLQUFBYSxNQUFBUyxNQUFBQztBQUFBQSxzQkFBQUssTUFBQUMsUUFBQUMsTUFBQUMsT0FBQWpCO0FBQUFBLHVCQUFBa0IsTUFBQUMsUUFBQUMsTUFBQUMsT0FBQWxDO0FBQUFBLGVBRW9DLCtDQUF3QjtBQUFBO0FBQUEsY0FDeEQseURBQWtDO0FBQUE7QUFBQSxhQUVwQyxzREFBK0I7QUFBQSxjQUxqQztBQUFBLEdBS21DO0FBQUE7QUFBQSxJQUFBeUQ7QUFBQUEsTURoSXZDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQWhDLFNBQUFQLEdBQUF3QztBQUFBQSxJQ3FJSTtBQUFBLHFCQUFBNUQsT0FBQUMsS0FBQWEsTUFBQVMsTUFBQUM7QUFBQUEsc0JBQUFELE9BQUF2QixPQUFBQyxLQUFBYSxNQUFBWCxPQUFBQztBQUFBQSxjQUVJLGdFQUF3QztBQUFBO0FBQUEsYUFDMUMsdURBQStCO0FBQUEsY0FIakM7QUFBQSxHQUlDO0FBQUEsWUFBQXVCLFNBQUFQLEdBQUF5QztBQUFBQSxJQUdEO0FBQUEscUJBQUE3RCxPQUFBQyxLQUFBYSxNQUFBUyxNQUFBQztBQUFBQSxzQkFBQUQsT0FBQXZCLE9BQUFDLE9BQUFhLFFBQUFYLE9BQUFDO0FBQUFBLGNBT2E7QUFBQSx3QkFDUDtBQUFBLHdCQUVBLGdEQUFnQztBQUFBO0FBQUEsYUFDcEMsdURBQStCO0FBQUEsY0FYakM7QUFBQSxHQVlDO0FBQUE7QUFBQSxJQUFBMEQsU0R4Skw7QUFBQSxJQUFBeEMsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBRSxnQkFBQTtBQUFBLFlBQUFDLGFBQUFFLEdBQUE3QztBQUFBQSxJQ2dLa0I7QUFBQTtBQUFBO0FBQUEsc0JBQUFnQyxHQUFzQixPQUFLLHFCQUFMLGlCQUFLO0FBQUE7QUFBQSxZQUFBWSxTQUFBNUMsR0FBQTZDLEdBRTNCLHlCQUFPO0FBQUEsWUFBQUQsU0FBQTVDLEdBQUE2QztBQUFBQSxJQUNQO0FBQUEsd0NBQUE3QyxHQUFlLHlCQUFPO0FBQUE7QUFBQSxZQUFBdUQsUUFBQXZELEdBQUF3RCxJQUFBQyxJQUR0QixPQUlrQixTQUpsQix3QkFJeUI7QUFBQSxZQUFBSyxRQUFBOUQsR0FBQXdELElBQUFDLElBQUFNO0FBQUFBLElBSnpCLE9BS3lCLFNBQWYsU0FMViw2QkFLZ0M7QUFBQTtBQUFBLFlBQUFLLFFBQUFwRSxHQUFBd0QsSUFBQUMsSUFBQU0sSUFBQU07QUFBQUEsSUFMaEMsT0FNZ0MsU0FBdEIsa0JBTlYsa0NBTXVDO0FBQUE7QUFBQSxZQUFBekIsU0FBQThCLEdBQUFDO0FBQUFBLElBRXZDLDZDQUFBeEQsT0FBZSxTQUFDO0FBQUE7QUFBQSxZQUFBeUIsU0FBQThCLEdBQUFDO0FBQUFBLElBQ2hCO0FBQUE7QUFBQTtBQUFBLHNCQUFBM0MsR0FBZSxnQ0FBQWIsT0FBZSxTQUFDO0FBQUE7QUFBQTtBQUFBLElBQUE2RDtBQUFBQSxNRDNLakQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IFBhcnRpYWwgb2YgJ2EgcGFydGlhbFxuICAgIHwgTGF6eSAgICBvZiAnYSB0IExhenkudFxuICAgIHwgRG9uZSAgICBvZiBpbnQgKiAnYVxuICAgIHwgRmFpbCAgICBvZiBpbnQgKiBzdHJpbmcgbGlzdCAqIHN0cmluZ1xuXG4gIGFuZCAnYSBwYXJ0aWFsID1cbiAgICB7IGNvbW1pdHRlZCA6IGludFxuICAgIDsgY29udGludWUgIDogQmlnc3RyaW5nYWYudCAtPiBvZmY6aW50IC0+IGxlbjppbnQgLT4gTW9yZS50IC0+ICdhIHQgfVxuXG5lbmRcbnR5cGUgJ2Egd2l0aF9zdGF0ZSA9IElucHV0LnQgLT4gIGludCAtPiBNb3JlLnQgLT4gJ2FcblxudHlwZSAnYSBmYWlsdXJlID0gKHN0cmluZyBsaXN0IC0+IHN0cmluZyAtPiAnYSBTdGF0ZS50KSB3aXRoX3N0YXRlXG50eXBlICgnYSwgJ3IpIHN1Y2Nlc3MgPSAoJ2EgLT4gJ3IgU3RhdGUudCkgd2l0aF9zdGF0ZVxuXG50eXBlICdhIHQgPVxuICB7IHJ1biA6ICdyLiAoJ3IgZmFpbHVyZSAtPiAoJ2EsICdyKSBzdWNjZXNzIC0+ICdyIFN0YXRlLnQpIHdpdGhfc3RhdGUgfVxuXG5sZXQgZmFpbF9rICAgIGlucHV0IHBvcyBfIG1hcmtzIG1zZyA9XG4gIFN0YXRlLkZhaWwocG9zIC0gSW5wdXQuY2xpZW50X2NvbW1pdHRlZF9ieXRlcyBpbnB1dCwgbWFya3MsIG1zZylcbmxldCBzdWNjZWVkX2sgaW5wdXQgcG9zIF8gICAgICAgdiAgID1cbiAgU3RhdGUuRG9uZShwb3MgLSBJbnB1dC5jbGllbnRfY29tbWl0dGVkX2J5dGVzIGlucHV0LCB2KVxuXG5sZXQgcmVjIHRvX2V4cG9ydGVkX3N0YXRlID0gZnVuY3Rpb25cbiAgfCBTdGF0ZS5QYXJ0aWFsIHtjb21taXR0ZWQ7Y29udGludWV9IC0+XG4gICAgIEV4cG9ydGVkX3N0YXRlLlBhcnRpYWxcbiAgICAgICB7IGNvbW1pdHRlZFxuICAgICAgIDsgY29udGludWUgPVxuICAgICAgICAgICBmdW4gYnMgfm9mZiB+bGVuIG1vcmUgLT5cbiAgICAgICAgICAgdG9fZXhwb3J0ZWRfc3RhdGUgKGNvbnRpbnVlIGJzIH5vZmYgfmxlbiBtb3JlKX1cbiAgfCBTdGF0ZS5Eb25lIChpLHgpIC0+IEV4cG9ydGVkX3N0YXRlLkRvbmUgKGkseClcbiAgfCBTdGF0ZS5GYWlsIChpLCBzbCwgcykgLT4gRXhwb3J0ZWRfc3RhdGUuRmFpbCAoaSwgc2wsIHMpXG4gIHwgU3RhdGUuTGF6eSB4IC0+IHRvX2V4cG9ydGVkX3N0YXRlIChMYXp5LmZvcmNlIHgpXG5cbmxldCBwYXJzZSBwID1cbiAgbGV0IGlucHV0ID0gSW5wdXQuY3JlYXRlIEJpZ3N0cmluZ2FmLmVtcHR5IH5jb21taXR0ZWRfYnl0ZXM6MCB+b2ZmOjAgfmxlbjowIGluXG4gIHRvX2V4cG9ydGVkX3N0YXRlIChwLnJ1biBpbnB1dCAwIEluY29tcGxldGUgZmFpbF9rIHN1Y2NlZWRfaylcblxubGV0IHBhcnNlX2JpZ3N0cmluZyBwIGlucHV0ID1cbiAgbGV0IGlucHV0ID0gSW5wdXQuY3JlYXRlIGlucHV0IH5jb21taXR0ZWRfYnl0ZXM6MCB+b2ZmOjAgfmxlbjooQmlnc3RyaW5nYWYubGVuZ3RoIGlucHV0KSBpblxuICBFeHBvcnRlZF9zdGF0ZS5zdGF0ZV90b19yZXN1bHQgKHRvX2V4cG9ydGVkX3N0YXRlIChwLnJ1biBpbnB1dCAwIENvbXBsZXRlIGZhaWxfayBzdWNjZWVkX2spKVxuXG5tb2R1bGUgTW9uYWQgPSBzdHJ1Y3RcbiAgbGV0IHJldHVybiB2ID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBzdWNjIGlucHV0IHBvcyBtb3JlIHZcbiAgICB9XG5cbiAgbGV0IGZhaWwgbXNnID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIF9zdWNjIC0+XG4gICAgICBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIG1zZ1xuICAgIH1cblxuICBsZXQgKD4+PSkgcCBmID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyB2ID0gKGYgdikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKD4+fCkgcCBmID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyB2ID0gc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyAoZiB2KSBpblxuICAgICAgcC5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJ1xuICAgIH1cblxuICBsZXQgKDwkPikgZiBtID1cbiAgICBtID4+fCBmXG5cbiAgbGV0ICg8Kj4pIGYgbSA9XG4gICAgKCogZiA+Pj0gZnVuIGYgLT4gbSA+PnwgZiAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MwIGlucHV0MCBwb3MwIG1vcmUwIGYgPVxuICAgICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgbSA9IHN1Y2MgaW5wdXQxIHBvczEgbW9yZTEgKGYgbSkgaW5cbiAgICAgICAgbS5ydW4gaW5wdXQwIHBvczAgbW9yZTAgZmFpbCBzdWNjMVxuICAgICAgaW5cbiAgICAgIGYucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzAgfVxuXG4gIGxldCBsaWZ0IGYgbSA9XG4gICAgZiA8JD4gbVxuXG4gIGxldCBsaWZ0MiBmIG0xIG0yID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtMSA9XG4gICAgICAgIGxldCBzdWNjMiBpbnB1dDIgcG9zMiBtb3JlMiBtMiA9IHN1Y2MgaW5wdXQyIHBvczIgbW9yZTIgKGYgbTEgbTIpIGluXG4gICAgICAgIG0yLnJ1biBpbnB1dDEgcG9zMSBtb3JlMSBmYWlsIHN1Y2MyXG4gICAgICBpblxuICAgICAgbTEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYzEgfVxuXG4gIGxldCBsaWZ0MyBmIG0xIG0yIG0zID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBzdWNjMSBpbnB1dDEgcG9zMSBtb3JlMSBtMSA9XG4gICAgICAgIGxldCBzdWNjMiBpbnB1dDIgcG9zMiBtb3JlMiBtMiA9XG4gICAgICAgICAgbGV0IHN1Y2MzIGlucHV0MyBwb3MzIG1vcmUzIG0zID1cbiAgICAgICAgICAgIHN1Y2MgaW5wdXQzIHBvczMgbW9yZTMgKGYgbTEgbTIgbTMpIGluXG4gICAgICAgICAgbTMucnVuIGlucHV0MiBwb3MyIG1vcmUyIGZhaWwgc3VjYzMgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0IGxpZnQ0IGYgbTEgbTIgbTMgbTQgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MxIGlucHV0MSBwb3MxIG1vcmUxIG0xID1cbiAgICAgICAgbGV0IHN1Y2MyIGlucHV0MiBwb3MyIG1vcmUyIG0yID1cbiAgICAgICAgICBsZXQgc3VjYzMgaW5wdXQzIHBvczMgbW9yZTMgbTMgPVxuICAgICAgICAgICAgbGV0IHN1Y2M0IGlucHV0NCBwb3M0IG1vcmU0IG00ID1cbiAgICAgICAgICAgICAgc3VjYyBpbnB1dDQgcG9zNCBtb3JlNCAoZiBtMSBtMiBtMyBtNCkgaW5cbiAgICAgICAgICAgIG00LnJ1biBpbnB1dDMgcG9zMyBtb3JlMyBmYWlsIHN1Y2M0IGluXG4gICAgICAgICAgbTMucnVuIGlucHV0MiBwb3MyIG1vcmUyIGZhaWwgc3VjYzMgaW5cbiAgICAgICAgbTIucnVuIGlucHV0MSBwb3MxIG1vcmUxIGZhaWwgc3VjYzJcbiAgICAgIGluXG4gICAgICBtMS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMSB9XG5cbiAgbGV0ICggKj4pIGEgYiA9XG4gICAgKCogYSA+Pj0gZnVuIF8gLT4gYiAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnIF8gPSBiLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIGEucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYydcbiAgICB9XG5cbiAgbGV0ICg8KiApIGEgYiA9XG4gICAgKCogYSA+Pj0gZnVuIHggLT4gYiA+PnwgZnVuIF8gLT4geCAqKVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IHN1Y2MwIGlucHV0MCBwb3MwIG1vcmUwIHggPVxuICAgICAgICBsZXQgc3VjYzEgaW5wdXQxIHBvczEgbW9yZTEgXyA9IHN1Y2MgaW5wdXQxIHBvczEgbW9yZTEgeCBpblxuICAgICAgICBiLnJ1biBpbnB1dDAgcG9zMCBtb3JlMCBmYWlsIHN1Y2MxXG4gICAgICBpblxuICAgICAgYS5ydW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjMCB9XG5lbmRcblxubW9kdWxlIENob2ljZSA9IHN0cnVjdFxuICBsZXQgKDw/PikgcCBtYXJrID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyBtYXJrcyBtc2cgPVxuICAgICAgICBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIChtYXJrOjptYXJrcykgbXNnIGluXG4gICAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsJyBzdWNjXG4gICAgfVxuXG4gIGxldCAoPHw+KSBwIHEgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnIG1hcmtzIG1zZyA9XG4gICAgICAgICgqIFRoZSBvbmx5IHR3byBjb25zdHJ1Y3RvcnMgdGhhdCBpbnRyb2R1Y2UgbmV3IGZhaWx1cmUgY29udGludWF0aW9ucyBhcmVcbiAgICAgICAgICogWzw/Pl0gYW5kIFs8fD5dLiBJZiB0aGUgaW5pdGlhbCBpbnB1dCBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICAgICAgICAgKiBvZiB0aGUgY29tbWl0dGVkIGlucHV0LCB0aGVuIGNhbGxpbmcgdGhlIGZhaWx1cmUgY29udGludWF0aW9uIHdpbGxcbiAgICAgICAgICogaGF2ZSB0aGUgZWZmZWN0IG9mIHVud2luZGluZyBhbGwgY2hvaWNlcyBhbmQgY29sbGVjdGluZyBtYXJrcyBhbG9uZ1xuICAgICAgICAgKiB0aGUgd2F5LiAqKVxuICAgICAgICBpZiBwb3MgPCBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIGlucHV0JyB0aGVuXG4gICAgICAgICAgZmFpbCBpbnB1dCcgcG9zJyBtb3JlIG1hcmtzIG1zZ1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcS5ydW4gaW5wdXQnIHBvcyBtb3JlJyBmYWlsIHN1Y2MgaW5cbiAgICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwnIHN1Y2NcbiAgICB9XG5lbmRcblxubW9kdWxlIE1vbmFkX3VzZV9mb3JfZGVidWdnaW5nID0gc3RydWN0XG4gIGxldCByZXR1cm4gPSBNb25hZC5yZXR1cm5cbiAgbGV0IGZhaWwgICA9IE1vbmFkLmZhaWxcbiAgbGV0ICg+Pj0pICA9IE1vbmFkLig+Pj0pXG5cbiAgbGV0ICg+PnwpIG0gZiA9IG0gPj49IGZ1biB4IC0+IHJldHVybiAoZiB4KVxuXG4gIGxldCAoPCQ+KSBmIG0gPSBtID4+fCBmXG4gIGxldCAoPCo+KSBmIG0gPSBmID4+PSBmdW4gZiAtPiBtID4+fCBmXG5cbiAgbGV0IGxpZnQgID0gKD4+fClcbiAgbGV0IGxpZnQyIGYgbTEgbTIgICAgICAgPSBmIDwkPiBtMSA8Kj4gbTJcbiAgbGV0IGxpZnQzIGYgbTEgbTIgbTMgICAgPSBmIDwkPiBtMSA8Kj4gbTIgPCo+IG0zXG4gIGxldCBsaWZ0NCBmIG0xIG0yIG0zIG00ID0gZiA8JD4gbTEgPCo+IG0yIDwqPiBtMyA8Kj4gbTRcblxuICBsZXQgKCAqPikgYSBiID0gYSA+Pj0gZnVuIF8gLT4gYlxuICBsZXQgKDwqICkgYSBiID0gYSA+Pj0gZnVuIHggLT4gYiA+PnwgZnVuIF8gLT4geFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDk5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImFuZ3N0cm9tLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfbGliX2J1ZmZlcmluZ19tbCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwzIiwiYTEiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIkFzc2VydF9mYWlsdXJlIiwiQmlnc3RyaW5nYWYiLCJvZl9iaWdzdHJpbmciLCJvZmYiLCJsZW4iLCJidWYiLCJjcmVhdGUiLCJ3cml0YWJsZV9zcGFjZSIsInQiLCJlbnN1cmUiLCJ0b19jb3B5Iiwib2xkX2xlbiIsIm5ld19sZW4iLCJzcGFjZSIsIm5ld19idWYiLCJ3cml0ZV9wb3MiLCJmZWVkX3N0cmluZyIsInN0ciIsImZlZWRfYmlnc3RyaW5nIiwiYiIsImZlZWRfaW5wdXQiLCJwYXJhbSIsInMiLCJzaGlmdCIsIm4iLCJmb3JfcmVhZGluZyIsInVuY29uc3VtZWQiLCJvcHQiLCJvZl91bmNvbnN1bWVkIiwiQW5nc3Ryb21fQnVmZmVyaW5nIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvYW5nc3Ryb20vYnVmZmVyaW5nLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRSxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUwsR0FBQUMsSUFBQUUsSUFBQUMsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsYUFBQUMsS0FBQUMsS0FBQUM7QUFBQUEsSUNNRTtBQUFBO0FBQUEsSUFDUTtBQUFBLEtBQ1I7QUFBQSxJQUQ4QjtBQUFBLEdBQ2I7QUFBQSxZQUFBQyxPQUFBRjtBQUFBQSxJQUdVLE9BQXdCLG1CQUF4QixnQ0FBd0I7QUFBQTtBQUFBLFlBQUFHLGVBQUFDO0FBQUFBLFFBQUEsTUFHbkQ7QUFBQSxxREFBd0I7QUFBQSxHQUFRO0FBQUEsWUFBQUMsT0FBQUQsR0FBQUU7QUFBQUE7QUFBQUEsS0FBQSxNQUdoQztBQUFBO0FBQUEsSUFtQm1CO0FBQUEsSUFDZDtBQUFBLEtBakJMO0FBQUEsS0FBd0U7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBQyxVQUkxRDtBQUFBLEtBQUFDLFVBQ2Q7QUFBQSxLQUFBQyxRQUNZO0FBQUEsSUFDWjtBQUFBO0FBQUEsVUFBQUMsVUFHYztBQUFBLE1BQ2Q7QUFBQSxNQUEwRTtBQUFBLE1BRTFFO0FBQUE7QUFBQTtBQUFBLEtBTEU7QUFBQTtBQUFBLEdBV21CO0FBQUEsWUFBQUMsVUFBQVAsR0FHckIsdUJBQWE7QUFBQSxZQUFBUSxZQUFBUixHQUFBTCxLQUFBQyxLQUFBYTtBQUFBQSxJQUdiO0FBQUE7QUFBQSxJQUNBO0FBQUE7QUFBQSxJQUNBO0FBQUEsY0FDb0U7QUFBQSxJQUFwRTtBQUFBLElBQXNGO0FBQUE7QUFBQSxHQUNsRTtBQUFBLFlBQUFDLGVBQUFWLEdBQUFMLEtBQUFDLEtBQUFlO0FBQUFBLElBR3BCO0FBQUE7QUFBQSxJQUNRO0FBQUEsS0FBb0I7QUFBQSxJQUM1QjtBQUFBLGNBQ3NEO0FBQUEsSUFBdEQ7QUFBQSxJQUF3RTtBQUFBO0FBQUEsR0FDcEQ7QUFBQSxZQUFBQyxXQUFBWixHQUFBYTtBQUFBQSxJQUVQO0FBQUEsU0FBQUYsSUFBQTtBQUFBLEtBRWtDLE9BQXNCLHFCQUF0QixpQ0FBd0I7QUFBQTtBQUFBLFFBQUFHLElBRjFEO0FBQUEsSUFDSyxxREFDcUQ7QUFBQTtBQUFBLFlBQUFDLE1BQUFmLEdBQUFnQjtBQUFBQSxJQUd2RTtBQUFBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQTtBQUFBLEdBQWtCO0FBQUEsWUFBQUMsWUFBQUo7QUFBQUEsUUFBQWhCLE1BRUosVUFBQUYsTUFBQSxVQUFBQyxNQUFBO0FBQUEsSUFDZCxnREFBNkI7QUFBQTtBQUFBLFlBQUFzQixXQUFBQyxLQUFBTjtBQUFBQTtBQUFBQSxLQUFBRSxRQVNoQjtBQUFBLEtBQUFsQixNQUFBO0FBQUEsS0FBQUYsTUFBQTtBQUFBLEtBQUFDLE1BQUE7QUFBQSxJQUNiLGlCQUNBO0FBQUEsSUFEQTtBQUFBLEdBQ3dEO0FBQUEsWUFBQXdCLGNBQUFQO0FBQUFBLFFBQUFqQixNQUV4QyxVQUFBRCxNQUFBLFVBQUFFLE1BQUE7QUFBQSxJQUNoQjtBQUFBLEdBQWlCO0FBQUE7QUFBQSxJQUFBd0I7QUFBQUEsTURsRm5CIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJ0eXBlIHQgPVxuICB7IG11dGFibGUgYnVmIDogQmlnc3RyaW5nYWYudFxuICA7IG11dGFibGUgb2ZmIDogaW50XG4gIDsgbXV0YWJsZSBsZW4gOiBpbnQgfVxuXG5sZXQgb2ZfYmlnc3RyaW5nIH5vZmYgfmxlbiBidWYgPVxuICBhc3NlcnQgKG9mZiA+PSAwKTtcbiAgYXNzZXJ0IChCaWdzdHJpbmdhZi5sZW5ndGggYnVmID49IGxlbiAtIG9mZik7XG4gIHsgYnVmOyBvZmY7IGxlbiB9XG5cbmxldCBjcmVhdGUgbGVuID1cbiAgb2ZfYmlnc3RyaW5nIH5vZmY6MCB+bGVuOjAgKEJpZ3N0cmluZ2FmLmNyZWF0ZSBsZW4pXG5cbmxldCB3cml0YWJsZV9zcGFjZSB0ID1cbiAgQmlnc3RyaW5nYWYubGVuZ3RoIHQuYnVmIC0gdC5sZW5cblxubGV0IHRyYWlsaW5nX3NwYWNlIHQgPVxuICBCaWdzdHJpbmdhZi5sZW5ndGggdC5idWYgLSAodC5vZmYgKyB0LmxlbilcblxubGV0IGNvbXByZXNzIHQgPVxuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdCB0LmJ1ZiB+c3JjX29mZjp0Lm9mZiB0LmJ1ZiB+ZHN0X29mZjowIH5sZW46dC5sZW47XG4gIHQub2ZmIDwtIDBcblxubGV0IGdyb3cgdCB0b19jb3B5ID1cbiAgbGV0IG9sZF9sZW4gPSBCaWdzdHJpbmdhZi5sZW5ndGggdC5idWYgaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgb2xkX2xlbiBpblxuICBsZXQgc3BhY2UgPSB3cml0YWJsZV9zcGFjZSB0IGluXG4gIHdoaWxlIHNwYWNlICsgIW5ld19sZW4gLSBvbGRfbGVuIDwgdG9fY29weSBkb1xuICAgIG5ld19sZW4gOj0gKDMgKiAhbmV3X2xlbikgLyAyXG4gIGRvbmU7XG4gIGxldCBuZXdfYnVmID0gQmlnc3RyaW5nYWYuY3JlYXRlICFuZXdfbGVuIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0IHQuYnVmIH5zcmNfb2ZmOnQub2ZmIG5ld19idWYgfmRzdF9vZmY6MCB+bGVuOnQubGVuO1xuICB0LmJ1ZiA8LSBuZXdfYnVmO1xuICB0Lm9mZiA8LSAwXG5cbmxldCBlbnN1cmUgdCB0b19jb3B5ID1cbiAgaWYgdHJhaWxpbmdfc3BhY2UgdCA8IHRvX2NvcHkgdGhlblxuICAgIGlmIHdyaXRhYmxlX3NwYWNlIHQgPj0gdG9fY29weVxuICAgIHRoZW4gY29tcHJlc3MgdFxuICAgIGVsc2UgZ3JvdyB0IHRvX2NvcHlcblxubGV0IHdyaXRlX3BvcyB0ID1cbiAgdC5vZmYgKyB0LmxlblxuXG5sZXQgZmVlZF9zdHJpbmcgdCB+b2ZmIH5sZW4gc3RyID1cbiAgYXNzZXJ0IChvZmYgPj0gMCk7XG4gIGFzc2VydCAoU3RyaW5nLmxlbmd0aCBzdHIgPj0gbGVuIC0gb2ZmKTtcbiAgZW5zdXJlIHQgbGVuO1xuICBCaWdzdHJpbmdhZi51bnNhZmVfYmxpdF9mcm9tX3N0cmluZyBzdHIgfnNyY19vZmY6b2ZmIHQuYnVmIH5kc3Rfb2ZmOih3cml0ZV9wb3MgdCkgfmxlbjtcbiAgdC5sZW4gPC0gdC5sZW4gKyBsZW5cblxubGV0IGZlZWRfYmlnc3RyaW5nIHQgfm9mZiB+bGVuIGIgPVxuICBhc3NlcnQgKG9mZiA+PSAwKTtcbiAgYXNzZXJ0IChCaWdzdHJpbmdhZi5sZW5ndGggYiA+PSBsZW4gLSBvZmYpO1xuICBlbnN1cmUgdCBsZW47XG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0IGIgfnNyY19vZmY6b2ZmIHQuYnVmIH5kc3Rfb2ZmOih3cml0ZV9wb3MgdCkgfmxlbjtcbiAgdC5sZW4gPC0gdC5sZW4gKyBsZW5cblxubGV0IGZlZWRfaW5wdXQgdCA9IGZ1bmN0aW9uXG4gIHwgYFN0cmluZyAgICBzIC0+IGZlZWRfc3RyaW5nICAgIHQgfm9mZjowIH5sZW46KFN0cmluZyAgICAgLmxlbmd0aCBzKSBzXG4gIHwgYEJpZ3N0cmluZyBiIC0+IGZlZWRfYmlnc3RyaW5nIHQgfm9mZjowIH5sZW46KEJpZ3N0cmluZ2FmLmxlbmd0aCBiKSBiXG5cbmxldCBzaGlmdCB0IG4gPVxuICBhc3NlcnQgKHQubGVuID49IG4pO1xuICB0Lm9mZiA8LSB0Lm9mZiArIG47XG4gIHQubGVuIDwtIHQubGVuIC0gblxuXG5sZXQgZm9yX3JlYWRpbmcgeyBidWY7IG9mZjsgbGVuIH0gPVxuICBCaWdzdHJpbmdhZi5zdWIgfm9mZiB+bGVuIGJ1ZlxuXG5tb2R1bGUgVW5jb25zdW1lZCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgYnVmIDogQmlnc3RyaW5nYWYudFxuICAgIDsgb2ZmIDogaW50XG4gICAgOyBsZW4gOiBpbnQgfVxuZW5kXG5cbmxldCB1bmNvbnN1bWVkID8oc2hpZnQ9MCkgeyBidWY7IG9mZjsgbGVuIH0gPVxuICBhc3NlcnQgKGxlbiA+PSBzaGlmdCk7XG4gIHsgVW5jb25zdW1lZC5idWY7IG9mZiA9IG9mZiArIHNoaWZ0OyBsZW4gPSBsZW4gLSBzaGlmdCB9XG5cbmxldCBvZl91bmNvbnN1bWVkIHsgVW5jb25zdW1lZC5idWY7IG9mZjsgbGVuIH0gPVxuICB7IGJ1Zjsgb2ZmOyBsZW4gfVxuXG50eXBlIHVuY29uc3VtZWQgPSBVbmNvbnN1bWVkLnQgPVxuICB7IGJ1ZiA6IEJpZ3N0cmluZ2FmLnRcbiAgOyBvZmYgOiBpbnRcbiAgOyBsZW4gOiBpbnQgfVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjY0OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJhbmdzdHJvbS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X2NvdW50X3doaWxlMSIsImNzdF9ub3RfZW5vdWdoX2lucHV0IiwiY3N0X3NhdGlzZnkiLCJjc3Rfc2F0aXNmeV9DIiwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJTdGRsaWIiLCJBbmdzdHJvbV9JbnB1dCIsIkJpZ3N0cmluZ2FmIiwiU3RkbGliX0ludDY0IiwiU3RkbGliX0ludDMyIiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0NoYXIiLCJTdGRsaWJfUHJpbnRmIiwiQW5nc3Ryb21fQnVmZmVyaW5nIiwiQW5nc3Ryb21fUGFyc2VyIiwiQW5nc3Ryb21fRXhwb3J0ZWRfc3RhdGUiLCJTdGRsaWJfU3lzIiwicGFyc2UiLCJwYXJzZV9iaWdzdHJpbmciLCJzdGF0ZV90b19vcHRpb24iLCJmYWlsX3RvX3N0cmluZyIsInN0YXRlX3RvX3Jlc3VsdCIsInJldHVybiIsImZhaWwiLCJzeW1ib2xfYmluZCIsInN5bWJvbF9tYXAiLCJzeW1ib2wiLCJsaWZ0IiwibGlmdDIiLCJsaWZ0MyIsImxpZnQ0IiwiaW5jbHVkZSIsImNzdF9wYXJzZV9pbnZhbGlkX2FyZ3VtZW50X2luaSIsImNzdF9wcm9tcHRfaW5wdXRfc2hydW5rIiwiZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIiwiYnVmZmVyaW5nIiwicGFyYW0iLCJwIiwidiIsImNvbnN1bWVkIiwidW5jb25zdW1lZCIsIm1zZyIsIm1hcmtzIiwib3B0IiwiaW5pdGlhbF9idWZmZXJfc2l6ZSIsImlucHV0IiwibW9yZSIsImZvcl9yZWFkaW5nIiwiZmVlZCIsInN0YXRlIiwiayIsInN0YXRlX3RvX3VuY29uc3VtZWQiLCJwcm9tcHQiLCJwb3MiLCJzdWNjIiwicGFyc2VyX3VuY29tbWl0dGVkX2J5dGVzIiwicGFyc2VyX2NvbW1pdHRlZF9ieXRlcyIsImNvbnRpbnVlIiwib2ZmIiwibGVuIiwiZGVtYW5kX2lucHV0IiwiZW5zdXJlX3N1c3BlbmRlZCIsIm4iLCJnbyIsInVuc2FmZV9hcHBseSIsImVuc3VyZSIsImF0X2VuZF9vZl9pbnB1dCIsImNzdF9lbmRfb2ZfaW5wdXQiLCJlbmRfb2ZfaW5wdXQiLCJjc3RfYWR2YW5jZSIsImFkdmFuY2UiLCJhdmFpbGFibGUiLCJjb21taXQiLCJ1bnNhZmVfbG9va2FoZWFkIiwicGVla19jaGFyIiwicGVla19jaGFyX2ZhaWwiLCJzYXRpc2Z5IiwiYyIsImNoYXIiLCJub3RfY2hhciIsImFueV9jaGFyIiwiaW50OCIsImkiLCJhbnlfdWludDgiLCJzIiwiYW55X2ludDgiLCJjc3Rfc2tpcCIsImNzdF90YWtlX25fMCIsImNzdF90YWtlX2JpZ3N0cmluZ19uXzAiLCJjc3Rfbm9fbW9yZV9jaG9pY2VzIiwiY3N0X0FuZ3N0cm9tX2ZpeF9kaXJlY3Rfbm90X3NlIiwic2tpcCIsImNvdW50X3doaWxlIiwiaW5pdCIsIndpdGhfYnVmZmVyIiwiaW5wdXRfbGVuIiwiY291bnRfd2hpbGUxIiwic3RyaW5nIiwiYnVmZmVyIiwibWF0Y2giLCJ4IiwiZSIsInN0cmluZ19jaSIsInNraXBfd2hpbGUiLCJ0YWtlIiwidGFrZV9iaWdzdHJpbmciLCJ0YWtlX2JpZ3N0cmluZ193aGlsZSIsInRha2VfYmlnc3RyaW5nX3doaWxlMSIsInRha2VfYmlnc3RyaW5nX3RpbGwiLCJwZWVrX3N0cmluZyIsInRha2Vfd2hpbGUiLCJ0YWtlX3doaWxlMSIsInRha2VfdGlsbCIsImNob2ljZSIsInBzIiwiZmFpbHVyZV9tc2ciLCJub3RzZXQiLCJidWYiLCJmaXhfZGlyZWN0IiwiciIsImZpeF9sYXp5IiwibWF4X3N0ZXBzIiwic3RlcHMiLCJjc3RfTEVfaW50NjQiLCJjc3RfTEVfaW50MzIiLCJjc3RfTEVfaW50MTYiLCJjc3RfQkVfaW50NjQiLCJjc3RfQkVfaW50MzIiLCJjc3RfQkVfaW50MTYiLCJjc3RfY29uc3VtZWRfcGFyc2VyX2NvbW1pdHRlZCIsImNzdF9jb3VudF9uXzAiLCJjc3RfZW5kX29mX2xpbmUiLCJmaXgiLCJvcHRpb24iLCJjb25zIiwieHMiLCJsaXN0IiwiY291bnQiLCJsb29wIiwibWFueSIsIm0iLCJtYW55MSIsIm1hbnlfdGlsbCIsInQiLCJzZXBfYnkxIiwic2VwX2J5Iiwic2tpcF9tYW55Iiwic2tpcF9tYW55MSIsImVuZF9vZl9saW5lIiwic2NhbiIsInBhcnNlciIsInNjYW5fc3RhdGUiLCJzY2FuX3N0cmluZyIsImNvbnN1bWVfd2l0aCIsImNvbnN1bWVkX2JpZ3N0cmluZyIsImJvdGgiLCJhIiwiYiIsIm1hcCIsImJpbmQiLCJtYXAyIiwibWFwMyIsIm1hcDQiLCJkIiwiTGV0X3N5bnRheCIsImludDE2IiwiaW50MzIiLCJpbnQ2NCIsImFueV91aW50MTYiLCJicyIsImFueV9pbnQxNiIsImFueV9pbnQzMiIsImFueV9pbnQ2NCIsImFueV9mbG9hdCIsImFueV9kb3VibGUiLCJwZWVrIiwiY2hlY2siLCJDb25zdW1lIiwiY29uc3VtZSIsInBhcnNlX3N0cmluZyIsIkFuZ3N0cm9tIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvYW5nc3Ryb20vYW5nc3Ryb20ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLDJCQUFBO0FBQUEsSUFBQUMsMkJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQywwQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQTtBQUFBLElBQUFDLFdBQUE7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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHJzQnJIIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDb3B5cmlnaHQgKGMpIDIwMTYgSW5oYWJpdGVkIFR5cGUgTExDLlxuXG4gICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cblxuICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgICAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBhdXRob3Igbm9yIHRoZSBuYW1lcyBvZiBoaXMgY29udHJpYnV0b3JzXG4gICAgICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gICAgICAgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cbiAgICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT05UUklCVVRPUlMgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTU1xuICAgIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICAgIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICAgIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAgICBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EU1xuICAgIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICAgIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCxcbiAgICBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU5cbiAgICBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAgICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSopXG5cbm1vZHVsZSBCaWdhcnJheSA9IHN0cnVjdFxuICAoKiBEbyBub3QgYWNjZXNzIEJpZ2FycmF5IG9wZXJhdGlvbnMgZGlyZWN0bHkuIElmIGFueXRoaW5nJ3MgbmVlZGVkLCByZWZlciB0b1xuICAgKiB0aGUgaW50ZXJuYWwgQmlnc3RyaW5nIG1vZHVsZS4gKilcbmVuZFxuXG50eXBlIGJpZ3N0cmluZyA9IEJpZ3N0cmluZ2FmLnRcblxuXG5tb2R1bGUgVW5idWZmZXJlZCA9IHN0cnVjdFxuICBpbmNsdWRlIFBhcnNlclxuXG4gIGluY2x1ZGUgRXhwb3J0ZWRfc3RhdGVcblxuICB0eXBlIG1vcmUgPSBNb3JlLnQgPVxuICAgIHwgQ29tcGxldGVcbiAgICB8IEluY29tcGxldGVcbmVuZFxuXG5pbmNsdWRlIFVuYnVmZmVyZWRcbmluY2x1ZGUgUGFyc2VyLk1vbmFkXG5pbmNsdWRlIFBhcnNlci5DaG9pY2VcblxubW9kdWxlIEJ1ZmZlcmVkID0gc3RydWN0XG4gIHR5cGUgdW5jb25zdW1lZCA9IEJ1ZmZlcmluZy51bmNvbnN1bWVkID1cbiAgICB7IGJ1ZiA6IGJpZ3N0cmluZ1xuICAgIDsgb2ZmIDogaW50XG4gICAgOyBsZW4gOiBpbnQgfVxuXG4gIHR5cGUgaW5wdXQgPVxuICAgIFsgYEJpZ3N0cmluZyBvZiBiaWdzdHJpbmdcbiAgICB8IGBTdHJpbmcgICAgb2Ygc3RyaW5nIF1cblxuICB0eXBlICdhIHN0YXRlID1cbiAgICB8IFBhcnRpYWwgb2YgKFsgaW5wdXQgfCBgRW9mIF0gLT4gJ2Egc3RhdGUpXG4gICAgfCBEb25lICAgIG9mIHVuY29uc3VtZWQgKiAnYVxuICAgIHwgRmFpbCAgICBvZiB1bmNvbnN1bWVkICogc3RyaW5nIGxpc3QgKiBzdHJpbmdcblxuICBsZXQgZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIH5mIGJ1ZmZlcmluZyA9IGZ1bmN0aW9uXG4gICAgfCBVbmJ1ZmZlcmVkLlBhcnRpYWwgcCAgICAgICAgIC0+IFBhcnRpYWwgKGYgcClcbiAgICB8IFVuYnVmZmVyZWQuRG9uZShjb25zdW1lZCwgdikgLT5cbiAgICAgIGxldCB1bmNvbnN1bWVkID0gQnVmZmVyaW5nLnVuY29uc3VtZWQgfnNoaWZ0OmNvbnN1bWVkIGJ1ZmZlcmluZyBpblxuICAgICAgRG9uZSh1bmNvbnN1bWVkLCB2KVxuICAgIHwgVW5idWZmZXJlZC5GYWlsKGNvbnN1bWVkLCBtYXJrcywgbXNnKSAtPlxuICAgICAgbGV0IHVuY29uc3VtZWQgPSBCdWZmZXJpbmcudW5jb25zdW1lZCB+c2hpZnQ6Y29uc3VtZWQgYnVmZmVyaW5nIGluXG4gICAgICBGYWlsKHVuY29uc3VtZWQsIG1hcmtzLCBtc2cpXG5cbiAgbGV0IHBhcnNlID8oaW5pdGlhbF9idWZmZXJfc2l6ZT0weDEwMDApIHAgPVxuICAgIGlmIGluaXRpYWxfYnVmZmVyX3NpemUgPCAxIHRoZW5cbiAgICAgIGZhaWx3aXRoIFwicGFyc2U6IGludmFsaWQgYXJndW1lbnQsIGluaXRpYWxfYnVmZmVyX3NpemUgPCAxXCI7XG4gICAgbGV0IGJ1ZmZlcmluZyA9IEJ1ZmZlcmluZy5jcmVhdGUgaW5pdGlhbF9idWZmZXJfc2l6ZSBpblxuICAgIGxldCByZWMgZiBwIGlucHV0ID1cbiAgICAgIEJ1ZmZlcmluZy5zaGlmdCBidWZmZXJpbmcgcC5jb21taXR0ZWQ7XG4gICAgICBsZXQgbW9yZSA6IE1vcmUudCA9XG4gICAgICAgIG1hdGNoIGlucHV0IHdpdGhcbiAgICAgICAgfCBgRW9mICAgICAgICAgICAgLT4gQ29tcGxldGVcbiAgICAgICAgfCAjaW5wdXQgYXMgaW5wdXQgLT5cbiAgICAgICAgICBCdWZmZXJpbmcuZmVlZF9pbnB1dCBidWZmZXJpbmcgaW5wdXQ7XG4gICAgICAgICAgSW5jb21wbGV0ZVxuICAgICAgaW5cbiAgICAgIGxldCBmb3JfcmVhZGluZyA9IEJ1ZmZlcmluZy5mb3JfcmVhZGluZyBidWZmZXJpbmcgaW5cbiAgICAgIHAuY29udGludWUgZm9yX3JlYWRpbmcgfm9mZjowIH5sZW46KEJpZ3N0cmluZ2FmLmxlbmd0aCBmb3JfcmVhZGluZykgbW9yZVxuICAgICAgfD4gZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIGJ1ZmZlcmluZyB+ZlxuICAgIGluXG4gICAgVW5idWZmZXJlZC5wYXJzZSBwXG4gICAgfD4gZnJvbV91bmJ1ZmZlcmVkX3N0YXRlIGJ1ZmZlcmluZyB+ZlxuXG4gIGxldCBmZWVkIHN0YXRlIGlucHV0ID1cbiAgICBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgfCBQYXJ0aWFsIGsgLT4gayBpbnB1dFxuICAgIHwgRmFpbCh1bmNvbnN1bWVkLCBtYXJrcywgbXNnKSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggaW5wdXQgd2l0aFxuICAgICAgfCBgRW9mICAgLT4gc3RhdGVcbiAgICAgIHwgI2lucHV0IGFzIGlucHV0IC0+XG4gICAgICAgIGxldCBidWZmZXJpbmcgPSBCdWZmZXJpbmcub2ZfdW5jb25zdW1lZCB1bmNvbnN1bWVkIGluXG4gICAgICAgIEJ1ZmZlcmluZy5mZWVkX2lucHV0IGJ1ZmZlcmluZyBpbnB1dDtcbiAgICAgICAgRmFpbChCdWZmZXJpbmcudW5jb25zdW1lZCBidWZmZXJpbmcsIG1hcmtzLCBtc2cpXG4gICAgICBlbmRcbiAgICB8IERvbmUodW5jb25zdW1lZCwgdikgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGlucHV0IHdpdGhcbiAgICAgIHwgYEVvZiAgIC0+IHN0YXRlXG4gICAgICB8ICNpbnB1dCBhcyBpbnB1dCAtPlxuICAgICAgICBsZXQgYnVmZmVyaW5nID0gQnVmZmVyaW5nLm9mX3VuY29uc3VtZWQgdW5jb25zdW1lZCBpblxuICAgICAgICBCdWZmZXJpbmcuZmVlZF9pbnB1dCBidWZmZXJpbmcgaW5wdXQ7XG4gICAgICAgIERvbmUoQnVmZmVyaW5nLnVuY29uc3VtZWQgYnVmZmVyaW5nLCB2KVxuICAgICAgZW5kXG5cbiAgbGV0IHN0YXRlX3RvX29wdGlvbiA9IGZ1bmN0aW9uXG4gICAgfCBEb25lKF8sIHYpIC0+IFNvbWUgdlxuICAgIHwgUGFydGlhbCBfICAtPiBOb25lXG4gICAgfCBGYWlsIF8gICAgIC0+IE5vbmVcblxuICBsZXQgc3RhdGVfdG9fcmVzdWx0ID0gZnVuY3Rpb25cbiAgICB8IFBhcnRpYWwgXyAgICAgICAgICAgLT4gRXJyb3IgXCJpbmNvbXBsZXRlIGlucHV0XCJcbiAgICB8IERvbmUoXywgdikgICAgICAgICAgLT4gT2sgdlxuICAgIHwgRmFpbChfLCBtYXJrcywgbXNnKSAtPiBFcnJvciAoVW5idWZmZXJlZC5mYWlsX3RvX3N0cmluZyBtYXJrcyBtc2cpXG5cbiAgbGV0IHN0YXRlX3RvX3VuY29uc3VtZWQgPSBmdW5jdGlvblxuICAgIHwgRG9uZSh1bmNvbnN1bWVkLCBfKVxuICAgIHwgRmFpbCh1bmNvbnN1bWVkLCBfLCBfKSAtPiBTb21lIHVuY29uc3VtZWRcbiAgICB8IFBhcnRpYWwgXyAgICAgICAgICAgICAgLT4gTm9uZVxuXG5lbmRcblxuKCoqIEJFR0lOOiBnZXR0aW5nIGlucHV0ICopXG5cbmxldCByZWMgcHJvbXB0IGlucHV0IHBvcyBmYWlsIHN1Y2MgPVxuICAoKiBbcHJvbXB0XSBzaG91bGQgb25seSBjYWxsIFtzdWNjXSBpZiBpdCBoYXMgcmVjZWl2ZWQgbW9yZSBpbnB1dC4gSWYgdGhlcmVcbiAgICogaXMgbm8gY2hhbmNlIHRoYXQgdGhlIGlucHV0IHdpbGwgZ3JvdywgaS5lLiwgW21vcmUgPSBDb21wbGV0ZV0sIHRoZW5cbiAgICogW3Byb21wdF0gc2hvdWxkIGNhbGwgW2ZhaWxdLiBPdGhlcndpc2UgKGluIHRoZSBjYXNlIHdoZXJlIHRoZSBpbnB1dFxuICAgKiBoYXNuJ3QgZ3Jvd24gYnV0IFttb3JlID0gSW5jb21wbGV0ZV0ganVzdCBwcm9tcHQgYWdhaW4uICopXG4gIGxldCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgPSBJbnB1dC5wYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgaW5wdXQgaW5cbiAgbGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgICA9IElucHV0LnBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgICBpbnB1dCBpblxuICAoKiBUaGUgY29udGludWF0aW9uIHNob3VsZCBub3QgaG9sZCBhbnkgcmVmZXJlbmNlcyB0byBpbnB1dCBhYm92ZS4gKilcbiAgbGV0IGNvbnRpbnVlIGlucHV0IH5vZmYgfmxlbiBtb3JlID1cbiAgICBpZiBsZW4gPCBwYXJzZXJfdW5jb21taXR0ZWRfYnl0ZXMgdGhlblxuICAgICAgZmFpbHdpdGggXCJwcm9tcHQ6IGlucHV0IHNocnVuayFcIjtcbiAgICBsZXQgaW5wdXQgPSBJbnB1dC5jcmVhdGUgaW5wdXQgfm9mZiB+bGVuIH5jb21taXR0ZWRfYnl0ZXM6cGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpblxuICAgIGlmIGxlbiA9IHBhcnNlcl91bmNvbW1pdHRlZF9ieXRlcyB0aGVuXG4gICAgICBtYXRjaCAobW9yZSA6IE1vcmUudCkgd2l0aFxuICAgICAgfCBDb21wbGV0ZSAgIC0+IGZhaWwgaW5wdXQgcG9zIE1vcmUuQ29tcGxldGVcbiAgICAgIHwgSW5jb21wbGV0ZSAtPiBwcm9tcHQgaW5wdXQgcG9zIGZhaWwgc3VjY1xuICAgIGVsc2VcbiAgICAgIHN1Y2MgaW5wdXQgcG9zIG1vcmVcbiAgaW5cbiAgU3RhdGUuUGFydGlhbCB7IGNvbW1pdHRlZCA9IElucHV0LmJ5dGVzX2Zvcl9jbGllbnRfdG9fY29tbWl0IGlucHV0OyBjb250aW51ZSB9XG5cbmxldCBkZW1hbmRfaW5wdXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBtYXRjaCAobW9yZSA6IE1vcmUudCkgd2l0aFxuICAgIHwgQ29tcGxldGUgICAtPiBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwibm90IGVub3VnaCBpbnB1dFwiXG4gICAgfCBJbmNvbXBsZXRlIC0+XG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgPSBzdWNjIGlucHV0JyBwb3MnIG1vcmUnICgpXG4gICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPSBmYWlsIGlucHV0JyBwb3MnIG1vcmUnIFtdIFwibm90IGVub3VnaCBpbnB1dFwiIGluXG4gICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gIH1cblxubGV0IGVuc3VyZV9zdXNwZW5kZWQgbiBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgPVxuICBsZXQgcmVjIGdvID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsJyBzdWNjJyAtPlxuICAgICAgaWYgcG9zJyArIG4gPD0gSW5wdXQubGVuZ3RoIGlucHV0JyB0aGVuXG4gICAgICAgIHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnICgpXG4gICAgICBlbHNlXG4gICAgICAgIChkZW1hbmRfaW5wdXQgKj4gZ28pLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsJyBzdWNjJ1xuICAgIH1cbiAgaW5cbiAgKGRlbWFuZF9pbnB1dCAqPiBnbykucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjY1xuXG5sZXQgdW5zYWZlX2FwcGx5IGxlbiB+ZiA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBsZW4gfmYpXG4gIH1cblxubGV0IHVuc2FmZV9hcHBseV9vcHQgbGVuIH5mID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbWF0Y2ggSW5wdXQuYXBwbHkgaW5wdXQgcG9zIGxlbiB+ZiB3aXRoXG4gICAgfCBFcnJvciBlIC0+IGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gZVxuICAgIHwgT2sgICAgeCAtPiBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgeFxuICB9XG5cbmxldCBlbnN1cmUgbiBwID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgaWYgcG9zICsgbiA8PSBJbnB1dC5sZW5ndGggaW5wdXRcbiAgICB0aGVuIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjY1xuICAgIGVsc2VcbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyAoKSA9IHAucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjYyBpblxuICAgICAgZW5zdXJlX3N1c3BlbmRlZCBuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG4oKiogRU5EOiBnZXR0aW5nIGlucHV0ICopXG5cbmxldCBhdF9lbmRfb2ZfaW5wdXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSBmYWxzZVxuICAgIGVsc2UgbWF0Y2ggbW9yZSB3aXRoXG4gICAgfCBDb21wbGV0ZSAtPiBzdWNjIGlucHV0IHBvcyBtb3JlIHRydWVcbiAgICB8IEluY29tcGxldGUgLT5cbiAgICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgZmFsc2VcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9IHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgdHJ1ZSBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbmxldCBlbmRfb2ZfaW5wdXQgPVxuICBhdF9lbmRfb2ZfaW5wdXRcbiAgPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlICAtPiByZXR1cm4gKClcbiAgICB8IGZhbHNlIC0+IGZhaWwgXCJlbmRfb2ZfaW5wdXRcIlxuXG5sZXQgYWR2YW5jZSBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwiYWR2YW5jZVwiXG4gIGVsc2VcbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+IHN1Y2MgaW5wdXQgKHBvcyArIG4pIG1vcmUgKCkgfVxuICAgIGluXG4gICAgZW5zdXJlIG4gcFxuXG5sZXQgcG9zID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPiBzdWNjIGlucHV0IHBvcyBtb3JlIHBvcyB9XG5cbmxldCBhdmFpbGFibGUgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgc3VjYyBpbnB1dCBwb3MgbW9yZSAoSW5wdXQubGVuZ3RoIGlucHV0IC0gcG9zKVxuICB9XG5cbmxldCBjb21taXQgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgSW5wdXQuY29tbWl0IGlucHV0IHBvcztcbiAgICBzdWNjIGlucHV0IHBvcyBtb3JlICgpIH1cblxuKCogRG8gbm90IHVzZSB0aGlzIGlmIFtwXSBjb250YWlucyBhIFtjb21taXRdLiAqKVxubGV0IHVuc2FmZV9sb29rYWhlYWQgcCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBzdWNjJyBpbnB1dCcgXyBtb3JlJyB2ID0gc3VjYyBpbnB1dCcgcG9zIG1vcmUnIHYgaW5cbiAgICBwLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MnIH1cblxubGV0IHBlZWtfY2hhciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIF9mYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSAoU29tZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcykpXG4gICAgZWxzZSBpZiBtb3JlID0gQ29tcGxldGUgdGhlblxuICAgICAgc3VjYyBpbnB1dCBwb3MgbW9yZSBOb25lXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyAoU29tZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0JyBwb3MnKSlcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIHBvcycgbW9yZScgTm9uZSBpblxuICAgICAgcHJvbXB0IGlucHV0IHBvcyBmYWlsJyBzdWNjJ1xuICB9XG5cbigqIFRoaXMgcGFyc2VyIGlzIHRvbyBpbXBvcnRhbnQgdG8gbm90IGJlIG9wdGltaXplZC4gRG8gYSBjdXN0b20gam9iLiAqKVxubGV0IHJlYyBwZWVrX2NoYXJfZmFpbCA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGlmIHBvcyA8IElucHV0Lmxlbmd0aCBpbnB1dFxuICAgIHRoZW4gc3VjYyBpbnB1dCBwb3MgbW9yZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcylcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKCkgPVxuICAgICAgICBwZWVrX2NoYXJfZmFpbC5ydW4gaW5wdXQnIHBvcycgbW9yZScgZmFpbCBzdWNjIGluXG4gICAgICBlbnN1cmVfc3VzcGVuZGVkIDEgaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjJyB9XG5cbmxldCBzYXRpc2Z5IGYgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBpZiBwb3MgPCBJbnB1dC5sZW5ndGggaW5wdXQgdGhlblxuICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBpZiBmIGNcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjXG4gICAgICBlbHNlIFByaW50Zi5rc3ByaW50ZiAoZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSkgXCJzYXRpc2Z5OiAlQ1wiIGNcbiAgICBlbHNlXG4gICAgICBsZXQgc3VjYycgaW5wdXQnIHBvcycgbW9yZScgKCkgPVxuICAgICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCcgcG9zJyBpblxuICAgICAgICBpZiBmIGNcbiAgICAgICAgdGhlbiBzdWNjIGlucHV0JyAocG9zJyArIDEpIG1vcmUnIGNcbiAgICAgICAgZWxzZSBQcmludGYua3NwcmludGYgKGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10pIFwic2F0aXNmeTogJUNcIiBjXG4gICAgICBpblxuICAgICAgZW5zdXJlX3N1c3BlbmRlZCAxIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYycgfVxuXG5sZXQgY2hhciBjID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgaWYgSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcyA9IGNcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjXG4gICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gKFByaW50Zi5zcHJpbnRmIFwiY2hhciAlQ1wiIGMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgbm90X2NoYXIgYyA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgIGxldCBjJyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIGlmIGMgPD4gYydcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSBjJ1xuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIChQcmludGYuc3ByaW50ZiBcIm5vdCBjaGFyICVDXCIgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfY2hhciA9XG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIChJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zKSAgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBpbnQ4IGkgPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IENoYXIuY29kZSAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcykgaW5cbiAgICAgIGlmIGMgPSBpIGxhbmQgMHhmZlxuICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIGNcbiAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSAoUHJpbnRmLnNwcmludGYgXCJpbnQ4ICVkXCIgaSkgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfdWludDggPVxuICBsZXQgcCA9XG4gICAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgX2ZhaWwgc3VjYyAtPlxuICAgICAgbGV0IGMgPSBJbnB1dC51bnNhZmVfZ2V0X2NoYXIgaW5wdXQgcG9zIGluXG4gICAgICBzdWNjIGlucHV0IChwb3MgKyAxKSBtb3JlIChDaGFyLmNvZGUgYykgfVxuICBpblxuICBlbnN1cmUgMSBwXG5cbmxldCBhbnlfaW50OCA9XG4gICgqIGh0dHBzOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWwjVmFyaWFibGVTaWduRXh0ZW5kUmlza3kgKilcbiAgbGV0IHMgPSBTeXMuaW50X3NpemUgLSA4IGluXG4gIGxldCBwID1cbiAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBfZmFpbCBzdWNjIC0+XG4gICAgICBsZXQgYyA9IElucHV0LnVuc2FmZV9nZXRfY2hhciBpbnB1dCBwb3MgaW5cbiAgICAgIHN1Y2MgaW5wdXQgKHBvcyArIDEpIG1vcmUgKChDaGFyLmNvZGUgYyBsc2wgcykgYXNyIHMpIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgc2tpcCBmID1cbiAgbGV0IHAgPVxuICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgaWYgZiAoSW5wdXQudW5zYWZlX2dldF9jaGFyIGlucHV0IHBvcylcbiAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgMSkgbW9yZSAoKVxuICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwic2tpcFwiIH1cbiAgaW5cbiAgZW5zdXJlIDEgcFxuXG5sZXQgcmVjIGNvdW50X3doaWxlIH5pbml0IH5mIH53aXRoX2J1ZmZlciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBsZW4gICAgICAgICA9IElucHV0LmNvdW50X3doaWxlIGlucHV0IChwb3MgKyBpbml0KSB+ZiBpblxuICAgIGxldCBpbnB1dF9sZW4gICA9IElucHV0Lmxlbmd0aCBpbnB1dCBpblxuICAgIGxldCBpbml0JyAgICAgICA9IGluaXQgKyBsZW4gaW5cbiAgICAoKiBDaGVjayBpZiB0aGUgbG9vcCB0ZXJtaW5hdGVkIGJlY2F1c2UgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuICAgICAqIGJ1ZmZlci4gSWYgc28sIHRoZW4gcHJvbXB0IGZvciBhZGRpdGlvbmFsIGlucHV0IGFuZCBjb250aW51ZS4gKilcbiAgICBpZiBwb3MgKyBpbml0JyA8IGlucHV0X2xlbiB8fCBtb3JlID0gQ29tcGxldGVcbiAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGluaXQnKSBtb3JlIChJbnB1dC5hcHBseSBpbnB1dCBwb3MgaW5pdCcgfmY6d2l0aF9idWZmZXIpXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgKGNvdW50X3doaWxlIH5pbml0OmluaXQnIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgYW5kIGZhaWwnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgc3VjYyBpbnB1dCcgKHBvcycgKyBpbml0JykgbW9yZScgKElucHV0LmFwcGx5IGlucHV0JyBwb3MnIGluaXQnIH5mOndpdGhfYnVmZmVyKVxuICAgICAgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgcmVjIGNvdW50X3doaWxlMSB+ZiB+d2l0aF9idWZmZXIgPVxuICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICBsZXQgbGVuICAgICAgICAgPSBJbnB1dC5jb3VudF93aGlsZSBpbnB1dCBwb3MgfmYgaW5cbiAgICBsZXQgaW5wdXRfbGVuICAgPSBJbnB1dC5sZW5ndGggaW5wdXQgaW5cbiAgICAoKiBDaGVjayBpZiB0aGUgbG9vcCB0ZXJtaW5hdGVkIGJlY2F1c2UgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbnB1dFxuICAgICAqIGJ1ZmZlci4gSWYgc28sIHRoZW4gcHJvbXB0IGZvciBhZGRpdGlvbmFsIGlucHV0IGFuZCBjb250aW51ZS4gKilcbiAgICBpZiBsZW4gPCAxXG4gICAgdGhlblxuICAgICAgaWYgcG9zIDwgaW5wdXRfbGVuIHx8IG1vcmUgPSBDb21wbGV0ZVxuICAgICAgdGhlbiBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiY291bnRfd2hpbGUxXCJcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgICAoY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlcikucnVuIGlucHV0JyBwb3MnIG1vcmUnIGZhaWwgc3VjY1xuICAgICAgICBhbmQgZmFpbCcgaW5wdXQnIHBvcycgbW9yZScgPVxuICAgICAgICAgIGZhaWwgaW5wdXQnIHBvcycgbW9yZScgW10gXCJjb3VudF93aGlsZTFcIlxuICAgICAgICBpblxuICAgICAgICBwcm9tcHQgaW5wdXQgcG9zIGZhaWwnIHN1Y2MnXG4gICAgZWxzZSBpZiBwb3MgKyBsZW4gPCBpbnB1dF9sZW4gfHwgbW9yZSA9IENvbXBsZXRlXG4gICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBsZW4pIG1vcmUgKElucHV0LmFwcGx5IGlucHV0IHBvcyBsZW4gfmY6d2l0aF9idWZmZXIpXG4gICAgZWxzZVxuICAgICAgbGV0IHN1Y2MnIGlucHV0JyBwb3MnIG1vcmUnID1cbiAgICAgICAgKGNvdW50X3doaWxlIH5pbml0OmxlbiB+ZiB+d2l0aF9idWZmZXIpLnJ1biBpbnB1dCcgcG9zJyBtb3JlJyBmYWlsIHN1Y2NcbiAgICAgIGFuZCBmYWlsJyBpbnB1dCcgcG9zJyBtb3JlJyA9XG4gICAgICAgIHN1Y2MgaW5wdXQnIChwb3MnICsgbGVuKSBtb3JlJyAoSW5wdXQuYXBwbHkgaW5wdXQnIHBvcycgbGVuIH5mOndpdGhfYnVmZmVyKVxuICAgICAgaW5cbiAgICAgIHByb21wdCBpbnB1dCBwb3MgZmFpbCcgc3VjYydcbiAgfVxuXG5sZXQgc3RyaW5nXyBmIHMgPVxuICAoKiBYWFgoc2VsaW9wb3UpOiBJbmVmZmljaWVudC4gQ291bGQgY2hlY2sgcHJlZml4IGVxdWFsaXR5IHRvIHNob3J0LWNpcmN1aXRcbiAgICogdGhlIGlvLiAqKVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGVuc3VyZSAgbGVuICh1bnNhZmVfYXBwbHlfb3B0IGxlbiB+ZjooZnVuIGJ1ZmZlciB+b2ZmIH5sZW4gLT5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgd2hpbGUgIWkgPCBsZW4gJiYgQ2hhci5lcXVhbCAoZiAoQmlnc3RyaW5nYWYudW5zYWZlX2dldCBidWZmZXIgKG9mZiArICFpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZiAoU3RyaW5nLnVuc2FmZV9nZXQgcyAhaSkpXG4gICAgZG9cbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgbGVuID0gIWlcbiAgICB0aGVuIE9rIChCaWdzdHJpbmdhZi5zdWJzdHJpbmcgYnVmZmVyIH5vZmYgfmxlbilcbiAgICBlbHNlIEVycm9yIFwic3RyaW5nXCIpKVxuXG5sZXQgc3RyaW5nIHMgICAgPSBzdHJpbmdfIChmdW4geCAtPiB4KSBzXG5sZXQgc3RyaW5nX2NpIHMgPSBzdHJpbmdfIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxubGV0IHNraXBfd2hpbGUgZiA9XG4gIGNvdW50X3doaWxlIH5pbml0OjAgfmYgfndpdGhfYnVmZmVyOihmdW4gXyB+b2ZmOl8gfmxlbjpfIC0+ICgpKVxuXG5sZXQgdGFrZSBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwidGFrZTogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mOkJpZ3N0cmluZ2FmLnN1YnN0cmluZylcblxubGV0IHRha2VfYmlnc3RyaW5nIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIGZhaWwgXCJ0YWtlX2JpZ3N0cmluZzogbiA8IDBcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBtYXggbiAwIGluXG4gICAgZW5zdXJlIG4gKHVuc2FmZV9hcHBseSBuIH5mOkJpZ3N0cmluZ2FmLmNvcHkpXG5cbmxldCB0YWtlX2JpZ3N0cmluZ193aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuY29weVxuXG5sZXQgdGFrZV9iaWdzdHJpbmdfd2hpbGUxIGYgPVxuICBjb3VudF93aGlsZTEgfmYgfndpdGhfYnVmZmVyOkJpZ3N0cmluZ2FmLmNvcHlcblxubGV0IHRha2VfYmlnc3RyaW5nX3RpbGwgZiA9XG4gIHRha2VfYmlnc3RyaW5nX3doaWxlIChmdW4gYyAtPiBub3QgKGYgYykpXG5cbmxldCBwZWVrX3N0cmluZyBuID1cbiAgdW5zYWZlX2xvb2thaGVhZCAodGFrZSBuKVxuXG5sZXQgdGFrZV93aGlsZSBmID1cbiAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5cbmxldCB0YWtlX3doaWxlMSBmID1cbiAgY291bnRfd2hpbGUxIH5mIH53aXRoX2J1ZmZlcjpCaWdzdHJpbmdhZi5zdWJzdHJpbmdcblxubGV0IHRha2VfdGlsbCBmID1cbiAgdGFrZV93aGlsZSAoZnVuIGMgLT4gbm90IChmIGMpKVxuXG5sZXQgY2hvaWNlID8oZmFpbHVyZV9tc2c9XCJubyBtb3JlIGNob2ljZXNcIikgcHMgPVxuICBMaXN0LmZvbGRfcmlnaHQgKDx8PikgcHMgKGZhaWwgZmFpbHVyZV9tc2cpXG5cbmxldCBub3RzZXQgPSB7IHJ1biA9IGZ1biBfYnVmIF9wb3MgX21vcmUgX2ZhaWwgX3N1Y2MgLT4gZmFpbHdpdGggXCJBbmdzdHJvbS5maXhfZGlyZWN0IG5vdCBzZXRcIiB9XG5cbmxldCBmaXhfZGlyZWN0IGYgPVxuICBsZXQgcmVjIHAgPSByZWYgbm90c2V0XG4gIGFuZCByID0geyBydW4gPSBmdW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICghcCkucnVuIGJ1ZiBwb3MgbW9yZSBmYWlsIHN1Y2MgfVxuICBpblxuICBwIDo9IGYgcjtcbiAgclxuXG5sZXQgZml4X2xhenkgfm1heF9zdGVwcyBmID1cbiAgbGV0IHN0ZXBzID0gcmVmIG1heF9zdGVwcyBpblxuICBsZXQgcmVjIHAgPSBsYXp5IChmIHIpXG4gIGFuZCByID0geyBydW4gPSBmdW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGRlY3Igc3RlcHM7XG4gICAgaWYgIXN0ZXBzIDwgMFxuICAgIHRoZW4gKFxuICAgICAgc3RlcHMgOj0gbWF4X3N0ZXBzO1xuICAgICAgU3RhdGUuTGF6eSAobGF6eSAoKExhenkuZm9yY2UgcCkucnVuIGJ1ZiBwb3MgbW9yZSBmYWlsIHN1Y2MpKSlcbiAgICBlbHNlXG4gICAgICAoTGF6eS5mb3JjZSBwKS5ydW4gYnVmIHBvcyBtb3JlIGZhaWwgc3VjY1xuICAgICAgICAgIH1cbiAgaW5cbiAgclxuXG5sZXQgZml4ID0gbWF0Y2ggU3lzLmJhY2tlbmRfdHlwZSB3aXRoXG4gIHwgTmF0aXZlIC0+IGZpeF9kaXJlY3RcbiAgfCBCeXRlY29kZSAtPiBmaXhfZGlyZWN0XG4gIHwgT3RoZXIgXyAtPiBmdW4gZiAtPiBmaXhfbGF6eSB+bWF4X3N0ZXBzOjIwIGZcblxubGV0IG9wdGlvbiB4IHAgPVxuICBwIDx8PiByZXR1cm4geFxuXG5sZXQgY29ucyB4IHhzID0geCA6OiB4c1xuXG5sZXQgcmVjIGxpc3QgcHMgPVxuICBtYXRjaCBwcyB3aXRoXG4gIHwgW10gICAgLT4gcmV0dXJuIFtdXG4gIHwgcDo6cHMgLT4gbGlmdDIgY29ucyBwIChsaXN0IHBzKVxuXG5sZXQgY291bnQgbiBwID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBmYWlsIFwiY291bnQ6IG4gPCAwXCJcbiAgZWxzZVxuICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gcmV0dXJuIFtdXG4gICAgICB8IG4gLT4gbGlmdDIgY29ucyBwIChsb29wIChuIC0gMSkpXG4gICAgaW5cbiAgICBsb29wIG5cblxubGV0IG1hbnkgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICAobGlmdDIgY29ucyBwIG0pIDx8PiByZXR1cm4gW10pXG5cbmxldCBtYW55MSBwID1cbiAgbGlmdDIgY29ucyBwIChtYW55IHApXG5cbmxldCBtYW55X3RpbGwgcCB0ID1cbiAgZml4IChmdW4gbSAtPlxuICAgICh0ICo+IHJldHVybiBbXSkgPHw+IChsaWZ0MiBjb25zIHAgbSkpXG5cbmxldCBzZXBfYnkxIHMgcCA9XG4gIGZpeCAoZnVuIG0gLT5cbiAgICBsaWZ0MiBjb25zIHAgKChzICo+IG0pIDx8PiByZXR1cm4gW10pKVxuXG5sZXQgc2VwX2J5IHMgcCA9XG4gIChsaWZ0MiBjb25zIHAgKChzICo+IHNlcF9ieTEgcyBwKSA8fD4gcmV0dXJuIFtdKSkgPHw+IHJldHVybiBbXVxuXG5sZXQgc2tpcF9tYW55IHAgPVxuICBmaXggKGZ1biBtIC0+XG4gICAgICAoKHAgPj58IGZ1biBfIC0+IHRydWUpIDx8PiByZXR1cm4gZmFsc2UpID4+PSBmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IG1cbiAgICAgIHwgZmFsc2UgLT4gcmV0dXJuICgpXG4gICAgKVxuXG5sZXQgc2tpcF9tYW55MSBwID1cbiAgcCAqPiBza2lwX21hbnkgcFxuXG5sZXQgZW5kX29mX2xpbmUgPVxuICAoY2hhciAnXFxuJyAqPiByZXR1cm4gKCkpIDx8PiAoc3RyaW5nIFwiXFxyXFxuXCIgKj4gcmV0dXJuICgpKSA8Pz4gXCJlbmRfb2ZfbGluZVwiXG5cbmxldCBzY2FuXyBzdGF0ZSBmIH53aXRoX2J1ZmZlciA9XG4gIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgIGxldCBzdGF0ZSA9IHJlZiBzdGF0ZSBpblxuICAgIGxldCBwYXJzZXIgPVxuICAgICAgY291bnRfd2hpbGUgfmluaXQ6MCB+ZjooZnVuIGMgLT5cbiAgICAgICAgbWF0Y2ggZiAhc3RhdGUgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgICB8IFNvbWUgc3RhdGUnIC0+IHN0YXRlIDo9IHN0YXRlJzsgdHJ1ZSlcbiAgICAgIH53aXRoX2J1ZmZlclxuICAgICAgPj58IGZ1biB4IC0+IHgsICFzdGF0ZVxuICAgIGluXG4gICAgcGFyc2VyLnJ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgfVxuXG5sZXQgc2NhbiBzdGF0ZSBmID1cbiAgc2Nhbl8gc3RhdGUgZiB+d2l0aF9idWZmZXI6Qmlnc3RyaW5nYWYuc3Vic3RyaW5nXG5cbmxldCBzY2FuX3N0YXRlIHN0YXRlIGYgPVxuICBzY2FuXyBzdGF0ZSBmIH53aXRoX2J1ZmZlcjooZnVuIF8gfm9mZjpfIH5sZW46XyAtPiAoKSlcbiAgPj58IGZ1biAoKCksIHN0YXRlKSAtPiBzdGF0ZVxuXG5sZXQgc2Nhbl9zdHJpbmcgc3RhdGUgZiA9XG4gIHNjYW4gc3RhdGUgZiA+PnwgZnN0XG5cbmxldCBjb25zdW1lX3dpdGggcCBmID1cbiAgeyBydW4gPSBmdW4gaW5wdXQgcG9zIG1vcmUgZmFpbCBzdWNjIC0+XG4gICAgbGV0IHN0YXJ0ID0gcG9zIGluXG4gICAgbGV0IHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgPSBJbnB1dC5wYXJzZXJfY29tbWl0dGVkX2J5dGVzIGlucHV0ICBpblxuICAgIGxldCBzdWNjJyBpbnB1dCcgcG9zJyBtb3JlJyBfID1cbiAgICAgIGlmIHBhcnNlcl9jb21taXR0ZWRfYnl0ZXMgPD4gSW5wdXQucGFyc2VyX2NvbW1pdHRlZF9ieXRlcyBpbnB1dCdcbiAgICAgIHRoZW4gZmFpbCBpbnB1dCcgcG9zJyBtb3JlJyBbXSBcImNvbnN1bWVkOiBwYXJzZXIgY29tbWl0dGVkXCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbGVuID0gcG9zJyAtIHN0YXJ0IGluXG4gICAgICAgIGxldCBjb25zdW1lZCA9IElucHV0LmFwcGx5IGlucHV0JyBzdGFydCBsZW4gfmYgaW5cbiAgICAgICAgc3VjYyBpbnB1dCcgcG9zJyBtb3JlJyBjb25zdW1lZClcbiAgICBpblxuICAgIHAucnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYydcbiAgfVxuXG5sZXQgY29uc3VtZWQgICAgICAgICAgIHAgPSBjb25zdW1lX3dpdGggcCBCaWdzdHJpbmdhZi5zdWJzdHJpbmdcbmxldCBjb25zdW1lZF9iaWdzdHJpbmcgcCA9IGNvbnN1bWVfd2l0aCBwIEJpZ3N0cmluZ2FmLmNvcHlcblxubGV0IGJvdGggYSBiID0gbGlmdDIgKGZ1biBhIGIgLT4gYSwgYikgYSBiXG5sZXQgbWFwIHQgfmYgPSB0ID4+fCBmXG5sZXQgYmluZCB0IH5mID0gdCA+Pj0gZlxubGV0IG1hcDIgYSBiIH5mID0gbGlmdDIgZiBhIGJcbmxldCBtYXAzIGEgYiBjIH5mID0gbGlmdDMgZiBhIGIgY1xubGV0IG1hcDQgYSBiIGMgZCB+ZiA9IGxpZnQ0IGYgYSBiIGMgZFxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBsZXQgKCA+Pj0gKSA9ICggPj49IClcblxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwID0gbWFwXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IGJvdGggPSBib3RoXG4gICAgbGV0IG1hcDIgPSBtYXAyXG4gICAgbGV0IG1hcDMgPSBtYXAzXG4gICAgbGV0IG1hcDQgPSBtYXA0XG4gIGVuZFxuZW5kXG5cbmxldCAoIGxldCsgKSA9ICggPj58IClcbmxldCAoIGxldCogKSA9ICggPj49IClcbmxldCAoIGFuZCsgKSA9IGJvdGhcblxubW9kdWxlIEJFID0gc3RydWN0XG4gICgqIFhYWChzZWxpb3BvdSk6IFRoZSBwYXR0ZXJuIGluIGJvdGggdGhpcyBtb2R1bGUgYW5kIFtMRV0gYXJlIGEgY29tcHJvbWlzZVxuICAgKiBiZXR3ZWVuIGVmZmljaWVuY3kgYW5kIGNvZGUgcmV1c2UuIEJ5IGlubGluaW5nIFtlbnN1cmVdIHlvdSBjYW4gcmVjb3ZlclxuICAgKiBhYm91dCAyIG5hbm9zZWNvbmRzIG9uIGF2ZXJhZ2UuIFRoYXQgbWF5IGFkZCB1cCBpbiBjZXJ0YWluIGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogVGhpcyBwYXR0ZXJuIGRvZXMgbm90IGFsbG9jYXRlIGluIHRoZSBmYXN0IChzdWNjZXNzKSBwYXRoLlxuICAgKiAqKVxuICBsZXQgaW50MTYgbiA9XG4gICAgbGV0IGJ5dGVzID0gMiBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnB1dC51bnNhZmVfZ2V0X2ludDE2X2JlIGlucHV0IHBvcyA9IChuIGxhbmQgMHhmZmZmKVxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkJFLmludDE2XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50MzIgbiA9XG4gICAgbGV0IGJ5dGVzID0gNCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQzMi5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQzMl9iZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJCRS5pbnQzMlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDY0IG4gPVxuICAgIGxldCBieXRlcyA9IDggaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50NjQuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50NjRfYmUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiQkUuaW50NjRcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG4gIGxldCBhbnlfdWludDE2ID1cbiAgICBlbnN1cmUgMiAodW5zYWZlX2FwcGx5IDIgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDE2X2JlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQxNiAgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfc2lnbl9leHRlbmRlZF9iZSAgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDMyICA9XG4gICAgZW5zdXJlIDQgKHVuc2FmZV9hcHBseSA0IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQzMl9iZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50NjQgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfYmUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2Zsb2F0ID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQzMi5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2JlIGJzIG9mZikpKVxuXG4gIGxldCBhbnlfZG91YmxlID1cbiAgICBlbnN1cmUgOCAodW5zYWZlX2FwcGx5IDggfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBJbnQ2NC5mbG9hdF9vZl9iaXRzIChCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDY0X2JlIGJzIG9mZikpKVxuZW5kXG5cbm1vZHVsZSBMRSA9IHN0cnVjdFxuICBsZXQgaW50MTYgbiA9XG4gICAgbGV0IGJ5dGVzID0gMiBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnB1dC51bnNhZmVfZ2V0X2ludDE2X2xlIGlucHV0IHBvcyA9IChuIGxhbmQgMHhmZmZmKVxuICAgICAgICB0aGVuIHN1Y2MgaW5wdXQgKHBvcyArIGJ5dGVzKSBtb3JlICgpXG4gICAgICAgIGVsc2UgZmFpbCBpbnB1dCBwb3MgbW9yZSBbXSBcIkxFLmludDE2XCIgfVxuICAgIGluXG4gICAgZW5zdXJlIGJ5dGVzIHBcblxuICBsZXQgaW50MzIgbiA9XG4gICAgbGV0IGJ5dGVzID0gNCBpblxuICAgIGxldCBwID1cbiAgICAgIHsgcnVuID0gZnVuIGlucHV0IHBvcyBtb3JlIGZhaWwgc3VjYyAtPlxuICAgICAgICBpZiBJbnQzMi5lcXVhbCAoSW5wdXQudW5zYWZlX2dldF9pbnQzMl9sZSBpbnB1dCBwb3MpIG5cbiAgICAgICAgdGhlbiBzdWNjIGlucHV0IChwb3MgKyBieXRlcykgbW9yZSAoKVxuICAgICAgICBlbHNlIGZhaWwgaW5wdXQgcG9zIG1vcmUgW10gXCJMRS5pbnQzMlwiIH1cbiAgICBpblxuICAgIGVuc3VyZSBieXRlcyBwXG5cbiAgbGV0IGludDY0IG4gPVxuICAgIGxldCBieXRlcyA9IDggaW5cbiAgICBsZXQgcCA9XG4gICAgICB7IHJ1biA9IGZ1biBpbnB1dCBwb3MgbW9yZSBmYWlsIHN1Y2MgLT5cbiAgICAgICAgaWYgSW50NjQuZXF1YWwgKElucHV0LnVuc2FmZV9nZXRfaW50NjRfbGUgaW5wdXQgcG9zKSBuXG4gICAgICAgIHRoZW4gc3VjYyBpbnB1dCAocG9zICsgYnl0ZXMpIG1vcmUgKClcbiAgICAgICAgZWxzZSBmYWlsIGlucHV0IHBvcyBtb3JlIFtdIFwiTEUuaW50NjRcIiB9XG4gICAgaW5cbiAgICBlbnN1cmUgYnl0ZXMgcFxuXG5cbiAgbGV0IGFueV91aW50MTYgPVxuICAgIGVuc3VyZSAyICh1bnNhZmVfYXBwbHkgMiB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MTZfbGUgYnMgb2ZmKSlcblxuICBsZXQgYW55X2ludDE2ICA9XG4gICAgZW5zdXJlIDIgKHVuc2FmZV9hcHBseSAyIH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQxNl9zaWduX2V4dGVuZGVkX2xlICBicyBvZmYpKVxuXG4gIGxldCBhbnlfaW50MzIgID1cbiAgICBlbnN1cmUgNCAodW5zYWZlX2FwcGx5IDQgfmY6KGZ1biBicyB+b2ZmIH5sZW46XyAtPiBCaWdzdHJpbmdhZi51bnNhZmVfZ2V0X2ludDMyX2xlIGJzIG9mZikpXG5cbiAgbGV0IGFueV9pbnQ2NCA9XG4gICAgZW5zdXJlIDggKHVuc2FmZV9hcHBseSA4IH5mOihmdW4gYnMgfm9mZiB+bGVuOl8gLT4gQmlnc3RyaW5nYWYudW5zYWZlX2dldF9pbnQ2NF9sZSBicyBvZmYpKVxuXG4gIGxldCBhbnlfZmxvYXQgPVxuICAgIGVuc3VyZSA0ICh1bnNhZmVfYXBwbHkgNCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDMyLmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50MzJfbGUgYnMgb2ZmKSkpXG5cbiAgbGV0IGFueV9kb3VibGUgPVxuICAgIGVuc3VyZSA4ICh1bnNhZmVfYXBwbHkgOCB+ZjooZnVuIGJzIH5vZmYgfmxlbjpfIC0+IEludDY0LmZsb2F0X29mX2JpdHMgKEJpZ3N0cmluZ2FmLnVuc2FmZV9nZXRfaW50NjRfbGUgYnMgb2ZmKSkpXG5lbmRcblxubW9kdWxlIFVuc2FmZSA9IHN0cnVjdFxuICBsZXQgdGFrZSBuIGYgPVxuICAgIGxldCBuID0gbWF4IG4gMCBpblxuICAgIGVuc3VyZSBuICh1bnNhZmVfYXBwbHkgbiB+ZilcblxuICBsZXQgcGVlayBuIGYgPVxuICAgIHVuc2FmZV9sb29rYWhlYWQgKHRha2UgbiBmKVxuXG4gIGxldCB0YWtlX3doaWxlIGNoZWNrIGYgPVxuICAgIGNvdW50X3doaWxlIH5pbml0OjAgfmY6Y2hlY2sgfndpdGhfYnVmZmVyOmZcblxuICBsZXQgdGFrZV93aGlsZTEgY2hlY2sgZiA9XG4gICAgY291bnRfd2hpbGUxIH5mOmNoZWNrIH53aXRoX2J1ZmZlcjpmXG5cbiAgbGV0IHRha2VfdGlsbCBjaGVjayBmID1cbiAgICB0YWtlX3doaWxlIChmdW4gYyAtPiBub3QgKGNoZWNrIGMpKSBmXG5lbmRcblxubW9kdWxlIENvbnN1bWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IFByZWZpeFxuICAgIHwgQWxsXG5lbmRcblxubGV0IHBhcnNlX2JpZ3N0cmluZyB+Y29uc3VtZSBwIGJzID1cbiAgbGV0IHAgPVxuICAgIG1hdGNoIChjb25zdW1lIDogQ29uc3VtZS50KSB3aXRoXG4gICAgfCBQcmVmaXggLT4gcFxuICAgIHwgQWxsIC0+IHAgPCogZW5kX29mX2lucHV0XG4gIGluXG4gIFVuYnVmZmVyZWQucGFyc2VfYmlnc3RyaW5nIHAgYnNcblxubGV0IHBhcnNlX3N0cmluZyB+Y29uc3VtZSBwIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBicyAgPSBCaWdzdHJpbmdhZi5jcmVhdGUgbGVuIGluXG4gIEJpZ3N0cmluZ2FmLnVuc2FmZV9ibGl0X2Zyb21fc3RyaW5nIHMgfnNyY19vZmY6MCBicyB+ZHN0X29mZjowIH5sZW47XG4gIHBhcnNlX2JpZ3N0cmluZyB+Y29uc3VtZSBwIGJzXG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
