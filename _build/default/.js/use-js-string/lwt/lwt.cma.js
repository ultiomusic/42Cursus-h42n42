// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Lwt_sequence
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Empty = [248, "Lwt_sequence.Empty", runtime.caml_fresh_oo_id(0)];
   function get(node){return node[3];}
   function set(node, data){node[3] = data; return 0;}
   function remove(node){
    var
     _k_ = node[4],
     _l_ =
       _k_
        ? (node[4] = 0, node[1][2] = node[2], node[2][1] = node[1], 0)
        : _k_;
    return _l_;
   }
   function create(param){
    var seq = [];
    runtime.caml_update_dummy(seq, [0, seq, seq]);
    return seq;
   }
   function clear(seq){seq[1] = seq; seq[2] = seq; return 0;}
   function is_empty(seq){return seq[2] === seq ? 1 : 0;}
   function length(seq){
    var curr$1 = seq[2], curr = curr$1, len = 0;
    for(;;){
     if(curr === seq) return len;
     var len$0 = len + 1 | 0, curr$0 = curr[2];
     curr = curr$0;
     len = len$0;
    }
   }
   function add_l(data, seq){
    var node = [0, seq, seq[2], data, 1];
    seq[2][1] = node;
    seq[2] = node;
    return node;
   }
   function add_r(data, seq){
    var node = [0, seq[1], seq, data, 1];
    seq[1][2] = node;
    seq[1] = node;
    return node;
   }
   function take_l(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[2];
    remove(node);
    return node[3];
   }
   function take_r(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[1];
    remove(node);
    return node[3];
   }
   function take_opt_l(seq){
    if(is_empty(seq)) return 0;
    var node = seq[2];
    remove(node);
    return [0, node[3]];
   }
   function take_opt_r(seq){
    if(is_empty(seq)) return 0;
    var node = seq[1];
    remove(node);
    return [0, node[3]];
   }
   function transfer_l(s1, s2){
    s2[2][1] = s1[1];
    s1[1][2] = s2[2];
    s2[2] = s1[2];
    s1[2][1] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function transfer_r(s1, s2){
    s2[1][2] = s1[2];
    s1[2][1] = s2[1];
    s2[1] = s1[1];
    s1[1][2] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function iter_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _j_ = curr !== seq ? 1 : 0;
     if(! _j_) return _j_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[2];
     curr = curr$0;
    }
   }
   function iter_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _i_ = curr !== seq ? 1 : 0;
     if(! _i_) return _i_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[1];
     curr = curr$0;
    }
   }
   function iter_node_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _h_ = curr !== seq ? 1 : 0;
     if(! _h_) return _h_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[2];
     curr = curr$0;
    }
   }
   function iter_node_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _g_ = curr !== seq ? 1 : 0;
     if(! _g_) return _g_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[1];
     curr = curr$0;
    }
   }
   function fold_l(f, seq, acc){
    var curr$2 = seq[2], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4]){
      var acc$1 = caml_call2(f, curr[3], acc$0), curr$0 = curr[2];
      curr = curr$0;
      acc$0 = acc$1;
     }
     else{var curr$1 = curr[2]; curr = curr$1;}
    }
   }
   function fold_r(f, seq, acc){
    var curr$2 = seq[1], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4]){
      var acc$1 = caml_call2(f, curr[3], acc$0), curr$0 = curr[1];
      curr = curr$0;
      acc$0 = acc$1;
     }
     else{var curr$1 = curr[1]; curr = curr$1;}
    }
   }
   function find_node_l(f, seq){
    var curr$2 = seq[2], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[2];
      curr = curr$0;
     }
     else{var curr$1 = curr[2]; curr = curr$1;}
    }
   }
   function find_node_r(f, seq){
    var curr$2 = seq[1], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[1];
      curr = curr$0;
     }
     else{var curr$1 = curr[1]; curr = curr$1;}
    }
   }
   function find_node_opt_l(f, seq){
    try{var _e_ = [0, find_node_l(f, seq)]; return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function find_node_opt_r(f, seq){
    try{var _b_ = [0, find_node_r(f, seq)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var
    Lwt_sequence =
      [0,
       get,
       set,
       remove,
       create,
       clear,
       is_empty,
       length,
       add_l,
       add_r,
       Empty,
       take_l,
       take_r,
       take_opt_l,
       take_opt_r,
       transfer_l,
       transfer_r,
       iter_l,
       iter_r,
       iter_node_l,
       iter_node_r,
       fold_l,
       fold_r,
       find_node_opt_l,
       find_node_opt_r,
       find_node_l,
       find_node_r];
   runtime.caml_register_global(2, Lwt_sequence, "Lwt_sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt
//# unitInfo: Requires: CamlinternalLazy, Lwt_sequence, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Lwt = "Lwt.",
    cst_Lwt_s = "Lwt.%s",
    cst_src_core_lwt_ml = "src/core/lwt.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Map = global_data.Stdlib__Map,
    compare = runtime.caml_compare,
    Storage_map = caml_call1(Stdlib_Map[1], [0, compare]);
   function state_of_result(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var exn = param[1];
    return [1, exn];
   }
   function underlying(p){
    var match = p[1];
    switch(match[0]){
      case 0:
       return p;
      case 1:
       return p;
      case 2:
       return p;
      default:
       var p2 = match[1], p1 = underlying(p2);
       if(1 - (p1 === p2 ? 1 : 0)) p[1] = [3, p1];
       return p1;
    }
   }
   function handle_all(param){return 1;}
   function handle_all_except_runtime(param){
    return param === Stdlib[9] ? 0 : param === Stdlib[10] ? 0 : 1;
   }
   var v = [0, handle_all];
   function set(f){v[1] = f; return 0;}
   function run(e){return caml_call1(v[1], e);}
   var next_key_id = [0, 0];
   function new_key(param){
    var id = next_key_id[1];
    next_key_id[1] = id + 1 | 0;
    return [0, id, 0];
   }
   var
    current_storage = [0, Storage_map[1]],
    _a_ = [0, cst_src_core_lwt_ml, 980, 23],
    _b_ = [0, cst_src_core_lwt_ml, 981, 22],
    cst_Fatal_error_exception = "Fatal error: exception ";
   function get(key){
    if(! caml_call2(Storage_map[32], key[1], current_storage[1])) return 0;
    var refresh = caml_call2(Storage_map[17], key[1], current_storage[1]);
    caml_call1(refresh, 0);
    var value = key[2];
    key[2] = 0;
    return value;
   }
   function with_value(key, value, f){
    if(value)
     var
      refresh = function(param){key[2] = value; return 0;},
      new_storage =
        caml_call3(Storage_map[2], key[1], refresh, current_storage[1]);
    else
     var new_storage = caml_call2(Storage_map[6], key[1], current_storage[1]);
    var saved_storage = current_storage[1];
    current_storage[1] = new_storage;
    try{
     var result = caml_call1(f, 0);
     current_storage[1] = saved_storage;
     return result;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     current_storage[1] = saved_storage;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function concat_regular_callbacks(l1, l2){
    return typeof l1 === "number"
            ? l2
            : typeof l2 === "number" ? l1 : [0, l1, l2];
   }
   function clean_up_callback_cells(callbacks){
    if(typeof callbacks !== "number")
     switch(callbacks[0]){
       case 0:
        var
         l2 = callbacks[2],
         l1 = callbacks[1],
         l1$0 = clean_up_callback_cells(l1),
         l2$0 = clean_up_callback_cells(l2);
        return concat_regular_callbacks(l1$0, l2$0);
       case 2:
        if(! callbacks[1][1]) return 0; break;
     }
    return callbacks;
   }
   function clear_explicitly_removable_cal(cell, ps){
    cell[1] = 0;
    return caml_call1
            (caml_call1
              (Stdlib_List[18],
               function(p){
                var match = underlying(p)[1];
                switch(match[0]){
                  case 1:
                   return 0;
                  case 2:
                   var callbacks = match[1], _aU_ = callbacks[1];
                   if(typeof _aU_ !== "number" && 2 === _aU_[0]){callbacks[1] = 0; return 0;}
                   var cleanups_deferred = callbacks[4] + 1 | 0;
                   return 42 < cleanups_deferred
                           ? (callbacks
                              [4]
                             = 0,
                             callbacks[1] = clean_up_callback_cells(callbacks[1]),
                             0)
                           : (callbacks[4] = cleanups_deferred, 0);
                  default: return 0;
                }
               }),
             ps);
   }
   function add_regular_callback_list_node(callbacks, node){
    var
     existing = callbacks[1],
     node$0 = typeof existing === "number" ? node : [0, node, existing];
    callbacks[1] = node$0;
    return 0;
   }
   function add_implicitly_removed_callbac(callbacks, f){
    return add_regular_callback_list_node(callbacks, [1, f]);
   }
   function add_explicitly_removable_callb(ps, f){
    var cell = [];
    function self_removing_callback_wrapper(result){
     clear_explicitly_removable_cal(cell, ps);
     return caml_call1(f, result);
    }
    runtime.caml_update_dummy(cell, [0, [0, self_removing_callback_wrapper]]);
    var node = [2, cell];
    caml_call1
     (caml_call1
       (Stdlib_List[18],
        function(p){
         var match = underlying(p)[1];
         switch(match[0]){
           case 1:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
           case 2:
            var callbacks = match[1];
            return add_regular_callback_list_node(callbacks, node);
           default:
            throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
         }
        }),
      ps);
    return cell;
   }
   function add_explicitly_removable_callb$0(ps, f){add_explicitly_removable_callb(ps, f);
   }
   function add_cancel_callback(callbacks, f){
    var
     node = [1, current_storage[1], f],
     node$0 =
       typeof callbacks[2] === "number" ? node : [0, node, callbacks[2]];
    callbacks[2] = node$0;
    return 0;
   }
   var
    async_exception_hook =
      [0,
       function(exn){
        caml_call1(Stdlib[49], cst_Fatal_error_exception);
        var _aT_ = caml_call1(Stdlib_Printexc[1], exn);
        caml_call1(Stdlib[49], _aT_);
        caml_call1(Stdlib[48], 10);
        caml_call1(Stdlib_Printexc[5], Stdlib[40]);
        caml_call1(Stdlib[63], Stdlib[40]);
        return caml_call1(Stdlib[99], 2);
       }];
   function handle_with_async_exception_ho(f, v){
    try{var _aS_ = caml_call1(f, v); return _aS_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return caml_call1(async_exception_hook[1], exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    Canceled =
      [248, "Lwt.Resolution_loop.Canceled", runtime.caml_fresh_oo_id(0)];
   function run_callbacks(callbacks, result){
    if(1 === result[0])
     var _aR_ = result[1] === Canceled ? 1 : 0, is_canceled = _aR_;
    else
     var is_canceled = 0;
    if(is_canceled){
     var
      fs = callbacks[2],
      iter_callback_list$2 =
        function(counter, fs, rest){
         var fs$0 = fs, rest$0 = rest;
         for(;;){
          if(typeof fs$0 === "number"){
           if(counter >= 50)
            return caml_trampoline_return(iter_list$0, [0, rest$0]);
           var counter$0 = counter + 1 | 0;
           return iter_list$0(counter$0, rest$0);
          }
          switch(fs$0[0]){
            case 0:
             var fs$1 = fs$0[2], fs$2 = fs$0[1], rest$1 = [0, fs$1, rest$0];
             fs$0 = fs$2;
             rest$0 = rest$1;
             break;
            case 1:
             var f = fs$0[2], storage = fs$0[1];
             current_storage[1] = storage;
             handle_with_async_exception_ho(f, 0);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$1 = counter + 1 | 0;
             return iter_list$0(counter$1, rest$0);
            default:
             var node = fs$0[1];
             caml_call1(Lwt_sequence[3], node);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$2 = counter + 1 | 0;
             return iter_list$0(counter$2, rest$0);
          }
         }
        },
      iter_callback_list =
        function(fs, rest){
         return caml_trampoline(iter_callback_list$2(0, fs, rest));
        },
      iter_list$0 =
        function(counter, rest){
         if(! rest) return;
         var rest$0 = rest[2], fs = rest[1];
         if(counter >= 50)
          return caml_trampoline_return(iter_callback_list$2, [0, fs, rest$0]);
         var counter$0 = counter + 1 | 0;
         return iter_callback_list$2(counter$0, fs, rest$0);
        };
     iter_callback_list(fs, 0);
    }
    var fs$0 = callbacks[1];
    function iter_callback_list$1(counter, fs, rest){
     var fs$0 = fs, rest$0 = rest;
     for(;;){
      if(typeof fs$0 === "number"){
       if(counter >= 50)
        return caml_trampoline_return(iter_list, [0, rest$0]);
       var counter$0 = counter + 1 | 0;
       return iter_list(counter$0, rest$0);
      }
      switch(fs$0[0]){
        case 0:
         var fs$1 = fs$0[2], fs$2 = fs$0[1], rest$1 = [0, fs$1, rest$0];
         fs$0 = fs$2;
         rest$0 = rest$1;
         break;
        case 1:
         var f = fs$0[1];
         caml_call1(f, result);
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$1 = counter + 1 | 0;
         return iter_list(counter$1, rest$0);
        default:
         var match = fs$0[1][1];
         if(match){
          var f$0 = match[1];
          caml_call1(f$0, result);
          if(counter >= 50)
           return caml_trampoline_return(iter_list, [0, rest$0]);
          var counter$2 = counter + 1 | 0;
          return iter_list(counter$2, rest$0);
         }
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$3 = counter + 1 | 0;
         return iter_list(counter$3, rest$0);
      }
     }
    }
    function iter_callback_list$0(fs, rest){
     return caml_trampoline(iter_callback_list$1(0, fs, rest));
    }
    function iter_list(counter, rest){
     if(! rest) return 0;
     var rest$0 = rest[2], fs = rest[1];
     if(counter >= 50)
      return caml_trampoline_return(iter_callback_list$1, [0, fs, rest$0]);
     var counter$0 = counter + 1 | 0;
     return iter_callback_list$1(counter$0, fs, rest$0);
    }
    return iter_callback_list$0(fs$0, 0);
   }
   var
    current_callback_nesting_depth = [0, 0],
    deferred_callbacks = caml_call1(Stdlib_Queue[2], 0),
    default_maximum_callback_nesti = 42,
    _c_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _d_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _e_ = [0, 0],
    cst_wakeup_result = "wakeup_result",
    cst_wakeup = "wakeup",
    cst_wakeup_exn = "wakeup_exn",
    _f_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _g_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _h_ = [0, 1],
    cst_wakeup_later_result = "wakeup_later_result",
    cst_wakeup_later = "wakeup_later",
    cst_wakeup_later_exn = "wakeup_later_exn",
    _i_ = [0, 0];
   function leave_resolution_loop(storage_snapshot){
    if(1 === current_callback_nesting_depth[1])
     for(;;){
      if(caml_call1(Stdlib_Queue[13], deferred_callbacks)) break;
      var
       match = caml_call1(Stdlib_Queue[7], deferred_callbacks),
       result = match[2],
       callbacks = match[1];
      run_callbacks(callbacks, result);
     }
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] - 1 | 0;
    current_storage[1] = storage_snapshot;
    return 0;
   }
   function run_in_resolution_loop(f){
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] + 1 | 0;
    var storage_snapshot = current_storage[1], result = caml_call1(f, 0);
    leave_resolution_loop(storage_snapshot);
    return result;
   }
   function abandon_wakeups(param){
    var _aQ_ = 0 !== current_callback_nesting_depth[1] ? 1 : 0;
    return _aQ_ ? leave_resolution_loop(Storage_map[1]) : _aQ_;
   }
   function run_callbacks_or_defer_them(_aP_, opt, callbacks, result){
    var
     allow_deferring = _aP_ ? _aP_[1] : 1,
     maximum_callback_nesting_depth =
       opt ? opt[1] : default_maximum_callback_nesti,
     should_defer =
       allow_deferring
        ? maximum_callback_nesting_depth
          <= current_callback_nesting_depth[1]
          ? 1
          : 0
        : allow_deferring;
    return should_defer
            ? caml_call2
              (Stdlib_Queue[4], [0, callbacks, result], deferred_callbacks)
            : run_in_resolution_loop
              (function(param){return run_callbacks(callbacks, result);});
   }
   function resolve
   (allow_deferring, maximum_callback_nesting_depth, p, result){
    var callbacks = p[1][1];
    p[1] = result;
    run_callbacks_or_defer_them
     (allow_deferring, maximum_callback_nesting_depth, callbacks, result);
    return p;
   }
   function run_callback_or_defer_it(opt, f, if_deferred){
    var run_immediately_and_ensure_tai = opt ? opt[1] : 0;
    if(run_immediately_and_ensure_tai) return caml_call1(f, 0);
    var should_defer = 42 <= current_callback_nesting_depth[1] ? 1 : 0;
    if(! should_defer)
     return run_in_resolution_loop(function(param){return caml_call1(f, 0);});
    var
     match = caml_call1(if_deferred, 0),
     deferred_result = match[3],
     deferred_callback = match[2],
     immediate_result = match[1],
     deferred_record = [0, [1, deferred_callback], 0, 0, 0];
    caml_call2
     (Stdlib_Queue[4],
      [0, deferred_record, deferred_result],
      deferred_callbacks);
    return immediate_result;
   }
   function wakeup_general(api_function_name, r, result){
    var p = underlying(r), _aO_ = p[1];
    switch(_aO_[0]){
      case 1:
       return _aO_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _d_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(_e_, 0, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _c_, api_function_name);
    }
   }
   function wakeup_result(r, result){
    return wakeup_general(cst_wakeup_result, r, result);
   }
   function wakeup(r, v){return wakeup_general(cst_wakeup, r, [0, v]);}
   function wakeup_exn(r, exn){
    return wakeup_general(cst_wakeup_exn, r, [1, exn]);
   }
   function wakeup_later_general(api_function_name, r, result){
    var p = underlying(r), _aN_ = p[1];
    switch(_aN_[0]){
      case 1:
       return _aN_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _g_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(0, _h_, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _f_, api_function_name);
    }
   }
   function wakeup_later_result(r, result){
    return wakeup_later_general(cst_wakeup_later_result, r, result);
   }
   function wakeup_later(r, v){
    return wakeup_later_general(cst_wakeup_later, r, [0, v]);
   }
   function wakeup_later_exn(r, exn){
    return wakeup_later_general(cst_wakeup_later_exn, r, [1, exn]);
   }
   function cancel(p){
    var canceled_result = [1, Canceled];
    function cancel_and_collect_callbacks(callbacks_accumulator, p){
     var p$0 = p;
     for(;;){
      var p$1 = underlying(p$0), match = p$1[1];
      switch(match[0]){
        case 1:
         return callbacks_accumulator;
        case 2:
         var callbacks = match[1], match$0 = callbacks[3];
         if(typeof match$0 === "number")
          return 0 === match$0
                  ? callbacks_accumulator
                  : (p$1
                     [1]
                    = canceled_result,
                    [0, callbacks, callbacks_accumulator]);
         if(0 !== match$0[0]){
          var ps = match$0[1];
          return caml_call3
                  (Stdlib_List[26],
                   cancel_and_collect_callbacks,
                   callbacks_accumulator,
                   ps);
         }
         var p$2 = match$0[1];
         p$0 = p$2;
         break;
        default: return callbacks_accumulator;
      }
     }
    }
    var callbacks = cancel_and_collect_callbacks(0, p);
    return caml_call1
            (caml_call1
              (Stdlib_List[18],
               function(param){
                return run_callbacks_or_defer_them
                        (_i_, 0, param, canceled_result);
               }),
             callbacks);
   }
   function return$0(v){return [0, [0, v]];}
   function of_result(result){return [0, state_of_result(result)];}
   function fail(exn){return [0, [1, exn]];}
   var return_unit = return$0(0), return_none = return$0(0);
   function return_some(x){return return$0([0, x]);}
   var
    return_nil = return$0(0),
    return_true = return$0(1),
    return_false = return$0(0),
    _j_ = [0, 0],
    _k_ = [0, 0],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _n_ = [0, 0],
    _o_ = [0, 1],
    _p_ = [0, 0],
    _q_ = [0, 1],
    _r_ = [0, 0],
    _s_ = [0, 0],
    _t_ = [0, 1],
    _u_ = [0, 0],
    _v_ = [0, 1],
    _w_ = [0, 0],
    _x_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1],
    _A_ = [0, 1],
    _B_ = [0, 1],
    _C_ = [0, 0],
    _D_ = [0, 1],
    _E_ = [0, 1],
    _F_ = [0, 1],
    _G_ = [0, 1],
    _H_ = [0, 1],
    _I_ = [0, 1],
    _J_ = [0, 1],
    _K_ = [0, 0],
    _L_ = [0, 0],
    _M_ = [0, cst_src_core_lwt_ml, 2651, 13],
    _N_ = [0, cst_src_core_lwt_ml, 2670, 24],
    _O_ = [0, cst_src_core_lwt_ml, 2709, 6],
    _P_ = [0, cst_src_core_lwt_ml, 2729, 6];
   function return_ok(x){return return$0([0, x]);}
   function return_error(x){return return$0([1, x]);}
   function fail_with(msg){return [0, [1, [0, Stdlib[7], msg]]];}
   function fail_invalid_arg(msg){return [0, [1, [0, Stdlib[6], msg]]];}
   function new_pending(how_to_cancel){
    var state = [2, [0, 0, 0, how_to_cancel, 0]];
    return [0, state];
   }
   function wait(param){var p = new_pending(0); return [0, p, p];}
   function task(param){var p = new_pending(1); return [0, p, p];}
   function add_task_r(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[9], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function add_task_l(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[8], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function protected$0(p_internal){
    switch(underlying(p_internal)[1][0]){
      case 1:
       return p_internal;
      case 2:
       var
        p = new_pending(1),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_j_, 0, p$0, p_result);
           return 0;
          },
        ps = [0, p_internal, 0],
        cell = add_explicitly_removable_callb(ps, callback),
        remove_the_callback =
          function(param){return clear_explicitly_removable_cal(cell, ps);},
        p_callbacks = p[1][1];
       add_cancel_callback(p_callbacks, remove_the_callback);
       return p;
      default: return p_internal;
    }
   }
   function no_cancel(p_internal){
    var match = underlying(p_internal)[1];
    switch(match[0]){
      case 1:
       return p_internal;
      case 2:
       var
        p_callbacks = match[1],
        p = new_pending(0),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_k_, 0, p$0, p_result);
           return 0;
          };
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p;
      default: return p_internal;
    }
   }
   function make_into_proxy(outer_promise, user_provided_promise){
    var p1 = underlying(user_provided_promise);
    if(p1 === outer_promise) return p1;
    var match = p1[1];
    switch(match[0]){
      case 1:
       return resolve(_m_, 0, outer_promise, p1[1]);
      case 2:
       var
        p_callbacks = match[1],
        outer_callbacks = outer_promise[1][1],
        regular_callbacks =
          concat_regular_callbacks(outer_callbacks[1], p_callbacks[1]),
        cleanups_deferred = outer_callbacks[4] + p_callbacks[4] | 0;
       if(42 < cleanups_deferred)
        var
         cleanups_deferred$0 = 0,
         regular_callbacks$0 = clean_up_callback_cells(regular_callbacks);
       else
        var
         cleanups_deferred$0 = cleanups_deferred,
         regular_callbacks$0 = regular_callbacks;
       var
        l2 = p_callbacks[2],
        l1 = outer_callbacks[2],
        cancel_callbacks =
          typeof l1 === "number"
           ? l2
           : typeof l2 === "number" ? l1 : [0, l1, l2];
       outer_callbacks[1] = regular_callbacks$0;
       outer_callbacks[2] = cancel_callbacks;
       outer_callbacks[4] = cleanups_deferred$0;
       outer_callbacks[3] = p_callbacks[3];
       var state = [3, outer_promise];
       p1[1] = state;
       return outer_promise;
      default: return resolve(_l_, 0, outer_promise, p1[1]);
    }
   }
   function symbol_bind(p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$2 = underlying(p);
       resolve(_n_, 0, p$2, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aM_ = caml_call1(f, v), p$0 = _aM_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = result[1];
       return run_callback_or_defer_it
               (_o_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function backtrace_bind(add_loc, p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1], p$2 = underlying(p);
       resolve(_p_, 0, p$2, [1, caml_call1(add_loc, exn$0)]);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aL_ = caml_call1(f, v), p$0 = _aL_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [0, [1, caml_call1(add_loc, exn)]];
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_q_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function symbol(f, p){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$1 = underlying(p);
       resolve(_s_, 0, p$1, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aK_ = [0, caml_call1(f, v)], p_result$0 = _aK_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p_result$0 = [1, exn];
      }
      var p$0 = underlying(p);
      resolve(_r_, 0, p$0, p_result$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = result[1];
       return run_callback_or_defer_it
               (_t_,
                function(param){
                 try{var _aJ_ = [0, caml_call1(f, v)], _aI_ = _aJ_;}
                 catch(exn$0){
                  var exn = caml_wrap_exception(exn$0);
                  if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
                  var _aI_ = [1, exn];
                 }
                 return [0, _aI_];
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function catch$0(f, h){
    try{var _aG_ = caml_call1(f, 0), p = _aG_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_u_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aH_ = caml_call1(h, exn), p$1 = _aH_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(exn$0);
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_v_,
                function(param){return caml_call1(h, exn$0);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function backtrace_catch(add_loc, f, h){
    try{var _aE_ = caml_call1(f, 0), p = _aE_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_w_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aF_ = caml_call1(h, exn), p$1 = _aF_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(caml_call1(add_loc, exn$0));
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_x_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function try_bind(f$0, f, h){
    try{var _aB_ = caml_call1(f$0, 0), p = _aB_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aD_ = caml_call1(h, exn$0), p$2 = _aD_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(exn$1);
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aC_ = caml_call1(f, v), p$0 = _aC_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_z_,
                function(param){return caml_call1(h, exn$0);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_y_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function backtrace_try_bind(add_loc, f$0, f, h){
    try{var _ay_ = caml_call1(f$0, 0), p = _ay_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aA_ = caml_call1(h, exn$0), p$2 = _aA_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(caml_call1(add_loc, exn$1));
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _az_ = caml_call1(f, v), p$0 = _az_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return run_callback_or_defer_it
               (_B_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_A_,
                function(param){return caml_call1(f, v);},
                function(param){
                 var
                  match = create_result_promise_and_call(0),
                  callback = match[2],
                  p = match[1];
                 return [0, p, callback, p$0[1]];
                });
    }
   }
   function finalize(f$0, f){
    return try_bind
            (f$0,
             function(x){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return return$0(x);});
             },
             function(e){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return fail(e);});
             });
   }
   function backtrace_finalize(add_loc, f$0, f){
    return backtrace_try_bind
            (add_loc,
             f$0,
             function(x){
              return symbol_bind
                      (caml_call1(f, 0), function(param){return return$0(x);});
             },
             function(e){
              return symbol_bind
                      (caml_call1(f, 0),
                       function(param){return fail(caml_call1(add_loc, e));});
             });
   }
   function on_cancel(p, f){
    var p$0 = underlying(p), match = p$0[1];
    switch(match[0]){
      case 1:
       return match[1] === Canceled
               ? run_callback_or_defer_it
                 (_D_,
                  function(param){
                   return handle_with_async_exception_ho(f, 0);
                  },
                  function(param){
                   return [0,
                           0,
                           function(param){
                            return handle_with_async_exception_ho(f, 0);
                           },
                           _C_];
                  })
               : 0;
      case 2:
       var callbacks = match[1]; return add_cancel_callback(callbacks, f);
      default: return 0;
    }
   }
   function on_success(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]) return 0;
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return 0;
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_E_,
                function(param){return handle_with_async_exception_ho(f, v);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function on_failure(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 !== result[0]) return 0;
      var exn = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, exn);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1];
       return run_callback_or_defer_it
               (_F_,
                function(param){
                 return handle_with_async_exception_ho(f, exn);
                },
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function on_termination(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, 0);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return run_callback_or_defer_it
               (_H_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       return run_callback_or_defer_it
               (_G_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function on_any(p, f, g){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]){
       var exn = result[1];
       current_storage[1] = saved_storage;
       return handle_with_async_exception_ho(g, exn);
      }
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1];
       return run_callback_or_defer_it
               (_J_,
                function(param){
                 return handle_with_async_exception_ho(g, exn);
                },
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var v = match[1];
       return run_callback_or_defer_it
               (_I_,
                function(param){return handle_with_async_exception_ho(f, v);},
                function(param){
                 var callback = callback_if_deferred(0);
                 return [0, 0, callback, p$0[1]];
                });
    }
   }
   function wrap_in_cancelable(p_internal){
    var p_underlying = underlying(p_internal);
    switch(p_underlying[1][0]){
      case 1:
       return p_internal;
      case 2:
       var match = task(0), r = match[2], p = match[1];
       on_cancel(p, function(param){return cancel(p_internal);});
       on_any
        (p_internal,
         function(_ax_){return wakeup(r, _ax_);},
         function(_aw_){return wakeup_exn(r, _aw_);});
       return p;
      default: return p_internal;
    }
   }
   function dont_wait(f, h){
    try{var _av_ = caml_call1(f, 0), p = _av_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1]; return caml_call1(h, exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(h, exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function async(f){
    try{var _au_ = caml_call1(f, 0), p = _au_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return caml_call1(async_exception_hook[1], exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function ignore_result(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; throw caml_maybe_attach_backtrace(exn, 0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function join(ps){
    var
     p = new_pending([1, ps]),
     number_pending_in_ps = [0, 0],
     join_result = [0, _K_];
    function callback(new_result){
     if(1 === new_result[0] && 1 !== join_result[1][0])
      join_result[1] = new_result;
     number_pending_in_ps[1] = number_pending_in_ps[1] - 1 | 0;
     var _ar_ = 0 === number_pending_in_ps[1] ? 1 : 0;
     if(_ar_){
      var p$0 = underlying(p), _as_ = join_result[1];
      resolve(_L_, 0, underlying(p$0), _as_);
      var _at_ = 0;
     }
     else
      var _at_ = _ar_;
     return _at_;
    }
    var ps$0 = ps;
    for(;;){
     if(! ps$0)
      return 0 === number_pending_in_ps[1] ? [0, join_result[1]] : p;
     var ps$1 = ps$0[2], p$0 = ps$0[1], p_result = underlying(p$0)[1];
     switch(p_result[0]){
       case 1:
        if(1 !== join_result[1][0]) join_result[1] = p_result;
        ps$0 = ps$1;
        break;
       case 2:
        var p_callbacks = p_result[1];
        number_pending_in_ps[1] = number_pending_in_ps[1] + 1 | 0;
        add_implicitly_removed_callbac(p_callbacks, callback);
        ps$0 = ps$1;
        break;
       default: ps$0 = ps$1;
     }
    }
   }
   function both(p1, p2){
    var
     pair = [0, 0, 0],
     p1$0 =
       symbol_bind(p1, function(v){pair[1] = [0, v]; return return_unit;}),
     p2$0 =
       symbol_bind(p2, function(v){pair[2] = [0, v]; return return_unit;});
    return symbol
            (function(param){
              var _aq_ = pair[1], match = pair[2];
              if(_aq_ && match){
               var v2 = match[1], v1 = _aq_[1];
               return [0, v1, v2];
              }
              throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
             },
             join([0, p1$0, [0, p2$0, 0]]));
   }
   function all(ps){
    if(! ps) return return_nil;
    var _ap_ = ps[2], x = ps[1];
    if(! _ap_) return symbol(function(y){return [0, y, 0];}, x);
    if(_ap_[2]){
     var vs = runtime.caml_make_vect(caml_call1(Stdlib_List[1], ps), 0);
     return symbol
             (function(param){
               var i$1 = vs.length - 2 | 0, i = i$1, acc = 0;
               for(;;){
                if(0 > i) return acc;
                var match = vs[1 + i];
                if(! match)
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _N_], 1);
                var x = match[1], acc$0 = [0, x, acc], i$0 = i - 1 | 0;
                i = i$0;
                acc = acc$0;
               }
              },
              join
               (caml_call1
                 (caml_call1
                   (Stdlib_List[21],
                    function(index, p){
                     return symbol_bind
                             (p,
                              function(v){
                               runtime.caml_check_bound(vs, index)[1 + index] = [0, v];
                               return return_unit;
                              });
                    }),
                  ps)));
    }
    var y = _ap_[1];
    return symbol
            (function(param){
              var y = param[2], x = param[1];
              return [0, x, [0, y, 0]];
             },
             both(x, y));
   }
   function count_resolved_promises_in(ps){
    var total$1 = 0, ps$2 = ps;
    a:
    for(;;){
     if(! ps$2) return [0, total$1];
     var ps$3 = ps$2[2], p$0 = ps$2[1];
     switch(underlying(p$0)[1][0]){
       case 1:
        break a;
       case 2:
        ps$2 = ps$3; break;
       default: var total$2 = total$1 + 1 | 0; total$1 = total$2; ps$2 = ps$3;
     }
    }
    var
     rejected$1 = [0, p$0, 0],
     total = 1,
     rejected = rejected$1,
     ps$0 = ps$3;
    for(;;){
     if(! ps$0) return [1, [0, total, rejected]];
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        var rejected$0 = [0, p, rejected], total$0 = total + 1 | 0;
        total = total$0;
        rejected = rejected$0;
        ps$0 = ps$1;
        break;
       case 2:
        ps$0 = ps$1; break;
       default: ps$0 = ps$1;
     }
    }
   }
   function nth_resolved(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0) return p;
        var n$2 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$2;
        break;
       case 2:
        ps$0 = ps$1; break;
       default:
        if(0 >= n$0) return p; var n$1 = n$0 - 1 | 0; ps$0 = ps$1; n$0 = n$1;
     }
    }
   }
   function nth_resolved_and_cancel_pendin(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0){caml_call2(Stdlib_List[18], cancel, ps$1); return p;}
        var n$2 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$2;
        break;
       case 2:
        cancel(p); ps$0 = ps$1; break;
       default:
        if(0 >= n$0){caml_call2(Stdlib_List[18], cancel, ps$1); return p;}
        var n$1 = n$0 - 1 | 0;
        ps$0 = ps$1;
        n$0 = n$1;
     }
    }
   }
   var
    prng =
      [246, function(_ao_){return caml_call1(Stdlib_Random[19][1], [0]);}],
    cst_Lwt_choose_would_return_a_ =
      "Lwt.choose [] would return a promise that is pending forever",
    _Q_ = [0, 0],
    cst_Lwt_pick_would_return_a_pr =
      "Lwt.pick [] would return a promise that is pending forever",
    _R_ = [0, 0],
    cst_Lwt_nchoose_would_return_a =
      "Lwt.nchoose [] would return a promise that is pending forever",
    _S_ = [0, 0],
    cst_Lwt_npick_would_return_a_p =
      "Lwt.npick [] would return a promise that is pending forever",
    _T_ = [0, 0],
    cst_Lwt_nchoose_split_would_re =
      "Lwt.nchoose_split [] would return a promise that is pending forever",
    _U_ = [0, 0],
    _V_ = [0, 0];
   function choose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_choose_would_return_a_);
    var match = count_resolved_promises_in(ps);
    if(0 === match[0]){
     var n = match[1];
     if(0 === n){
      var
       p = new_pending([1, ps]),
       callback =
         function(result){
          var p$0 = underlying(p);
          resolve(_Q_, 0, p$0, result);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p;
     }
     if(1 === n) return nth_resolved(ps, 0);
     var _ak_ = caml_obj_tag(prng);
     a:
     if(250 === _ak_)
      var _al_ = prng[1];
     else{
      if(246 !== _ak_ && 244 !== _ak_){var _al_ = prng; break a;}
      var _al_ = caml_call1(CamlinternalLazy[2], prng);
     }
     return nth_resolved(ps, caml_call2(Stdlib_Random[19][5], _al_, n));
    }
    var
     match$0 = match[1],
     ps$0 = match$0[2],
     n$0 = match$0[1],
     _am_ = caml_obj_tag(prng);
    a:
    if(250 === _am_)
     var _an_ = prng[1];
    else{
     if(246 !== _am_ && 244 !== _am_){var _an_ = prng; break a;}
     var _an_ = caml_call1(CamlinternalLazy[2], prng);
    }
    return nth_resolved(ps$0, caml_call2(Stdlib_Random[19][5], _an_, n$0));
   }
   function pick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_pick_would_return_a_pr);
    var match = count_resolved_promises_in(ps);
    if(0 === match[0]){
     var n = match[1];
     if(0 === n){
      var
       p = new_pending([1, ps]),
       callback =
         function(result){
          caml_call2(Stdlib_List[18], cancel, ps);
          var p$0 = underlying(p);
          resolve(_R_, 0, p$0, result);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p;
     }
     if(1 === n) return nth_resolved_and_cancel_pendin(ps, 0);
     var _ag_ = caml_obj_tag(prng);
     a:
     if(250 === _ag_)
      var _ah_ = prng[1];
     else{
      if(246 !== _ag_ && 244 !== _ag_){var _ah_ = prng; break a;}
      var _ah_ = caml_call1(CamlinternalLazy[2], prng);
     }
     return nth_resolved_and_cancel_pendin
             (ps, caml_call2(Stdlib_Random[19][5], _ah_, n));
    }
    var match$0 = match[1], qs = match$0[2], n$0 = match$0[1];
    caml_call2(Stdlib_List[18], cancel, ps);
    var _ai_ = caml_obj_tag(prng);
    a:
    if(250 === _ai_)
     var _aj_ = prng[1];
    else{
     if(246 !== _ai_ && 244 !== _ai_){var _aj_ = prng; break a;}
     var _aj_ = caml_call1(CamlinternalLazy[2], prng);
    }
    return nth_resolved(qs, caml_call2(Stdlib_Random[19][5], _aj_, n$0));
   }
   function collect_fulfilled_promises_aft(results, ps){
    var results$0 = results, ps$0 = ps;
    for(;;){
     if(! ps$0) return [0, caml_call1(Stdlib_List[10], results$0)];
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        return result;
       case 2:
        ps$0 = ps$1; break;
       default:
        var v = result[1], results$1 = [0, v, results$0];
        results$0 = results$1;
        ps$0 = ps$1;
     }
    }
   }
   function nchoose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_would_return_a);
    a:
    {
     b:
     {
      var ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
       switch(result$0[0]){
         case 1:
          var p$2 = [0, result$0]; break a;
         case 2:
          ps$2 = ps$3; break;
         default: break b;
       }
      }
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          resolve(_S_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$2 = p$1;
      break a;
     }
     var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){var p$2 = return$0(caml_call1(Stdlib_List[10], acc)); break;}
      var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
      switch(result[0]){
        case 1:
         var p$2 = [0, result]; break b;
        case 2:
         ps$0 = ps$1; break;
        default:
         var v = result[1], acc$0 = [0, v, acc]; acc = acc$0; ps$0 = ps$1;
      }
     }
    }
    return p$2;
   }
   function npick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_npick_would_return_a_p);
    a:
    {
     b:
     {
      var ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
       switch(result$0[0]){
         case 1:
          caml_call2(Stdlib_List[18], cancel, ps);
          var p$2 = [0, result$0];
          break a;
         case 2:
          ps$2 = ps$3; break;
         default: break b;
       }
      }
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          caml_call2(Stdlib_List[18], cancel, ps);
          resolve(_T_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$2 = p$1;
      break a;
     }
     var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){
       caml_call2(Stdlib_List[18], cancel, ps);
       var p$2 = return$0(caml_call1(Stdlib_List[10], acc));
       break;
      }
      var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
      switch(result[0]){
        case 1:
         caml_call2(Stdlib_List[18], cancel, ps);
         var p$2 = [0, result];
         break b;
        case 2:
         ps$0 = ps$1; break;
        default:
         var v = result[1], acc$0 = [0, v, acc]; acc = acc$0; ps$0 = ps$1;
      }
     }
    }
    return p$2;
   }
   function nchoose_split(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_split_would_re);
    a:
    {
     b:
     {
      var pending_acc = 0, ps$2 = ps;
      for(;;){
       if(! ps$2) break;
       var
        ps$3 = ps$2[2],
        p_internal$0 = ps$2[1],
        result$0 = underlying(p_internal$0)[1];
       switch(result$0[0]){
         case 1:
          var p$0 = [0, result$0]; break a;
         case 2:
          var pending_acc$0 = [0, p_internal$0, pending_acc];
          pending_acc = pending_acc$0;
          ps$2 = ps$3;
          break;
         default: break b;
       }
      }
      var
       p = new_pending([1, ps]),
       callback =
         function(result$0){
          var
           to_resolve = underlying(p),
           fulfilled = 0,
           pending = 0,
           ps$0 = ps;
          for(;;){
           if(ps$0){
            var
             ps$1 = ps$0[2],
             p_internal = ps$0[1],
             result = underlying(p_internal)[1];
            switch(result[0]){
              case 1:
               resolve(_U_, 0, to_resolve, result); break;
              case 2:
               var pending$0 = [0, p_internal, pending];
               pending = pending$0;
               ps$0 = ps$1;
               continue;
              default:
               var v = result[1], fulfilled$0 = [0, v, fulfilled];
               fulfilled = fulfilled$0;
               ps$0 = ps$1;
               continue;
            }
           }
           else{
            var _af_ = caml_call1(Stdlib_List[10], pending);
            resolve
             (_V_,
              0,
              to_resolve,
              [0, [0, caml_call1(Stdlib_List[10], fulfilled), _af_]]);
           }
           return 0;
          }
         };
      add_explicitly_removable_callb$0(ps, callback);
      var p$0 = p;
      break a;
     }
     var
      v$0 = result$0[1],
      results$1 = [0, v$0, 0],
      results = results$1,
      pending = pending_acc,
      ps$0 = ps$3;
     b:
     for(;;){
      if(! ps$0){
       var p$0 = return$0([0, caml_call1(Stdlib_List[10], results), pending]);
       break;
      }
      var
       ps$1 = ps$0[2],
       p_internal = ps$0[1],
       result = underlying(p_internal)[1];
      switch(result[0]){
        case 1:
         var p$0 = [0, result]; break b;
        case 2:
         var pending$0 = [0, p_internal, pending];
         pending = pending$0;
         ps$0 = ps$1;
         break;
        default:
         var v = result[1], results$0 = [0, v, results];
         results = results$0;
         ps$0 = ps$1;
      }
     }
    }
    return p$0;
   }
   function state(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [1, exn];
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function debug_state_is(expected_state, p){
    return return$0(runtime.caml_equal(state(p), expected_state));
   }
   function is_sleeping(p){
    switch(underlying(p)[1][0]){
      case 1:
       return 0;
      case 2:
       return 1;
      default: return 0;
    }
   }
   function poll(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var e = match[1]; throw caml_maybe_attach_backtrace(e, 0);
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function apply(f, x){
    try{var _ae_ = caml_call1(f, x); return _ae_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap(f){
    try{var _ad_ = return$0(caml_call1(f, 0)); return _ad_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap1(f, x1){
    try{var _ac_ = return$0(caml_call1(f, x1)); return _ac_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap2(f, x1, x2){
    try{var _ab_ = return$0(caml_call2(f, x1, x2)); return _ab_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap3(f, x1, x2, x3){
    try{var _aa_ = return$0(caml_call3(f, x1, x2, x3)); return _aa_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap4(f, x1, x2, x3, x4){
    try{var _$_ = return$0(caml_call4(f, x1, x2, x3, x4)); return _$_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap5(f, x1, x2, x3, x4, x5){
    try{var ___ = return$0(caml_call5(f, x1, x2, x3, x4, x5)); return ___;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap6(f, x1, x2, x3, x4, x5, x6){
    try{var _Z_ = return$0(caml_call6(f, x1, x2, x3, x4, x5, x6)); return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap7(f, x1, x2, x3, x4, x5, x6, x7){
    try{
     var _Y_ = return$0(caml_call7(f, x1, x2, x3, x4, x5, x6, x7));
     return _Y_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    pause_hook = [0, function(_X_){}],
    paused = caml_call1(Lwt_sequence[4], 0),
    _W_ = [0, 0];
   function pause(param){
    var p = add_task_r(paused);
    _W_[1]++;
    caml_call1(pause_hook[1], _W_[1]);
    return p;
   }
   function wakeup_paused(param){
    if(caml_call1(Lwt_sequence[6], paused)){_W_[1] = 0; return 0;}
    var tmp = caml_call1(Lwt_sequence[4], 0);
    caml_call2(Lwt_sequence[16], paused, tmp);
    _W_[1] = 0;
    return caml_call2
            (Lwt_sequence[17], function(r){return wakeup(r, 0);}, tmp);
   }
   function register_pause_notifier(f){pause_hook[1] = f; return 0;}
   function abandon_paused(param){
    caml_call1(Lwt_sequence[5], paused);
    _W_[1] = 0;
    return 0;
   }
   function paused_count(param){return _W_[1];}
   function map(t, f){return symbol(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function symbol$0(f, p){return symbol_bind(p, f);}
   function symbol$1(p, f){return symbol(f, p);}
   function symbol$2(p$0, p){return join([0, p$0, [0, p, 0]]);}
   function symbol$3(p$0, p){return choose([0, p$0, [0, p, 0]]);}
   var Let_syntax$1 = Let_syntax$0[1];
   function let$0(x, f){return symbol(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt =
      [0,
       wait,
       wakeup_later,
       wakeup_later_exn,
       return$0,
       fail,
       symbol_bind,
       catch$0,
       finalize,
       try_bind,
       dont_wait,
       async,
       async_exception_hook,
       both,
       join,
       all,
       pick,
       choose,
       npick,
       nchoose,
       nchoose_split,
       Canceled,
       task,
       cancel,
       on_cancel,
       protected$0,
       no_cancel,
       wrap_in_cancelable,
       symbol,
       on_success,
       on_failure,
       on_termination,
       on_any,
       [0,
        symbol_bind,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$0,
        symbol,
        Let_syntax$1],
       Let_syntax$0,
       Syntax,
       return_unit,
       return_none,
       return_nil,
       return_true,
       return_false,
       return_some,
       return_ok,
       return_error,
       fail_with,
       fail_invalid_arg,
       of_result,
       wakeup_later_result,
       state,
       new_key,
       get,
       with_value,
       wakeup,
       wakeup_exn,
       wakeup_result,
       add_task_r,
       add_task_l,
       pause,
       wakeup_paused,
       paused_count,
       register_pause_notifier,
       abandon_paused,
       wrap,
       wrap1,
       wrap2,
       wrap3,
       wrap4,
       wrap5,
       wrap6,
       wrap7,
       symbol_bind,
       symbol$1,
       symbol$3,
       symbol$2,
       symbol$0,
       symbol,
       is_sleeping,
       ignore_result,
       [0, handle_all, handle_all_except_runtime, set, run],
       poll,
       apply,
       backtrace_bind,
       backtrace_catch,
       backtrace_finalize,
       backtrace_try_bind,
       abandon_wakeups,
       debug_state_is];
   runtime.caml_register_global(71, Lwt, "Lwt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_switch
//# unitInfo: Requires: Lwt, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Off = [248, "Lwt_switch.Off", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, [0, [0, 0]]];}
   function is_on(switch$0){return switch$0[1] ? 1 : 0;}
   function check(param){
    if(param && ! param[1][1]) throw caml_maybe_attach_backtrace(Off, 1);
    return 0;
   }
   function add_hook(switch$0, hook){
    if(! switch$0) return 0;
    var match = switch$0[1][1];
    if(! match) throw caml_maybe_attach_backtrace(Off, 1);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return 0;
   }
   function add_hook_or_exec(switch$0, hook){
    if(! switch$0) return Lwt[36];
    var match = switch$0[1][1];
    if(! match) return caml_call1(hook, 0);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return Lwt[36];
   }
   function turn_off(switch$0){
    var _a_ = switch$0[1];
    if(! _a_) return Lwt[36];
    var hooks = _a_[1][1];
    switch$0[1] = 0;
    var
     _b_ =
       caml_call2
        (Stdlib_List[20],
         function(hook){return caml_call2(Lwt[80], hook, 0);},
         hooks);
    return caml_call1(Lwt[14], _b_);
   }
   function with_switch(fn){
    var switch$0 = create(0);
    return caml_call2
            (Lwt[8],
             function(param){return caml_call1(fn, switch$0);},
             function(param){return turn_off(switch$0);});
   }
   var
    Lwt_switch =
      [0,
       create,
       with_switch,
       is_on,
       turn_off,
       Off,
       check,
       add_hook,
       add_hook_or_exec];
   runtime.caml_register_global(3, Lwt_switch, "Lwt_switch");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_seq
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    return_nil = caml_call1(Lwt[4], 0),
    _h_ =
      [0,
       [11,
        "Lwt_seq.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_seq.iter_n: max_concurrency must be > 0, %d given"];
   function empty(param){return return_nil;}
   function return$0(x){
    return function(param){return caml_call1(Lwt[4], [0, x, empty]);};
   }
   function return_lwt(x){
    return function(param){
     return caml_call2(Lwt[35][3], x, function(x){return [0, x, empty];});};
   }
   function cons(x, t, param){return caml_call1(Lwt[4], [0, x, t]);}
   function cons_lwt(x, t, param){
    return caml_call2(Lwt[35][3], x, function(x){return [0, x, t];});
   }
   function _a_(seq1, seq2, param){
    var _au_ = caml_call1(seq1, 0);
    return caml_call2
            (Lwt[33][1],
             _au_,
             function(param){
              if(! param) return caml_call1(seq2, 0);
              var next = param[2], x = param[1];
              return caml_call1
                      (Lwt[4],
                       [0, x, function(_av_){return _a_(next, seq2, _av_);}]);
             });
   }
   function append(seq1, seq2, param){
    var _as_ = caml_call2(Lwt[80], seq1, 0);
    return caml_call2
            (Lwt[33][1],
             _as_,
             function(param){
              if(! param) return caml_call1(seq2, 0);
              var next = param[2], x = param[1];
              return caml_call1
                      (Lwt[4],
                       [0, x, function(_at_){return _a_(next, seq2, _at_);}]);
             });
   }
   function _b_(f, seq, param){
    var _aq_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][2],
             _aq_,
             function(param){
              if(! param) return 0;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              return [0, x$0, function(_ar_){return _b_(f, next, _ar_);}];
             });
   }
   function map(f, seq, param){
    var _ao_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][2],
             _ao_,
             function(param){
              if(! param) return 0;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              return [0, x$0, function(_ap_){return _b_(f, next, _ap_);}];
             });
   }
   function _c_(f, seq, param){
    var _al_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _al_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _am_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][3],
                       _am_,
                       function(x){
                        return [0, x, function(_an_){return _c_(f, next, _an_);}];
                       });
             });
   }
   function map_s(f, seq, param){
    var _ai_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ai_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _aj_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][3],
                       _aj_,
                       function(x){
                        return [0, x, function(_ak_){return _c_(f, next, _ak_);}];
                       });
             });
   }
   function _d_(f, seq, param){
    var _ag_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ag_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              if(! x$0) return _d_(f, next, 0);
              var y = x$0[1];
              return caml_call1
                      (Lwt[4], [0, y, function(_ah_){return _d_(f, next, _ah_);}]);
             });
   }
   function filter_map(f, seq, param){
    var _ae_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ae_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], x$0 = caml_call1(f, x);
              if(! x$0) return _d_(f, next, 0);
              var y = x$0[1];
              return caml_call1
                      (Lwt[4], [0, y, function(_af_){return _d_(f, next, _af_);}]);
             });
   }
   function _e_(f, seq, param){
    var _ab_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _ab_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _ac_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _ac_,
                       function(x){
                        if(! x) return _e_(f, next, 0);
                        var y = x[1];
                        return caml_call1
                                (Lwt[4], [0, y, function(_ad_){return _e_(f, next, _ad_);}]);
                       });
             });
   }
   function filter_map_s(f, seq, param){
    var ___ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             ___,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _$_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _$_,
                       function(x){
                        if(! x) return _e_(f, next, 0);
                        var y = x[1];
                        return caml_call1
                                (Lwt[4], [0, y, function(_aa_){return _e_(f, next, _aa_);}]);
                       });
             });
   }
   function _f_(f, seq, param){
    var _Y_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _Y_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], ok = caml_call1(f, x);
              return ok
                      ? caml_call1
                        (Lwt[4], [0, x, function(_Z_){return _f_(f, next, _Z_);}])
                      : _f_(f, next, 0);
             });
   }
   function filter(f, seq, param){
    var _W_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _W_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], ok = caml_call1(f, x);
              return ok
                      ? caml_call1
                        (Lwt[4], [0, x, function(_X_){return _f_(f, next, _X_);}])
                      : _f_(f, next, 0);
             });
   }
   function _g_(f, seq, param){
    var _T_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _T_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _U_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _U_,
                       function(ok){
                        return ok
                                ? caml_call1
                                  (Lwt[4], [0, x, function(_V_){return _g_(f, next, _V_);}])
                                : _g_(f, next, 0);
                       });
             });
   }
   function filter_s(f, seq, param){
    var _Q_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _Q_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1], _R_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1],
                       _R_,
                       function(ok){
                        return ok
                                ? caml_call1
                                  (Lwt[4], [0, x, function(_S_){return _g_(f, next, _S_);}])
                                : _g_(f, next, 0);
                       });
             });
   }
   function flat_map_app(f, seq, tail, param){
    var _N_ = caml_call1(seq, 0);
    return caml_call2
            (Lwt[33][1],
             _N_,
             function(param){
              if(param){
               var next = param[2], x = param[1];
               return caml_call1
                       (Lwt[4],
                        [0,
                         x,
                         function(_P_){return flat_map_app(f, next, tail, _P_);}]);
              }
              var _O_ = caml_call1(tail, 0);
              return caml_call2
                      (Lwt[33][1],
                       _O_,
                       function(param){
                        if(! param) return return_nil;
                        var next = param[2], x = param[1];
                        return flat_map_app(f, caml_call1(f, x), next, 0);
                       });
             });
   }
   function flat_map(f, seq, param){
    var _M_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _M_,
             function(param){
              if(! param) return return_nil;
              var next = param[2], x = param[1];
              return flat_map_app(f, caml_call1(f, x), next, 0);
             });
   }
   function fold_left(f, acc, seq){
    function aux(f, acc, seq){
     var _L_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _L_,
              function(param){
               if(! param) return caml_call1(Lwt[4], acc);
               var
                next = param[2],
                x = param[1],
                acc$0 = caml_call2(f, acc, x);
               return aux(f, acc$0, next);
              });
    }
    var _K_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _K_,
             function(param){
              if(! param) return caml_call1(Lwt[4], acc);
              var
               next = param[2],
               x = param[1],
               acc$0 = caml_call2(f, acc, x);
              return aux(f, acc$0, next);
             });
   }
   function fold_left_s(f, acc, seq){
    function aux(f, acc, seq){
     var _I_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _I_,
              function(param){
               if(! param) return caml_call1(Lwt[4], acc);
               var next = param[2], x = param[1], _J_ = caml_call2(f, acc, x);
               return caml_call2
                       (Lwt[35][1], _J_, function(acc){return aux(f, acc, next);});
              });
    }
    var _G_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _G_,
             function(param){
              if(! param) return caml_call1(Lwt[4], acc);
              var next = param[2], x = param[1], _H_ = caml_call2(f, acc, x);
              return caml_call2
                      (Lwt[35][1], _H_, function(acc){return aux(f, acc, next);});
             });
   }
   function iter(f, seq){
    function aux(seq){
     var _F_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _F_,
              function(param){
               if(! param) return Lwt[36];
               var next = param[2], x = param[1];
               caml_call1(f, x);
               return aux(next);
              });
    }
    var _E_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _E_,
             function(param){
              if(! param) return Lwt[36];
              var next = param[2], x = param[1];
              caml_call1(f, x);
              return aux(next);
             });
   }
   function iter_s(f, seq){
    function aux(seq){
     var _C_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _C_,
              function(param){
               if(! param) return Lwt[36];
               var next = param[2], x = param[1], _D_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[35][1], _D_, function(param){return aux(next);});
              });
    }
    var _A_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _A_,
             function(param){
              if(! param) return Lwt[36];
              var next = param[2], x = param[1], _B_ = caml_call1(f, x);
              return caml_call2
                      (Lwt[35][1], _B_, function(param){return aux(next);});
             });
   }
   function iter_p(f, seq){
    function aux(acc, seq){
     var _z_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[33][1],
              _z_,
              function(param){
               if(! param) return caml_call1(Lwt[14], acc);
               var next = param[2], x = param[1], p = caml_call1(f, x);
               return aux([0, p, acc], next);
              });
    }
    var acc = 0, _y_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2
            (Lwt[33][1],
             _y_,
             function(param){
              if(! param) return caml_call1(Lwt[14], acc);
              var next = param[2], x = param[1], p = caml_call1(f, x);
              return aux([0, p, acc], next);
             });
   }
   function iter_n(opt, f, seq){
    var max_concurrency = opt ? opt[1] : 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _h_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available, seq){
     function _t_(param){
      var available = param[2], running = param[1], _x_ = caml_call1(seq, 0);
      return caml_call2
              (Lwt[33][1],
               _x_,
               function(param){
                if(! param) return caml_call1(Lwt[14], running);
                var seq = param[2], elt = param[1];
                return loop
                        ([0, caml_call1(f, elt), running], available - 1 | 0, seq);
               });
     }
     if(0 < available)
      var _u_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _v_ = caml_call1(Lwt[20], running),
       _u_ =
         caml_call2
          (Lwt[33][1],
           _v_,
           function(param){
            var
             running = param[2],
             complete = param[1],
             _w_ =
               [0,
                running,
                available + caml_call1(Stdlib_List[1], complete) | 0];
            return caml_call1(Lwt[4], _w_);
           });
     return caml_call2(Lwt[33][1], _u_, _t_);
    }
    return loop
            (0,
             max_concurrency,
             function(param){return caml_call2(Lwt[80], seq, 0);});
   }
   function unfold(f, u, param){
    try{var val = caml_call1(f, u);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc))
      throw caml_maybe_attach_backtrace(exc, 0);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var match = val[1], u$0 = match[2], x = match[1];
    return caml_call1
            (Lwt[4], [0, x, function(_s_){return unfold(f, u$0, _s_);}]);
   }
   function _i_(f, u, param){
    var _q_ = caml_call1(f, u);
    return caml_call2
            (Lwt[35][1],
             _q_,
             function(x){
              if(! x) return return_nil;
              var match = x[1], u = match[2], x$0 = match[1];
              return caml_call1
                      (Lwt[4], [0, x$0, function(_r_){return _i_(f, u, _r_);}]);
             });
   }
   function unfold_lwt(f, u, param){
    var _o_ = caml_call2(Lwt[80], f, u);
    return caml_call2
            (Lwt[35][1],
             _o_,
             function(x){
              if(! x) return return_nil;
              var match = x[1], u = match[2], x$0 = match[1];
              return caml_call1
                      (Lwt[4], [0, x$0, function(_p_){return _i_(f, u, _p_);}]);
             });
   }
   function of_list(l, param){
    if(l)
     var
      t = l[2],
      h = l[1],
      _m_ = [0, h, function(_n_){return of_list(t, _n_);}];
    else
     var _m_ = 0;
    return caml_call1(Lwt[4], _m_);
   }
   function to_list(seq){
    function aux(f, seq){
     var _k_ = caml_call1(seq, 0);
     return caml_call2
             (Lwt[6],
              _k_,
              function(param){
               if(param){
                var t = param[2], h = param[1];
                return aux(function(x){return caml_call1(f, [0, h, x]);}, t);
               }
               var _l_ = caml_call1(f, 0);
               return caml_call1(Lwt[4], _l_);
              });
    }
    return aux(function(x){return x;}, caml_call1(Lwt[80], seq));
   }
   function of_seq(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Lwt[78][4], exn))
      throw caml_maybe_attach_backtrace(exn, 0);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    if(! val) return return_nil;
    var next = val[2], x = val[1];
    return caml_call1
            (Lwt[4], [0, x, function(_j_){return of_seq(next, _j_);}]);
   }
   function of_seq_lwt(seq){
    return function(param){
     var match = caml_call1(seq, 0);
     if(! match) return return_nil;
     var next = match[2], x = match[1];
     return caml_call2
             (Lwt[35][3],
              x,
              function(x){
               var next$0 = of_seq_lwt(next);
               return [0, x, next$0];
              });};
   }
   function of_seq_lwt$0(seq){
    return function(param){
     try{var val = caml_call1(seq, 0);}
     catch(exc$0){
      var exc = caml_wrap_exception(exc$0);
      if(caml_call1(Lwt[78][4], exc))
       throw caml_maybe_attach_backtrace(exc, 0);
      throw caml_maybe_attach_backtrace(exc, 0);
     }
     if(! val) return return_nil;
     var next = val[2], x = val[1];
     return caml_call2
             (Lwt[35][3],
              x,
              function(x){
               var next$0 = of_seq_lwt(next);
               return [0, x, next$0];
              });};
   }
   var
    Lwt_seq =
      [0,
       empty,
       return$0,
       return_lwt,
       cons,
       cons_lwt,
       append,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       flat_map,
       fold_left,
       fold_left_s,
       iter,
       iter_s,
       iter_p,
       iter_n,
       unfold,
       unfold_lwt,
       to_list,
       of_list,
       of_seq,
       of_seq_lwt$0];
   runtime.caml_register_global(5, Lwt_seq, "Lwt_seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_stream
//# unitInfo: Requires: CamlinternalOO, Lwt, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__List, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst_blocked = "blocked",
    cst_close = "close",
    cst_closed = "closed",
    cst_count = "count",
    cst_push = "push",
    cst_resize = "resize",
    cst_set_reference = "set_reference",
    cst_size = "size",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$3 = "    ",
    cst$4 = "   ",
    cst$5 = " |",
    cst = cst$6,
    cst$0 = cst$6,
    cst$1 = cst$6,
    cst$2 = cst$6,
    shared =
      [0,
       cst_size,
       cst_set_reference,
       cst_resize,
       cst_push,
       cst_count,
       cst_closed,
       cst_close,
       cst_blocked],
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Array = global_data.Stdlib__Array,
    Closed = [248, "Lwt_stream.Closed", caml_fresh_oo_id(0)],
    Full = [248, "Lwt_stream.Full", caml_fresh_oo_id(0)],
    Empty = [248, "Lwt_stream.Empty", caml_fresh_oo_id(0)],
    _a_ = [0, cst_closed],
    cst_Lwt_stream_clone = "Lwt_stream.clone",
    cst_Lwt_stream_bounded_push_re = "Lwt_stream.bounded_push#resize";
   function new_node(param){
    var node = [];
    runtime.caml_update_dummy(node, [0, node, 0]);
    return node;
   }
   function clone(s){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_clone);
    return [0, s[1], s[2], s[3], s[4], s[5]];
   }
   function from_source(source){
    var
     node = new_node(0),
     match = caml_call1(Lwt[1], 0),
     close = match[2],
     closed = match[1];
    return [0, source, close, closed, node, [0, node]];
   }
   function from(f){return from_source([0, [0, f, Lwt[36]]]);}
   function from_direct(f){return from_source([1, f]);}
   function closed(s){return s[3];}
   function is_closed(s){return 1 - caml_call1(Lwt[76], s[3]);}
   function enqueue(e, last){
    var node = last[1], new_last = new_node(0);
    node[2] = e;
    node[1] = new_last;
    last[1] = new_last;
   }
   function enqueue$0(e, s){return enqueue(e, s[5]);}
   function create_with_reference(param){
    var
     match = caml_call1(Lwt[1], 0),
     push_signal_resolver = match[2],
     push_signal = match[1],
     push_signal_resolver$0 = [0, push_signal_resolver],
     source = [0, push_signal, 0, 0],
     t = from_source([2, source]),
     close = t[2],
     closed = t[3],
     last = t[5];
    function push(x){
     if(1 - caml_call1(Lwt[76], closed))
      throw caml_maybe_attach_backtrace(Closed, 1);
     enqueue(x, last);
     if(source[2]){
      source[2] = 0;
      var
       old_push_signal_resolver = push_signal_resolver$0[1],
       match = caml_call1(Lwt[1], 0),
       new_push_signal_resolver = match[2],
       new_waiter = match[1];
      source[1] = new_waiter;
      push_signal_resolver$0[1] = new_push_signal_resolver;
      caml_call2(Lwt[2], old_push_signal_resolver, 0);
     }
     var _aH_ = 0 === x ? 1 : 0;
     return _aH_ ? caml_call2(Lwt[52], close, 0) : _aH_;
    }
    return [0, t, push, function(x){source[3] = x; return 0;}];
   }
   function return$0(a){
    var match = create_with_reference(0), push = match[2], stream = match[1];
    caml_call1(push, [0, a]);
    caml_call1(push, 0);
    return stream;
   }
   function return_lwt(a){
    var match = create_with_reference(0), push = match[2], source = match[1];
    caml_call2
     (Lwt[10],
      function(param){
       return caml_call2
               (Lwt[6],
                a,
                function(x){
                 caml_call1(push, [0, x]);
                 caml_call1(push, 0);
                 return Lwt[36];
                });
      },
      function(exc){return caml_call1(push, 0);});
    return source;
   }
   function of_seq(s){
    var s$0 = [0, s];
    function get(param){
     var match = caml_call1(s$0[1], 0);
     if(! match) return 0;
     var s = match[2], elt = match[1];
     s$0[1] = s;
     return [0, elt];
    }
    return from_direct(get);
   }
   function of_lwt_seq(s){
    var s$0 = [0, s];
    function get(param){
     var _aG_ = caml_call1(s$0[1], 0);
     return caml_call2
             (Lwt[33][2],
              _aG_,
              function(param){
               if(! param) return 0;
               var s = param[2], elt = param[1];
               s$0[1] = s;
               return [0, elt];
              });
    }
    return from(get);
   }
   function create(param){
    var match = create_with_reference(0), push = match[2], source = match[1];
    return [0, source, push];
   }
   function of_iter(iter, i){
    var match = create(0), push = match[2], stream = match[1];
    caml_call2(iter, function(x){return caml_call1(push, [0, x]);}, i);
    caml_call1(push, 0);
    return stream;
   }
   function of_list(l){return of_iter(Stdlib_List[18], l);}
   function of_array(a){return of_iter(Stdlib_Array[12], a);}
   function of_string(s){return of_iter(Stdlib_String[30], s);}
   function notify_pusher(info, last){
    enqueue(info[5], last);
    info[5] = 0;
    var
     old_wakener = info[7],
     match = caml_call1(Lwt[22], 0),
     wakener = match[2],
     waiter = match[1];
    info[6] = waiter;
    info[7] = wakener;
    return caml_call2(Lwt[2], old_wakener, 0);
   }
   var
    bounded_push_impl =
      caml_call2
       (CamlinternalOO[19],
        [0,
         cst_blocked,
         cst_close,
         cst_push,
         cst_count,
         cst_size,
         cst_set_reference,
         cst_resize,
         cst_closed],
        function(_ap_){
         var
          _aq_ = caml_call2(CamlinternalOO[3], _ap_, cst),
          _ar_ = caml_call2(CamlinternalOO[3], _ap_, cst$0),
          _as_ = caml_call2(CamlinternalOO[3], _ap_, cst$1),
          _at_ = caml_call2(CamlinternalOO[3], _ap_, cst$2),
          _au_ = caml_call3(CamlinternalOO[4], _ap_, shared, _a_),
          _av_ = _au_[9];
         caml_call2
          (CamlinternalOO[11],
           _ap_,
           [0,
            _au_[1],
            function(self_1){return self_1[1 + _aq_][3];},
            _au_[3],
            function(self_1, size){
             if(size < 0)
              caml_call1(Stdlib[1], cst_Lwt_stream_bounded_push_re);
             self_1[1 + _aq_][3] = size;
             var
              _aE_ = self_1[1 + _aq_][4] < self_1[1 + _aq_][3] ? 1 : 0,
              _aF_ = _aE_ ? 0 !== self_1[1 + _aq_][5] ? 1 : 0 : _aE_;
             return _aF_
                     ? (self_1
                         [1 + _aq_]
                        [4]
                       = self_1[1 + _aq_][4] + 1 | 0,
                       notify_pusher(self_1[1 + _aq_], self_1[1 + _as_]))
                     : _aF_;
            },
            _au_[4],
            function(self_1, x){
             if(self_1[1 + _av_]) return caml_call1(Lwt[5], Closed);
             if(0 !== self_1[1 + _aq_][5]) return caml_call1(Lwt[5], Full);
             if(self_1[1 + _aq_][3] <= self_1[1 + _aq_][4]){
              self_1[1 + _aq_][5] = [0, x];
              return caml_call2
                      (Lwt[7],
                       function(param){return self_1[1 + _aq_][6];},
                       function(exn){
                        if(exn !== Lwt[21])
                         throw caml_maybe_attach_backtrace(exn, 0);
                        self_1[1 + _aq_][5] = 0;
                        var
                         match = caml_call1(Lwt[22], 0),
                         wakener = match[2],
                         waiter = match[1];
                        self_1[1 + _aq_][6] = waiter;
                        self_1[1 + _aq_][7] = wakener;
                        throw caml_maybe_attach_backtrace(exn, 0);
                       });
             }
             enqueue([0, x], self_1[1 + _as_]);
             self_1[1 + _aq_][4] = self_1[1 + _aq_][4] + 1 | 0;
             if(self_1[1 + _aq_][2]){
              self_1[1 + _aq_][2] = 0;
              var
               old_wakener = self_1[1 + _ar_][1],
               match = caml_call1(Lwt[1], 0),
               new_wakener = match[2],
               new_waiter = match[1];
              self_1[1 + _aq_][1] = new_waiter;
              self_1[1 + _ar_][1] = new_wakener;
              caml_call2(Lwt[2], old_wakener, 0);
             }
             return Lwt[36];
            },
            _au_[7],
            function(self_1){
             var _aD_ = 1 - self_1[1 + _av_];
             if(! _aD_) return _aD_;
             self_1[1 + _av_] = 1;
             var node = self_1[1 + _as_][1], new_last = new_node(0);
             node[2] = 0;
             node[1] = new_last;
             self_1[1 + _as_][1] = new_last;
             if(0 !== self_1[1 + _aq_][5]){
              self_1[1 + _aq_][5] = 0;
              caml_call2(Lwt[3], self_1[1 + _aq_][7], Closed);
             }
             if(self_1[1 + _aq_][2]){
              self_1[1 + _aq_][2] = 0;
              var old_wakener = self_1[1 + _ar_][1];
              caml_call2(Lwt[2], old_wakener, 0);
             }
             return caml_call2(Lwt[52], self_1[1 + _at_], 0);
            },
            _au_[5],
            function(self_1){return self_1[1 + _aq_][4];},
            _au_[8],
            function(self_1){return 0 !== self_1[1 + _aq_][5] ? 1 : 0;},
            _au_[6],
            function(self_1){return self_1[1 + _av_];},
            _au_[2],
            function(self_1, x){self_1[1 + _aq_][8] = x; return 0;}]);
         return function(_aB_, _aA_, _az_, _ay_, _ax_, _aw_){
          var _aC_ = caml_call2(CamlinternalOO[24], _aA_, _ap_);
          _aC_[1 + _at_] = _aw_;
          _aC_[1 + _as_] = _ax_;
          _aC_[1 + _ar_] = _ay_;
          _aC_[1 + _aq_] = _az_;
          _aC_[1 + _av_] = 0;
          return _aC_;};
        }),
    cst_Lwt_stream_create_bounded = "Lwt_stream.create_bounded",
    _b_ =
      [0,
       [11,
        "Lwt_stream.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_stream.iter_n: max_concurrency must be > 0, %d given"],
    cst_Lwt_stream_parse = "Lwt_stream.parse",
    _c_ = [0, [4, 6, [0, 2, 8], 0, [11, "|  ", 0]], "%08x|  "],
    _d_ = [0, [4, 6, [0, 2, 2], 0, [12, 32, 0]], "%02x "];
   function create_bounded(size){
    if(size < 0) caml_call1(Stdlib[1], cst_Lwt_stream_create_bounded);
    var
     match = caml_call1(Lwt[1], 0),
     wakener = match[2],
     waiter = match[1],
     match$0 = caml_call1(Lwt[22], 0),
     push_wakener = match$0[2],
     push_waiter = match$0[1],
     wakener_cell = [0, wakener],
     info = [0, waiter, 0, size, 0, 0, push_waiter, push_wakener, 0],
     t = from_source([3, info]);
    return [0,
            t,
            caml_call5
             (bounded_push_impl[1], 0, info, wakener_cell, t[5], t[2])];
   }
   function feed(s){
    var match = s[1];
    switch(match[0]){
      case 0:
       var from = match[1];
       if(caml_call1(Lwt[76], from[2])) return caml_call1(Lwt[25], from[2]);
       var
        thread =
          caml_call2
           (Lwt[7],
            function(param){
             var _ao_ = caml_call1(from[1], 0);
             return caml_call2
                     (Lwt[33][1],
                      _ao_,
                      function(x){
                       enqueue$0(x, s);
                       if(0 === x) caml_call2(Lwt[52], s[2], 0);
                       return Lwt[36];
                      });
            },
            function(_an_){throw caml_maybe_attach_backtrace(_an_, 0);});
       from[2] = thread;
       return caml_call1(Lwt[25], thread);
      case 1:
       var f = match[1], x = caml_call1(f, 0);
       enqueue$0(x, s);
       if(0 === x) caml_call2(Lwt[52], s[2], 0);
       return Lwt[36];
      case 2:
       var push = match[1]; push[2] = 1; return caml_call1(Lwt[25], push[1]);
      default:
       var push$0 = match[1];
       push$0[2] = 1;
       return caml_call1(Lwt[25], push$0[1]);
    }
   }
   function consume(s, node){
    var _am_ = node === s[4] ? 1 : 0;
    if(! _am_) return _am_;
    s[4] = node[1];
    var match = s[1];
    if(3 !== match[0]) return;
    var info = match[1];
    if(0 !== info[5]) return notify_pusher(info, s[5]);
    info[4] = info[4] - 1 | 0;
   }
   function peek_rec(s, node){
    if(node !== s[5][1]) return caml_call1(Lwt[4], node[2]);
    var _al_ = feed(s);
    return caml_call2
            (Lwt[33][1], _al_, function(param){return peek_rec(s, node);});
   }
   function peek(s){return peek_rec(s, s[4]);}
   function npeek_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _ak_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _ak_);
     }
     if(node$0 === s[5][1]){
      var _ai_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ai_,
               function(param){return npeek_rec(node$0, acc$0, n$0, s);});
     }
     var match = node$0[2];
     if(! match){
      var _aj_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _aj_);
     }
     var
      x = match[1],
      n$1 = n$0 - 1 | 0,
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
     n$0 = n$1;
    }
   }
   function npeek(n, s){return npeek_rec(s[4], 0, n, s);}
   function get_rec(s, node){
    if(node === s[5][1]){
     var _ah_ = feed(s);
     return caml_call2
             (Lwt[33][1], _ah_, function(param){return get_rec(s, node);});
    }
    if(0 !== node[2]) consume(s, node);
    return caml_call1(Lwt[4], node[2]);
   }
   function get(s){return get_rec(s, s[4]);}
   function get_exn_rec(s, node){
    if(node === s[5][1])
     return caml_call3
             (Lwt[9],
              function(param){return feed(s);},
              function(param){return get_exn_rec(s, node);},
              function(exn){return caml_call1(Lwt[4], [0, [1, exn]]);});
    var match = node[2];
    if(! match) return Lwt[37];
    var value = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], [0, [0, value]]);
   }
   function wrap_exn(s){
    return from(function(param){return get_exn_rec(s, s[4]);});
   }
   function nget_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _ag_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _ag_);
     }
     if(node$0 === s[5][1]){
      var _ae_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ae_,
               function(param){return nget_rec(node$0, acc$0, n$0, s);});
     }
     var match = s[4][2];
     if(! match){
      var _af_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _af_);
     }
     var x = match[1];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
     n$0 = n$1;
    }
   }
   function nget(n, s){return nget_rec(s[4], 0, n, s);}
   function get_while_rec(node, acc, f, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _ab_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _ab_,
               function(param){return get_while_rec(node$0, acc$0, f, s);});
     }
     var match = node$0[2];
     if(! match){
      var _ad_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _ad_);
     }
     var x = match[1], test = caml_call1(f, x);
     if(! test){
      var _ac_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _ac_);
     }
     consume(s, node$0);
     var acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function get_while(f, s){return get_while_rec(s[4], 0, f, s);}
   function get_while_s_rec(node, acc, f, s){
    if(node === s[5][1]){
     var _Z_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _Z_,
              function(param){return get_while_s_rec(node, acc, f, s);});
    }
    var match = node[2];
    if(match){
     var x = match[1], ___ = caml_call1(f, x);
     return caml_call2
             (Lwt[33][1],
              ___,
              function(param){
               if(param){
                consume(s, node);
                return get_while_s_rec(node[1], [0, x, acc], f, s);
               }
               var _aa_ = caml_call1(Stdlib_List[10], acc);
               return caml_call1(Lwt[4], _aa_);
              });
    }
    var _$_ = caml_call1(Stdlib_List[10], acc);
    return caml_call1(Lwt[4], _$_);
   }
   function get_while_s(f, s){return get_while_s_rec(s[4], 0, f, s);}
   function next_rec(s, node){
    if(node === s[5][1]){
     var _Y_ = feed(s);
     return caml_call2
             (Lwt[33][1], _Y_, function(param){return next_rec(s, node);});
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[5], Empty);
    var x = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], x);
   }
   function next(s){return next_rec(s, s[4]);}
   function last_new_rec(node, x, s){
    var node$0 = node, x$0 = x;
    for(;;)
     if(node$0 === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Lwt[4], x$0);
      if(0 !== match[0]){var exn = match[1]; return caml_call1(Lwt[5], exn);}
     }
     else{
      var match$0 = node$0[2];
      if(! match$0) return caml_call1(Lwt[4], x$0);
      var x$1 = match$0[1];
      consume(s, node$0);
      var node$1 = node$0[1];
      node$0 = node$1;
      x$0 = x$1;
     }
   }
   function last_new(s){
    var node = s[4];
    if(node !== s[5][1]){
     var match$0 = node[2];
     if(! match$0) return caml_call1(Lwt[5], Empty);
     var x$0 = match$0[1];
     consume(s, node);
     return last_new_rec(node[1], x$0, s);
    }
    var thread = next(s), match = caml_call1(Lwt[48], thread);
    if(typeof match !== "number" && 0 === match[0]){
     var x = match[1];
     return last_new_rec(node, x, s);
    }
    return thread;
   }
   function to_list_rec(node, acc, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _W_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _W_,
               function(param){return to_list_rec(node$0, acc$0, s);});
     }
     var match = node$0[2];
     if(! match){
      var _X_ = caml_call1(Stdlib_List[10], acc$0);
      return caml_call1(Lwt[4], _X_);
     }
     var x = match[1];
     consume(s, node$0);
     var acc$1 = [0, x, acc$0], node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function to_list(s){return to_list_rec(s[4], 0, s);}
   function to_string_rec(node, buf, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _U_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _U_,
               function(param){return to_string_rec(node$0, buf, s);});
     }
     var match = node$0[2];
     if(! match){
      var _V_ = caml_call1(Stdlib_Buffer[2], buf);
      return caml_call1(Lwt[4], _V_);
     }
     var x = match[1];
     consume(s, node$0);
     caml_call2(Stdlib_Buffer[12], buf, x);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function to_string(s){
    var _T_ = caml_call1(Stdlib_Buffer[1], 128);
    return to_string_rec(s[4], _T_, s);
   }
   function junk(s){
    var node = s[4];
    if(node === s[5][1]){
     var _S_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _S_,
              function(param){
               if(0 !== node[2]) consume(s, node);
               return Lwt[36];
              });
    }
    if(0 !== node[2]) consume(s, node);
    return Lwt[36];
   }
   function njunk_rec(node, n, s){
    var node$0 = node, n$0 = n;
    for(;;){
     if(0 >= n$0) return Lwt[36];
     if(node$0 === s[5][1]){
      var _R_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _R_,
               function(param){return njunk_rec(node$0, n$0, s);});
     }
     if(! node$0[2]) return Lwt[36];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, node$1 = node$0[1];
     node$0 = node$1;
     n$0 = n$1;
    }
   }
   function njunk(n, s){return njunk_rec(s[4], n, s);}
   function junk_while_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _Q_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _Q_,
               function(param){return junk_while_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1], test = caml_call1(f, x);
     if(! test) return Lwt[36];
     consume(s, node$0);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function junk_while(f, s){return junk_while_rec(s[4], f, s);}
   function junk_while_s_rec(node, f, s){
    if(node === s[5][1]){
     var _O_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _O_,
              function(param){return junk_while_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1], _P_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _P_,
             function(param){
              return param
                      ? (consume(s, node), junk_while_s_rec(node[1], f, s))
                      : Lwt[36];
             });
   }
   function junk_while_s(f, s){return junk_while_s_rec(s[4], f, s);}
   function junk_available(s){
    var node$1 = s[4], node = node$1;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      if(! node[2]) return 0;
      consume(s, node);
      var node$0 = node[1];
      node = node$0;
     }
   }
   function junk_old(s){
    var _N_ = junk_available(s);
    return caml_call1(Lwt[4], _N_);
   }
   function get_available(s){
    var node$1 = s[4], node = node$1, acc = 0;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[10], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = node[2];
      if(! match$0) return caml_call1(Stdlib_List[10], acc);
      var x = match$0[1];
      consume(s, node);
      var acc$0 = [0, x, acc], node$0 = node[1];
      node = node$0;
      acc = acc$0;
     }
   }
   function get_available_up_to(n$1, s){
    var node$1 = s[4], node = node$1, acc = 0, n = n$1;
    for(;;){
     if(0 >= n) return caml_call1(Stdlib_List[10], acc);
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[10], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = s[4][2];
      if(! match$0) return caml_call1(Stdlib_List[10], acc);
      var x = match$0[1];
      consume(s, node);
      var n$0 = n - 1 | 0, acc$0 = [0, x, acc], node$0 = node[1];
      node = node$0;
      acc = acc$0;
      n = n$0;
     }
    }
   }
   function is_empty(s){
    if(s[4] !== s[5][1]) return caml_call1(Lwt[4], 0 === s[4][2] ? 1 : 0);
    var _M_ = feed(s);
    return caml_call2(Lwt[33][1], _M_, function(param){return is_empty(s);});
   }
   function map(f, s){
    return from
            (function(param){
              var _L_ = get(s);
              return caml_call2
                      (Lwt[33][2],
                       _L_,
                       function(param){
                        if(! param) return 0;
                        var x = param[1], x$0 = caml_call1(f, x);
                        return [0, x$0];
                       });
             });
   }
   function map_s(f, s){
    return from
            (function(param){
              var _J_ = get(s);
              return caml_call2
                      (Lwt[33][1],
                       _J_,
                       function(param){
                        if(! param) return Lwt[37];
                        var x = param[1], _K_ = caml_call1(f, x);
                        return caml_call2
                                (Lwt[33][2], _K_, function(x){return [0, x];});
                       });
             });
   }
   function filter(f, s){
    function next(param){
     var t = get(s);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], test = caml_call1(f, x);
               return test ? t : next(0);
              });
    }
    return from(next);
   }
   function filter_s(f, s){
    function next(param){
     var t = get(s);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return t;
               var x = param[1], _I_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        _I_,
                        function(param){return param ? t : next(0);});
              });
    }
    return from(next);
   }
   function filter_map(f, s){
    function next(param){
     var _H_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _H_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], x$0 = caml_call1(f, x);
               return x$0 ? caml_call1(Lwt[4], x$0) : next(0);
              });
    }
    return from(next);
   }
   function filter_map_s(f, s){
    function next(param){
     var _G_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _G_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], t = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        t,
                        function(param){return param ? t : next(0);});
              });
    }
    return from(next);
   }
   function map_list(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     var _F_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _F_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], l = caml_call1(f, x);
               pendings[1] = l;
               return next(0);
              });
    }
    return from(next);
   }
   function map_list_s(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     var _D_ = get(s);
     return caml_call2
             (Lwt[33][1],
              _D_,
              function(param){
               if(! param) return Lwt[37];
               var x = param[1], _E_ = caml_call1(f, x);
               return caml_call2
                       (Lwt[33][1],
                        _E_,
                        function(l){pendings[1] = l; return next(0);});
              });
    }
    return from(next);
   }
   function flatten(s){return map_list(function(l){return l;}, s);}
   function fold_rec(node, f, s, acc){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var _C_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _C_,
               function(param){return fold_rec(node$0, f, s, acc$0);});
     }
     var match = node$0[2];
     if(! match) return caml_call1(Lwt[4], acc$0);
     var x = match[1];
     consume(s, node$0);
     var acc$1 = caml_call2(f, x, acc$0), node$1 = node$0[1];
     node$0 = node$1;
     acc$0 = acc$1;
    }
   }
   function fold(f, s, acc){return fold_rec(s[4], f, s, acc);}
   function fold_s_rec(node, f, s, acc){
    if(node === s[5][1]){
     var _A_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _A_,
              function(param){return fold_s_rec(node, f, s, acc);});
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[4], acc);
    var x = match[1];
    consume(s, node);
    var _B_ = caml_call2(f, x, acc);
    return caml_call2
            (Lwt[33][1],
             _B_,
             function(acc){return fold_s_rec(node[1], f, s, acc);});
   }
   function fold_s(f, s, acc){return fold_s_rec(s[4], f, s, acc);}
   function iter_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _z_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _z_,
               function(param){return iter_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1];
     consume(s, node$0);
     caml_call1(f, x);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function iter(f, s){return iter_rec(s[4], f, s);}
   function iter_s_rec(node, f, s){
    if(node === s[5][1]){
     var _x_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _x_,
              function(param){return iter_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var _y_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _y_,
             function(param){return iter_s_rec(node[1], f, s);});
   }
   function iter_s(f, s){return iter_s_rec(s[4], f, s);}
   function iter_p_rec(node, f, s){
    if(node === s[5][1]){
     var _w_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _w_,
              function(param){return iter_p_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var res = caml_call1(f, x), rest = iter_p_rec(node[1], f, s);
    return caml_call2(Lwt[33][1], res, function(param){return rest;});
   }
   function iter_p(f, s){return iter_p_rec(s[4], f, s);}
   function iter_n(opt, f, stream){
    var max_concurrency = opt ? opt[1] : 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _b_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available){
     function _r_(param){
      var available = param[2], running = param[1], _v_ = get(stream);
      return caml_call2
              (Lwt[33][1],
               _v_,
               function(param){
                if(! param) return caml_call1(Lwt[14], running);
                var elt = param[1];
                return loop
                        ([0, caml_call1(f, elt), running], available - 1 | 0);
               });
     }
     if(0 < available)
      var _s_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _t_ = caml_call1(Lwt[20], running),
       _s_ =
         caml_call2
          (Lwt[33][1],
           _t_,
           function(param){
            var
             running = param[2],
             complete = param[1],
             _u_ =
               [0,
                running,
                available + caml_call1(Stdlib_List[1], complete) | 0];
            return caml_call1(Lwt[4], _u_);
           });
     return caml_call2(Lwt[33][1], _s_, _r_);
    }
    return loop(0, max_concurrency);
   }
   function find_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _q_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _q_,
               function(param){return find_rec(node$0, f, s);});
     }
     var opt = node$0[2];
     if(! opt) return Lwt[37];
     var x = opt[1];
     consume(s, node$0);
     var test = caml_call1(f, x);
     if(test) return caml_call1(Lwt[4], opt);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function find(f, s){return find_rec(s[4], f, s);}
   function find_s_rec(node, f, s){
    if(node === s[5][1]){
     var _o_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _o_,
              function(param){return find_s_rec(node, f, s);});
    }
    var opt = node[2];
    if(! opt) return Lwt[37];
    var x = opt[1];
    consume(s, node);
    var _p_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _p_,
             function(param){
              return param
                      ? caml_call1(Lwt[4], opt)
                      : find_s_rec(node[1], f, s);
             });
   }
   function find_s(f, s){return find_s_rec(s[4], f, s);}
   function find_map_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var _n_ = feed(s);
      return caml_call2
              (Lwt[33][1],
               _n_,
               function(param){return find_map_rec(node$0, f, s);});
     }
     var match = node$0[2];
     if(! match) return Lwt[37];
     var x = match[1];
     consume(s, node$0);
     var x$0 = caml_call1(f, x);
     if(0 !== x$0) return caml_call1(Lwt[4], x$0);
     var node$1 = node$0[1];
     node$0 = node$1;
    }
   }
   function find_map(f, s){return find_map_rec(s[4], f, s);}
   function find_map_s_rec(node, f, s){
    if(node === s[5][1]){
     var _m_ = feed(s);
     return caml_call2
             (Lwt[33][1],
              _m_,
              function(param){return find_map_s_rec(node, f, s);});
    }
    var match = node[2];
    if(! match) return Lwt[37];
    var x = match[1];
    consume(s, node);
    var t = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             t,
             function(param){
              return param ? t : find_map_s_rec(node[1], f, s);
             });
   }
   function find_map_s(f, s){return find_map_s_rec(s[4], f, s);}
   function combine(s1, s2){
    function next(param){
     var t1 = get(s1), t2 = get(s2);
     return caml_call2
             (Lwt[33][1],
              t1,
              function(n1){
               return caml_call2
                       (Lwt[33][1],
                        t2,
                        function(n2){
                         if(n1 && n2){
                          var x2 = n2[1], x1 = n1[1];
                          return caml_call1(Lwt[4], [0, [0, x1, x2]]);
                         }
                         return Lwt[37];
                        });
              });
    }
    return from(next);
   }
   function append(s1, s2){
    var current_s = [0, s1];
    function next(param){
     var t = get(current_s[1]);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               return param
                       ? t
                       : current_s
                          [1]
                         === s2
                         ? Lwt[37]
                         : (current_s[1] = s2, next(0));
              });
    }
    return from(next);
   }
   function concat(s_top){
    var current_s = [0, from(function(param){return Lwt[37];})];
    function next(param){
     var t = get(current_s[1]);
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(param) return t;
               var _l_ = get(s_top);
               return caml_call2
                       (Lwt[33][1],
                        _l_,
                        function(param){
                         if(! param) return Lwt[37];
                         var s = param[1];
                         current_s[1] = s;
                         return next(0);
                        });
              });
    }
    return from(next);
   }
   function choose(streams){
    function source(s){
     var _k_ = get(s);
     return [0,
             s,
             caml_call2(Lwt[33][2], _k_, function(x){return [0, s, x];})];
    }
    var streams$0 = [0, caml_call2(Stdlib_List[20], source, streams)];
    function next(param){
     var l = streams$0[1];
     if(! l) return Lwt[37];
     var
      _h_ = caml_call2(Stdlib_List[20], function(_j_){return _j_[2];}, l),
      _i_ = caml_call1(Lwt[17], _h_);
     return caml_call2
             (Lwt[33][1],
              _i_,
              function(param){
               var
                x = param[2],
                s = param[1],
                l$0 = caml_call2(Stdlib_List[56], s, l);
               return x
                       ? (streams$0
                          [1]
                         = [0, source(s), l$0],
                         caml_call1(Lwt[4], x))
                       : (streams$0[1] = l$0, next(0));
              });
    }
    return from(next);
   }
   function parse(s, f){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_parse);
    var node = s[4];
    return caml_call2
            (Lwt[7],
             function(param){return caml_call1(f, s);},
             function(exn){
              s[4] = node;
              throw caml_maybe_attach_backtrace(exn, 0);
             });
   }
   function hexdump(stream){
    var buf = caml_call1(Stdlib_Buffer[1], 80), num = [0, 0];
    return from
            (function(param){
              var _e_ = nget(16, stream);
              return caml_call2
                      (Lwt[33][1],
                       _e_,
                       function(l){
                        if(! l) return Lwt[37];
                        caml_call1(Stdlib_Buffer[8], buf);
                        caml_call3(Stdlib_Printf[5], buf, _c_, num[1]);
                        num[1] = num[1] + 16 | 0;
                        var pos = 0, param = l;
                        for(;;){
                         if(! param) break;
                         var l$0 = param[2], x = param[1];
                         if(8 === pos) caml_call2(Stdlib_Buffer[12], buf, 32);
                         caml_call3(Stdlib_Printf[5], buf, _d_, x);
                         var pos$0 = pos + 1 | 0;
                         pos = pos$0;
                         param = l$0;
                        }
                        var pos$1 = pos;
                        for(;;){
                         if(pos$1 >= 16) break;
                         if(8 === pos$1)
                          caml_call2(Stdlib_Buffer[16], buf, cst$3);
                         else
                          caml_call2(Stdlib_Buffer[16], buf, cst$4);
                         var pos$2 = pos$1 + 1 | 0;
                         pos$1 = pos$2;
                        }
                        caml_call2(Stdlib_Buffer[16], buf, cst$5);
                        caml_call2
                         (Stdlib_List[18],
                          function(ch){
                           a:
                           {
                            if(32 <= ch && 126 >= ch){var _g_ = ch; break a;}
                            var _g_ = 46;
                           }
                           return caml_call2(Stdlib_Buffer[12], buf, _g_);
                          },
                          l);
                        caml_call2(Stdlib_Buffer[12], buf, 124);
                        var _f_ = [0, caml_call1(Stdlib_Buffer[2], buf)];
                        return caml_call1(Lwt[4], _f_);
                       });
             });
   }
   var
    Lwt_stream =
      [0,
       from,
       from_direct,
       Closed,
       create,
       create_with_reference,
       Full,
       create_bounded,
       return$0,
       return_lwt,
       of_seq,
       of_lwt_seq,
       of_list,
       of_array,
       of_string,
       clone,
       to_list,
       to_string,
       Empty,
       peek,
       npeek,
       get,
       nget,
       get_while,
       get_while_s,
       next,
       last_new,
       junk,
       njunk,
       junk_while,
       junk_while_s,
       junk_available,
       get_available,
       get_available_up_to,
       is_empty,
       is_closed,
       closed,
       junk_old,
       choose,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       map_list,
       map_list_s,
       fold,
       fold_s,
       iter,
       iter_p,
       iter_s,
       iter_n,
       find,
       find_s,
       find_map,
       find_map_s,
       combine,
       append,
       concat,
       flatten,
       wrap_exn,
       parse,
       hexdump];
   runtime.caml_register_global(28, Lwt_stream, "Lwt_stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_result
//# unitInfo: Requires: Lwt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Assert_failure = global_data.Assert_failure;
   function return$0(x){return caml_call1(Lwt[4], [0, x]);}
   function fail(e){return caml_call1(Lwt[4], [1, e]);}
   var lift = Lwt[4], _a_ = [0, "src/core/lwt_result.ml", 84, 14];
   function ok(x){return caml_call2(Lwt[28], function(y){return [0, y];}, x);}
   function error(x){
    return caml_call2(Lwt[28], function(y){return [1, y];}, x);
   }
   function map(f, e){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return [0, caml_call1(f, x)];
              }
              var e = param[1];
              return [1, e];
             },
             e);
   }
   function map_error(f, e){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){var x = param[1]; return [0, x];}
              var e = param[1];
              return [1, caml_call1(f, e)];
             },
             e);
   }
   function map_err(f, e){return map_error(f, e);}
   function catch$0(e){
    return caml_call2
            (Lwt[7], function(param){return ok(caml_call1(e, 0));}, fail);
   }
   function get_exn(e){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return caml_call1(Lwt[4], x);
              }
              var e = param[1];
              return caml_call1(Lwt[5], e);
             });
   }
   function symbol_bind(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
              var e = param[1];
              return caml_call1(Lwt[4], [1, e]);
             });
   }
   function bind_error(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return caml_call1(Lwt[4], [0, x]);
              }
              var e = param[1];
              return caml_call1(f, e);
             });
   }
   function bind_lwt(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){
               var x = param[1];
               return ok(caml_call1(f, x));
              }
              var e = param[1];
              return fail(e);
             });
   }
   function bind_result(e, f){
    return caml_call2
            (Lwt[28],
             function(param){
              if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
              var e = param[1];
              return [1, e];
             },
             e);
   }
   function bind_lwt_error(e, f){
    return caml_call2
            (Lwt[6],
             e,
             function(param){
              if(0 === param[0]){var x = param[1]; return return$0(x);}
              var e = param[1], _d_ = caml_call1(f, e);
              return caml_call2(Lwt[6], _d_, fail);
             });
   }
   function bind_lwt_err(e, f){return bind_lwt_error(e, f);}
   function both(a, b){
    var s = [0, 0];
    function set_once(e){return s[1] ? 0 : (s[1] = [0, e], 0);}
    var
     b$0 = map_error(set_once, b),
     a$0 = map_error(set_once, a),
     _b_ = caml_call2(Lwt[13], a$0, b$0);
    return caml_call2
            (Lwt[28],
             function(param){
              var _c_ = param[1];
              if(0 === _c_[0]){
               var match = param[2], x = _c_[1];
               if(0 === match[0]){var y = match[1]; return [0, [0, x, y]];}
              }
              var param$0 = s[1];
              if(! param$0)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
              var e = param$0[1];
              return [1, e];
             },
             _b_);
   }
   function iter(f, r){
    return caml_call2
            (Lwt[6],
             r,
             function(param){
              if(0 !== param[0]) return Lwt[36];
              var x = param[1];
              return caml_call1(f, x);
             });
   }
   function iter_error(f, r){
    return caml_call2
            (Lwt[6],
             r,
             function(param){
              if(0 === param[0]) return Lwt[36];
              var e = param[1];
              return caml_call1(f, e);
             });
   }
   function symbol(e, f){return map(f, e);}
   function map$0(t, f){return map(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map$0, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function let$0(x, f){return map(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt_result =
      [0,
       return$0,
       fail,
       lift,
       ok,
       error,
       catch$0,
       get_exn,
       map,
       map_error,
       symbol_bind,
       bind_error,
       bind_lwt,
       bind_lwt_error,
       bind_result,
       both,
       iter,
       iter_error,
       [0, symbol, symbol_bind],
       Let_syntax$0,
       Syntax,
       symbol,
       symbol_bind,
       map_err,
       bind_lwt_err];
   runtime.caml_register_global(3, Lwt_result, "Lwt_result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pqueue
//# unitInfo: Requires: Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, "src/core/lwt_pqueue.ml", 81, 15];
   function Make(Ord){
    function link(t1, t2){
     var
      c2 = t2[3],
      r2 = t2[2],
      x2 = t2[1],
      c1 = t1[3],
      r1 = t1[2],
      x1 = t1[1],
      c = caml_call2(Ord[1], x1, x2);
     return 0 < c
             ? [0, x2, r2 + 1 | 0, [0, t1, c2]]
             : [0, x1, r1 + 1 | 0, [0, t2, c1]];
    }
    function ins(t, ts){
     var t$0 = t, ts$0 = ts;
     for(;;){
      if(! ts$0) return [0, t$0, 0];
      var t$1 = ts$0[1], r$0 = t$1[2], r = t$0[2];
      if(r < r$0) return [0, t$0, ts$0];
      var ts$1 = ts$0[2], t$2 = link(t$0, t$1);
      t$0 = t$2;
      ts$0 = ts$1;
     }
    }
    function is_empty(ts){return 0 === ts ? 1 : 0;}
    function add(x, ts){return ins([0, x, 0, 0], ts);}
    function union(ts$0, ts){
     if(! ts$0) return ts;
     if(! ts) return ts$0;
     var
      ts2 = ts[2],
      t2 = ts[1],
      ts1 = ts$0[2],
      t1 = ts$0[1],
      r = t2[2],
      r$2 = t1[2];
     if(r$2 < r) return [0, t1, union(ts1, [0, t2, ts2])];
     var r$1 = t1[2], r$0 = t2[2];
     if(r$0 < r$1) return [0, t2, union([0, t1, ts1], ts2)];
     var _c_ = union(ts1, ts2);
     return ins(link(t1, t2), _c_);
    }
    function find_min(param){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var t = param[1];
     if(! param[2]){var x$2 = t[1]; return x$2;}
     var
      ts = param[2],
      x = find_min(ts),
      x$1 = t[1],
      c = caml_call2(Ord[1], x$1, x);
     if(0 <= c) return x;
     var x$0 = t[1];
     return x$0;
    }
    function lookup_min(param){
     if(! param) return 0;
     var t = param[1];
     if(! param[2]){var x$2 = t[1]; return [0, x$2];}
     var ts = param[2], result = lookup_min(ts);
     if(! result) return 0;
     var x = result[1], x$1 = t[1], c = caml_call2(Ord[1], x$1, x);
     if(0 <= c) return result;
     var x$0 = t[1];
     return [0, x$0];
    }
    function get_min(param){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var t = param[1];
     if(! param[2]) return [0, t, 0];
     var
      ts = param[2],
      match = get_min(ts),
      ts$0 = match[2],
      t$0 = match[1],
      x = t$0[1],
      x$0 = t[1],
      c = caml_call2(Ord[1], x$0, x);
     return 0 <= c ? [0, t$0, [0, t, ts$0]] : [0, t, ts];
    }
    function remove_min(ts){
     if(! ts) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var _b_ = get_min(ts), ts$0 = _b_[2], c = _b_[1][3];
     return union(caml_call1(Stdlib_List[10], c), ts$0);
    }
    function size(l){
     return caml_call3
             (Stdlib_List[26],
              function(s, t){
               var tl = t[3];
               return s + (1 + size(tl) | 0) | 0;
              },
              0,
              l);
    }
    return [0,
            0,
            is_empty,
            add,
            union,
            find_min,
            lookup_min,
            remove_min,
            size];
   }
   var Lwt_pqueue = [0, Make];
   runtime.caml_register_global(4, Lwt_pqueue, "Lwt_pqueue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_list
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function tail_recursive_map(f, l){
    var _O_ = caml_call2(Stdlib_List[22], f, l);
    return caml_call1(Stdlib_List[10], _O_);
   }
   function tail_recursive_mapi_rev(f, l){
    var acc = 0, i = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      tl = param[2],
      hd = param[1],
      i$0 = i + 1 | 0,
      acc$0 = [0, caml_call2(f, i, hd), acc];
     acc = acc$0;
     i = i$0;
     param = tl;
    }
   }
   function iter_s(f, l){
    if(! l) return Lwt[36];
    var l$0 = l[2], x = l[1], _N_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1], _N_, function(param){return iter_s(f, l$0);});
   }
   function iter_p(f, l){
    var
     _M_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[22], _M_, l);
    return caml_call1(Lwt[14], ts);
   }
   function _a_(i, f, l){
    if(! l) return Lwt[36];
    var
     l$0 = l[2],
     x = l[1],
     _K_ = caml_call1(f, i),
     _L_ = caml_call2(Lwt[80], _K_, x);
    return caml_call2
            (Lwt[33][1], _L_, function(param){return _a_(i + 1 | 0, f, l$0);});
   }
   function iteri_s(f, l){return _a_(0, f, l);}
   function iteri_p(f, l){
    function f$0(i){
     var _J_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _J_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return caml_call1(Lwt[14], ts);
   }
   function map_s(f, l){
    function inner(acc, param){
     if(param){
      var tl = param[2], hd = param[1], _H_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1], _H_, function(r){return inner([0, r, acc], tl);});
     }
     var _I_ = caml_call1(Stdlib_List[10], acc);
     return caml_call1(Lwt[4], _I_);
    }
    return inner(0, l);
   }
   function collect_rev(acc, param){
    if(! param) return caml_call1(Lwt[4], acc);
    var ts = param[2], t = param[1];
    return caml_call2
            (Lwt[33][1], t, function(i){return collect_rev([0, i, acc], ts);});
   }
   function map_p(f, l){
    var
     _G_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[22], _G_, l);
    return collect_rev(0, ts);
   }
   function filter_map_s(f, l){
    function inner(acc, param){
     if(param){
      var tl = param[2], hd = param[1], _E_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1],
               _E_,
               function(param){
                if(! param) return inner(acc, tl);
                var v = param[1];
                return inner([0, v, acc], tl);
               });
     }
     var _F_ = caml_call1(Stdlib_List[10], acc);
     return caml_call1(Lwt[4], _F_);
    }
    return inner(0, l);
   }
   function filter_map_p(f, l){
    function collect_optional_rev(acc, param){
     if(! param) return caml_call1(Lwt[4], acc);
     var ts = param[2], t = param[1];
     return caml_call2
             (Lwt[33][1],
              t,
              function(param){
               if(! param) return collect_optional_rev(acc, ts);
               var v = param[1];
               return collect_optional_rev([0, v, acc], ts);
              });
    }
    var
     _D_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[22], _D_, l);
    return collect_optional_rev(0, ts);
   }
   function mapi_s(f, l){
    function inner(acc, i, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _A_ = caml_call1(f, i),
       _B_ = caml_call2(Lwt[80], _A_, hd);
      return caml_call2
              (Lwt[33][1],
               _B_,
               function(v){return inner([0, v, acc], i + 1 | 0, tl);});
     }
     var _C_ = caml_call1(Stdlib_List[10], acc);
     return caml_call1(Lwt[4], _C_);
    }
    return inner(0, 0, l);
   }
   function mapi_p(f, l){
    function f$0(i){
     var _z_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _z_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return collect_rev(0, ts);
   }
   function rev_map_append_s(acc, f, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var l$0 = l[2], x = l[1], _y_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _y_,
             function(x){return rev_map_append_s([0, x, acc], f, l$0);});
   }
   function rev_map_s(f, l){return rev_map_append_s(0, f, l);}
   function rev_map_p(f, l$1){
    var acc$1 = Lwt[38], acc = acc$1, l = l$1;
    for(;;){
     if(! l) return acc;
     var l$0 = l[2], x = l[1];
     let acc$1 = acc;
     var
      _x_ = caml_call2(Lwt[80], f, x),
      acc$0 =
        caml_call2
         (Lwt[33][1],
          _x_,
          function(x){
           return caml_call2
                   (Lwt[33][2], acc$1, function(l){return [0, x, l];});
          });
     acc = acc$0;
     l = l$0;
    }
   }
   function fold_left_s(f, acc, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var
     l$0 = l[2],
     x = l[1],
     _v_ = caml_call1(f, acc),
     _w_ = caml_call2(Lwt[80], _v_, x);
    return caml_call2
            (Lwt[33][1], _w_, function(acc){return fold_left_s(f, acc, l$0);});
   }
   function fold_right_s(f, l, acc){
    function inner(f, a, param){
     if(! param) return caml_call1(Lwt[4], a);
     var
      tl = param[2],
      hd = param[1],
      _t_ = caml_call1(f, hd),
      _u_ = caml_call2(Lwt[80], _t_, a);
     return caml_call2(Lwt[33][1], _u_, function(a){return inner(f, a, tl);});
    }
    return inner(f, acc, caml_call1(Stdlib_List[10], l));
   }
   function for_all_s(f, l){
    if(! l) return Lwt[39];
    var l$0 = l[2], x = l[1], _s_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _s_,
             function(param){return param ? for_all_s(f, l$0) : Lwt[40];});
   }
   function for_all_p(f, l){
    var _q_ = map_p(f, l);
    return caml_call2
            (Lwt[33][1],
             _q_,
             function(bl){
              var
               _r_ = caml_call2(Stdlib_List[33], function(x){return x;}, bl);
              return caml_call1(Lwt[4], _r_);
             });
   }
   function exists_s(f, l){
    if(! l) return Lwt[40];
    var l$0 = l[2], x = l[1], _p_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _p_,
             function(param){return param ? Lwt[39] : exists_s(f, l$0);});
   }
   function exists_p(f, l){
    var _n_ = map_p(f, l);
    return caml_call2
            (Lwt[33][1],
             _n_,
             function(bl){
              var
               _o_ = caml_call2(Stdlib_List[34], function(x){return x;}, bl);
              return caml_call1(Lwt[4], _o_);
             });
   }
   function find_s(f, l){
    if(! l) return caml_call1(Lwt[5], Stdlib[8]);
    var l$0 = l[2], x = l[1], _m_ = caml_call2(Lwt[80], f, x);
    return caml_call2
            (Lwt[33][1],
             _m_,
             function(param){
              return param ? caml_call1(Lwt[4], x) : find_s(f, l$0);
             });
   }
   function optionalize(f, x){
    var _l_ = caml_call1(f, x);
    return caml_call2
            (Lwt[33][1],
             _l_,
             function(b){return b ? caml_call1(Lwt[4], [0, x]) : Lwt[37];});
   }
   function filter_s(f, l){
    return filter_map_s(function(_k_){return optionalize(f, _k_);}, l);
   }
   function filter_p(f, l){
    return filter_map_p(function(_j_){return optionalize(f, _j_);}, l);
   }
   function partition_s(f, l){
    function inner(acc1, acc2, param){
     if(param){
      var tl = param[2], hd = param[1], _g_ = caml_call2(Lwt[80], f, hd);
      return caml_call2
              (Lwt[33][1],
               _g_,
               function(b){
                return b
                        ? inner([0, hd, acc1], acc2, tl)
                        : inner(acc1, [0, hd, acc2], tl);
               });
     }
     var
      _h_ = caml_call1(Stdlib_List[10], acc2),
      _i_ = [0, caml_call1(Stdlib_List[10], acc1), _h_];
     return caml_call1(Lwt[4], _i_);
    }
    return inner(0, 0, l);
   }
   function partition_p(f, l){
    function g(x){
     var _f_ = caml_call2(Lwt[80], f, x);
     return caml_call2
             (Lwt[33][1],
              _f_,
              function(b){return caml_call1(Lwt[4], [0, b, x]);});
    }
    var _b_ = map_p(g, l);
    return caml_call2
            (Lwt[33][1],
             _b_,
             function(tl){
              var
               group1 =
                 tail_recursive_map
                  (function(_e_){return _e_[2];},
                   caml_call2
                    (Stdlib_List[44], function(_d_){return _d_[1];}, tl)),
               group2 =
                 tail_recursive_map
                  (function(_c_){return _c_[2];},
                   caml_call2
                    (Stdlib_List[44], function(x){return 1 - x[1];}, tl));
              return caml_call1(Lwt[4], [0, group1, group2]);
             });
   }
   var
    Lwt_list =
      [0,
       iter_s,
       iter_p,
       iteri_s,
       iteri_p,
       map_s,
       map_p,
       mapi_s,
       mapi_p,
       rev_map_s,
       rev_map_p,
       fold_left_s,
       fold_right_s,
       for_all_s,
       for_all_p,
       exists_s,
       exists_p,
       find_s,
       filter_s,
       filter_p,
       filter_map_s,
       filter_map_p,
       partition_s,
       partition_p];
   runtime.caml_register_global(3, Lwt_list, "Lwt_list");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pool
//# unitInfo: Requires: Lwt, Lwt_list, Lwt_sequence, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Lwt_list = global_data.Lwt_list,
    Lwt = global_data.Lwt;
   function create(m, _n_, _m_, opt, create){
    var
     validate = _n_ ? _n_[1] : function(param){return Lwt[39];},
     check = _m_ ? _m_[1] : function(param, f){return caml_call1(f, 1);},
     dispose = opt ? opt[1] : function(param){return Lwt[36];},
     _o_ = caml_call1(Lwt_sequence[4], 0);
    return [0,
            create,
            check,
            validate,
            dispose,
            [0, [0, 0]],
            m,
            0,
            caml_call1(Stdlib_Queue[2], 0),
            _o_];
   }
   function create_member(p){
    return caml_call2
            (Lwt[7],
             function(param){p[7] = p[7] + 1 | 0; return caml_call1(p[1], 0);},
             function(exn){
              p[7] = p[7] - 1 | 0;
              return caml_call1(Lwt[5], exn);
             });
   }
   function release(p, c){
    var match = caml_call1(Lwt_sequence[13], p[9]);
    if(! match) return caml_call2(Stdlib_Queue[4], c, p[8]);
    var wakener = match[1];
    return caml_call2(Lwt[2], wakener, c);
   }
   function dispose(p, c){
    var _l_ = caml_call1(p[4], c);
    return caml_call2
            (Lwt[33][1],
             _l_,
             function(param){p[7] = p[7] - 1 | 0; return Lwt[36];});
   }
   function validate_and_return(p, c){
    return caml_call3
            (Lwt[9],
             function(param){return caml_call1(p[3], c);},
             function(param){
              if(param) return caml_call1(Lwt[4], c);
              var _k_ = dispose(p, c);
              return caml_call2
                      (Lwt[33][1], _k_, function(param){return create_member(p);});
             },
             function(e){
              var _i_ = dispose(p, c);
              return caml_call2
                      (Lwt[33][1],
                       _i_,
                       function(param){
                        var match = caml_call1(Lwt_sequence[13], p[9]);
                        if(match){
                         var wakener = match[1], _j_ = caml_call2(Lwt[80], p[1], 0);
                         caml_call3
                          (Lwt[32],
                           _j_,
                           function(c){return caml_call2(Lwt[2], wakener, c);},
                           function(exn){return caml_call2(Lwt[3], wakener, exn);});
                        }
                        throw caml_maybe_attach_backtrace(e, 0);
                       });
             });
   }
   function use(p, f){
    function _c_(c){
     var
      cleared = p[5][1],
      promise =
        caml_call2
         (Lwt[7],
          function(param){return caml_call1(f, c);},
          function(e){
           var cleared$0 = cleared[1], ok = [0, 0];
           caml_call2(p[2], c, function(result){ok[1] = result; return 0;});
           a:
           {
            var _g_ = function(param){return caml_call1(Lwt[5], e);};
            if(! cleared$0 && ok[1]){
             release(p, c);
             var _h_ = Lwt[36];
             break a;
            }
            var _h_ = dispose(p, c);
           }
           return caml_call2(Lwt[33][1], _h_, _g_);
          });
     return caml_call2
             (Lwt[33][1],
              promise,
              function(param){
               if(cleared[1]){
                var _f_ = dispose(p, c);
                return caml_call2
                        (Lwt[33][1], _f_, function(param){return promise;});
               }
               release(p, c);
               return promise;
              });
    }
    if(caml_call1(Stdlib_Queue[13], p[8]))
     if(p[7] < p[6])
      var _d_ = create_member(p);
     else
      var
       _b_ = caml_call1(Lwt[55], p[9]),
       _d_ =
         caml_call2
          (Lwt[33][1],
           _b_,
           function(_e_){return validate_and_return(p, _e_);});
    else
     var
      c = caml_call1(Stdlib_Queue[5], p[8]),
      _d_ = validate_and_return(p, c);
    return caml_call2(Lwt[33][1], _d_, _c_);
   }
   function clear(p){
    var
     elements =
       caml_call3
        (Stdlib_Queue[16],
         function(l, element){return [0, element, l];},
         0,
         p[8]);
    caml_call1(Stdlib_Queue[11], p[8]);
    var old_cleared = p[5][1];
    old_cleared[1] = 1;
    p[5][1] = [0, 0];
    return caml_call2
            (Lwt_list[1], function(_a_){return dispose(p, _a_);}, elements);
   }
   function wait_queue_length(p){return caml_call1(Lwt_sequence[7], p[9]);}
   var Lwt_pool = [0, create, use, clear, wait_queue_length];
   runtime.caml_register_global(4, Lwt_pool, "Lwt_pool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mvar
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence;
   function create_empty(param){
    var _b_ = caml_call1(Lwt_sequence[4], 0);
    return [0, 0, caml_call1(Lwt_sequence[4], 0), _b_];
   }
   function create(v){
    var _a_ = caml_call1(Lwt_sequence[4], 0);
    return [0, [0, v], caml_call1(Lwt_sequence[4], 0), _a_];
   }
   function put(mvar, v){
    if(mvar[1]){
     var
      match = caml_call1(Lwt[22], 0),
      w = match[2],
      res = match[1],
      node = caml_call2(Lwt_sequence[9], [0, v, w], mvar[2]);
     caml_call2
      (Lwt[24],
       res,
       function(param){return caml_call1(Lwt_sequence[3], node);});
     return res;
    }
    var match$0 = caml_call1(Lwt_sequence[13], mvar[3]);
    if(match$0){
     var w$0 = match$0[1];
     caml_call2(Lwt[2], w$0, v);
    }
    else
     mvar[1] = [0, v];
    return Lwt[36];
   }
   function take_available(mvar){
    var match$1 = mvar[1];
    if(! match$1) return 0;
    var v$0 = match$1[1], match = caml_call1(Lwt_sequence[13], mvar[2]);
    if(match){
     var match$0 = match[1], w = match$0[2], v = match$0[1];
     mvar[1] = [0, v];
     caml_call2(Lwt[2], w, 0);
    }
    else
     mvar[1] = 0;
    return [0, v$0];
   }
   function take(mvar){
    var match = take_available(mvar);
    if(! match) return caml_call1(Lwt[55], mvar[3]);
    var v = match[1];
    return caml_call1(Lwt[4], v);
   }
   function is_empty(mvar){return mvar[1] ? 0 : 1;}
   var
    Lwt_mvar = [0, create, create_empty, put, take, take_available, is_empty];
   runtime.caml_register_global(2, Lwt_mvar, "Lwt_mvar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mutex
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Lwt = global_data.Lwt;
   function create(param){return [0, 0, caml_call1(Lwt_sequence[4], 0)];}
   function lock(m){
    return m[1] ? caml_call1(Lwt[55], m[2]) : (m[1] = 1, Lwt[36]);
   }
   function unlock(m){
    var _b_ = m[1];
    if(! _b_) return _b_;
    if(caml_call1(Lwt_sequence[6], m[2])){m[1] = 0; return 0;}
    var _c_ = caml_call1(Lwt_sequence[11], m[2]);
    return caml_call2(Lwt[2], _c_, 0);
   }
   function with_lock(m, f){
    var _a_ = lock(m);
    return caml_call2
            (Lwt[33][1],
             _a_,
             function(param){
              return caml_call2
                      (Lwt[8], f, function(param){unlock(m); return Lwt[36];});
             });
   }
   function is_locked(m){return m[1];}
   function is_empty(m){return caml_call1(Lwt_sequence[6], m[2]);}
   var Lwt_mutex = [0, create, lock, unlock, is_locked, is_empty, with_lock];
   runtime.caml_register_global(2, Lwt_mutex, "Lwt_mutex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_condition
//# unitInfo: Requires: Lwt, Lwt_mutex, Lwt_sequence, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_List = global_data.Stdlib__List,
    Lwt_mutex = global_data.Lwt_mutex,
    create = Lwt_sequence[4];
   function wait(mutex, cvar){
    var waiter = caml_call1(Lwt[55], cvar);
    if(mutex){var m = mutex[1]; caml_call1(Lwt_mutex[3], m);}
    return caml_call2
            (Lwt[8],
             function(param){return waiter;},
             function(param){
              if(! mutex) return Lwt[36];
              var m = mutex[1];
              return caml_call1(Lwt_mutex[2], m);
             });
   }
   function signal(cvar, arg){
    try{
     var
      _b_ = caml_call1(Lwt_sequence[11], cvar),
      _c_ = caml_call2(Lwt[2], _b_, arg);
     return _c_;
    }
    catch(_d_){
     var _a_ = caml_wrap_exception(_d_);
     if(_a_ === Lwt_sequence[10]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   function broadcast(cvar, arg){
    var
     wakeners =
       caml_call3
        (Lwt_sequence[22], function(x, l){return [0, x, l];}, cvar, 0);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    return caml_call2
            (Stdlib_List[18],
             function(wakener){return caml_call2(Lwt[2], wakener, arg);},
             wakeners);
   }
   function broadcast_exn(cvar, exn){
    var
     wakeners =
       caml_call3
        (Lwt_sequence[22], function(x, l){return [0, x, l];}, cvar, 0);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    return caml_call2
            (Stdlib_List[18],
             function(wakener){return caml_call2(Lwt[3], wakener, exn);},
             wakeners);
   }
   var Lwt_condition = [0, create, wait, signal, broadcast, broadcast_exn];
   runtime.caml_register_global(4, Lwt_condition, "Lwt_condition");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJFbXB0eSIsImdldCIsIm5vZGUiLCJzZXQiLCJkYXRhIiwicmVtb3ZlIiwiY3JlYXRlIiwicGFyYW0iLCJzZXEiLCJjbGVhciIsImlzX2VtcHR5IiwibGVuZ3RoIiwiY3VyciIsImxlbiIsImFkZF9sIiwiYWRkX3IiLCJ0YWtlX2wiLCJ0YWtlX3IiLCJ0YWtlX29wdF9sIiwidGFrZV9vcHRfciIsInRyYW5zZmVyX2wiLCJzMSIsInMyIiwidHJhbnNmZXJfciIsIml0ZXJfbCIsIml0ZXJfciIsIml0ZXJfbm9kZV9sIiwiaXRlcl9ub2RlX3IiLCJmb2xkX2wiLCJhY2MiLCJmb2xkX3IiLCJmaW5kX25vZGVfbCIsImZpbmRfbm9kZV9yIiwiZmluZF9ub2RlX29wdF9sIiwiZmluZF9ub2RlX29wdF9yIiwiTHd0X3NlcXVlbmNlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvbHd0L2x3dF9zZXF1ZW5jZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEs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QSxRQUFBakIsU0FhakIsUUFBQUEsT0FBQSxRQUFBaUIsUUFBQTtBQUFBO0FBQUEsS0FURSxpQkFDRTtBQUFBLEtBR0E7QUFBQSxVQUFBQSxRQUNzQiwrQkFBQWpCLFNBQXNCO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUEsU0FFMUM7QUFBQTtBQUFBLEdBRVc7QUFBQSxZQUFBbUIsWUFBQXJDLEdBQUFjO0FBQUFBLFFBQUFJLFNBZ0JqQixRQUFBQSxPQUFBO0FBQUE7QUFBQSxLQVpFLGlCQVVFO0FBQUEsS0FSQTtBQUFBLE1BQ0ssMkJBQ0Q7QUFBQSxVQUFBQSxTQUVBO0FBQUE7QUFBQTtBQUFBLGNBQUFBLFNBRUY7QUFBQTtBQUFBLEdBSU87QUFBQSxZQUFBb0IsWUFBQXRDLEdBQUFjO0FBQUFBLFFBQUFJLFNBZ0JiLFFBQUFBLE9BQUE7QUFBQTtBQUFBLEtBWkUsaUJBVUU7QUFBQSxLQVJBO0FBQUEsTUFDSywyQkFDRDtBQUFBLFVBQUFBLFNBRUE7QUFBQTtBQUFBO0FBQUEsY0FBQUEsU0FFRjtBQUFBO0FBQUEsR0FJTztBQUFBLFlBQUFxQixnQkFBQXZDLEdBQUFjO0FBQUFBLElBR2IsY0FBUztBQUFBO0FBQUEsZURsT1g7QUFBQSwyQkNrT2lEO0FBQUEsS0RsT2pEO0FBQUE7QUFBQSxHQ2tPcUQ7QUFBQSxZQUFBMEIsZ0JBQUF4QyxHQUFBYztBQUFBQSxJQUduRCxjQUFTO0FBQUE7QUFBQSxlRHJPWDtBQUFBLDJCQ3FPaUQ7QUFBQSxLRHJPakQ7QUFBQTtBQUFBLEdDcU9xRDtBQUFBO0FBQUEsSUFBQTJCO0FBQUFBLE1Eck9yRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5leGNlcHRpb24gRW1wdHlcblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIHByZXYgOiAnYSB0O1xuICBtdXRhYmxlIG5leHQgOiAnYSB0O1xufVxuXG50eXBlICdhIG5vZGUgPSB7XG4gIG5vZGVfcHJldiA6ICdhIHQ7XG4gIG5vZGVfbmV4dCA6ICdhIHQ7XG4gIG11dGFibGUgbm9kZV9kYXRhIDogJ2E7XG4gIG11dGFibGUgbm9kZV9hY3RpdmUgOiBib29sO1xufVxuXG5leHRlcm5hbCBzZXFfb2Zfbm9kZSA6ICdhIG5vZGUgLT4gJ2EgdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG5vZGVfb2Zfc2VxIDogJ2EgdCAtPiAnYSBub2RlID0gXCIlaWRlbnRpdHlcIlxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE9wZXJhdGlvbnMgb24gbm9kZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBnZXQgbm9kZSA9XG4gIG5vZGUubm9kZV9kYXRhXG5cbmxldCBzZXQgbm9kZSBkYXRhID1cbiAgbm9kZS5ub2RlX2RhdGEgPC0gZGF0YVxuXG5sZXQgcmVtb3ZlIG5vZGUgPVxuICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gYmVnaW5cbiAgICBub2RlLm5vZGVfYWN0aXZlIDwtIGZhbHNlO1xuICAgIGxldCBzZXEgPSBzZXFfb2Zfbm9kZSBub2RlIGluXG4gICAgc2VxLnByZXYubmV4dCA8LSBzZXEubmV4dDtcbiAgICBzZXEubmV4dC5wcmV2IDwtIHNlcS5wcmV2XG4gIGVuZFxuXG4oKiArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICB8IE9wZXJhdGlvbnMgb24gc2VxdWVuY2VzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICopXG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgcmVjIHNlcSA9IHsgcHJldiA9IHNlcTsgbmV4dCA9IHNlcSB9IGluXG4gIHNlcVxuXG5sZXQgY2xlYXIgc2VxID1cbiAgc2VxLnByZXYgPC0gc2VxO1xuICBzZXEubmV4dCA8LSBzZXFcblxubGV0IGlzX2VtcHR5IHNlcSA9IHNlcS5uZXh0ID09IHNlcVxuXG5sZXQgbGVuZ3RoIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyIGxlbiA9XG4gICAgaWYgY3VyciA9PSBzZXEgdGhlblxuICAgICAgbGVuXG4gICAgZWxzZVxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluIGxvb3Agbm9kZS5ub2RlX25leHQgKGxlbiArIDEpXG4gIGluXG4gIGxvb3Agc2VxLm5leHQgMFxuXG5sZXQgYWRkX2wgZGF0YSBzZXEgPVxuICBsZXQgbm9kZSA9IHsgbm9kZV9wcmV2ID0gc2VxOyBub2RlX25leHQgPSBzZXEubmV4dDsgbm9kZV9kYXRhID0gZGF0YTsgbm9kZV9hY3RpdmUgPSB0cnVlIH0gaW5cbiAgc2VxLm5leHQucHJldiA8LSBzZXFfb2Zfbm9kZSBub2RlO1xuICBzZXEubmV4dCA8LSBzZXFfb2Zfbm9kZSBub2RlO1xuICBub2RlXG5cbmxldCBhZGRfciBkYXRhIHNlcSA9XG4gIGxldCBub2RlID0geyBub2RlX3ByZXYgPSBzZXEucHJldjsgbm9kZV9uZXh0ID0gc2VxOyBub2RlX2RhdGEgPSBkYXRhOyBub2RlX2FjdGl2ZSA9IHRydWUgfSBpblxuICBzZXEucHJldi5uZXh0IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIHNlcS5wcmV2IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIG5vZGVcblxubGV0IHRha2VfbCBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIHJhaXNlIEVtcHR5XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIHNlcS5uZXh0IGluXG4gICAgcmVtb3ZlIG5vZGU7XG4gICAgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX3Igc2VxID1cbiAgaWYgaXNfZW1wdHkgc2VxIHRoZW5cbiAgICByYWlzZSBFbXB0eVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEucHJldiBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdGFrZV9vcHRfbCBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIE5vbmVcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLm5leHQgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBTb21lIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdGFrZV9vcHRfciBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIE5vbmVcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLnByZXYgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBTb21lIG5vZGUubm9kZV9kYXRhXG4gIGVuZFxuXG5sZXQgdHJhbnNmZXJfbCBzMSBzMiA9XG4gIHMyLm5leHQucHJldiA8LSBzMS5wcmV2O1xuICBzMS5wcmV2Lm5leHQgPC0gczIubmV4dDtcbiAgczIubmV4dCA8LSBzMS5uZXh0O1xuICBzMS5uZXh0LnByZXYgPC0gczI7XG4gIHMxLnByZXYgPC0gczE7XG4gIHMxLm5leHQgPC0gczFcblxubGV0IHRyYW5zZmVyX3IgczEgczIgPVxuICBzMi5wcmV2Lm5leHQgPC0gczEubmV4dDtcbiAgczEubmV4dC5wcmV2IDwtIHMyLnByZXY7XG4gIHMyLnByZXYgPC0gczEucHJldjtcbiAgczEucHJldi5uZXh0IDwtIHMyO1xuICBzMS5wcmV2IDwtIHMxO1xuICBzMS5uZXh0IDwtIHMxXG5cbmxldCBpdGVyX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlLm5vZGVfZGF0YTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgaXRlcl9yIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW4gYmVnaW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuIGYgbm9kZS5ub2RlX2RhdGE7XG4gICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGl0ZXJfbm9kZV9sIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW4gYmVnaW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuIGYgbm9kZTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgaXRlcl9ub2RlX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlO1xuICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5wcmV2XG5cbmxldCBmb2xkX2wgZiBzZXEgYWNjID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgYWNjID1cbiAgICBpZiBjdXJyID09IHNlcSB0aGVuXG4gICAgICBhY2NcbiAgICBlbHNlXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlblxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0IChmIG5vZGUubm9kZV9kYXRhIGFjYylcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dCBhY2NcbiAgaW5cbiAgbG9vcCBzZXEubmV4dCBhY2NcblxubGV0IGZvbGRfciBmIHNlcSBhY2MgPVxuICBsZXQgcmVjIGxvb3AgY3VyciBhY2MgPVxuICAgIGlmIGN1cnIgPT0gc2VxIHRoZW5cbiAgICAgIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXYgKGYgbm9kZS5ub2RlX2RhdGEgYWNjKVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9wcmV2IGFjY1xuICBpblxuICBsb29wIHNlcS5wcmV2IGFjY1xuXG5sZXQgZmluZF9ub2RlX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgaWYgZiBub2RlLm5vZGVfZGF0YSB0aGVuXG4gICAgICAgICAgbm9kZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0XG4gICAgZWxzZVxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIGluXG4gIGxvb3Agc2VxLm5leHRcblxubGV0IGZpbmRfbm9kZV9yIGYgc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgPVxuICAgIGlmIGN1cnIgIT0gc2VxIHRoZW5cbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGlmIGYgbm9kZS5ub2RlX2RhdGEgdGhlblxuICAgICAgICAgIG5vZGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXZcbiAgICAgIGVsc2VcbiAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgIGVsc2VcbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICBpblxuICBsb29wIHNlcS5wcmV2XG5cbmxldCBmaW5kX25vZGVfb3B0X2wgZiBzZXEgPVxuICB0cnkgU29tZSAoZmluZF9ub2RlX2wgZiBzZXEpIHdpdGggTm90X2ZvdW5kIC0+IE5vbmVcblxubGV0IGZpbmRfbm9kZV9vcHRfciBmIHNlcSA9XG4gIHRyeSBTb21lIChmaW5kX25vZGVfciBmIHNlcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9Md3QiLCJjc3RfTHd0X3MiLCJjc3Rfc3JjX2NvcmVfbHd0X21sIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNSIsImE0IiwiY2FtbF9jYWxsNiIsImE1IiwiY2FtbF9jYWxsNyIsImE2IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsIkx3dF9zZXF1ZW5jZSIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0xpc3QiLCJTdGRsaWIiLCJDYW1saW50ZXJuYWxMYXp5IiwiU3RkbGliX1JhbmRvbSIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWJfUXVldWUiLCJTdGRsaWJfUHJpbnRleGMiLCJTdGRsaWJfTWFwIiwiY29tcGFyZSIsIlN0b3JhZ2VfbWFwIiwic3RhdGVfb2ZfcmVzdWx0IiwicGFyYW0iLCJ4IiwiZXhuIiwidW5kZXJseWluZyIsInAiLCJtYXRjaCIsInAyIiwicDEiLCJoYW5kbGVfYWxsIiwiaGFuZGxlX2FsbF9leGNlcHRfcnVudGltZSIsInYiLCJzZXQiLCJydW4iLCJlIiwibmV4dF9rZXlfaWQiLCJuZXdfa2V5IiwiaWQiLCJjdXJyZW50X3N0b3JhZ2UiLCJjc3RfRmF0YWxfZXJyb3JfZXhjZXB0aW9uIiwiZ2V0Iiwia2V5IiwicmVmcmVzaCIsInZhbHVlIiwid2l0aF92YWx1ZSIsIm5ld19zdG9yYWdlIiwic2F2ZWRfc3RvcmFnZSIsInJlc3VsdCIsImNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyIsImwxIiwibDIiLCJjbGVhbl91cF9jYWxsYmFja19jZWxscyIsImNhbGxiYWNrcyIsImNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbCIsImNlbGwiLCJwcyIsImNsZWFudXBzX2RlZmVycmVkIiwiYWRkX3JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9ub2RlIiwibm9kZSIsImV4aXN0aW5nIiwiYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjIiwiYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiIiwic2VsZl9yZW1vdmluZ19jYWxsYmFja193cmFwcGVyIiwiYWRkX2NhbmNlbF9jYWxsYmFjayIsImFzeW5jX2V4Y2VwdGlvbl9ob29rIiwiaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvIiwiQ2FuY2VsZWQiLCJydW5fY2FsbGJhY2tzIiwiaXNfY2FuY2VsZWQiLCJmcyIsIml0ZXJfY2FsbGJhY2tfbGlzdCIsImNvdW50ZXIiLCJyZXN0Iiwic3RvcmFnZSIsIml0ZXJfbGlzdCIsImN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCIsImRlZmVycmVkX2NhbGxiYWNrcyIsImRlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aSIsImNzdF93YWtldXBfcmVzdWx0IiwiY3N0X3dha2V1cCIsImNzdF93YWtldXBfZXhuIiwiY3N0X3dha2V1cF9sYXRlcl9yZXN1bHQiLCJjc3Rfd2FrZXVwX2xhdGVyIiwiY3N0X3dha2V1cF9sYXRlcl9leG4iLCJsZWF2ZV9yZXNvbHV0aW9uX2xvb3AiLCJzdG9yYWdlX3NuYXBzaG90IiwicnVuX2luX3Jlc29sdXRpb25fbG9vcCIsImFiYW5kb25fd2FrZXVwcyIsInJ1bl9jYWxsYmFja3Nfb3JfZGVmZXJfdGhlbSIsIm9wdCIsImFsbG93X2RlZmVycmluZyIsIm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCIsInNob3VsZF9kZWZlciIsInJlc29sdmUiLCJydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXQiLCJpZl9kZWZlcnJlZCIsInJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaSIsImRlZmVycmVkX3Jlc3VsdCIsImRlZmVycmVkX2NhbGxiYWNrIiwiaW1tZWRpYXRlX3Jlc3VsdCIsImRlZmVycmVkX3JlY29yZCIsIndha2V1cF9nZW5lcmFsIiwiYXBpX2Z1bmN0aW9uX25hbWUiLCJyIiwid2FrZXVwX3Jlc3VsdCIsIndha2V1cCIsIndha2V1cF9leG4iLCJ3YWtldXBfbGF0ZXJfZ2VuZXJhbCIsIndha2V1cF9sYXRlcl9yZXN1bHQiLCJ3YWtldXBfbGF0ZXIiLCJ3YWtldXBfbGF0ZXJfZXhuIiwiY2FuY2VsIiwiY2FuY2VsZWRfcmVzdWx0IiwiY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyIsImNhbGxiYWNrc19hY2N1bXVsYXRvciIsInJldHVybiIsIm9mX3Jlc3VsdCIsImZhaWwiLCJyZXR1cm5fdW5pdCIsInJldHVybl9ub25lIiwicmV0dXJuX3NvbWUiLCJyZXR1cm5fbmlsIiwicmV0dXJuX3RydWUiLCJyZXR1cm5fZmFsc2UiLCJyZXR1cm5fb2siLCJyZXR1cm5fZXJyb3IiLCJmYWlsX3dpdGgiLCJtc2ciLCJmYWlsX2ludmFsaWRfYXJnIiwibmV3X3BlbmRpbmciLCJob3dfdG9fY2FuY2VsIiwic3RhdGUiLCJ3YWl0IiwidGFzayIsImFkZF90YXNrX3IiLCJzZXF1ZW5jZSIsImFkZF90YXNrX2wiLCJwcm90ZWN0ZWQiLCJwX2ludGVybmFsIiwiY2FsbGJhY2siLCJwX3Jlc3VsdCIsInJlbW92ZV90aGVfY2FsbGJhY2siLCJwX2NhbGxiYWNrcyIsIm5vX2NhbmNlbCIsIm1ha2VfaW50b19wcm94eSIsIm91dGVyX3Byb21pc2UiLCJ1c2VyX3Byb3ZpZGVkX3Byb21pc2UiLCJvdXRlcl9jYWxsYmFja3MiLCJyZWd1bGFyX2NhbGxiYWNrcyIsImNhbmNlbF9jYWxsYmFja3MiLCJzeW1ib2xfYmluZCIsImNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbCIsImJhY2t0cmFjZV9iaW5kIiwiYWRkX2xvYyIsInN5bWJvbCIsImNhdGNoIiwiaCIsImJhY2t0cmFjZV9jYXRjaCIsInRyeV9iaW5kIiwiYmFja3RyYWNlX3RyeV9iaW5kIiwiZmluYWxpemUiLCJiYWNrdHJhY2VfZmluYWxpemUiLCJvbl9jYW5jZWwiLCJvbl9zdWNjZXNzIiwiY2FsbGJhY2tfaWZfZGVmZXJyZWQiLCJvbl9mYWlsdXJlIiwib25fdGVybWluYXRpb24iLCJvbl9hbnkiLCJnIiwid3JhcF9pbl9jYW5jZWxhYmxlIiwicF91bmRlcmx5aW5nIiwiZG9udF93YWl0IiwiYXN5bmMiLCJpZ25vcmVfcmVzdWx0Iiwiam9pbiIsIm51bWJlcl9wZW5kaW5nX2luX3BzIiwiam9pbl9yZXN1bHQiLCJuZXdfcmVzdWx0IiwiYm90aCIsInBhaXIiLCJ2MiIsInYxIiwiYWxsIiwieSIsInZzIiwiaSIsImFjYyIsImluZGV4IiwiY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4iLCJ0b3RhbCIsInJlamVjdGVkIiwibnRoX3Jlc29sdmVkIiwibiIsIm50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbiIsInBybmciLCJjc3RfTHd0X2Nob29zZV93b3VsZF9yZXR1cm5fYV8iLCJjc3RfTHd0X3BpY2tfd291bGRfcmV0dXJuX2FfcHIiLCJjc3RfTHd0X25jaG9vc2Vfd291bGRfcmV0dXJuX2EiLCJjc3RfTHd0X25waWNrX3dvdWxkX3JldHVybl9hX3AiLCJjc3RfTHd0X25jaG9vc2Vfc3BsaXRfd291bGRfcmUiLCJjaG9vc2UiLCJwaWNrIiwicXMiLCJjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnQiLCJyZXN1bHRzIiwibmNob29zZSIsIm5waWNrIiwibmNob29zZV9zcGxpdCIsInBlbmRpbmdfYWNjIiwidG9fcmVzb2x2ZSIsImZ1bGZpbGxlZCIsInBlbmRpbmciLCJkZWJ1Z19zdGF0ZV9pcyIsImV4cGVjdGVkX3N0YXRlIiwiaXNfc2xlZXBpbmciLCJwb2xsIiwiYXBwbHkiLCJ3cmFwIiwid3JhcDEiLCJ4MSIsIndyYXAyIiwieDIiLCJ3cmFwMyIsIngzIiwid3JhcDQiLCJ4NCIsIndyYXA1IiwieDUiLCJ3cmFwNiIsIng2Iiwid3JhcDciLCJ4NyIsInBhdXNlX2hvb2siLCJwYXVzZWQiLCJwYXVzZSIsIndha2V1cF9wYXVzZWQiLCJ0bXAiLCJyZWdpc3Rlcl9wYXVzZV9ub3RpZmllciIsImFiYW5kb25fcGF1c2VkIiwicGF1c2VkX2NvdW50IiwibWFwIiwidCIsImJpbmQiLCJPcGVuX29uX3JocyIsIkxldF9zeW50YXgiLCJsZXQiLCJTeW50YXgiLCJMd3QiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9sd3QvbHd0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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQvbEdyQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG4oKiBSZWFkaW5nIGd1aWRlXG5cbiAgIFdlbGNvbWUgdG8gdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBMd3QgY29yZSEgVGhpcyBpcyBhIGJpZyBmaWxlLCBidXQgd2VcbiAgIGhvcGUgdGhhdCByZWFkaW5nIGl0IChwYXJ0cyBhdCBhIHRpbWUhKSB3aWxsIG5vdCBiZSBzY2FyeSA6KSBIZXJlIGlzIHdoeTpcblxuXG4gICAqIFNlY3Rpb25pbmdcblxuICAgVGhlIGNvZGUgaXMgYnJva2VuIHVwIGludG8gc2VjdGlvbnMsIGVhY2ggb25lIG9mIHdoaWNoIGlzIGFuIGludGVybmFsIG1vZHVsZS5cbiAgIE1vc3Qgb2YgdGhlIG1vZHVsZXMgaGF2ZSBhIHNpZ25hdHVyZSwgd2hpY2ggc2VydmVzIGFzIGEgbmVhdCB0YWJsZSBvZlxuICAgY29udGVudHMuXG5cbiAgIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHJlYWQgdGhpcyBmaWxlIHdpdGggY29kZSBmb2xkaW5nIGVuYWJsZWQuIElmIHlvdVxuICAgZm9sZCBhbGwgdGhlIG1vZHVsZXMsIHlvdSBjYW4gdmlzdWFsaXplIHRoZSBsb2dpY2FsIHN0cnVjdHVyZSBvZiBMd3QgcXVpdGVcbiAgIGVhc2lseS4gWW91IGNhbiB0aGVuIGV4cGFuZCBtb2R1bGVzIGFzIG5lZWRlZCwgZGVwZW5kaW5nIG9uIHdoYXQgcGFydCBvZiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIHlvdSBhcmUgaW50ZXJlc3RlZCBpbi4gV2l0aG91dCBjb2RlIGZvbGRpbmcsIHlvdSBmYWNlIGFuXG4gICBpbnRpbWlkYXRpbmcgd2FsbCBvZiBjb2RlIDooIFlvdSBjYW4gc3RpbGwgdmlzdWFsbHkgcGFyc2UgdGhlIGZpbGUsIGhvd2V2ZXIsXG4gICBiZWNhdXNlIHRoZXJlIGFyZSBwbGVudHkgb2YgYmxhbmsgbGluZXMgdG8gaGVscCBzZWN0aW9uIHRoaW5ncyBvZmYuIFlvdSBjYW5cbiAgIGFsc28gdmlldyB0aGlzIGZpbGUgZm9sZGVkIG9ubGluZTpcblxuICAgICBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hYW50cm9uLzlmYWIwYmRlYWQ5OGE2MGZjY2YwNmUwMTg5MTg2ODYzXG4gICAgIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2FhbnRyb24vOTdiNTg1MjBkNWJiNDg1OGNjYWM2ZjU0NzAwYTI0ZDdcblxuICAgVGhlIHNpZ25hdHVyZXMgYXJlIHVudXN1YWw6IGJpZyBjb21tZW50cyBhcmUgYWJzZW50LiBUaGV5IGFyZSBtb3ZlZCBpbnRvIHRoZVxuICAgbW9kdWxlcywgc28gdGhhdCB0aGV5IGFyZSBoaWRkZW4gYnkgY29kZSBmb2xkaW5nIHdoZW4geW91ICh0aGUgcmVhZGVyISkgYXJlXG4gICBub3QgaW50ZXJlc3RlZCBpbiB0aG9zZSBtb2R1bGVzLlxuXG5cbiAgICogRG9jdW1lbnRhdGlvblxuXG4gICBUaGUgZG9jdW1lbnRhdGlvbiBiZWdpbnMgd2l0aCBhbiBvdmVydmlldyBvZiBtYWpvciBjb25jZXB0cyBhbmQgY29tcG9uZW50cy5cbiAgIFRoaXMgb3ZlcnZpZXcgcHV0cyBldmVyeXRoaW5nIGludG8gY29udGV4dC4gWW91IGRvbid0IGhhdmUgdG8gcmVhZCB0aGUgd2hvbGVcbiAgIHRoaW5nLiBUaGUgb3ZlcnZpZXcgYmVnaW5zIHdpdGggYmFzaWMgY29uY2VwdHMsIG1vdmVzIG9uIHRvIGFkdmFuY2VkIG9uZXMsXG4gICBhbmQgdGhlbiBnZXRzIGludG8gdGhlIHRydWx5IGVzb3RlcmljLiBZb3UgY2FuIHJlYWQgYWJvdXQgZWFjaCBjb25jZXB0IG9uIGFuXG4gICBhcy1uZWVkZWQgYmFzaXMuIEhvd2V2ZXIsIG9uY2UgeW91IGhhdmUgcmVhZCB0aGUgd2hvbGUgb3ZlcnZpZXcsIHlvdSB3aWxsIGJlXG4gICBhd2FyZSBvZiAqZXZlcnl0aGluZyogdGhhdCBpcyBuZWVkZWQgdG8gdW5kZXJzdGFuZCwgYW5kIHdvcmsgd2l0aCwgdGhlIGNvcmVcbiAgIG9mIEx3dC5cblxuICAgTGl0dGVyZWQgaW4gdGhlIGNvZGUgYXJlIGFkZGl0aW9uYWwgY29tbWVudHMsIHRoYXQgZ28gaW4tZGVwdGggb24gdmFyaW91c1xuICAgbG9jYWwgaW1wbGVtZW50YXRpb24gZGV0YWlscywgb3Bwb3J0dW5pdGllcywgcmVncmV0cywgYW5kIHRoZSBsaWtlLlxuXG4gICBUaGUgc2VjdGlvbnMgKG1vZHVsZXMpIG9mIHRoZSBjb2RlIGNvcnJlc3BvbmQgY2xvc2VseSB0byBzZWN0aW9ucyBvZiB0aGVcbiAgIG92ZXJ2aWV3LlxuXG5cbiAgICogV2hpdGVzcGFjZVxuXG4gICBUaGUgdG90YWwgbGluZSBjb3VudCBvZiB0aGlzIGZpbGUgbWF5IHNlZW0gZnJpZ2h0ZW5pbmcsIGJ1dCBvbmUgdGhpcmQgb2YgaXRcbiAgIGlzIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBib3RoIHRoZXJlIHRvIGhlbHAgeW91IHJlYWQgdGhlIHJlbWFpbmluZyB0d29cbiAgIHRoaXJkcyFcblxuICAgQWxzbywgd2l0aGluIHRob3NlIHR3byB0aGlyZHMsIHRoZXJlIGFyZSBsYXJnZSBncm91cHMgb2YgZnVuY3Rpb25zIHRoYXQgYXJlXG4gICByZXBldGl0aXZlIGFuZCBmb3JtdWxhaWMsIHNvIHRoZXJlIGlzIG11Y2ggbGVzcyBjb25jZXB0dWFsbHktdW5pcXVlIGNvZGUgaW5cbiAgIEx3dCB0aGFuIHlvdSBtaWdodCB0aGluayBhdCBmaXJzdC5cblxuXG4gICAqIFBsZWFzZSBlZGl0IHRoZSBjb2RlIGFuZCB0aGUgZG9jcyFcblxuICAgVGhpcyBjb2RlIGlzIG1lYW50IHRvIGJlIHJlYWRhYmxlLCBhbmQgdG8gYmUgZWRpdGVkLiBJZiB5b3UgYXJlIHJlYWRpbmdcbiAgIHNvbWV0aGluZywgYW5kIHRoaW5rIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0byBleHByZXNzIGl0LCBwbGVhc2UgZ28gYWhlYWQgYW5kXG4gICBvcGVuIGEgcHVsbCByZXF1ZXN0IHRvIHRoZSBMd3QgcmVwb3NpdG9yeSBhdFxuXG4gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dFxuXG4gICBFdmVuIGlmIHlvdXIgcHVsbCByZXF1ZXN0IHNvbWVob3cgZG9lc24ndCBnZXQgbWVyZ2VkLCB5b3Ugd2lsbCBoYXZlIGVkdWNhdGVkXG4gICB0aGUgbWFpbnRhaW5lcnMsIG5vdCB0byBtZW50aW9uIG90aGVyIGNvbnRyaWJ1dG9ycywgYW5kIHVzZXJzLiBUaGlzIGlzIHRydWVcbiAgIGV2ZW4gaWYgdGhlIGNoYW5nZSBpcyB0cml2aWFsIC0tIHNvbWV0aW1lcywgbWFpbnRhaW5lcnMganVzdCBuZWVkIHRvIGJlXG4gICBlZHVjYXRlZCBtdWx0aXBsZSB0aW1lcyBiZWZvcmUgdGhleSBzZWUgdGhlIHdpc2RvbSBvZiBpdCA6L1xuXG4gICBMaWtld2lzZSwgaWYgeW91IHdvdWxkIGxpa2UgdG8gbWFrZSBhIGNvZGUgY29udHJpYnV0aW9uIHRvIHRoZSBMd3QgY29yZSwgaXRcbiAgIGlzIHF1aXRlIHdlbGNvbWUsIGFuZCB3ZSBob3BlIHRoYXQgdGhpcyBjb2RlIGlzIHJlYWRhYmxlIGVub3VnaCBmb3IgeW91IHRvIGJlXG4gICBhYmxlIHRvIG1ha2UgaXQhXG5cblxuICAgRW5qb3khICopXG5cblxuXG4oKiBPdmVydmlld1xuXG4gICBJbiB0aGlzIGZpbGUsIHRoZXJlIGlzIGEgXCJtb2RlbFwiIGZ1bmN0aW9uIC0tIFtMd3QuYmluZF0gLS0gd2hpY2ggcHVsbHNcbiAgIHRvZ2V0aGVyIG1hbnkgKHRob3VnaCBub3QgYWxsKSBvZiB0aGUgY29uY2VwdHMgYW5kIGhlbHBlcnMgZGlzY3Vzc2VkIGluIHRoaXNcbiAgIG92ZXJ2aWV3LiBUbyBmaW5kIGl0LCBzZWFyY2ggZm9yIFwibGV0IGJpbmQsXCIgYW5kIHlvdSBjYW4gZXhhbWluZSBpdCB3aGlsZVxuICAgcmVhZGluZyB0aGUgb3ZlcnZpZXcuIFRoZSBhdXRob3JzIG9mIHRoaXMgZmlsZSBpbnRlbmQgdG8gcHV0IGV4dHJhIGVmZm9ydFxuICAgaW50byB3cml0aW5nIG5pY2UgY29tbWVudHMgaW5zaWRlIFtMd3QuYmluZF0gOilcblxuXG4gICAwLiBNYWluIG1lY2hhbmlzbSBhbmQgdHdvIGFzcGVjdHNcblxuICAgVGhlIEx3dCBpbnRlcmZhY2UgKFtsd3QubWxpXSkgcHJvdmlkZXMgb25lIG1haW4gbWVjaGFuaXNtLCBwcm9taXNlcywgYW5kIHR3b1xuICAgXCJhc3BlY3RzLFwiIHdoaWNoIGFyZSAqbm90KiBuZWNlc3NhcnkgdG8gdW5kZXJzdGFuZCB0aGUgbWFpbiBtZWNoYW5pc21cbiAgIHByb21pc2VzLCBidXQgdGhleSBhcmUgc3RpbGwgdGhlcmU6XG5cbiAgIC0gcHJvbWlzZSBjYW5jZWxsYXRpb25cbiAgIC0gc2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlXG5cbiAgIElmIHlvdSBhcmUgbm90IGludGVyZXN0ZWQgaW4gY2FuY2VsbGF0aW9uIG9yIHN0b3JhZ2UsIHlvdSBjYW4gaWdub3JlIHRoZXNlXG4gICB0d28gY29tcGxpY2F0aW9ucywgYW5kIHN0aWxsIGdldCBhIHByZXR0eSBnb29kIHVuZGVyc3RhbmRpbmcgb2YgdGhlIGNvZGUuIFRvXG4gICBoZWxwLCBhbGwgaWRlbnRpZmllcnMgcmVsYXRlZCB0byBjYW5jZWxsYXRpb24gY29udGFpbiB0aGUgc3RyaW5nIFwiY2FuY2VsLFwiXG4gICBhbmQgYWxsIGlkZW50aWZpZXJzIHJlbGF0ZWQgdG8gc3RvcmFnZSBjb250YWluIFwic3RvcmFnZS5cIlxuXG5cbiAgIDEuIFByb21pc2VzXG5cbiAgIEEgcHJvbWlzZSBpcyBhIGNlbGwgdGhhdCBjYW4gYmUgaW4gb25lIG9mIHR3byBzdGF0ZXM6IFwicmVzb2x2ZWRcIiBvclxuICAgXCJwZW5kaW5nLlwiXG5cbiAgIC0gUmVzb2x2ZWQgcHJvbWlzZXNcblxuICAgICBBIHJlc29sdmVkIHByb21pc2UgaXMgZWl0aGVyIFwiZnVsZmlsbGVkXCIgd2l0aCBhIHZhbHVlLCBvciBcInJlamVjdGVkXCIgd2l0aFxuICAgICBhbiBleGNlcHRpb24uIFRoZSBzdGF0ZSBvZiBhIHJlc29sdmVkIHByb21pc2Ugd2lsbCBuZXZlciBjaGFuZ2UgYWdhaW46IGFcbiAgICAgcmVzb2x2ZWQgcHJvbWlzZSBpcyBpbW11dGFibGUuIEEgcmVzb2x2ZWQgcHJvbWlzZSBpcyBiYXNpY2FsbHkgZXF1aXZhbGVudFxuICAgICB0byBhbiBbKCdhLCBleG4pIFN0ZGxpYi5yZXN1bHRdLiBSZXNvbHZlZCBwcm9taXNlcyBhcmUgcHJvZHVjZWQgaW4gdHdvXG4gICAgIHdheXM6XG5cbiAgICAgLSBbTHd0LnJldHVybl0sIFtMd3QuZmFpbF0sIGFuZCByZWxhdGVkIGZ1bmN0aW9ucywgcHJvZHVjZSBcInRyaXZpYWxcIlxuICAgICAgIHByb21pc2VzIHRoYXQgYXJlIHJlc29sdmVkIGZyb20gdGhlIHN0YXJ0LlxuICAgICAtIFRoZSBvdGhlciB3YXkgaXMgdG8gcmVzb2x2ZSBhIHByb21pc2UgdGhhdCBzdGFydGVkIG91dCBwZW5kaW5nLlxuXG4gICAgIE5vdGUgdGhhdCByZWplY3RlZCBwcm9taXNlcyBoYXZlIG5vdGhpbmcgdG8gZG8gd2l0aCB1bmhhbmRsZWQgZXhjZXB0aW9ucy5cblxuICAgLSBQZW5kaW5nIHByb21pc2VzXG5cbiAgICAgLi4uYXJlIHRob3NlIHRoYXQgbWF5IGJlY29tZSByZXNvbHZlZCBpbiB0aGUgZnV0dXJlLiBFYWNoIHBlbmRpbmcgcHJvbWlzZVxuICAgICBjYXJyaWVzIGEgbGlzdCBvZiBjYWxsYmFja3MuIFRoZXNlIGNhbGxiYWNrcyBhcmUgYWRkZWQgYnkgZnVuY3Rpb25zIGxpa2VcbiAgICAgW0x3dC5iaW5kXSwgYW5kIGNhbGxlZCBieSBMd3QgaWYvd2hlbiB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZC4gVGhlc2VcbiAgICAgY2FsbGJhY2tzIHR5cGljYWxseSBlbmQgdXAgcmVzb2x2aW5nIGFkZGl0aW9uYWwgcHJvbWlzZXM7IHNlZSBzZWN0aW9uXG4gICAgIFwiUmVzb2x1dGlvbiBsb29wXCIgYmVsb3cuXG5cbiAgICAgUGVuZGluZyBwcm9taXNlcyBhcmUgcHJvZHVjZWQgaW4gdGhyZWUgd2F5cywgYWNjb3JkaW5nIHRvIGhvdyB0aGV5IGNhbiBiZVxuICAgICByZXNvbHZlZDpcblxuICAgICAtIEluaXRpYWwgcHJvbWlzZXNcblxuICAgICAgIC4uLmFyZSBjcmVhdGVkIGJ5IFtMd3Qud2FpdF0gYW5kIFtMd3QudGFza10uIFRoZSB1c2VyIG9mIEx3dCByZXNvbHZlc1xuICAgICAgIHRoZXNlIHByb21pc2VzIG1hbnVhbGx5LCB0aHJvdWdoIHRoZSByZXNvbHZlcnMgcmV0dXJuZWQgYnkgdGhvc2VcbiAgICAgICBmdW5jdGlvbnMuXG5cbiAgICAgLSBTZXF1ZW50aWFsIGNvbXBvc2l0aW9uXG5cbiAgICAgICBGb3IgZXhhbXBsZSwgW0x3dC5iaW5kXS4gVGhlc2UgcHJvbWlzZXMgb25seSBhcmUgb25seSByZXNvbHZlZCB3aGVuIHRoZVxuICAgICAgIHByZWNlZGluZyBzZXF1ZW5jZSBvZiBwcm9taXNlcyByZXNvbHZlcy4gVGhlIHVzZXIgY2Fubm90IHJlc29sdmUgdGhlc2VcbiAgICAgICBwcm9taXNlcyBkaXJlY3RseSAoYnV0IHNlZSB0aGUgc2VjdGlvbiBvbiBjYW5jZWxsYXRpb24gYmVsb3cpLlxuXG4gICAgIC0gQ29uY3VycmVudCBjb21wb3NpdGlvblxuXG4gICAgICAgRm9yIGV4YW1wbGUsIFtMd3Quam9pbl0gb3IgW0x3dC5jaG9vc2VdLiBUaGVzZSBwcm9taXNlcyBhcmUgb25seSByZXNvbHZlZFxuICAgICAgIHdoZW4gYWxsIG9yIG9uZSBvZiBhIHNldCBvZiBcInByZWNlZGluZ1wiIHByb21pc2VzIHJlc29sdmUuIFRoZSB1c2VyIGNhbm5vdFxuICAgICAgIHJlc29sdmUgdGhlc2UgcHJvbWlzZXMgZGlyZWN0bHkgKGJ1dCBzZWUgdGhlIHNlY3Rpb24gb24gY2FuY2VsbGF0aW9uXG4gICAgICAgYmVsb3cpLlxuXG5cbiAgIDIuIFJlc29sdmVyc1xuXG4gICBSZXNvbHZlcnMgYXJlIGdpdmVuIHRvIHRoZSB1c2VyIGJ5IFtMd3Qud2FpdF0gYW5kIFtMd3QudGFza10sIGFuZCBjYW4gYmUgdXNlZFxuICAgYnkgdGhlIHVzZXIgdG8gcmVzb2x2ZSB0aGUgY29ycmVzcG9uZGluZyBwcm9taXNlcy4gTm90ZSB0aGF0IHRoaXMgbWVhbnMgdGhlXG4gICB1c2VyIG9ubHkgZXZlciBnZXRzIHJlc29sdmVycyBmb3IgaW5pdGlhbCBwcm9taXNlcy5cblxuICAgSW50ZXJuYWxseSwgcmVzb2x2ZXJzIGFyZSB0aGUgZXhhY3Qgc2FtZSBvYmplY3RzIGFzIHRoZSBwcm9taXNlcyB0aGV5XG4gICByZXNvbHZlLCBldmVuIHRob3VnaCB0aGUgcmVzb2x2ZXIgaXMgZXhwb3NlZCBhcyBhIHJlZmVyZW5jZSBvZiBhIGRpZmZlcmVudFxuICAgdHlwZSBieSBbbHd0Lm1saV0uIEZvciBkZXRhaWxzIG9uIHdoeSwgc2VlIHNlY3Rpb24gXCJUeXBlIHN5c3RlbSBhYnVzZVwiIGJlbG93LlxuXG5cbiAgIDMuIENhbGxiYWNrc1xuXG4gICAuLi5hcmUgYXR0YWNoZWQgYnkgTHd0IHRvIHBlbmRpbmcgcHJvbWlzZXMsIGFuZCBhcmUgcnVuIGJ5IEx3dCBpZi93aGVuIHRob3NlXG4gICBwcm9taXNlcyBhcmUgcmVzb2x2ZWQuIFRoZXNlIGNhbGxiYWNrcyBhcmUgbm90IGRpcmVjdGx5IGV4cG9zZWQgdGhyb3VnaFxuICAgW2x3dC5tbGldIC0tIHRoZXkgYXJlIGEgbG93LWxldmVsIG1lY2hhbmlzbS4gRm9yIGV4YW1wbGUsIHRvIGltcGxlbWVudFxuICAgW0x3dC5iaW5kIHAgZl0sIEx3dCBhdHRhY2hlcyBhIGNhbGxiYWNrIHRvIFtwXSB0aGF0IGRvZXMgc29tZSBpbnRlcm5hbCBMd3RcbiAgIGJvb2sta2VlcGluZywgYW5kIHRoZW4gY2FsbHMgW2ZdIGlmIFtwXSBpcyBmdWxmaWxsZWQsIGFuZCBkb2VzIHNvbWV0aGluZyBlbHNlXG4gICBpZiBbcF0gaXMgcmVqZWN0ZWQuXG5cbiAgIENhbGxiYWNrcyBjb21lIGluIHR3byBmbGF2b3JzOiByZWd1bGFyIGNhbGxiYWNrcyBhbmQgY2FuY2VsIGNhbGxiYWNrcy4gVGhlXG4gICBvbmx5IG1hdGVyaWFsIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlbSBhcmUgdGhhdDpcblxuICAgLSByZWd1bGFyIGNhbGxiYWNrcyBhcmUgYWx3YXlzIGNhbGxlZCB3aGVuIGEgcHJvbWlzZSBpcyByZXNvbHZlZCwgYnV0IGNhbmNlbFxuICAgICBjYWxsYmFja3MgYXJlIGNhbGxlZCwgaW4gYWRkaXRpb24sIG9ubHkgaWYgdGhlIHByb21pc2UgaXMgY2FuY2VsZWQsIGFuZFxuICAgLSBhbGwgY2FuY2VsIGNhbGxiYWNrcyBvZiBhIHByb21pc2UgYXJlIGNhbGxlZCBiZWZvcmUgYW55IHJlZ3VsYXIgY2FsbGJhY2tcbiAgICAgaXMgY2FsbGVkLlxuXG4gICBDYW5jZWxsYXRpb24gaXMgYSBzcGVjaWFsIGNhc2Ugb2YgcmVzb2x1dGlvbiwgaW4gcGFydGljdWxhciwgYSBzcGVjaWFsIGNhc2VcbiAgIG9mIHJlamVjdGlvbiwgYnV0IHNlZSB0aGUgc2VjdGlvbiBvbiBjYW5jZWxsYXRpb24gbGF0ZXIgYmVsb3cuXG5cblxuICAgNC4gUmVzb2x1dGlvbiBsb29wXG5cbiAgIFJlc29sdmluZyBhIHBlbmRpbmcgcHJvbWlzZSB0cmlnZ2VycyBpdHMgY2FsbGJhY2tzLCBhbmQgdGhvc2UgbWlnaHQgcmVzb2x2ZVxuICAgbW9yZSBwZW5kaW5nIHByb21pc2VzLCB0cmlnZ2VyaW5nIG1vcmUgY2FsbGJhY2tzLCBldGMuIFRoaXMgYmVoYXZpb3IgaXMgdGhlXG4gICAqcmVzb2x1dGlvbiBsb29wKi4gTHd0IGhhcyBzb21lIG1hY2hpbmVyeSB0byBhdm9pZCBzdGFjayBvdmVyZmxvdyBhbmQgb3RoZXJcbiAgIHVuZm9ydHVuYXRlIHNpdHVhdGlvbnMgZHVyaW5nIHRoaXMgbG9vcC5cblxuICAgVGhpcyBjaGFpbmluZyBvZiBwcm9taXNlIHJlc29sdXRpb25zIHRocm91Z2ggY2FsbGJhY2tzIGNhbiBiZSBzZWVuIGFzIGEga2luZFxuICAgb2YgcHJvbWlzZSBkZXBlbmRlbmN5IGdyYXBoLCBpbiB3aGljaCB0aGUgbm9kZXMgYXJlIHBlbmRpbmcgcHJvbWlzZXMsIGFuZCB0aGVcbiAgIGVkZ2VzIGFyZSBjYWxsYmFja3MuIER1cmluZyB0aGUgcmVzb2x1dGlvbiBsb29wLCBMd3Qgc3RhcnRzIGF0IHNvbWUgaW5pdGlhbFxuICAgcHJvbWlzZSB0aGF0IGlzIGdldHRpbmcgcmVzb2x2ZWQgYnkgdGhlIHVzZXIsIGFuZCByZWN1cnNpdmVseSByZXNvbHZlcyBhbGxcbiAgIGRlcGVuZGVudCBwcm9taXNlcy4gVGhlIGdyYXBoIGlzIG1vZGlmaWVkOiByZXNvbHZlZCBwcm9taXNlcyBhcmUgbm8gbG9uZ2VyXG4gICBwZW5kaW5nLCBzbyB0aGV5IGFyZSBubyBsb25nZXIgcGFydCBvZiB0aGUgZ3JhcGguXG5cbiAgIFNvbWUgb2YgdGhlc2UgZGVwZW5kZW5jaWVzIGFyZSBleHBsaWNpdCB0byBMd3QsIGUuZy4gdGhlIGNhbGxiYWNrcyByZWdpc3RlcmVkXG4gICBieSBbTHd0LmJpbmRdLiBPdGhlcnMgYXJlIG5vdCB2aXNpYmxlIHRvIEx3dCwgYmVjYXVzZSB0aGUgdXNlciBjYW4gYWx3YXlzXG4gICByZWdpc3RlciBhIGNhbGxiYWNrIHVzaW5nIGEgZnVuY3Rpb24gbGlrZSBbTHd0Lm9uX3N1Y2Nlc3NdLCBhbmQgdXNlIHRoYXRcbiAgIGNhbGxiYWNrIHRvIHJlc29sdmUgYW5vdGhlciBpbml0aWFsIHByb21pc2UuIEFsbCB0aGUgZXhwbGljaXQgZGVwZW5kZW5jaWVzXG4gICBhcmUgY3JlYXRlZCBieSBMd3QncyBvd24gc2VxdWVudGlhbCBhbmQgY29uY3VycmVudCBjb21wb3NpdGlvbiBmdW5jdGlvbnNcbiAgIChzbywgW0x3dC5iaW5kXSwgW0x3dC5qb2luXSwgZXRjKS4gV2hldGhlciBkZXBlbmRlbmNpZXMgYXJlIGV4cGxpY2l0IG9yIG5vdFxuICAgaXMgcmVsZXZhbnQgb25seSB0byBjYW5jZWxsYXRpb24uXG5cblxuICAgNS4gQ2FuY2VsbGF0aW9uXG5cbiAgIEFzIGRlc2NyaWJlZCBhYm92ZSwgb3JkaW5hcnkgcHJvbWlzZSByZXNvbHV0aW9uIHByb2NlZWRzIGZyb20gYW4gaW5pdGlhbFxuICAgcHJvbWlzZSwgZm9yd2FyZCBhbG9uZyBjYWxsYmFja3MgdGhyb3VnaCB0aGUgZGVwZW5kZW5jeSBncmFwaC4gU2luY2UgaXRcbiAgIHN0YXJ0cyBmcm9tIGFuIGluaXRpYWwgcHJvbWlzZSwgaXQgY2FuIG9ubHkgYmUgdHJpZ2dlcmVkIHVzaW5nIGEgcmVzb2x2ZXIuXG5cbiAgIENhbmNlbGxhdGlvbiBpcyBhIHNvcnQgb2YgZHVhbCB0byBvcmRpbmFyeSByZXNvbHV0aW9uLiBJbnN0ZWFkIG9mIHN0YXJ0aW5nIGF0XG4gICBhbiBpbml0aWFsIHByb21pc2UvcmVzb2x2ZXIsIGNhbmNlbGxhdGlvbiBzdGFydHMgYXQgKmFueSogcHJvbWlzZS4gSXQgdGhlblxuICAgZ29lcyAqYmFja3dhcmRzKiB0aHJvdWdoIHRoZSBleHBsaWNpdCBkZXBlbmRlbmN5IGdyYXBoLCBsb29raW5nIGZvclxuICAgY2FuY2VsYWJsZSBpbml0aWFsIHByb21pc2VzIHRvIGNhbmNlbCAtLSB0aG9zZSB0aGF0IHdlcmUgY3JlYXRlZCBieVxuICAgW0x3dC50YXNrXS4gQWZ0ZXIgZmluZGluZyB0aGVtLCBjYW5jZWxsYXRpb24gcmVzb2x2ZXMgdGhlbSBub3JtYWxseSB3aXRoXG4gICBbUmVqZWN0ZWQgTHd0LkNhbmNlbGVkXSwgY2F1c2luZyBhbiBvcmRpbmFyeSBwcm9taXNlIHJlc29sdXRpb24gcHJvY2Vzcy5cblxuICAgVG8gc3VtbWFyaXplLCBjYW5jZWxsYXRpb24gaXMgYSB3YXkgdG8gdHJpZ2dlciBhbiAqb3JkaW5hcnkqIHJlc29sdXRpb24gb2ZcbiAgIHByb21pc2VzIGNyZWF0ZWQgd2l0aCBbTHd0LnRhc2tdLCBieSBmaXJzdCBzZWFyY2hpbmcgZm9yIHRoZW0gaW4gdGhlIHByb21pc2VcbiAgIGRlcGVuZGVuY3kgZ3JhcGggKHdoaWNoIGlzIGFzc2VtYmxlZCBieSBbTHd0LmJpbmRdLCBbTHd0LmpvaW5dLCBldGMpLlxuXG4gICBUaGlzIGJhY2t3YXJkcyBzZWFyY2ggaXMgdHJpZ2dlcmVkIG9ubHkgYnkgW0x3dC5jYW5jZWxdLiBJdCBpcyBhbHNvIHBvc3NpYmxlXG4gICBmb3IgdGhlIHVzZXIgdG8gY2FuY2VsIGEgcHJvbWlzZSBkaXJlY3RseSBieSByZWplY3RpbmcgaXQgd2l0aFxuICAgW0x3dC5DYW5jZWxlZF0sIGJ1dCBpbiBhbGwgY2FzZXMgd2hlcmUgdGhlIHVzZXIgY2FuIGRvIHNvLCB0aGUgc2VhcmNoIHdvdWxkXG4gICBiZSByZWR1bmRhbnQgYW55d2F5IC0tIHRoZSB1c2VyIGhhcyBvbmx5IHR3byB3YXlzIG9mIGRpcmVjdGx5IHJlamVjdGluZyBhXG4gICBwcm9taXNlIHdpdGggW0x3dC5DYW5jZWxlZF0gKG9yIGFueSBleGNlcHRpb24sIGZvciB0aGF0IG1hdHRlcik6XG5cbiAgIC0gVGhlIHVzZXIgY2FuIGNyZWF0ZSBhbiBpbml0aWFsIHByb21pc2UsIHRoZW4gcmVqZWN0IGl0IHRocm91Z2ggaXRzXG4gICAgIHJlc29sdmVyLiBUaGUgc2VhcmNoIGlzIHJlZHVuZGFudCBiZWNhdXNlIGl0IHdvdWxkIGZpbmQgb25seSB0aGUgc2FtZVxuICAgICBpbml0aWFsIHByb21pc2UgdG8gY2FuY2VsLlxuICAgLSBUaGUgdXNlciBjYW4gY3JlYXRlIGEgdHJpdmlhbCBwcm9taXNlIGJ5IGNhbGxpbmcgW0x3dC5mYWlsIEx3dC5DYW5jZWxlZF0uXG4gICAgIFRoZSBzZWFyY2ggaXMgYWdhaW4gcmVkdW5kYW50OyBpbiB0aGlzIGNhc2UgaXQgd291bGQgZmluZCBub3RoaW5nIHRvXG4gICAgIGNhbmNlbC5cblxuICAgTm90ZSB0aGF0IHRoZXJlIGlzIGEgcXVpcms6IG9ubHkgcHJvbWlzZXMgY3JlYXRlZCBieSBbTHd0LnRhc2tdIGFyZVxuICAgc3VzY2VwdGlibGUgdG8gYmVpbmcgY2FuY2VsZWQgYnkgW0x3dC5jYW5jZWxdLCBidXQgdGhlIHVzZXIgY2FuIG1hbnVhbGx5XG4gICBjYW5jZWwgaW5pdGlhbCBwcm9taXNlcyBjcmVhdGVkIGJ5IGJvdGggW0x3dC50YXNrXSBhbmQgW0x3dC53YWl0XS5cblxuICAgRHVlIHRvIFtMd3QuY2FuY2VsXSwgcHJvbWlzZSBjYW5jZWxsYXRpb24sIGFuZCB0aGVyZWZvcmUgcmVzb2x1dGlvbiwgY2FuIGJlXG4gICBpbml0aWF0ZWQgYnkgdGhlIHVzZXIgd2l0aG91dCBhY2Nlc3MgdG8gYSByZXNvbHZlci4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yXG4gICByZWFzb25pbmcgYWJvdXQgc3RhdGUgY2hhbmdlcyBpbiB0aGUgaW1wbGVtZW50YXRpb24gb2YgTHd0LCBhbmQgaXMgcmVmZXJlbmNlZFxuICAgaW4gc29tZSBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY29tbWVudHMuXG5cblxuICAgNi4gTm8gSS9PXG5cbiAgIFRoZSBMd3QgY29yZSBkZWxpYmVyYXRlbHkgZG9lc24ndCBkbyBJL08uIFRoZSByZXNvbHV0aW9uIGxvb3Agc3RvcHMgcnVubmluZ1xuICAgb25jZSBubyBwcm9taXNlcyBjYW4gYmUgcmVzb2x2ZWQgaW1tZWRpYXRlbHkuIEl0IGhhcyB0byBiZSByZXN0YXJ0ZWQgbGF0ZXJcbiAgIGJ5IHNvbWUgc3Vycm91bmRpbmcgSS9PIGxvb3AuIFRoaXMgSS9PIGxvb3AgdHlwaWNhbGx5IGtlZXBzIHRyYWNrIG9mIHBlbmRpbmdcbiAgIHByb21pc2VzIHRoYXQgcmVwcmVzZW50IGJsb2NrZWQgb3IgaW4tcHJvZ3Jlc3MgSS9POyBvdGhlciBwZW5kaW5nIHByb21pc2VzXG4gICB0aGF0IGluZGlyZWN0bHkgZGVwZW5kIG9uIEkvTyBhcmUgbm90IGV4cGxpY2l0bHkgdHJhY2tlZC4gVGhleSBhcmUgcmV0YWluZWRcbiAgIGluIG1lbW9yeSBieSByZWZlcmVuY2VzIGNhcHR1cmVkIGluc2lkZSBjYWxsYmFja3MuXG5cbiAgIE9uIFVuaXggYW5kIFdpbmRvd3MsIGEgc2VwYXJhdGUgdG9wLWxldmVsIGxvb3AsIHR5cGljYWxseSBbTHd0X21haW4ucnVuXSwgaXNcbiAgIG5lY2Vzc2FyeSB0byByZXBlYXRlZGx5IGNhbGwgW3NlbGVjdF0sIFtlcG9sbF0sIG9yIFtrZXZlbnRdLCBhbmQgcmVzb2x2ZVxuICAgYmxvY2tlZCBJL08gcHJvbWlzZXMuXG5cbiAgIEluIEphdmFTY3JpcHQsIHJlZmVyZW5jZXMgdG8gcHJvbWlzZXMgYXJlIHJldGFpbmVkIGJ5IEphdmFTY3JpcHQgY29kZSwgd2hpY2hcbiAgIGlzLCBpbiB0dXJuLCB0cmlnZ2VyZWQgYnkgdGhlIEpTIGVuZ2luZS4gSW4gb3RoZXIgd29yZHMsIHRoZSB0b3AtbGV2ZWwgbG9vcFxuICAgaXMgYnVyaWVkIGluc2lkZSB0aGUgSlMgZW5naW5lLlxuXG4gICBUaGlzIHNlcGFyYXRpb24gb2YgdGhlIEx3dCBjb3JlIGZyb20gdGhlIHRvcC1sZXZlbCBJL08gbG9vcCBrZWVwcyB0aGUgY29yZVxuICAgcG9ydGFibGUuXG5cblxuICAgNy4gUHJvbWlzZSBcInByb3h5aW5nXCJcblxuICAgSW4gW0x3dC5iaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdF0sIHRoZSBvdXRlciBbJ2IgdF0gaXMgY3JlYXRlZCBieVxuICAgW2JpbmRdIGZpcnN0LCBhbmQgcmV0dXJuZWQgdG8gdGhlIHVzZXIuIFRoZSBpbm5lciBbJ2IgdF0gaXMgY3JlYXRlZCBieSB0aGVcbiAgIHVzZXIgbGF0ZXIsIGFuZCB0aGVuIHJldHVybmVkIHRvIFtiaW5kXS4gQXQgdGhhdCBwb2ludCwgW2JpbmRdIG5lZWRzIHRvIG1ha2VcbiAgIHRoZSBpbm5lciBhbmQgb3V0ZXIgWydiIHRdcyBiZWhhdmUgaWRlbnRpY2FsbHkuXG5cbiAgIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IG1ha2luZyBvbmUgb2YgdGhlIHByb21pc2VzIHBvaW50IHRvIHRoZSBvdGhlci4gVGhlXG4gICBmaXJzdCBvZiB0aGUgcHJvbWlzZXMgdGh1cyBiZWNvbWVzIGEgXCJwcm94eSxcIiBhbmQgdGhlIG90aGVyIGlzIGl0c1xuICAgXCJ1bmRlcmx5aW5nXCIgcHJvbWlzZS5cblxuICAgQWZ0ZXIgdGhhdCwgYWxsIG9wZXJhdGlvbnMgdGhhdCB3b3VsZCBiZSBwZXJmb3JtZWQgYnkgTHd0IG9uIHRoZSBwcm94eSBhcmVcbiAgIGluc3RlYWQgcGVyZm9ybWVkIG9uIHRoZSB1bmRlcmx5aW5nIHByb21pc2UuIFRoaXMgaXMgZW5zdXJlZCBieSB0aGUgbnVtZXJvdXNcbiAgIGNhbGxzIHRvIHRoZSBpbnRlcm5hbCBmdW5jdGlvbiBbdW5kZXJseWluZ10gaW4gdGhpcyBmaWxlLlxuXG4gICBCZWNhdXNlIG9mIHRoZSBwZXJ2YXNpdmUgdXNlIG9mIFt1bmRlcmx5aW5nXSwgcHJveGllcyBjYW4gYmUgbW9yZSBvciBsZXNzXG4gICBpZ25vcmVkIG9uIGEgZmlyc3QgcmVhZGluZyB0aGUgY29kZS4gSG93ZXZlciwgYmVjb21pbmcgYSBwcm94eSBpcyBhIGtpbmQgb2ZcbiAgIHN0YXRlIGNoYW5nZSwgYW5kIGFueSBwcm9taXNlIHRoYXQgaXMgcmV0dXJuZWQgYnkgYSBjYWxsYmFjayB0byBbYmluZF0sIG9yIHRvXG4gICBhIHNpbWlsYXIgTHd0IGZ1bmN0aW9uLCBtaWdodCBiZWNvbWUgYSBwcm94eS4gVGhhdCBtZWFuczoganVzdCBhYm91dCBhbnlcbiAgIHByb21pc2UgdGhhdCBpcyBoYW5kZWQgdG8gdGhlIHVzZXIsIG1pZ2h0IGJlY29tZSBhIHByb3h5IHByb21pc2UgYnkgdGhlIG5leHRcbiAgIHRpbWUgTHd0IHNlZXMgaXQuIFRoaXMgaXMgaW1wb3J0YW50IGZvciByZWFzb25pbmcgYWJvdXQgcG9zc2libGUgc3RhdGVcbiAgIGNoYW5nZXMgaW4gaW1wbGVtZW50YXRpb24gb2YgTHd0LCBhbmQgaXMgcmVmZXJlbmNlZCBpbiBzb21lIGltcGxlbWVudGF0aW9uXG4gICBkZXRhaWwgY29tbWVudHMuXG5cblxuICAgOC4gU2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlXG5cbiAgIEx3dCBoYXMgYSBnbG9iYWwga2V5LXZhbHVlIG1hcC4gVGhlIG1hcCBjYW4gYmUgcHJlc2VydmVkIGFjcm9zcyBzZXF1ZW50aWFsXG4gICBjb21wb3NpdGlvbiBmdW5jdGlvbnMsIHNvIHRoYXQgaXQgaGFzIHRoZSBzYW1lIHN0YXRlIGluIHRoZSB1c2VyJ3MgY2FsbGJhY2tcbiAgIFtmXSBhcyBpdCBkaWQgYXQgdGhlIHRpbWUgdGhlIHVzZXIgY2FsbGVkIFtMd3QuYmluZCBwIGZdLlxuXG4gICBUaGUgZGV0YWlscyBhcmUgcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZCwgYW5kIGRpc2N1c3NlZCBpbiBtb2R1bGVcbiAgIFtTZXF1ZW5jZV9hc3NvY2lhdGVkX3N0b3JhZ2VdLiBUaGUgbWFpbiB0aGluZyB0byBiZSBhd2FyZSBvZiBpcyB0aGUgbWFueVxuICAgcmVmZXJlbmNlcyB0byBbY3VycmVudF9zdG9yYWdlXSB0aHJvdWdob3V0IEx3dCwgd2hpY2ggYXJlIG5lZWRlZCB0byBwcm9wZXJseVxuICAgc2F2ZSBhbmQgcmVzdG9yZSB0aGUgbWFwcGluZy5cblxuXG4gICA5LiBUeXBlIHN5c3RlbSBhYnVzZVxuXG4gICBUaGUgaW1wbGVtZW50YXRpb24gdXNlcyB0aGUgdHlwZSBzeXN0ZW0gc29tZXdoYXQgZXh0ZW5zaXZlbHkuIEdlbnRsZVxuICAgaW50cm9kdWN0aW9ucyBjYW4gYmUgZm91bmQgaGVyZTpcblxuICAgICBodHRwczovL2Rpc2N1c3Mub2NhbWwub3JnL3QvMTYxLzdcbiAgICAgaHR0cHM6Ly9kaXNjdXNzLm9jYW1sLm9yZy90LzE2MS8xNlxuXG4gICBBIHNob3J0IHN1bW1hcnkgZm9sbG93cy5cblxuICAgVGhlIHByb21pc2Ugc3RhdGUgaXMsIGludGVybmFsbHksIGEgR0FEVCB3aGljaCBlbmNvZGVzIHRoZSBzdGF0ZSBpbiBpdHMgdHlwZVxuICAgcGFyYW1ldGVycy4gVGh1cywgaWYgeW91IGRvIFtsZXQgcCA9IHVuZGVybHlpbmcgcF0sIHRoZSBzaGFkb3dpbmcgcmVmZXJlbmNlXG4gICBbcF0gaXMgc3RhdGljYWxseSBrbm93biAqbm90KiB0byBiZSBhIHByb3h5LCBhbmQgdGhlIGNvbXBpbGVyIGtub3dzIHRoYXQgdGhlXG4gICBjb3JyZXNwb25kaW5nIG1hdGNoIGNhc2UgW1Byb3h5IF9dIGlzIGltcG9zc2libGUuXG5cbiAgIFRoZSBleHRlcm5hbCBwcm9taXNlIHR5cGUsIFsnYSB0XSwgYW5kIHRoZSBleHRlcm5hbCByZXNvbHZlciB0eXBlLCBbJ2EgdV0sXG4gICBhcmUgbm90IEdBRFRzLiBGdXJ0aGVybW9yZSwgdGhleSBhcmUsIHJlc3BlY3RpdmVseSwgY292YXJpYW50IGFuZFxuICAgY29udHJhdmFyaWFudCBpbiBbJ2FdLCB3aGlsZSB0aGUgaW50ZXJuYWwgcHJvbWlzZSB0eXBlIGlzIGludmFyaWFudCBpbiBbJ2FdLlxuICAgRm9yIHRoZXNlIHJlYXNvbnMsIHRoZXJlIGFyZSBuYXN0eSBjYXN0cyBiZXR3ZWVuIFsnYSB0XSwgWydhIHVdLCBhbmQgdGhlXG4gICBpbnRlcm5hbCBwcm9taXNlIHR5cGUuIFRoZSBpbXBsZW1lbnRhdGlvbiBpcywgb2YgY291cnNlLCB3cml0dGVuIGluIHRlcm1zIG9mXG4gICB0aGUgaW50ZXJuYWwgdHlwZS5cblxuICAgQ2FzdGluZyBmcm9tIGFuIFsnYSB0XSB0byBhbiBpbnRlcm5hbCBwcm9taXNlIHByb2R1Y2VzIGEgcmVmZXJlbmNlIGZvclxuICAgd2hpY2ggdGhlIHN0YXRlIGlzIFwidW5rbm93blwiOiB0aGlzIGlzIHNpbXVsYXRlZCB3aXRoIGEgaGVscGVyIEdBRFQsIHdoaWNoXG4gICBlbmNvZGVzIGV4aXN0ZW50aWFsIHR5cGVzLiBUaGVyZSBhcmUgc2V2ZXJhbCBzaW1pbGFyIGNhc3RzLCB3aGljaCBhcmUgdXNlZFxuICAgdG8gZG9jdW1lbnQgcG9zc2libGUgc3RhdGUgY2hhbmdlcyBiZXR3ZWVuIHRoZSB0aW1lIGEgcHJvbWlzZSBpcyBjcmVhdGVkLFxuICAgYW5kIHRoZSBsYXRlciB0aW1lIGl0IGlzIHVzZWQgaW4gYSBjYWxsYmFjay4gWW91IGNhbiBzZWUgdGhlc2UgY2FzdHMgaW5cbiAgIGFjdGlvbiBpbiBbTHd0LmJpbmRdLiBUaGUgY2FzdCBzeW50YXggaXMgcHJldHR5IGxpZ2h0LCBhbmQsIGJlc2lkZXMgYmVpbmdcbiAgIGNvbW1lbnRlZCBpbiBbYmluZF0sIGFsbCBzdWNoIGNhc3RzIGFyZSBkb2N1bWVudGVkIGluIG1vZHVsZXMgW1B1YmxpY190eXBlc11cbiAgIGFuZCBbQmFzaWNfaGVscGVyc10uXG5cblxuICAgSWYgeW91J3ZlIG1hZGUgaXQgdGhpcyBmYXIsIHlvdSBhcmUgYW4gTHd0IGV4cGVydCEgUmVqb2ljZSEgKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbigqIFNvbWUgc2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlIHR5cGVzXG5cbiAgIFNlcXVlbmNlLWFzc29jaWF0ZWQgc3RvcmFnZSBpcyBkZWZpbmVkIGFuZCBkb2N1bWVudGVkIGxhdGVyLCBpbiBtb2R1bGVcbiAgIFtTZXF1ZW5jZV9hc3NvY2lhdGVkX3N0b3JhZ2VdLiBIb3dldmVyLCB0aGUgZm9sbG93aW5nIHR5cGVzIGFyZSBtZW50aW9uZWQgaW5cbiAgIHRoZSBkZWZpbml0aW9uIG9mIFtwcm9taXNlXSwgc28gdGhleSBtdXN0IGJlIGRlZmluZWQgaGVyZSBmaXJzdC4gKilcbm1vZHVsZSBTdG9yYWdlX21hcCA9XG4gIE1hcC5NYWtlXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gaW50XG4gICAgICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbiAgICBlbmQpXG50eXBlIHN0b3JhZ2UgPSAodW5pdCAtPiB1bml0KSBTdG9yYWdlX21hcC50XG5cblxuXG5tb2R1bGUgTWFpbl9pbnRlcm5hbF90eXBlcyA9XG5zdHJ1Y3RcbiAgKCogUGhhbnRvbSB0eXBlcyBmb3IgdXNlIHdpdGggdHlwZXMgW3Byb21pc2VdIGFuZCBbc3RhdGVdLiBUaGVzZSBhcmUgbmV2ZXJcbiAgICAgY29uc3RydWN0ZWQ7IHRoZSBwdXJwb3NlIG9mIHRoZSBjb25zdHJ1Y3RvcnMgaXMgdG8gcHJvdmUgdG8gdGhlIHR5cGVcbiAgICAgY2hlY2tlciB0aGF0IHRoZXNlIHR5cGVzIGFyZSBkaXN0aW5jdCBmcm9tIGVhY2ggb3RoZXIuIFdhcm5pbmcgMzcsIFwidW51c2VkXG4gICAgIGNvbnN0cnVjdG9yLFwiIHRoZXJlZm9yZSBoYXMgdG8gYmUgdGVtcG9yYXJpbHkgc3VwcHJlc3NlZC4gKilcblxuICBbQEBAb2NhbWwud2FybmluZyBcIi0zN1wiXVxuXG4gIHR5cGUgdW5kZXJseWluZyA9IHByaXZhdGUgVW5kZXJseWluZ19hbmRfdGhpc19jb25zdHJ1Y3Rvcl9pc19ub3RfdXNlZFxuICB0eXBlIHByb3h5ID0gcHJpdmF0ZSBQcm94eV9hbmRfdGhpc19jb25zdHJ1Y3Rvcl9pc19ub3RfdXNlZFxuXG4gIHR5cGUgcmVzb2x2ZWQgPSBwcml2YXRlIFJlc29sdmVkX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG4gIHR5cGUgcGVuZGluZyA9IHByaXZhdGUgUGVuZGluZ19hbmRfdGhpc19jb25zdHJ1Y3Rvcl9pc19ub3RfdXNlZFxuXG4gIFtAQEBvY2FtbC53YXJuaW5nIFwiKzM3XCJdXG5cblxuXG4gICgqIFByb21pc2VzIHByb3Blci4gKilcblxuICB0eXBlICgnYSwgJ3UsICdjKSBwcm9taXNlID0ge1xuICAgIG11dGFibGUgc3RhdGUgOiAoJ2EsICd1LCAnYykgc3RhdGU7XG4gIH1cblxuICBhbmQgKF8sIF8sIF8pIHN0YXRlID1cbiAgICB8IEZ1bGZpbGxlZCA6ICdhICAgICAgICAgICAgICAgICAgLT4gKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVcbiAgICB8IFJlamVjdGVkICA6IGV4biAgICAgICAgICAgICAgICAgLT4gKCBfLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVcbiAgICB8IFBlbmRpbmcgICA6ICdhIGNhbGxiYWNrcyAgICAgICAgLT4gKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSAgc3RhdGVcbiAgICB8IFByb3h5ICAgICA6ICgnYSwgXywgJ2MpIHByb21pc2UgLT4gKCdhLCBwcm94eSwgICAgICAnYykgICAgICAgc3RhdGVcblxuICAoKiBOb3RlOlxuXG4gICAgIEEgcHJvbWlzZSB3aG9zZSBzdGF0ZSBpcyBbUHJveHkgX10gaXMgYSBcInByb3h5XCIgcHJvbWlzZS4gQSBwcm9taXNlIHdob3NlXG4gICAgIHN0YXRlIGlzICpub3QqIFtQcm94eSBfXSBpcyBhbiBcInVuZGVybHlpbmdcIiBwcm9taXNlLlxuXG4gICAgIFRoZSBcInVuZGVybHlpbmcgcHJvbWlzZSBvZiBbcF1cIiBpczpcblxuICAgICAtIFtwXSwgaWYgW3BdIGlzIGl0c2VsZiB1bmRlcmx5aW5nLlxuICAgICAtIE90aGVyd2lzZSwgW3BdIGlzIGEgcHJveHkgYW5kIGhhcyBzdGF0ZSBbUHJveHkgcCddLiBUaGUgdW5kZXJseWluZ1xuICAgICAgIHByb21pc2Ugb2YgW3BdIGlzIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgW3AnXS5cblxuICAgICBJbiBvdGhlciB3b3JkcywgdG8gZmluZCB0aGUgdW5kZXJseWluZyBwcm9taXNlIG9mIGEgcHJveHksIEx3dCBmb2xsb3dzIHRoZVxuICAgICBbUHJveHkgX10gbGlua3MgdG8gdGhlIGVuZC4gKilcblxuICAoKiBOb3RlOlxuXG4gICAgIFdoZW4gYSBwcm9taXNlIGlzIHJlc29sdmVkLCBvciBiZWNvbWVzIGEgcHJveHksIGl0cyBzdGF0ZSBmaWVsZCBpc1xuICAgICBtdXRhdGVkLiBUaGlzIGludmFsaWRhdGVzIHRoZSB0eXBlIGludmFyaWFudHMgb24gdGhlIHByb21pc2UuIFNlZSBpbnRlcm5hbFxuICAgICBmdW5jdGlvbiBbc2V0X3Byb21pc2Vfc3RhdGVdIGZvciBkZXRhaWxzIGFib3V0IHRoYXQuXG5cbiAgICAgV2hlbiBhbiBMd3QgZnVuY3Rpb24gaGFzIGEgcmVmZXJlbmNlIHRvIGEgcHJvbWlzZSwgYW5kIGFsc28gcmVnaXN0ZXJzIGFcbiAgICAgY2FsbGJhY2sgdGhhdCBoYXMgYSByZWZlcmVuY2UgdG8gdGhlIHNhbWUgcHJvbWlzZSwgdGhlIGludmFyaWFudHMgb24gdGhlXG4gICAgIHJlZmVyZW5jZSBtYXkgYmVjb21lIGludmFsaWQgYnkgdGhlIHRpbWUgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZC4gQWxsIHN1Y2hcbiAgICAgY2FsbGJhY2tzIGhhdmUgY29tbWVudHMgZXhwbGFpbmluZyB3aGF0IHRoZSB2YWxpZCBpbnZhcmlhbnRzIGFyZSBhdCB0aGF0XG4gICAgIHBvaW50LCBhbmQvb3IgY2FzdHMgdG8gKDEpIGdldCB0aGUgY29ycmVjdCB0eXBpbmcgYW5kICgyKSBkb2N1bWVudCB0aGVcbiAgICAgcG90ZW50aWFsIHN0YXRlIGNoYW5nZSBmb3IgcmVhZGVycyBvZiB0aGUgY29kZS4gKilcblxuXG5cbiAgKCogQ2FsbGJhY2sgaW5mb3JtYXRpb24gZm9yIHBlbmRpbmcgcHJvbWlzZXMuICopXG5cbiAgYW5kICdhIGNhbGxiYWNrcyA9IHtcbiAgICBtdXRhYmxlIHJlZ3VsYXJfY2FsbGJhY2tzIDogJ2EgcmVndWxhcl9jYWxsYmFja19saXN0O1xuICAgIG11dGFibGUgY2FuY2VsX2NhbGxiYWNrcyAgOiAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdDtcbiAgICBtdXRhYmxlIGhvd190b19jYW5jZWwgICAgIDogaG93X3RvX2NhbmNlbDtcbiAgICBtdXRhYmxlIGNsZWFudXBzX2RlZmVycmVkIDogaW50O1xuICB9XG5cbiAgYW5kICdhIHJlZ3VsYXJfY2FsbGJhY2sgPSAnYSByZXNvbHZlZF9zdGF0ZSAtPiB1bml0XG5cbiAgYW5kIGNhbmNlbF9jYWxsYmFjayA9IHVuaXQgLT4gdW5pdFxuXG4gIGFuZCAnYSByZXNvbHZlZF9zdGF0ZSA9ICgnYSwgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlXG5cbiAgYW5kIGhvd190b19jYW5jZWwgPVxuICAgIHwgTm90X2NhbmNlbGFibGUgICAgICAgICAgICAgIDogICAgICAgICAgICAgICAgICAgICAgICAgICBob3dfdG9fY2FuY2VsXG4gICAgfCBDYW5jZWxfdGhpc19wcm9taXNlICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvd190b19jYW5jZWxcbiAgICB8IFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lICAgICA6IChfLCBfLCBfKSBwcm9taXNlICAgICAgLT4gaG93X3RvX2NhbmNlbFxuICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIDogKF8sIF8sIF8pIHByb21pc2UgbGlzdCAtPiBob3dfdG9fY2FuY2VsXG5cbiAgYW5kICdhIHJlZ3VsYXJfY2FsbGJhY2tfbGlzdCA9XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHlcbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgb2ZcbiAgICAgICdhIHJlZ3VsYXJfY2FsbGJhY2tfbGlzdCAqICdhIHJlZ3VsYXJfY2FsbGJhY2tfbGlzdFxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBvZlxuICAgICAgJ2EgcmVndWxhcl9jYWxsYmFja1xuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIG9mXG4gICAgICAnYSByZWd1bGFyX2NhbGxiYWNrIG9wdGlvbiByZWZcblxuICBhbmQgXyBjYW5jZWxfY2FsbGJhY2tfbGlzdCA9XG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSA6XG4gICAgICBfIGNhbmNlbF9jYWxsYmFja19saXN0XG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgOlxuICAgICAgJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3QgKiAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdCAtPlxuICAgICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdFxuICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgOlxuICAgICAgc3RvcmFnZSAqIGNhbmNlbF9jYWxsYmFjayAtPlxuICAgICAgICBfIGNhbmNlbF9jYWxsYmFja19saXN0XG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSA6XG4gICAgICAoJ2EsIF8sIF8pIHByb21pc2UgTHd0X3NlcXVlbmNlLm5vZGUgLT5cbiAgICAgICAgJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3RcblxuICAoKiBOb3RlczpcblxuICAgICBUaGVzZSB0eXBlIGRlZmluaXRpb25zIGFyZSBndWlsdHkgb2YgcGVyZm9ybWluZyBzZXZlcmFsIG9wdGltaXphdGlvbnMsXG4gICAgIHdpdGhvdXQgd2hpY2ggdGhleSB3b3VsZCBiZSBtdWNoIGVhc2llciB0byB1bmRlcnN0YW5kLlxuXG4gICAgIC0gVGhlIHR5cGUgcGFyYW1ldGVycyBvZiBbJ2EgcmVzb2x2ZWRfc3RhdGVdIGd1YXJhbnRlZSB0aGF0IGl0IGlzIGVpdGhlclxuICAgICAgIFtGdWxmaWxsZWQgX10gb3IgW1JlamVjdGVkIF9dLiBTbywgaXQgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgIFsoJ2EsIGV4bikgU3RkbGliLnJlc3VsdF0sIGFuZCwgaW5kZWVkLCBzaG91bGQgaGF2ZSBhbiBpZGVudGljYWxcbiAgICAgICBtZW1vcnkgcmVwcmVzZW50YXRpb24uXG5cbiAgICAgLSBBcyBwZXIgdGhlIE92ZXJ2aWV3LCB0aGVyZSBhcmUgcmVndWxhciBjYWxsYmFja3MgYW5kIGNhbmNlbCBjYWxsYmFja3MuXG4gICAgICAgQ2FuY2VsIGNhbGxiYWNrcyBhcmUgY2FsbGVkIG9ubHkgb24gY2FuY2VsbGF0aW9uLCBhbmQsIHRoZW4sIGJlZm9yZSBhbnlcbiAgICAgICByZWd1bGFyIGNhbGxiYWNrcyBhcmUgY2FsbGVkLlxuXG4gICAgICAgRGVzcGl0ZSB0aGUgZGlmZmVyZW50IHR5cGVzIGZvciB0aGUgdHdvIGtpbmRzIG9mIGNhbGxiYWNrcywgdGhleSBhcmVcbiAgICAgICBvdGhlcndpc2UgdGhlIHNhbWUuIENhbmNlbCBjYWxsYmFja3MganVzdCBkb24ndCBuZWVkIGEgcmVzdWx0IHN0YXRlXG4gICAgICAgYXJndW1lbnQsIGJlY2F1c2UgaXQgaXMga25vd24gdG8gYmUgW1JlamVjdGVkIENhbmNlbGVkXS5cblxuICAgICAtIFJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBub3QgYWxsb3dlZCB0byByYWlzZSBleGNlcHRpb25zLiBBbGwgcmVndWxhclxuICAgICAgIGNhbGxiYWNrcyBhcmUgY3JlYXRlZCBpbiB0aGlzIGZpbGUsIHNvIHRoaXMgY2FuIGJlIGNoZWNrZWQuXG5cbiAgICAgICBDYW5jZWwgY2FsbGJhY2tzIGNhbiByYWlzZSBleGNlcHRpb25zLCBidXQgaWYgdGhleSBkbyBzbywgdGhlIGV4Y2VwdGlvbnNcbiAgICAgICBhcmUgcGFzc2VkIHRvIFthc3luY19leGNlcHRpb25faG9va10uXG5cbiAgICAgLSBbaG93X3RvX2NhbmNlbF0gaW1wbGVtZW50cyB0aGUgZGVwZW5kZW5jeSBncmFwaCBtZW50aW9uZWQgaW4gdGhlXG4gICAgICAgT3ZlcnZpZXcuIEl0IGlzIHRyYXZlcnNlZCBiYWNrd2FyZHMgZHVyaW5nIFtMd3QuY2FuY2VsXS4gSXQgaXMgYSBHQURUXG4gICAgICAgYmVjYXVzZSB3ZSBkb24ndCBjYXJlIGFib3V0IHRoZSBhY3R1YWwgdHlwZXMgb2YgdGhlIHByb21pc2UgcmVmZXJlbmNlc1xuICAgICAgIHN0b3JlZCwgb3IgdGhlaXIgaW52YXJpYW50cy4gVGhlIGNvbnN0cnVjdG9ycyBjb3JyZXNwb25kIHRvIHBlbmRpbmdcbiAgICAgICBwcm9taXNlIGtpbmRzIGFzIGZvbGxvd3M6XG4gICAgICAgICAtIFtOb3RfY2FuY2VsYWJsZV06IGluaXRpYWwsIFtMd3Qud2FpdF0uXG4gICAgICAgICAtIFtDYW5jZWxfdGhpc19wcm9taXNlXTogaW5pdGlhbCwgW0x3dC50YXNrXS5cbiAgICAgICAgIC0gW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fb25lXTogc2VxdWVudGlhbCBjb21wb3NpdGlvbiwgZS5nLiBbTHd0LmJpbmRdLlxuICAgICAgICAgLSBbUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsXTogY29uY3VycmVudCBjb21wb3NpdGlvbiwgZS5nLlxuICAgICAgICAgICBbTHd0LmpvaW5dLlxuXG4gICAgIC0gVGhlIHR3byBjYWxsYmFjayBsaXN0IHR5cGVzIGFyZSBvcmRpbmFyeSBhcHBlbmQtZnJpZW5kbHkgbGlzdHMsIHdpdGggdHdvXG4gICAgICAgb3B0aW1pemF0aW9ucyBpbmxpbmVkOlxuXG4gICAgICAgLSBbJ2EgcmVndWxhcl9jYWxsYmFja19saXN0XSBhcHBhcmVudGx5IGhhcyB0d28gXCJraW5kc1wiIG9mIHJlZ3VsYXJcbiAgICAgICAgIGNhbGxiYWNrcywgaW1wbGljaXRseSByZW1vdmVkIGFuZCBleHBsaWNpdGx5IHJlbW92YWJsZS4gQWxsIGNhbGxiYWNrc1xuICAgICAgICAgYXJlIHJlbW92YWJsZS4gSXQncyBqdXN0IHRoYXQsIGZvciBzb21lIGNhbGxiYWNrcywgdGhleSB3aWxsIG9ubHkgYmVcbiAgICAgICAgIHJlbW92ZWQgYXQgdGhlIHNhbWUgdGltZSB0aGF0IHRoZSBwcm9taXNlIHRoZXkgYXJlIGF0dGFjaGVkIHRvIGJlY29tZXNcbiAgICAgICAgIHJlc29sdmVkLiBXaGVuIHRoYXQgaGFwcGVucywgdGhlIGVudGlyZSBzdGF0ZSBvZiB0aGF0IHByb21pc2UgY2hhbmdlc1xuICAgICAgICAgdG8gW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10sIGFuZCB0aGUgcmVmZXJlbmNlIHRvIHRoZSB3aG9sZVxuICAgICAgICAgY2FsbGJhY2sgbGlzdCBpcyBzaW1wbHkgbG9zdC4gVGhpcyBcInJlbW92ZXNcIiB0aGUgY2FsbGJhY2suIEZvciB0aGVzZVxuICAgICAgICAgY2FsbGJhY2tzLCBbJ2EgcmVndWxhcl9jYWxsYmFja19saXN0XSBhdHRlbXB0cyB0byB0cmltIGFuIG9wdGlvbiBhbmQgYVxuICAgICAgICAgcmVmZXJlbmNlIGNlbGwgd2l0aCB0aGVcbiAgICAgICAgIFtSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrXSBjb25zdHJ1Y3Rvci5cblxuICAgICAgIC0gWydhIGNhbmNlbF9jYWxsYmFja19saXN0XSBoYXNcbiAgICAgICAgIFtDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBub2RlXSwgd2hpY2ggaXMgdGhlIHNhbWUgYXNcbiAgICAgICAgIFtDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayAoXywgKGZ1biBfIC0+XG4gICAgICAgICAgIEx3dF9zZXF1ZW5jZS5yZW1vdmUgbm9kZSkpXS5cbiAgICAgICAgIFRoaXMgd2FzIHByb2JhYmx5IGRvbmUgdG8gYXZvaWQgYSBjbG9zdXJlIGFsbG9jYXRpb24uXG5cbiAgICAgLSBUaGUgW2NsZWFudXBzX2RlZmVycmVkXSBmaWVsZCBpcyBleHBsYWluZWQgaW4gbW9kdWxlXG4gICAgICAgW1BlbmRpbmdfY2FsbGJhY2tzXS4gKilcbmVuZFxub3BlbiBNYWluX2ludGVybmFsX3R5cGVzXG5cblxuXG5tb2R1bGUgUHVibGljX3R5cGVzID1cbnN0cnVjdFxuICB0eXBlICsnYSB0XG4gIHR5cGUgLSdhIHVcblxuICBsZXQgdG9fcHVibGljX3Byb21pc2UgOiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gJ2EgdCA9IE9iai5tYWdpY1xuICBsZXQgdG9fcHVibGljX3Jlc29sdmVyIDogKCdhLCBfLCBfKSBwcm9taXNlIC0+ICdhIHUgPSBPYmoubWFnaWNcblxuICB0eXBlIF8gcGFja2VkX3Byb21pc2UgPVxuICAgIHwgSW50ZXJuYWwgOiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gJ2EgcGFja2VkX3Byb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCB0b19pbnRlcm5hbF9wcm9taXNlIChwIDogJ2EgdCkgOiAnYSBwYWNrZWRfcHJvbWlzZSA9XG4gICAgSW50ZXJuYWwgKE9iai5tYWdpYyBwKVxuICBsZXQgdG9faW50ZXJuYWxfcmVzb2x2ZXIgKHIgOiAnYSB1KSA6ICdhIHBhY2tlZF9wcm9taXNlID1cbiAgICBJbnRlcm5hbCAoT2JqLm1hZ2ljIHIpXG5cbiAgKCogTW9zdCBmdW5jdGlvbnMgdGhhdCB0YWtlIGEgcHVibGljIHByb21pc2UgKFsnYSB0XSkgY29udmVydCBpdCB0byBhblxuICAgICBpbnRlcm5hbCBwcm9taXNlIGFzIGZvbGxvd3M6XG5cbiAgICAgICAoKiBwIDogJ2EgdCAqKVxuXG4gICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgICAgICgqIHAgOiAoJ2EsIHUsIGMpIHByb21pc2UsIHdoZXJlIHUgYW5kIGMgYXJlIGZyZXNoIHR5cGVzLCBpLmUuIHRoZVxuICAgICAgICAgIGludmFyaWFudHMgb24gcCBhcmUgdW5rbm93bi4gKilcblxuICAgICBUaGlzIGNhc3QgaXMgYSBuby1vcCBjYXN0LiBJdCBvbmx5IHByb2R1Y2VzIGEgcmVmZXJlbmNlIHdpdGggYSBkaWZmZXJlbnRcbiAgICAgdHlwZS4gVGhlIGludHJvZHVjdGlvbiBhbmQgaW1tZWRpYXRlIGVsaW1pbmF0aW9uIG9mIFtJbnRlcm5hbCBfXSBzZWVtcyB0b1xuICAgICBiZSBvcHRpbWl6ZWQgYXdheSBldmVuIG9uIG9sZGVyIHZlcnNpb25zIG9mIE9DYW1sIHRoYXQgZG9uJ3QgaGF2ZSBGbGFtYmRhXG4gICAgIGFuZCBkb24ndCBzdXBwb3J0IFtbQEBvY2FtbC51bmJveGVkXV0uICopXG5cbiAgKCogVGhpcyBjb3VsZCBwcm9iYWJseSBzYXZlIGFuIGFsbG9jYXRpb24gYnkgdXNpbmcgW09iai5tYWdpY10uICopXG4gIGxldCBzdGF0ZV9vZl9yZXN1bHQgPSBmdW5jdGlvblxuICAgIHwgT2sgeCAtPiBGdWxmaWxsZWQgeFxuICAgIHwgRXJyb3IgZXhuIC0+IFJlamVjdGVkIGV4blxuZW5kXG5pbmNsdWRlIFB1YmxpY190eXBlc1xuXG5cblxubW9kdWxlIEJhc2ljX2hlbHBlcnMgOlxuc2lnXG4gIHZhbCBpZGVudGljYWwgOiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gKCdhLCBfLCBfKSBwcm9taXNlIC0+IGJvb2xcbiAgdmFsIHVuZGVybHlpbmcgOiAoJ2EsICd1LCAnYykgcHJvbWlzZSAtPiAoJ2EsIHVuZGVybHlpbmcsICdjKSBwcm9taXNlXG5cbiAgdHlwZSAoJ2EsICd1LCAnYykgc3RhdGVfY2hhbmdlZCA9XG4gICAgfCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIG9mICgnYSwgJ3UsICdjKSBwcm9taXNlXG4gICAgW0BAb2NhbWwudW5ib3hlZF1cbiAgdmFsIHNldF9wcm9taXNlX3N0YXRlIDpcbiAgICAoJ2EsIF8sIF8pIHByb21pc2UgLT4gKCdhLCAndSwgJ2MpIHN0YXRlIC0+ICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkXG5cbiAgdHlwZSAnYSBtYXlfbm93X2JlX3Byb3h5ID1cbiAgICB8IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSA6XG4gICAgICAoJ2EsIF8sIHBlbmRpbmcpIHByb21pc2UgLT4gJ2EgbWF5X25vd19iZV9wcm94eVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG4gIHZhbCBtYXlfbm93X2JlX3Byb3h5IDpcbiAgICAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2UgLT4gJ2EgbWF5X25vd19iZV9wcm94eVxuZW5kID1cbnN0cnVjdFxuICAoKiBDaGVja3MgcGh5c2ljYWwgZXF1YWxpdHkgKFs9PV0pIG9mIHR3byBpbnRlcm5hbCBwcm9taXNlcy4gVW5saWtlIFs9PV0sIGRvZXNcbiAgICAgbm90IGZvcmNlIHVuaWZpY2F0aW9uIG9mIHRoZWlyIGludmFyaWFudHMuICopXG4gIGxldCBpZGVudGljYWwgcDEgcDIgPVxuICAgICh0b19wdWJsaWNfcHJvbWlzZSBwMSkgPT0gKHRvX3B1YmxpY19wcm9taXNlIHAyKVxuXG4gICgqIFt1bmRlcmx5aW5nIHBdIGV2YWx1YXRlcyB0byB0aGUgdW5kZXJseWluZyBwcm9taXNlIG9mIFtwXS5cblxuICAgICBJZiBtdWx0aXBsZSBbUHJveHkgX10gbGlua3MgYXJlIHRyYXZlcnNlZCwgW3VuZGVybHlpbmddIHVwZGF0ZXMgYWxsIHRoZVxuICAgICBwcm94aWVzIHRvIHBvaW50IGltbWVkaWF0ZWx5IHRvIHRoZWlyIGZpbmFsIHVuZGVybHlpbmcgcHJvbWlzZS4gKilcbiAgbGV0IHJlYyB1bmRlcmx5aW5nXG4gICAgICA6IHR5cGUgdSBjLiAoJ2EsIHUsIGMpIHByb21pc2UgLT4gKCdhLCB1bmRlcmx5aW5nLCBjKSBwcm9taXNlID1cbiAgICBmdW4gcCAtPlxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiAocCA6IChfLCB1bmRlcmx5aW5nLCBfKSBwcm9taXNlKVxuICAgIHwgUmVqZWN0ZWQgXyAtPiBwXG4gICAgfCBQZW5kaW5nIF8gLT4gcFxuICAgIHwgUHJveHkgcCcgLT5cbiAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICBpZiBub3QgKGlkZW50aWNhbCBwJycgcCcpIHRoZW5cbiAgICAgICAgcC5zdGF0ZSA8LSBQcm94eSBwJyc7XG4gICAgICBwJydcblxuXG5cbiAgdHlwZSAoJ2EsICd1LCAnYykgc3RhdGVfY2hhbmdlZCA9XG4gICAgfCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIG9mICgnYSwgJ3UsICdjKSBwcm9taXNlXG4gICAgW0BAb2NhbWwudW5ib3hlZF1cblxuICBsZXQgc2V0X3Byb21pc2Vfc3RhdGUgcCBzdGF0ZSA9XG4gICAgbGV0IHAgOiAoXywgXywgXykgcHJvbWlzZSA9IE9iai5tYWdpYyBwIGluXG4gICAgcC5zdGF0ZSA8LSBzdGF0ZTtcbiAgICBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHBcblxuICAoKiBbc2V0X3Byb21pc2Vfc3RhdGUgcCBzdGF0ZV0gbXV0YXRlcyB0aGUgc3RhdGUgb2YgW3BdLCBhbmQgZXZhbHVhdGVzIHRvIGFcbiAgICAgKHdyYXBwZWQpIHJlZmVyZW5jZSB0byBbcF0gd2l0aCB0aGUgc2FtZSBpbnZhcmlhbnRzIGFzIG9uIFtzdGF0ZV0uIFRoZVxuICAgICBvcmlnaW5hbCByZWZlcmVuY2UgW3BdIHNob3VsZCBiZSBzaGFkb3dlZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbjpcblxuICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPSBzZXRfcHJvbWlzZV9zdGF0ZSBwIChGdWxmaWxsZWQgNDIpIGluIC4uLlxuXG4gICAgIFRoaXMgaXMgYSBraW5kIG9mIGNoZWFwIGltaXRhdGlvbiBvZiBsaW5lYXIgdHlwaW5nLCB3aGljaCBpcyBnb29kIGVub3VnaFxuICAgICBmb3IgdGhlIG5lZWRzIG9mIFtsd3QubWxdLlxuXG4gICAgIEludGVybmFsIGZ1bmN0aW9ucyB0aGF0IHRyYW5zaXRpdmVseSBjYWxsIFtzZXRfcHJvbWlzZV9zdGF0ZV0gbGlrZXdpc2VcbiAgICAgcmV0dXJuIHRoZSBuZXcgcmVmZXJlbmNlLiBUaGlzIGVuZHMgYXQgc29tZSB0b3AtbGV2ZWwgZnVuY3Rpb24sIHR5cGljYWxseVxuICAgICBlaXRoZXIgYSBjYWxsYmFjayBvciBhIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLiBUaGVyZSwgdGhlIG5ldyByZWZlcmVuY2VcbiAgICAgaXMgc3RpbGwgYm91bmQsIGJ1dCBpcyB0aGVuIGV4cGxpY2l0bHkgaWdub3JlZC5cblxuICAgICBUaGUgc3RhdGUgb2YgYSBwcm9taXNlIGlzIG5ldmVyIHVwZGF0ZWQgZGlyZWN0bHkgb3V0c2lkZSB0aGlzIG1vZHVsZVxuICAgICBbQmFzaWNfaGVscGVyc10uIEFsbCB1cGRhdGVzIGVsc2V3aGVyZSBhcmUgZG9uZSB0aHJvdWdoXG4gICAgIFtzZXRfcHJvbWlzZV9zdGF0ZV0uXG5cbiAgICAgVG8gYXZvaWQgcHJvYmxlbXMgd2l0aCB0eXBlLWxldmVsIGludmFyaWFudHMgbm90IG1hdGNoaW5nIHJlYWxpdHksIGRhdGFcbiAgICAgc3RydWN0dXJlcyBkbyBub3Qgc3RvcmUgcHJvbWlzZXMgd2l0aCBjb25jcmV0ZSBpbnZhcmlhbnRzIC0tIGV4Y2VwdFxuICAgICByZXNvbHZlZCBwcm9taXNlcywgd2hpY2ggYXJlIGltbXV0YWJsZS4gSW5kZWVkLCBpZiBvbmUgbG9va3MgYXRcbiAgICAgZGVmaW5pdGlvbnMgb2YgZGF0YSBzdHJ1Y3R1cmVzIHRoYXQgY2FuIHN0b3JlIHBlbmRpbmcgcHJvbWlzZXMsIGUuZy4gdGhlXG4gICAgIFtob3dfdG9fY2FuY2VsXSBncmFwaCwgdGhlIGludmFyaWFudHMgYXJlIGV4aXN0ZW50aWFsbHkgcXVhbnRpZmllZC5cblxuICAgICBOb3RlOiBpdCdzIHBvc3NpYmxlIHRvIHN0YXRpY2FsbHkgZGlzYWxsb3cgdGhlIHNldHRpbmcgb2YgdGhlIFtzdGF0ZV0gZmllbGRcbiAgICAgYnkgbWFraW5nIHR5cGUgW3Byb21pc2VdIHByaXZhdGUuIEhvd2V2ZXIsIHRoYXQgc2VlbXMgdG8gcmVxdWlyZSB3cml0aW5nIGFcbiAgICAgc2lnbmF0dXJlIHRoYXQgaXMgYSBuZWFyLWR1cGxpY2F0ZSBvZiBbTWFpbl9pbnRlcm5hbF90eXBlc10sIG9yIHNvbWUgYWJ1c2VcbiAgICAgb2YgZnVuY3RvcnMuICopXG5cblxuXG4gIHR5cGUgJ2EgbWF5X25vd19iZV9wcm94eSA9XG4gICAgfCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgOlxuICAgICAgKCdhLCBfLCBwZW5kaW5nKSBwcm9taXNlIC0+ICdhIG1heV9ub3dfYmVfcHJveHlcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBtYXlfbm93X2JlX3Byb3h5IHAgPSBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcFxuXG4gICgqIE1hbnkgZnVuY3Rpb25zLCBmb3IgZXhhbXBsZSBbTHd0LmJpbmRdIGFuZCBbTHd0LmpvaW5dLCBjcmVhdGUgYSBmcmVzaFxuICAgICBwZW5kaW5nIHByb21pc2UgW3BdIGFuZCByZXR1cm4gaXQgdG8gdGhlIHVzZXIuXG5cbiAgICAgVGhleSBkbyBub3QgcmV0dXJuIGEgY29ycmVzcG9uZGluZyByZXNvbHZlci4gVGhhdCBtZWFucyB0aGF0IG9ubHkgdGhlXG4gICAgIGZ1bmN0aW9uIGl0c2VsZiAodHlwaWNhbGx5LCBhIGNhbGxiYWNrIHJlZ2lzdGVyZWQgYnkgaXQpIGNhbiByZXNvbHZlIFtwXS5cbiAgICAgVGhlIG9ubHkgdGhpbmcgdGhlIHVzZXIgY2FuIGRvIGRpcmVjdGx5IGlzIHRyeSB0byBjYW5jZWwgW3BdLCBidXQsIHNpbmNlXG4gICAgIFtwXSBpcyBub3QgYW4gaW5pdGlhbCBwcm9taXNlLCB0aGUgY2FuY2VsbGF0aW9uIGF0dGVtcHQgc2ltcGx5IHByb3BhZ2F0ZXNcbiAgICAgcGFzdCBbcF0gdG8gW3BdJ3MgcHJlZGVjZXNzb3JzLiBJZiB0aGF0IGV2ZW50dWFsbHkgcmVzdWx0cyBpbiBjYW5jZWxpbmdcbiAgICAgW3BdLCBpdCB3aWxsIGJlIHRocm91Z2ggdGhlIG5vcm1hbCBtZWNoYW5pc21zIG9mIHRoZSBmdW5jdGlvbiAoZS5nLlxuICAgICBbTHd0LmJpbmRdJ3MgY2FsbGJhY2spLlxuXG4gICAgIEFzIGEgcmVzdWx0LCB0aGUgb25seSBwb3NzaWJsZSBzdGF0ZSBjaGFuZ2UsIGJlZm9yZSB0aGUgY2FsbGJhY2ssIGlzIHRoYXRcbiAgICAgW3BdIG1heSBoYXZlIGJlY29tZSBhIHByb3h5LiBOb3csXG5cbiAgICAgLSBJZiBbcF0gZG9lcyBub3QgdW5kZXJnbyB0aGlzIHN0YXRlIGNoYW5nZSBhbmQgYmVjb21lIGEgcHJveHksIGl0IHJlbWFpbnNcbiAgICAgICBhbiB1bmRlcmx5aW5nLCBwZW5kaW5nIHByb21pc2UuXG4gICAgIC0gSWYgW3BdIGRvZXMgYmVjb21lIGEgcHJveHksIGl0IHdpbGwgYmUgYSBwcm94eSBmb3IgYW5vdGhlciBwcm9taXNlIFtwJ11cbiAgICAgICBjcmVhdGVkIGZyZXNoIGJ5IFtMd3QuYmluZF0sIHRvIHdoaWNoIHRoaXMgc2FtZSBhcmd1bWVudCBhcHBsaWVzLiBTZWVcbiAgICAgICBbbWFrZV9pbnRvX3Byb3h5XS5cblxuICAgICBTbywgYnkgaW5kdWN0aW9uIG9uIHRoZSBsZW5ndGggb2YgdGhlIHByb3h5IChbUHJveHkgX10pIGNoYWluLCBhdCB0aGUgdGltZVxuICAgICB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkLCBbcF0gaXMgZWl0aGVyIGFuIHVuZGVybHlpbmcsIHBlbmRpbmcgcHJvbWlzZSwgb3IgYVxuICAgICBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuXG5cbiAgICAgVGhlIGNhc3RcblxuICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpbiAuLi5cblxuICAgICBlbmNvZGVzIHRoZSBwb3NzaWJpbGl0eSBvZiB0aGlzIHN0YXRlIGNoYW5nZS4gSXQgcmVwbGFjZXMgYSByZWZlcmVuY2VcblxuICAgICAgIHAgOiAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpXG5cbiAgICAgd2l0aFxuXG4gICAgICAgcCA6ICgnYSwgJFVua25vd24sIHBlbmRpbmcpXG5cbiAgICAgYW5kIGlzIHR5cGljYWxseSBzZWVuIGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGJhY2tzIHJlZ2lzdGVyZWQgYnlcbiAgICAgW0x3dC5iaW5kXSBhbmQgc2ltaWxhciBmdW5jdGlvbnMuXG5cbiAgICAgVGhlIGNhc3QgaXMgYSBuby1vcCBjYXN0LiBUaGUgaW50cm9kdWN0aW9uIGFuZCBpbW1lZGlhdGUgZWxpbWluYXRpb24gb2ZcbiAgICAgW1N0YXRlX21heV9oYXZlX2NoYW5nZWQgX10gc2VlbXMgdG8gYmUgb3B0aW1pemVkIGF3YXkgZXZlbiBvbiBvbGQgdmVyc2lvbnNcbiAgICAgb2YgT0NhbWwuICopXG5lbmRcbm9wZW4gQmFzaWNfaGVscGVyc1xuXG4oKiBTbWFsbCBoZWxwZXJzIHRvIGF2b2lkIGNhdGNoaW5nIG9jYW1sLXJ1bnRpbWUgZXhjZXB0aW9ucyAqKVxubW9kdWxlIEV4Y2VwdGlvbl9maWx0ZXIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZXhuIC0+IGJvb2xcbiAgbGV0IGhhbmRsZV9hbGwgPSBmdW4gXyAtPiB0cnVlXG4gIGxldCBoYW5kbGVfYWxsX2V4Y2VwdF9ydW50aW1lID0gZnVuY3Rpb25cbiAgICB8IE91dF9vZl9tZW1vcnkgLT4gZmFsc2VcbiAgICB8IFN0YWNrX292ZXJmbG93IC0+IGZhbHNlXG4gICAgfCBfIC0+IHRydWVcbiAgbGV0IHYgPVxuICAgICgqIERlZmF1bHQgdmFsdWU6IHRoZSBsZWdhY3kgYmVoYXZpb3VyIHRvIGF2b2lkIGJyZWFraW5nIHByb2dyYW1zICopXG4gICAgcmVmIGhhbmRsZV9hbGxcbiAgbGV0IHNldCBmID0gdiA6PSBmXG4gIGxldCBydW4gZSA9ICF2IGVcbmVuZFxuXG5tb2R1bGUgU2VxdWVuY2VfYXNzb2NpYXRlZF9zdG9yYWdlIDpcbnNpZ1xuICAoKiBQdWJsaWMgaW50ZXJmYWNlICopXG4gIHR5cGUgJ3Yga2V5XG4gIHZhbCBuZXdfa2V5IDogdW5pdCAtPiBfIGtleVxuICB2YWwgZ2V0IDogJ3Yga2V5IC0+ICd2IG9wdGlvblxuICB2YWwgd2l0aF92YWx1ZSA6ICd2IGtleSAtPiAndiBvcHRpb24gLT4gKHVuaXQgLT4gJ2IpIC0+ICdiXG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlICopXG4gIHZhbCBjdXJyZW50X3N0b3JhZ2UgOiBzdG9yYWdlIHJlZlxuZW5kID1cbnN0cnVjdFxuICAoKiBUaGUgaWRlYSBiZWhpbmQgc2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlIGlzIHRvIHByZXNlcnZlIHNvbWUgdmFsdWVzXG4gICAgIGR1cmluZyBhIGNhbGwgdG8gW2JpbmRdIG9yIG90aGVyIHNlcXVlbnRpYWwgY29tcG9zaXRpb24gb3BlcmF0aW9uLCBhbmRcbiAgICAgcmVzdG9yZSB0aG9zZSB2YWx1ZXMgaW4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOlxuXG4gICAgICAgTHd0LndpdGhfdmFsdWUgbXlfa2V5IChTb21lIFwiZm9vXCIpIChmdW4gKCkgLT5cbiAgICAgICBwID58PSBmdW4gKCkgLT5cbiAgICAgICBhc3NlcnQgKEx3dC5nZXQgbXlfa2V5ID0gU29tZSBcImZvb1wiKSlcbiAgICAgICAgICgqIFdpbGwgc3VjY2VlZCBldmVuIGlmIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIGxhdGVyLiAqKVxuXG4gICAgIE5vdGUgdGhhdCBpdCBkb2VzIG5vdCBtYXR0ZXIgdGhhdCB0aGUgY2FsbGJhY2sgaXMgZGVmaW5lZCB3aXRoaW4gYW5cbiAgICAgYXJndW1lbnQgb2YgW3dpdGhfdmFsdWVdLCBpLmUuLCB0aGlzIGRvZXMgdGhlIHNhbWU6XG5cbiAgICAgICBsZXQgZiA9IGZ1biAoKSAtPiBhc3NlcnQgKEx3dC5nZXQgbXlfa2V5ID0gU29tZSBcImZvb1wiKSBpblxuICAgICAgIEx3dC53aXRoX3ZhbHVlIG15X2tleSAoU29tZSBcImZvb1wiKSAoZnVuICgpIC0+IHAgPnw9IGYpXG5cbiAgICAgQWxsIHRoYXQgbWF0dGVycyBpcyB0aGF0IHRoZSB0b3AtbW9zdCBzZXF1ZW5jaW5nIG9wZXJhdGlvbiAoaW4gdGhpcyBjYXNlLFxuICAgICBtYXApIGlzIGV4ZWN1dGVkIGJ5IHRoYXQgYXJndW1lbnQuXG5cbiAgICAgVGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHNpbmdsZSBnbG9iYWwgaGV0ZXJvZ2VuZW91cyBrZXktdmFsdWUgbWFwLlxuICAgICBTZXF1ZW50aWFsIGNvbXBvc2l0aW9uIGZ1bmN0aW9ucyBzbmFwc2hvdCB0aGlzIG1hcCB3aGVuIHRoZXkgYXJlIGNhbGxlZCxcbiAgICAgYW5kIHJlc3RvcmUgdGhlIHNuYXBzaG90IHJpZ2h0IGJlZm9yZSBjYWxsaW5nIHRoZSB1c2VyJ3MgY2FsbGJhY2suIFRoZSBzYW1lXG4gICAgIGhhcHBlbnMgZm9yIGNhbmNlbCB0cmlnZ2VycyBhZGRlZCBieSBbb25fY2FuY2VsXS5cblxuICAgICBNYWludGFpbmVyJ3Mgbm90ZTogSSB0aGluayB1c2luZyB0aGlzIG1lY2hhbmlzbSBzaG91bGQgYmUgZGlzY291cmFnZWQgaW5cbiAgICAgbmV3IGNvZGUuICopXG5cbiAgdHlwZSAndiBrZXkgPSB7XG4gICAgaWQgOiBpbnQ7XG4gICAgbXV0YWJsZSB2YWx1ZSA6ICd2IG9wdGlvbjtcbiAgfVxuXG4gIGxldCBuZXh0X2tleV9pZCA9IHJlZiAwXG5cbiAgbGV0IG5ld19rZXkgKCkgPVxuICAgIGxldCBpZCA9ICFuZXh0X2tleV9pZCBpblxuICAgIG5leHRfa2V5X2lkIDo9IGlkICsgMTtcbiAgICB7aWQgPSBpZDsgdmFsdWUgPSBOb25lfVxuXG4gIGxldCBjdXJyZW50X3N0b3JhZ2UgPSByZWYgU3RvcmFnZV9tYXAuZW1wdHlcblxuICBsZXQgZ2V0IGtleSA9XG4gICAgaWYgU3RvcmFnZV9tYXAubWVtIGtleS5pZCAhY3VycmVudF9zdG9yYWdlIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWZyZXNoID0gU3RvcmFnZV9tYXAuZmluZCBrZXkuaWQgIWN1cnJlbnRfc3RvcmFnZSBpblxuICAgICAgcmVmcmVzaCAoKTtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS52YWx1ZSBpblxuICAgICAga2V5LnZhbHVlIDwtIE5vbmU7XG4gICAgICB2YWx1ZVxuICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIE5vbmVcblxuICBsZXQgd2l0aF92YWx1ZSBrZXkgdmFsdWUgZiA9XG4gICAgbGV0IG5ld19zdG9yYWdlID1cbiAgICAgIG1hdGNoIHZhbHVlIHdpdGhcbiAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgIGxldCByZWZyZXNoID0gZnVuICgpIC0+IGtleS52YWx1ZSA8LSB2YWx1ZSBpblxuICAgICAgICBTdG9yYWdlX21hcC5hZGQga2V5LmlkIHJlZnJlc2ggIWN1cnJlbnRfc3RvcmFnZVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIFN0b3JhZ2VfbWFwLnJlbW92ZSBrZXkuaWQgIWN1cnJlbnRfc3RvcmFnZVxuICAgIGluXG5cbiAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cbiAgICBjdXJyZW50X3N0b3JhZ2UgOj0gbmV3X3N0b3JhZ2U7XG4gICAgdHJ5XG4gICAgICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICByZXN1bHRcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICByYWlzZSBleG5cbmVuZFxuaW5jbHVkZSBTZXF1ZW5jZV9hc3NvY2lhdGVkX3N0b3JhZ2VcblxuXG5cbm1vZHVsZSBQZW5kaW5nX2NhbGxiYWNrcyA6XG5zaWdcbiAgKCogTXV0YXRpbmcgY2FsbGJhY2sgbGlzdHMgYXR0YWNoZWQgdG8gcGVuZGluZyBwcm9taXNlcyAqKVxuICB2YWwgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayA6XG4gICAgJ2EgY2FsbGJhY2tzIC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gdW5pdFxuICB2YWwgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgOlxuICAgICdhIHQgbGlzdCAtPiAnYSByZWd1bGFyX2NhbGxiYWNrIC0+IHVuaXRcbiAgdmFsIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9yZW1vdmVfZnVuY3Rpb24gOlxuICAgICdhIHQgbGlzdCAtPiAnYSByZWd1bGFyX2NhbGxiYWNrIC0+IGNhbmNlbF9jYWxsYmFja1xuICB2YWwgYWRkX2NhbmNlbF9jYWxsYmFjayA6ICdhIGNhbGxiYWNrcyAtPiBjYW5jZWxfY2FsbGJhY2sgLT4gdW5pdFxuICB2YWwgbWVyZ2VfY2FsbGJhY2tzIDogZnJvbTonYSBjYWxsYmFja3MgLT4gaW50bzonYSBjYWxsYmFja3MgLT4gdW5pdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIGwxIGwyID1cbiAgICBiZWdpbiBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5LCBfIC0+IGwyXG4gICAgfCBfLCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT4gbDFcbiAgICB8IF8sIF8gLT4gUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCAobDEsIGwyKVxuICAgIGVuZCBbQG9jYW1sLndhcm5pbmcgXCItNFwiXVxuXG4gIGxldCBjb25jYXRfY2FuY2VsX2NhbGxiYWNrcyBsMSBsMiA9XG4gICAgYmVnaW4gbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5LCBfIC0+IGwyXG4gICAgfCBfLCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPiBsMVxuICAgIHwgXywgXyAtPiBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGwxLCBsMilcbiAgICBlbmQgW0BvY2FtbC53YXJuaW5nIFwiLTRcIl1cblxuICAoKiBJbiBhIGNhbGxiYWNrIGxpc3QsIGZpbHRlcnMgb3V0IGNlbGxzIG9mIGV4cGxpY2l0bHkgcmVtb3ZhYmxlIGNhbGxiYWNrc1xuICAgICB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiAqKVxuICBsZXQgcmVjIGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzID0gZnVuY3Rpb25cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayB7Y29udGVudHMgPSBOb25lfSAtPlxuICAgICAgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5XG5cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayB7Y29udGVudHMgPSBTb21lIF99XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIF9cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSBhcyBjYWxsYmFja3MgLT5cbiAgICAgIGNhbGxiYWNrc1xuXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChsMSwgbDIpIC0+XG4gICAgICBsZXQgbDEgPSBjbGVhbl91cF9jYWxsYmFja19jZWxscyBsMSBpblxuICAgICAgbGV0IGwyID0gY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgbDIgaW5cbiAgICAgIGNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyBsMSBsMlxuXG4gICgqIFNlZSBbY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbF0gYW5kIFttZXJnZV9jYWxsYmFja3NdLiAqKVxuICBsZXQgY2xlYW51cF90aHJvdHRsZSA9IDQyXG5cbiAgKCogRXhwbGljaXRseSByZW1vdmFibGUgY2FsbGJhY2tzIGFyZSBhZGRlZCAobWFpbmx5KSBieSBbTHd0LmNob29zZV0gYW5kIGl0c1xuICAgICBzaW1pbGFyIGZ1bmN0aW9ucy4gSW4gW0x3dC5jaG9vc2UgW3A7IHAnXV0sIGlmIFtwJ10gcmVzb2x2ZXMgZmlyc3QsIHRoZVxuICAgICBjYWxsYmFjayBhZGRlZCBieSBbTHd0LmNob29zZV0gdG8gW3BdIGlzIHJlbW92ZWQuXG5cbiAgICAgVGhlIHJlbW92YWwgaXRzZWxmIGlzIGFjY29tcGxpc2hlZCB3aGVuIHRoaXMgZnVuY3Rpb24gY2xlYXJzIHRoZSByZWZlcmVuY2VcbiAgICAgY2VsbCBbY2VsbF0sIHdoaWNoIGNvbnRhaW5zIHRoZSByZWZlcmVuY2UgdG8gdGhhdCBjYWxsYmFjay5cblxuICAgICBJZiBbcF0gaXMgYSBsb25nLXBlbmRpbmcgcHJvbWlzZSB0aGF0IHJlcGVhdGVkbHkgcGFydGljaXBhdGVzIGluXG4gICAgIFtMd3QuY2hvb3NlXSwgcGVyaGFwcyBpbiBhIGxvb3AsIGl0IHdpbGwgYWNjdW11bGF0ZSBhIGxhcmdlIG51bWJlciBvZlxuICAgICBjbGVhcmVkIHJlZmVyZW5jZSBjZWxscyBpbiB0aGlzIGZhc2hpb24uIFRvIGF2b2lkIGEgbWVtb3J5IGxlYWssIHRoZXkgbXVzdFxuICAgICBiZSBjbGVhbmVkIHVwLiBIb3dldmVyLCB0aGUgY2VsbHMgYXJlIG5vdCBjbGVhbmVkIHVwIG9uICpldmVyeSogcmVtb3ZhbCxcbiAgICAgcHJlc3VtYWJseSBiZWNhdXNlIHNjYW5uaW5nIHRoZSBjYWxsYmFjayBsaXN0IHRoYXQgb2Z0ZW4sIGFuZCByZWJ1aWxkaW5nXG4gICAgIGl0LCBjYW4gZ2V0IGV4cGVuc2l2ZS5cblxuICAgICBDbGVhbnVwIGlzIHRocm90dGxlZCBieSBtYWludGFpbmluZyBhIGNvdW50ZXIsIFtjbGVhbnVwc19kZWZlcnJlZF0sIG9uIGVhY2hcbiAgICAgcGVuZGluZyBwcm9taXNlLiBUaGUgY291bnRlciBpcyBpbmNyZW1lbnRlZCBlYWNoIHRpbWUgdGhpcyBmdW5jdGlvbiB3YW50c1xuICAgICB0byBjbGVhbiB0aGUgY2FsbGJhY2sgbGlzdCAocmlnaHQgYWZ0ZXIgY2xlYXJpbmcgYSBjZWxsKS4gV2hlbiB0aGUgY291bnRlclxuICAgICByZWFjaGVzIFtjbGVhbnVwX3Rocm90dGxlXSwgdGhlIGNhbGxiYWNrIGxpc3QgaXMgYWN0dWFsbHkgc2Nhbm5lZCBhbmRcbiAgICAgY2xlYXJlZCBjYWxsYmFjayBjZWxscyBhcmUgcmVtb3ZlZC4gKilcbiAgbGV0IGNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGwgY2VsbCB+b3JpZ2luYWxseV9hZGRlZF90bzpwcyA9XG4gICAgY2VsbCA6PSBOb25lO1xuXG4gICAgKCogR28gdGhyb3VnaCB0aGUgcHJvbWlzZXMgdGhlIGNlbGwgaGFkIG9yaWdpbmFsbHkgYmVlbiBhZGRlZCB0bywgYW5kIGVpdGhlclxuICAgICAgIGRlZmVyIGEgY2xlYW51cCwgb3IgYWN0dWFsbHkgY2xlYW4gdXAgdGhlaXIgY2FsbGJhY2sgbGlzdHMuICopXG4gICAgcHMgfD4gTGlzdC5pdGVyIChmdW4gcCAtPlxuICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICgqIFNvbWUgb2YgdGhlIHByb21pc2VzIG1heSBhbHJlYWR5IGhhdmUgYmVlbiByZXNvbHZlZCBhdCB0aGUgdGltZSB0aGlzXG4gICAgICAgICBmdW5jdGlvbiBpcyBjYWxsZWQuICopXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+ICgpXG4gICAgICB8IFJlamVjdGVkIF8gLT4gKClcblxuICAgICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPlxuICAgICAgICBtYXRjaCBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3Mgd2l0aFxuICAgICAgICAoKiBJZiB0aGUgcHJvbWlzZSBoYXMgb25seSBvbmUgcmVndWxhciBjYWxsYmFjaywgYW5kIGl0IGlzIHJlbW92YWJsZSwgaXRcbiAgICAgICAgICAgbXVzdCBoYXZlIGJlZW4gdGhlIGNlbGwgY2xlYXJlZCBpbiB0aGlzIGZ1bmN0aW9uLCBhYm92ZS4gSW4gdGhhdFxuICAgICAgICAgICBjYXNlLCBqdXN0IHNldCBpdHMgY2FsbGJhY2sgbGlzdCB0byBlbXB0eS4gKilcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgXyAtPlxuICAgICAgICAgIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyA8LSBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHlcblxuICAgICAgICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogSSB0aGluayB0aGlzIGZ1bmN0aW9uIHNob3VsZG4ndCB0cnkgdG8gdHJpZ2dlciBhXG4gICAgICAgICAgIGNsZWFudXAgaW4gdGhlIGZpcnN0IHR3byBjYXNlcywgYnV0IEkgYW0gcHJlc2VydmluZyB0aGVtIGZvciBub3csIGFzXG4gICAgICAgICAgIHRoaXMgaXMgaG93IHRoZSBjb2RlIHdhcyB3cml0dGVuIGluIHRoZSBwYXN0LiAqKVxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgX1xuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgXyAtPlxuICAgICAgICAgIGxldCBjbGVhbnVwc19kZWZlcnJlZCA9IGNhbGxiYWNrcy5jbGVhbnVwc19kZWZlcnJlZCArIDEgaW5cbiAgICAgICAgICBpZiBjbGVhbnVwc19kZWZlcnJlZCA+IGNsZWFudXBfdGhyb3R0bGUgdGhlbiBiZWdpblxuICAgICAgICAgICAgY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkIDwtIDA7XG4gICAgICAgICAgICBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3MgPC1cbiAgICAgICAgICAgICAgY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzXG4gICAgICAgICAgZW5kIGVsc2VcbiAgICAgICAgICAgIGNhbGxiYWNrcy5jbGVhbnVwc19kZWZlcnJlZCA8LSBjbGVhbnVwc19kZWZlcnJlZClcblxuICAoKiBDb25jYXRlbmF0ZXMgYm90aCBraW5kcyBvZiBjYWxsYmFja3Mgb24gW35mcm9tXSB0byB0aGUgY29ycmVzcG9uZGluZyBsaXN0c1xuICAgICBvZiBbfmludG9dLiBUaGUgY2FsbGJhY2sgbGlzdHMgb24gW35mcm9tXSBhcmUgKm5vdCogdGhlbiBjbGVhcmVkLCBiZWNhdXNlXG4gICAgIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgYnkgW1NlcXVlbnRpYWxfY29tcG9zaXRpb24ubWFrZV9pbnRvX3Byb3h5XSxcbiAgICAgd2hpY2ggaW1tZWRpYXRlbHkgY2hhbmdlcyB0aGUgc3RhdGUgb2YgW35mcm9tXSBhbmQgbG9zZXMgcmVmZXJlbmNlcyB0byB0aGVcbiAgICAgb3JpZ2luYWwgY2FsbGJhY2sgbGlzdHMuXG5cbiAgICAgVGhlIFtjbGVhbnVwc19kZWZlcnJlZF0gZmllbGRzIG9mIGJvdGggcHJvbWlzZXMgYXJlIHN1bW1lZCwgYW5kIGlmIHRoZSBzdW1cbiAgICAgZXhjZWVkcyBbY2xlYW51cF90aHJvdHRsZV0sIGEgY2xlYW51cCBvZiByZWd1bGFyIGNhbGxiYWNrcyBpcyB0cmlnZ2VyZWQuXG4gICAgIFRoaXMgaXMgdG8gcHJldmVudCBtZW1vcnkgbGVha3M7IHNlZVxuICAgICBbY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbF0uICopXG4gIGxldCBtZXJnZV9jYWxsYmFja3MgfmZyb20gfmludG8gPVxuICAgIGxldCByZWd1bGFyX2NhbGxiYWNrcyA9XG4gICAgICBjb25jYXRfcmVndWxhcl9jYWxsYmFja3MgaW50by5yZWd1bGFyX2NhbGxiYWNrcyBmcm9tLnJlZ3VsYXJfY2FsbGJhY2tzIGluXG4gICAgbGV0IGNsZWFudXBzX2RlZmVycmVkID0gaW50by5jbGVhbnVwc19kZWZlcnJlZCArIGZyb20uY2xlYW51cHNfZGVmZXJyZWQgaW5cblxuICAgIGxldCByZWd1bGFyX2NhbGxiYWNrcywgY2xlYW51cHNfZGVmZXJyZWQgPVxuICAgICAgaWYgY2xlYW51cHNfZGVmZXJyZWQgPiBjbGVhbnVwX3Rocm90dGxlIHRoZW5cbiAgICAgICAgY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgcmVndWxhcl9jYWxsYmFja3MsIDBcbiAgICAgIGVsc2VcbiAgICAgICAgcmVndWxhcl9jYWxsYmFja3MsIGNsZWFudXBzX2RlZmVycmVkXG4gICAgaW5cblxuICAgIGxldCBjYW5jZWxfY2FsbGJhY2tzID1cbiAgICAgIGNvbmNhdF9jYW5jZWxfY2FsbGJhY2tzIGludG8uY2FuY2VsX2NhbGxiYWNrcyBmcm9tLmNhbmNlbF9jYWxsYmFja3MgaW5cblxuICAgIGludG8ucmVndWxhcl9jYWxsYmFja3MgPC0gcmVndWxhcl9jYWxsYmFja3M7XG4gICAgaW50by5jYW5jZWxfY2FsbGJhY2tzIDwtIGNhbmNlbF9jYWxsYmFja3M7XG4gICAgaW50by5jbGVhbnVwc19kZWZlcnJlZCA8LSBjbGVhbnVwc19kZWZlcnJlZFxuXG5cblxuICAoKiBHZW5lcmFsLCBpbnRlcm5hbCwgZnVuY3Rpb24gZm9yIGFkZGluZyBhIHJlZ3VsYXIgY2FsbGJhY2suICopXG4gIGxldCBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUgY2FsbGJhY2tzIG5vZGUgPVxuICAgIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyA8LVxuICAgICAgbWF0Y2ggY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIHdpdGhcbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5IC0+XG4gICAgICAgIG5vZGVcbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBfXG4gICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBfXG4gICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgXyBhcyBleGlzdGluZyAtPlxuICAgICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChub2RlLCBleGlzdGluZylcblxuICBsZXQgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBjYWxsYmFja3MgZiA9XG4gICAgYWRkX3JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9ub2RlXG4gICAgICBjYWxsYmFja3MgKFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgZilcblxuICAoKiBBZGRzIFtjYWxsYmFja10gYXMgcmVtb3ZhYmxlIHRvIGVhY2ggcHJvbWlzZSBpbiBbcHNdLiBUaGUgZmlyc3QgcHJvbWlzZSBpblxuICAgICBbcHNdIHRvIHRyaWdnZXIgW2NhbGxiYWNrXSByZW1vdmVzIFtjYWxsYmFja10gZnJvbSB0aGUgb3RoZXIgcHJvbWlzZXM7IHRoaXNcbiAgICAgZ3VhcmFudGVlcyB0aGF0IFtjYWxsYmFja10gaXMgY2FsbGVkIGF0IG1vc3Qgb25jZS4gQWxsIHRoZSBwcm9taXNlcyBpbiBbcHNdXG4gICAgIG11c3QgYmUgcGVuZGluZy5cblxuICAgICBUaGlzIGlzIGFuIGludGVybmFsIGZ1bmN0aW9uLCBpbmRpcmVjdGx5IHVzZWQgYnkgdGhlIGltcGxlbWVudGF0aW9ucyBvZlxuICAgICBbTHd0LmNob29zZV0gYW5kIHJlbGF0ZWQgZnVuY3Rpb25zLiAqKVxuICBsZXQgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX2NlbGwgcHMgZiA9XG4gICAgbGV0IHJlYyBjZWxsID0gcmVmIChTb21lIHNlbGZfcmVtb3ZpbmdfY2FsbGJhY2tfd3JhcHBlcilcbiAgICBhbmQgc2VsZl9yZW1vdmluZ19jYWxsYmFja193cmFwcGVyIHJlc3VsdCA9XG4gICAgICBjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsIGNlbGwgfm9yaWdpbmFsbHlfYWRkZWRfdG86cHM7XG4gICAgICBmIHJlc3VsdFxuICAgIGluXG5cbiAgICBsZXQgbm9kZSA9IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBjZWxsIGluXG4gICAgcHMgfD4gTGlzdC5pdGVyIChmdW4gcCAtPlxuICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT4gYWRkX3JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9ub2RlIGNhbGxiYWNrcyBub2RlXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBSZWplY3RlZCBfIC0+IGFzc2VydCBmYWxzZSk7XG5cbiAgICBjZWxsXG5cbiAgbGV0IGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGYgPVxuICAgIGlnbm9yZSAoYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX2NlbGwgcHMgZilcblxuICAoKiBUaGlzIGlzIGJhc2ljYWxseSBqdXN0IHRvIHN1cHBvcnQgW0x3dC5wcm90ZWN0ZWRdLCB3aGljaCBuZWVkcyB0byByZW1vdmVcbiAgICAgdGhlIGNhbGxiYWNrIGluIGNpcmN1bXN0YW5jZXMgb3RoZXIgdGhhbiB0aGUgY2FsbGJhY2sgYmVpbmcgY2FsbGVkLiAqKVxuICBsZXQgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX3JlbW92ZV9mdW5jdGlvbiBwcyBmID1cbiAgICBsZXQgY2VsbCA9IGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9jZWxsIHBzIGYgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgIGNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGwgY2VsbCB+b3JpZ2luYWxseV9hZGRlZF90bzpwc1xuXG4gIGxldCBhZGRfY2FuY2VsX2NhbGxiYWNrIGNhbGxiYWNrcyBmID1cbiAgICBsZXQgbm9kZSA9IENhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrICghY3VycmVudF9zdG9yYWdlLCBmKSBpblxuXG4gICAgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MgPC1cbiAgICAgIG1hdGNoIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIHdpdGhcbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgbm9kZVxuXG4gICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIF9cbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgX1xuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgXyAtPlxuICAgICAgICBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKG5vZGUsIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzKVxuZW5kXG5vcGVuIFBlbmRpbmdfY2FsbGJhY2tzXG5cblxuXG5tb2R1bGUgUmVzb2x1dGlvbl9sb29wIDpcbnNpZ1xuICAoKiBBbGwgdXNlci1wcm92aWRlZCBjYWxsYmFja3MgYXJlIGNhbGxlZCBieSBMd3Qgb25seSB0aHJvdWdoIHRoaXMgbW9kdWxlLiBJdFxuICAgICB0cmFja3MgdGhlIGN1cnJlbnQgY2FsbGJhY2sgc3RhY2sgZGVwdGgsIGFuZCBkZWNpZGVzIHdoZXRoZXIgZWFjaCBjYWxsYmFja1xuICAgICBjYWxsIHNob3VsZCBiZSBkZWZlcnJlZCBvciBub3QuICopXG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgb25seSBpbiB0aGlzIG1vZHVsZSBMd3QgKilcbiAgdmFsIHJlc29sdmUgOlxuICAgID9hbGxvd19kZWZlcnJpbmc6Ym9vbCAtPlxuICAgID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6aW50IC0+XG4gICAgKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlIC0+XG4gICAgJ2EgcmVzb2x2ZWRfc3RhdGUgLT5cbiAgICAgICgnYSwgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlX2NoYW5nZWRcblxuICB2YWwgcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtIDpcbiAgICA/YWxsb3dfZGVmZXJyaW5nOmJvb2wgLT5cbiAgICA/bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoOmludCAtPlxuICAgICgnYSBjYWxsYmFja3MpIC0+XG4gICAgJ2EgcmVzb2x2ZWRfc3RhdGUgLT5cbiAgICAgIHVuaXRcblxuICB2YWwgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0IDpcbiAgICA/cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOmJvb2wgLT5cbiAgICBjYWxsYmFjazoodW5pdCAtPiAnYSkgLT5cbiAgICBpZl9kZWZlcnJlZDoodW5pdCAtPiAnYSAqICdiIHJlZ3VsYXJfY2FsbGJhY2sgKiAnYiByZXNvbHZlZF9zdGF0ZSkgLT5cbiAgICAgICdhXG5cbiAgdmFsIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXRcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgZXhwb3NlZCB0byBvdGhlciBtb2R1bGVzIGluIEx3dCAqKVxuICB2YWwgYWJhbmRvbl93YWtldXBzIDogdW5pdCAtPiB1bml0XG5cbiAgKCogUHVibGljIGludGVyZmFjZSAqKVxuICBleGNlcHRpb24gQ2FuY2VsZWRcblxuICB2YWwgYXN5bmNfZXhjZXB0aW9uX2hvb2sgOiAoZXhuIC0+IHVuaXQpIHJlZlxuZW5kID1cbnN0cnVjdFxuICAoKiBXaGVuIEx3dCBuZWVkcyB0byBjYWxsIGEgY2FsbGJhY2ssIGl0IGVudGVycyB0aGUgcmVzb2x1dGlvbiBsb29wLiBUaGlzXG4gICAgIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gTHd0IHNldHMgdGhlIHN0YXRlIG9mIG9uZSBwcm9taXNlIHRvIFtGdWxmaWxsZWQgX11cbiAgICAgb3IgW1JlamVjdGVkIF9dLiBUaGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBhdHRhY2hlZCB0byB0aGUgcHJvbWlzZSB3aGVuIGl0XG4gICAgIHdhcyBwZW5kaW5nIG11c3QgdGhlbiBiZSBjYWxsZWQuXG5cbiAgICAgVGhpcyBhbHNvIGhhcHBlbnMgaW4gYSBmZXcgb3RoZXIgc2l0dWF0aW9ucy4gRm9yIGV4YW1wbGUsIHdoZW4gW0x3dC5iaW5kXVxuICAgICBpcyBjYWxsZWQgb24gYSBwcm9taXNlLCBidXQgdGhhdCBwcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQsIHRoZSBjYWxsYmFja1xuICAgICBwYXNzZWQgdG8gW2JpbmRdIG11c3QgYmUgY2FsbGVkLlxuXG4gICAgIFRoZSBjYWxsYmFja3MgdHJpZ2dlcmVkIGR1cmluZyB0aGUgcmVzb2x1dGlvbiBsb29wIG1pZ2h0IHJlc29sdmUgbW9yZVxuICAgICBwcm9taXNlcywgdHJpZ2dlcmluZyBtb3JlIGNhbGxiYWNrcywgYW5kIHNvIG9uLiBUaGlzIGlzIHdoYXQgbWFrZXMgdGhlXG4gICAgIHJlc29sdXRpb24gbG9vcCBhIHtlIGxvb3B9LlxuXG4gICAgIEx3dCBnZW5lcmFsbHkgdHJpZXMgdG8gY2FsbCBlYWNoIGNhbGxiYWNrIGltbWVkaWF0ZWx5LiBIb3dldmVyLCB0aGlzIGNhblxuICAgICBsZWFkIHRvIGEgcHJvZ3Jlc3NpdmUgZGVlcGVuaW5nIG9mIHRoZSBjYWxsIHN0YWNrLCB1bnRpbCB0aGVyZSBpcyBhIHN0YWNrXG4gICAgIG92ZXJmbG93LiBUaGlzIGNhbid0IGJlIGF2b2lkZWQgYnkgZG9pbmcgdGFpbCBjYWxscywgYmVjYXVzZSBMd3QgYWx3YXlzXG4gICAgIG5lZWRzIHRvIGRvIGV4Y2VwdGlvbiBoYW5kbGluZyBhcm91bmQgY2FsbGJhY2tzIGNhbGxzOiBlYWNoIGNhbGxiYWNrIGNhbGxcbiAgICAgaXMgZm9sbG93ZWQgYnkgYW4gZXhjZXB0aW9uIGhhbmRsZXIuIEluc3RlYWQsIHdoYXQgTHd0IGRvZXMgaXMgdHJhY2sgdGhlXG4gICAgIGN1cnJlbnQgY2FsbGJhY2sgY2FsbCBkZXB0aC4gT25jZSB0aGF0IGRlcHRoIHJlYWNoZXMgYSBjZXJ0YWluIG51bWJlcixcbiAgICAgW2RlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoXSwgZGVmaW5lZCBiZWxvdywgZnVydGhlciBjYWxsYmFja3NcbiAgICAgYXJlIGRlZmVycmVkIGludG8gYSBxdWV1ZSBpbnN0ZWFkLiBUaGF0IHF1ZXVlIGlzIGRyYWluZWQgd2hlbiBMd3QgZXhpdHNcbiAgICAgZnJvbSB0aGUgdG9wLW1vc3QgY2FsbGJhY2sgY2FsbCB0aGF0IHRyaWdnZXJlZCB0aGUgcmVzb2x1dGlvbiBsb29wIGluIHRoZVxuICAgICBmaXJzdCBwbGFjZS5cblxuICAgICBUbyBlbnN1cmUgdGhhdCB0aGlzIGRlZmVycmFsIG1lY2hhbmlzbSBpcyBhbHdheXMgcHJvcGVybHkgaW52b2tlZCwgYWxsXG4gICAgIGNhbGxiYWNrcyBjYWxsZWQgYnkgTHd0IGFyZSBjYWxsZWQgdGhyb3VnaCBvbmUgb2YgdGhyZWUgZnVuY3Rpb25zIHByb3ZpZGVkXG4gICAgIGJ5IHRoaXMgbW9kdWxlOlxuXG4gICAgIC0gW3Jlc29sdmVdLCB3aGljaCBjYWxscyBhbGwgdGhlIGNhbGxiYWNrcyBhc3NvY2lhdGVkIHRvIGEgcGVuZGluZyBwcm9taXNlXG4gICAgICAgKGFuZCByZXNvbHZlcyBpdCwgY2hhbmdpbmcgaXRzIHN0YXRlKS5cbiAgICAgLSBbcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtXSwgd2hpY2ggaXMgaW50ZXJuYWxseSB1c2VkIGJ5IFtyZXNvbHZlXSB0b1xuICAgICAgIGNhbGwgY2FsbGJhY2tzIHRoYXQgYXJlIGluIGEgcmVjb3JkIG9mIHR5cGUgWydhIGNhbGxiYWNrc10sIHdoaWNoIHJlY29yZHNcbiAgICAgICBhcmUgYXNzb2NpYXRlZCB3aXRoIHBlbmRpbmcgcHJvbWlzZXMuIFRoaXMgZnVuY3Rpb24gaXMgZXhwb3NlZCBiZWNhdXNlXG4gICAgICAgdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgW0x3dC5jYW5jZWxdIG5lZWRzIHRvIGNhbGwgaXQgZGlyZWN0bHkuXG4gICAgICAgUHJvbWlzZSByZXNvbHV0aW9uIGFuZCBjYWxsYmFjayBjYWxsaW5nIGFyZSBzZXBhcmF0ZWQgaW4gYSB1bmlxdWUgd2F5IGluXG4gICAgICAgW2NhbmNlbF0uXG4gICAgIC0gW3J1bl9jYWxsYmFja19vcl9kZWZlcl9pdF0sIHdoaWNoIGlzIHVzZWQgYnkgW0x3dC5iaW5kXSBhbmQgc2ltaWxhclxuICAgICAgIGZ1bmN0aW9ucyB0byBjYWxsIHNpbmdsZSBjYWxsYmFja3Mgd2hlbiB0aGUgcHJvbWlzZXMgcGFzc2VkIHRvXG4gICAgICAgW0x3dC5iaW5kXSwgZXRjLiwgYXJlIGFscmVhZHkgcmVzb2x2ZWQuXG5cbiAgICAgQ3VycmVudCBMd3QgYWN0dWFsbHkgaGFzIGEgbWVzc3kgbWl4IG9mIGNhbGxiYWNrLWNhbGxpbmcgYmVoYXZpb3JzLiBGb3JcbiAgICAgZXhhbXBsZSwgW0x3dC5iaW5kXSBpcyBleHBlY3RlZCB0byBhbHdheXMgY2FsbCBpdHMgY2FsbGJhY2sgaW1tZWRpYXRlbHksXG4gICAgIHdoaWxlIFtMd3Qud2FrZXVwX2xhdGVyXSBpcyBleHBlY3RlZCB0byBkZWZlciBhbGwgY2FsbGJhY2tzIG9mIHRoZSBwcm9taXNlXG4gICAgIHJlc29sdmVkLCB7ZSB1bmxlc3N9IEx3dCBpcyBub3QgYWxyZWFkeSBpbnNpZGUgdGhlIHJlc29sdXRpb24gbG9vcC5cblxuICAgICBXZSBwbGFubmVkIHRvIG1ha2UgdGhlc2UgYmVoYXZpb3JzIHVuaWZvcm0gaW4gTHd0IDQuMC4wLCBidXQgZGVjaWRlZFxuICAgICBhZ2FpbnN0IGl0IGR1ZSB0byB0aGUgcmlzayBvZiBicmVha2luZyB1c2Vycy4gU2VlXG5cbiAgICAgLSBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvcHVsbC81MDBcbiAgICAgLSBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvcHVsbC81MTlcblxuICAgICBBcyBwYXJ0IG9mIHRoZSBwcmVwYXJhdGlvbiBmb3IgdGhlIGNoYW5nZSwgdGhlIGFib3ZlIGNhbGxiYWNrLWludm9raW5nXG4gICAgIGZ1bmN0aW9ucyBzdXBwb3J0IHNldmVyYWwgb3B0aW9uYWwgYXJndW1lbnRzIHRvIGVtdWxhdGUgdGhlIHZhcmlvdXNcbiAgICAgYmVoYXZpb3JzLiBXZSBkZWNpZGVkIG5vdCB0byByZW1vdmUgdGhpcyBtYWNoaW5lcnksIGJlY2F1c2Ugd2UgbWlnaHQgd2FudFxuICAgICB0byBleHBvc2UgZGlmZmVyZW50IEFQSXMgdG8gTHd0IGluIHRoZSBmdXR1cmUuXG5cbiAgICAgLSBbfmFsbG93X2RlZmVycmluZzpmYWxzZV0gYWxsb3dzIGlnbm9yaW5nIHRoZSBjYWxsYmFjayBzdGFjayBkZXB0aCwgYW5kXG4gICAgICAgY2FsbGluZyB0aGUgY2FsbGJhY2tzIGltbWVkaWF0ZWx5LiBUaGlzIGVtdWxhdGVzIHRoZSBvbGQgcmVzb2x1dGlvblxuICAgICAgIGJlaGF2aW9yLlxuICAgICAtIFt+bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoOjFdIGFsbG93cyBsaW1pdGluZyB0aGUgZGVwdGggd2hpY2hcbiAgICAgICB0cmlnZ2VycyBkZWZlcnJhbCBvbiBhIHBlci1jYWxsLXNpdGUgYmFzaXMuIFRoaXMgaXMgdXNlZCBieVxuICAgICAgIFtMd3Qud2FrZXVwX2xhdGVyXS5cbiAgICAgLSBbfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXSBpcyBsaWtlXG4gICAgICAgW35hbGxvd19kZWZlcnJpbmc6ZmFsc2VdLCB3aGljaCBpZ25vcmVzIHRoZSBjYWxsYmFjayBzdGFjayBkZXB0aC5cbiAgICAgICBIb3dldmVyLCB0byBlbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgaXMgdGFpbC1jYWxsZWQsIEx3dCBkb2Vzbid0IGV2ZW5cbiAgICAgICB1cGRhdGUgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoIGZvciB0aGUgYmVuZWZpdCBvZiAqb3RoZXIqIGNhbGxiYWNrXG4gICAgICAgY2FsbHMuIEl0IGp1c3QgYmxpbmRseSBjYWxscyB0aGUgY2FsbGJhY2suXG5cbiAgICAgU2VlIGRpc2N1c3Npb24gb2YgY2FsbGJhY2stY2FsbGluZyBzZW1hbnRpY3MgaW46XG5cbiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvaXNzdWVzLzMyOVxuXG4gICAgICogQ29udGV4dFxuXG4gICAgIFRoZSByZXNvbHV0aW9uIGxvb3AgZWZmZWN0aXZlbHkgaGFuZGxlcyBhbGwgcHJvbWlzZXMgdGhhdCBjYW4gYmUgcmVzb2x2ZWRcbiAgICAgaW1tZWRpYXRlbHksIHdpdGhvdXQgYmxvY2tpbmcgb24gSS9PLiBBIGNvbXBsZXRlIHByb2dyYW0gdGhhdCBkb2VzIEkvT1xuICAgICBjYWxscyBbTHd0X21haW4ucnVuXS4gU2VlIFwiTm8gSS9PXCIgaW4gdGhlIE92ZXJ2aWV3LiAqKVxuXG5cblxuICBsZXQgYXN5bmNfZXhjZXB0aW9uX2hvb2sgPVxuICAgIHJlZiAoZnVuIGV4biAtPlxuICAgICAgcHJlcnJfc3RyaW5nIFwiRmF0YWwgZXJyb3I6IGV4Y2VwdGlvbiBcIjtcbiAgICAgIHByZXJyX3N0cmluZyAoUHJpbnRleGMudG9fc3RyaW5nIGV4bik7XG4gICAgICBwcmVycl9jaGFyICdcXG4nO1xuICAgICAgUHJpbnRleGMucHJpbnRfYmFja3RyYWNlIHN0ZGVycjtcbiAgICAgIGZsdXNoIHN0ZGVycjtcbiAgICAgIGV4aXQgMilcblxuICBsZXQgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2ID1cbiAgICAoKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjYXJlIGlmIFtmXSBldmFsdWF0ZXMgdG8gYSBwcm9taXNlLiBJblxuICAgICAgIHBhcnRpY3VsYXIsIGlmIFtmIHZdIGV2YWx1YXRlcyB0byBbcF0gYW5kIFtwXSBpcyBhbHJlYWR5IHJlamVjdGVkIG9yIHdpbGxcbiAgICAgICBiZSByZWplY3QgbGF0ZXIsIGl0IGlzIG5vdCB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhpcyBmdW5jdGlvbiB0byBwYXNzXG4gICAgICAgdGhlIGV4Y2VwdGlvbiB0byBbIWFzeW5jX2V4Y2VwdGlvbl9ob29rXS4gKilcbiAgICB0cnkgZiB2XG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICFhc3luY19leGNlcHRpb25faG9vayBleG5cblxuXG5cbiAgZXhjZXB0aW9uIENhbmNlbGVkXG5cblxuXG4gICgqIFJ1bnMgdGhlIGNhbGxiYWNrcyAoZm9ybWVybHkpIGFzc29jaWF0ZWQgdG8gYSBwcm9taXNlLiBDYW5jZWwgY2FsbGJhY2tzIGFyZVxuICAgICBydW4gZmlyc3QsIGlmIHRoZSBwcm9taXNlIHdhcyBjYW5jZWxlZC4gVGhlc2UgYXJlIGZvbGxvd2VkIGJ5IHJlZ3VsYXJcbiAgICAgY2FsbGJhY2tzLlxuXG4gICAgIFRoZSByZWFzb24gZm9yIHRoZSBcImZvcm1lcmx5XCIgaXMgdGhhdCB0aGUgcHJvbWlzZSdzIHN0YXRlIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgc2V0IHRvIFtGdWxmaWxsZWQgX10gb3IgW1JlamVjdGVkIF9dLCBzbyB0aGUgY2FsbGJhY2tzIGFyZSBubyBsb25nZXJcbiAgICAgcmVhY2hhYmxlIHRocm91Z2ggdGhlIHByb21pc2UgcmVmZXJlbmNlLiBUaGlzIGlzIHdoeSB0aGUgZGlyZWN0IFtjYWxsYmFja3NdXG4gICAgIHJlY29yZCBtdXN0IGJlIGdpdmVuIHRvIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCBydW5fY2FsbGJhY2tzXG4gICAgICAoY2FsbGJhY2tzIDogJ2EgY2FsbGJhY2tzKVxuICAgICAgKHJlc3VsdCA6ICdhIHJlc29sdmVkX3N0YXRlKSA6IHVuaXQgPVxuXG4gICAgbGV0IHJ1bl9jYW5jZWxfY2FsbGJhY2tzIGZzID1cbiAgICAgIGxldCByZWMgaXRlcl9jYWxsYmFja19saXN0IGZzIHJlc3QgPVxuICAgICAgICBtYXRjaCBmcyB3aXRoXG4gICAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIChzdG9yYWdlLCBmKSAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCk7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBub2RlIC0+XG4gICAgICAgICAgTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlO1xuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY29uY2F0IChmcywgZnMnKSAtPlxuICAgICAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyAoZnMnOjpyZXN0KVxuXG4gICAgICBhbmQgaXRlcl9saXN0IHJlc3QgPVxuICAgICAgICBtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGZzOjpyZXN0IC0+IGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyByZXN0XG5cbiAgICAgIGluXG5cbiAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyBbXVxuICAgIGluXG5cbiAgICBsZXQgcnVuX3JlZ3VsYXJfY2FsbGJhY2tzIGZzID1cbiAgICAgIGxldCByZWMgaXRlcl9jYWxsYmFja19saXN0IGZzIHJlc3QgPVxuICAgICAgICBtYXRjaCBmcyB3aXRoXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5IC0+XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIGYgLT5cbiAgICAgICAgICBmIHJlc3VsdDtcbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja1xuICAgICAgICAgICAge2NvbnRlbnRzID0gTm9uZX0gLT5cbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja1xuICAgICAgICAgICAge2NvbnRlbnRzID0gU29tZSBmfSAtPlxuICAgICAgICAgIGYgcmVzdWx0O1xuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCAoZnMsIGZzJykgLT5cbiAgICAgICAgICBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgKGZzJzo6cmVzdClcblxuICAgICAgYW5kIGl0ZXJfbGlzdCByZXN0ID1cbiAgICAgICAgbWF0Y2ggcmVzdCB3aXRoXG4gICAgICAgIHwgW10gLT4gKClcbiAgICAgICAgfCBmczo6cmVzdCAtPiBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdFxuXG4gICAgICBpblxuXG4gICAgICBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgW11cbiAgICBpblxuXG4gICAgKCogUGF0dGVybiBtYXRjaGluZyBpcyBtdWNoIGZhc3RlciB0aGFuIHBvbHltb3JwaGljIGNvbXBhcmlzb24uICopXG4gICAgbGV0IGlzX2NhbmNlbGVkID1cbiAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICB8IFJlamVjdGVkIENhbmNlbGVkIC0+IHRydWVcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPiBmYWxzZVxuICAgICAgfCBGdWxmaWxsZWQgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgaWYgaXNfY2FuY2VsZWQgdGhlblxuICAgICAgcnVuX2NhbmNlbF9jYWxsYmFja3MgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3M7XG4gICAgcnVuX3JlZ3VsYXJfY2FsbGJhY2tzIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrc1xuXG5cblxuICBsZXQgZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGggPSA0MlxuXG4gIGxldCBjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggPSByZWYgMFxuXG4gIHR5cGUgZGVmZXJyZWRfY2FsbGJhY2tzID1cbiAgICBEZWZlcnJlZCA6ICgnYSBjYWxsYmFja3MgKiAnYSByZXNvbHZlZF9zdGF0ZSkgLT4gZGVmZXJyZWRfY2FsbGJhY2tzXG4gICAgW0BAb2NhbWwudW5ib3hlZF1cblxuICBsZXQgZGVmZXJyZWRfY2FsbGJhY2tzIDogZGVmZXJyZWRfY2FsbGJhY2tzIFF1ZXVlLnQgPSBRdWV1ZS5jcmVhdGUgKClcblxuICAoKiBCZWZvcmUgZW50ZXJpbmcgYSByZXNvbHV0aW9uIGxvb3AsIGl0IGlzIG5lY2Vzc2FyeSB0byB0YWtlIGEgc25hcHNob3Qgb2ZcbiAgICAgdGhlIGN1cnJlbnQgc3RhdGUgb2Ygc2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlLiBUaGlzIGlzIGJlY2F1c2UgbWFueSBvZlxuICAgICB0aGUgY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBydW4gd2lsbCBtb2RpZnkgdGhlIHN0b3JhZ2UuIFRoZSBzdG9yYWdlIGlzXG4gICAgIHJlc3RvcmVkIHRvIHRoZSBzbmFwc2hvdCB3aGVuIHRoZSByZXNvbHV0aW9uIGxvb3AgaXMgZXhpdGVkLiAqKVxuICBsZXQgZW50ZXJfcmVzb2x1dGlvbl9sb29wICgpID1cbiAgICBjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggOj0gIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCArIDE7XG4gICAgbGV0IHN0b3JhZ2Vfc25hcHNob3QgPSAhY3VycmVudF9zdG9yYWdlIGluXG4gICAgc3RvcmFnZV9zbmFwc2hvdFxuXG4gIGxldCBsZWF2ZV9yZXNvbHV0aW9uX2xvb3AgKHN0b3JhZ2Vfc25hcHNob3QgOiBzdG9yYWdlKSA6IHVuaXQgPVxuICAgIGlmICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggPSAxIHRoZW4gYmVnaW5cbiAgICAgIHdoaWxlIG5vdCAoUXVldWUuaXNfZW1wdHkgZGVmZXJyZWRfY2FsbGJhY2tzKSBkb1xuICAgICAgICBsZXQgRGVmZXJyZWQgKGNhbGxiYWNrcywgcmVzdWx0KSA9IFF1ZXVlLnBvcCBkZWZlcnJlZF9jYWxsYmFja3MgaW5cbiAgICAgICAgcnVuX2NhbGxiYWNrcyBjYWxsYmFja3MgcmVzdWx0XG4gICAgICBkb25lXG4gICAgZW5kO1xuICAgIGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA6PSAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIC0gMTtcbiAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc3RvcmFnZV9zbmFwc2hvdFxuXG4gIGxldCBydW5faW5fcmVzb2x1dGlvbl9sb29wIGYgPVxuICAgIGxldCBzdG9yYWdlX3NuYXBzaG90ID0gZW50ZXJfcmVzb2x1dGlvbl9sb29wICgpIGluXG4gICAgbGV0IHJlc3VsdCA9IGYgKCkgaW5cbiAgICBsZWF2ZV9yZXNvbHV0aW9uX2xvb3Agc3RvcmFnZV9zbmFwc2hvdDtcbiAgICByZXN1bHRcblxuICAoKiBUaGlzIGlzIGJhc2ljYWxseSBhIGhhY2sgdG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9pc3N1ZXMvNDguXG4gICAgIElmIGN1cnJlbnRseSByZXNvbHZpbmcgcHJvbWlzZXMsIGl0IGltbWVkaWF0ZWx5IGV4aXRzIGFsbCByZWN1cnNpdmVcbiAgICAgZW50cmllcyBvZiB0aGUgcmVzb2x1dGlvbiBsb29wLCBnb2VzIHRvIHRoZSB0b3AgbGV2ZWwsIHJ1bnMgYW55IGRlZmVycmVkXG4gICAgIGNhbGxiYWNrcywgYW5kIGV4aXRzIHRoZSB0b3AtbGV2ZWwgcmVzb2x1dGlvbiBsb29wLlxuXG4gICAgIFRoZSBuYW1lIHNob3VsZCBwcm9iYWJseSBiZSBbYWJhb25kb25fcmVzb2x1dGlvbl9sb29wXS4gKilcbiAgbGV0IGFiYW5kb25fd2FrZXVwcyAoKSA9XG4gICAgaWYgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA8PiAwIHRoZW5cbiAgICAgIGxlYXZlX3Jlc29sdXRpb25fbG9vcCBTdG9yYWdlX21hcC5lbXB0eVxuXG5cblxuICBsZXQgcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtXG4gICAgICA/KGFsbG93X2RlZmVycmluZyA9IHRydWUpXG4gICAgICA/KG1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IGRlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoKVxuICAgICAgY2FsbGJhY2tzIHJlc3VsdCA9XG5cbiAgICBsZXQgc2hvdWxkX2RlZmVyID1cbiAgICAgIGFsbG93X2RlZmVycmluZ1xuICAgICAgJiYgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA+PSBtYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGhcbiAgICBpblxuXG4gICAgaWYgc2hvdWxkX2RlZmVyIHRoZW5cbiAgICAgIFF1ZXVlLnB1c2ggKERlZmVycmVkIChjYWxsYmFja3MsIHJlc3VsdCkpIGRlZmVycmVkX2NhbGxiYWNrc1xuICAgIGVsc2VcbiAgICAgIHJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AgKGZ1biAoKSAtPlxuICAgICAgICBydW5fY2FsbGJhY2tzIGNhbGxiYWNrcyByZXN1bHQpXG5cbiAgbGV0IHJlc29sdmUgP2FsbG93X2RlZmVycmluZyA/bWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoIHAgcmVzdWx0ID1cbiAgICBsZXQgUGVuZGluZyBjYWxsYmFja3MgPSBwLnN0YXRlIGluXG4gICAgbGV0IHAgPSBzZXRfcHJvbWlzZV9zdGF0ZSBwIHJlc3VsdCBpblxuXG4gICAgcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtXG4gICAgICA/YWxsb3dfZGVmZXJyaW5nID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGggY2FsbGJhY2tzIHJlc3VsdDtcblxuICAgIHBcblxuICBsZXQgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICA/KHJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbCA9IGZhbHNlKVxuICAgICAgfmNhbGxiYWNrOmZcbiAgICAgIH5pZl9kZWZlcnJlZCA9XG5cbiAgICBpZiBydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGwgdGhlblxuICAgICAgZiAoKVxuXG4gICAgZWxzZVxuICAgICAgbGV0IHNob3VsZF9kZWZlciA9XG4gICAgICAgICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGhcbiAgICAgICAgICA+PSBkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgICAgaW5cblxuICAgICAgaWYgc2hvdWxkX2RlZmVyIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IGltbWVkaWF0ZV9yZXN1bHQsIGRlZmVycmVkX2NhbGxiYWNrLCBkZWZlcnJlZF9yZXN1bHQgPVxuICAgICAgICAgIGlmX2RlZmVycmVkICgpIGluXG4gICAgICAgIGxldCBkZWZlcnJlZF9yZWNvcmQgPVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlZ3VsYXJfY2FsbGJhY2tzID1cbiAgICAgICAgICAgICAgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFja1xuICAgICAgICAgICAgICAgIGRlZmVycmVkX2NhbGxiYWNrO1xuICAgICAgICAgICAgY2FuY2VsX2NhbGxiYWNrcyA9IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5O1xuICAgICAgICAgICAgaG93X3RvX2NhbmNlbCA9IE5vdF9jYW5jZWxhYmxlO1xuICAgICAgICAgICAgY2xlYW51cHNfZGVmZXJyZWQgPSAwXG4gICAgICAgICAgfVxuICAgICAgICBpblxuICAgICAgICBRdWV1ZS5wdXNoXG4gICAgICAgICAgKERlZmVycmVkIChkZWZlcnJlZF9yZWNvcmQsIGRlZmVycmVkX3Jlc3VsdCkpIGRlZmVycmVkX2NhbGxiYWNrcztcbiAgICAgICAgaW1tZWRpYXRlX3Jlc3VsdFxuICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIHJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AgKGZ1biAoKSAtPlxuICAgICAgICAgIGYgKCkpXG5lbmRcbmluY2x1ZGUgUmVzb2x1dGlvbl9sb29wXG5cblxuXG5tb2R1bGUgUmVzb2x2aW5nIDpcbnNpZ1xuICB2YWwgd2FrZXVwX2xhdGVyX3Jlc3VsdCA6ICdhIHUgLT4gKCdhLCBleG4pIHJlc3VsdCAtPiB1bml0XG4gIHZhbCB3YWtldXBfbGF0ZXIgOiAnYSB1IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHdha2V1cF9sYXRlcl9leG4gOiBfIHUgLT4gZXhuIC0+IHVuaXRcblxuICB2YWwgd2FrZXVwX3Jlc3VsdCA6ICdhIHUgLT4gKCdhLCBleG4pIHJlc3VsdCAtPiB1bml0XG4gIHZhbCB3YWtldXAgOiAnYSB1IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHdha2V1cF9leG4gOiBfIHUgLT4gZXhuIC0+IHVuaXRcblxuICB2YWwgY2FuY2VsIDogJ2EgdCAtPiB1bml0XG5lbmQgPVxuc3RydWN0XG4gICgqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRldmlhdGVzIGZyb20gdGhlIFwiaWRlYWxcIiBjYWxsYmFjayBkZWZlcnJhbFxuICAgICBiZWhhdmlvcjogaXQgcnVucyBjYWxsYmFja3MgZGlyZWN0bHkgb24gdGhlIGN1cnJlbnQgc3RhY2suIEl0IHNob3VsZFxuICAgICB0aGVyZWZvcmUgYmUgcG9zc2libGUgdG8gY2F1c2UgYSBzdGFjayBvdmVyZmxvdyB1c2luZyB0aGlzIGZ1bmN0aW9uLiAqKVxuICBsZXQgd2FrZXVwX2dlbmVyYWwgYXBpX2Z1bmN0aW9uX25hbWUgciByZXN1bHQgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcmVzb2x2ZXIgciBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IFJlamVjdGVkIENhbmNlbGVkIC0+XG4gICAgICAoKVxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3QuJXNcIiBhcGlfZnVuY3Rpb25fbmFtZVxuXG4gICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgIGxldCByZXN1bHQgPSBzdGF0ZV9vZl9yZXN1bHQgcmVzdWx0IGluXG4gICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID0gcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAgcmVzdWx0IGluXG4gICAgICBpZ25vcmUgcFxuXG4gIGxldCB3YWtldXBfcmVzdWx0IHIgcmVzdWx0ID0gd2FrZXVwX2dlbmVyYWwgXCJ3YWtldXBfcmVzdWx0XCIgciByZXN1bHRcbiAgbGV0IHdha2V1cCByIHYgPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cFwiIHIgKE9rIHYpXG4gIGxldCB3YWtldXBfZXhuIHIgZXhuID0gd2FrZXVwX2dlbmVyYWwgXCJ3YWtldXBfZXhuXCIgciAoRXJyb3IgZXhuKVxuXG4gIGxldCB3YWtldXBfbGF0ZXJfZ2VuZXJhbCBhcGlfZnVuY3Rpb25fbmFtZSByIHJlc3VsdCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9yZXNvbHZlciByIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT5cbiAgICAgICgpXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHJlc3VsdCA9IHN0YXRlX29mX3Jlc3VsdCByZXN1bHQgaW5cbiAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICByZXNvbHZlIH5tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6MSBwIHJlc3VsdCBpblxuICAgICAgaWdub3JlIHBcblxuICBsZXQgd2FrZXVwX2xhdGVyX3Jlc3VsdCByIHJlc3VsdCA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJfcmVzdWx0XCIgciByZXN1bHRcbiAgbGV0IHdha2V1cF9sYXRlciByIHYgPVxuICAgIHdha2V1cF9sYXRlcl9nZW5lcmFsIFwid2FrZXVwX2xhdGVyXCIgciAoT2sgdilcbiAgbGV0IHdha2V1cF9sYXRlcl9leG4gciBleG4gPVxuICAgIHdha2V1cF9sYXRlcl9nZW5lcmFsIFwid2FrZXVwX2xhdGVyX2V4blwiIHIgKEVycm9yIGV4bilcblxuXG5cbiAgdHlwZSBwYWNrZWRfY2FsbGJhY2tzID1cbiAgICB8IFBhY2tlZCA6IF8gY2FsbGJhY2tzIC0+IHBhY2tlZF9jYWxsYmFja3NcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gICgqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRldmlhdGVzIGZyb20gdGhlIFwiaWRlYWxcIiBjYWxsYmFjayBkZWZlcnJhbFxuICAgICBiZWhhdmlvcjogaXQgcnVucyBjYWxsYmFja3MgZGlyZWN0bHkgb24gdGhlIGN1cnJlbnQgc3RhY2suIEl0IHNob3VsZFxuICAgICB0aGVyZWZvcmUgYmUgcG9zc2libGUgdG8gY2F1c2UgYSBzdGFjayBvdmVyZmxvdyB1c2luZyB0aGlzIGZ1bmN0aW9uLiAqKVxuICBsZXQgY2FuY2VsIHAgPVxuICAgIGxldCBjYW5jZWxlZF9yZXN1bHQgPSBSZWplY3RlZCBDYW5jZWxlZCBpblxuXG4gICAgKCogV2Fsa3MgdGhlIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaCBiYWNrd2FyZHMsIGxvb2tpbmcgZm9yIGNhbmNlbGFibGVcbiAgICAgICBpbml0aWFsIHByb21pc2VzLCBhbmQgY2FuY2VscyAob25seSkgdGhlbS5cblxuICAgICAgIEZvdW5kIGluaXRpYWwgcHJvbWlzZXMgYXJlIGNhbmNlbGVkIGltbWVkaWF0ZWx5LCBhcyB0aGV5IGFyZSBmb3VuZCwgYnlcbiAgICAgICBzZXR0aW5nIHRoZWlyIHN0YXRlIHRvIFtSZWplY3RlZCBDYW5jZWxlZF0uIFRoaXMgaXMgdG8gcHJldmVudCB0aGVtIGZyb21cbiAgICAgICBiZWluZyBcImZvdW5kIHR3aWNlXCIgaWYgdGhleSBhcmUgcmVhY2hhYmxlIGJ5IHR3byBvciBtb3JlIGRpc3RpbmN0IHBhdGhzXG4gICAgICAgdGhyb3VnaCB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IGdyYXBoLlxuXG4gICAgICAgVGhlIGNhbGxiYWNrcyBvZiB0aGVzZSBpbml0aWFsIHByb21pc2VzIGFyZSB0aGVuIHJ1biwgaW4gYSBzZXBhcmF0ZVxuICAgICAgIHBoYXNlLiBUaGVzZSBjYWxsYmFja3MgcHJvcGFnYXRlIGNhbmNlbGxhdGlvbiBmb3J3YXJkcyB0byBhbnkgZGVwZW5kZW50XG4gICAgICAgcHJvbWlzZXMuIFNlZSBcIkNhbmNlbGxhdGlvblwiIGluIHRoZSBPdmVydmlldy4gKilcbiAgICBsZXQgcHJvcGFnYXRlX2NhbmNlbCA6IChfLCBfLCBfKSBwcm9taXNlIC0+IHBhY2tlZF9jYWxsYmFja3MgbGlzdCA9XG4gICAgICAgIGZ1biBwIC0+XG4gICAgICBsZXQgcmVjIGNhbmNlbF9hbmRfY29sbGVjdF9jYWxsYmFja3MgOlxuICAgICAgICAgICdhICd1ICdjLiBwYWNrZWRfY2FsbGJhY2tzIGxpc3QgLT4gKCdhLCAndSwgJ2MpIHByb21pc2UgLT5cbiAgICAgICAgICAgIHBhY2tlZF9jYWxsYmFja3MgbGlzdCA9XG4gICAgICAgICAgZnVuICh0eXBlIGMpIGNhbGxiYWNrc19hY2N1bXVsYXRvciAocCA6IChfLCBfLCBjKSBwcm9taXNlKSAtPlxuXG4gICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgICAgICAoKiBJZiB0aGUgcHJvbWlzZSBpcyBub3Qgc3RpbGwgcGVuZGluZywgaXQgY2FuJ3QgYmUgY2FuY2VsZWQuICopXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICBjYWxsYmFja3NfYWNjdW11bGF0b3JcbiAgICAgICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAgICAgY2FsbGJhY2tzX2FjY3VtdWxhdG9yXG5cbiAgICAgICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPlxuICAgICAgICAgIG1hdGNoIGNhbGxiYWNrcy5ob3dfdG9fY2FuY2VsIHdpdGhcbiAgICAgICAgICB8IE5vdF9jYW5jZWxhYmxlIC0+XG4gICAgICAgICAgICBjYWxsYmFja3NfYWNjdW11bGF0b3JcbiAgICAgICAgICB8IENhbmNlbF90aGlzX3Byb21pc2UgLT5cbiAgICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgICAgICBzZXRfcHJvbWlzZV9zdGF0ZSBwIGNhbmNlbGVkX3Jlc3VsdCBpblxuICAgICAgICAgICAgaWdub3JlIHA7XG4gICAgICAgICAgICAoUGFja2VkIGNhbGxiYWNrcyk6OmNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCcgLT5cbiAgICAgICAgICAgIGNhbmNlbF9hbmRfY29sbGVjdF9jYWxsYmFja3MgY2FsbGJhY2tzX2FjY3VtdWxhdG9yIHAnXG4gICAgICAgICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMgLT5cbiAgICAgICAgICAgIExpc3QuZm9sZF9sZWZ0IGNhbmNlbF9hbmRfY29sbGVjdF9jYWxsYmFja3MgY2FsbGJhY2tzX2FjY3VtdWxhdG9yIHBzXG4gICAgICBpblxuICAgICAgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBbXSBwXG4gICAgaW5cblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IGNhbGxiYWNrcyA9IHByb3BhZ2F0ZV9jYW5jZWwgcCBpblxuXG4gICAgY2FsbGJhY2tzIHw+IExpc3QuaXRlciAoZnVuIChQYWNrZWQgY2FsbGJhY2tzKSAtPlxuICAgICAgcnVuX2NhbGxiYWNrc19vcl9kZWZlcl90aGVtXG4gICAgICAgIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgY2FsbGJhY2tzIGNhbmNlbGVkX3Jlc3VsdClcbmVuZFxuaW5jbHVkZSBSZXNvbHZpbmdcblxuXG5cbm1vZHVsZSBUcml2aWFsX3Byb21pc2VzIDpcbnNpZ1xuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICB2YWwgZmFpbCA6IGV4biAtPiBfIHRcbiAgdmFsIG9mX3Jlc3VsdCA6ICgnYSwgZXhuKSByZXN1bHQgLT4gJ2EgdFxuXG4gIHZhbCByZXR1cm5fdW5pdCA6IHVuaXQgdFxuICB2YWwgcmV0dXJuX3RydWUgOiBib29sIHRcbiAgdmFsIHJldHVybl9mYWxzZSA6IGJvb2wgdFxuICB2YWwgcmV0dXJuX25vbmUgOiBfIG9wdGlvbiB0XG4gIHZhbCByZXR1cm5fc29tZSA6ICdhIC0+ICdhIG9wdGlvbiB0XG4gIHZhbCByZXR1cm5fb2sgOiAnYSAtPiAoJ2EsIF8pIHJlc3VsdCB0XG4gIHZhbCByZXR1cm5fZXJyb3IgOiAnZSAtPiAoXywgJ2UpIHJlc3VsdCB0XG4gIHZhbCByZXR1cm5fbmlsIDogXyBsaXN0IHRcblxuICB2YWwgZmFpbF93aXRoIDogc3RyaW5nIC0+IF8gdFxuICB2YWwgZmFpbF9pbnZhbGlkX2FyZyA6IHN0cmluZyAtPiBfIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgbGV0IHJldHVybiB2ID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBGdWxmaWxsZWQgdn1cblxuICBsZXQgb2ZfcmVzdWx0IHJlc3VsdCA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gc3RhdGVfb2ZfcmVzdWx0IHJlc3VsdH1cblxuICBsZXQgZmFpbCBleG4gPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IFJlamVjdGVkIGV4bn1cblxuICBsZXQgcmV0dXJuX3VuaXQgPSByZXR1cm4gKClcbiAgbGV0IHJldHVybl9ub25lID0gcmV0dXJuIE5vbmVcbiAgbGV0IHJldHVybl9zb21lIHggPSByZXR1cm4gKFNvbWUgeClcbiAgbGV0IHJldHVybl9uaWwgPSByZXR1cm4gW11cbiAgbGV0IHJldHVybl90cnVlID0gcmV0dXJuIHRydWVcbiAgbGV0IHJldHVybl9mYWxzZSA9IHJldHVybiBmYWxzZVxuICBsZXQgcmV0dXJuX29rIHggPSByZXR1cm4gKE9rIHgpXG4gIGxldCByZXR1cm5fZXJyb3IgeCA9IHJldHVybiAoRXJyb3IgeClcblxuICBsZXQgZmFpbF93aXRoIG1zZyA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKEZhaWx1cmUgbXNnKX1cblxuICBsZXQgZmFpbF9pbnZhbGlkX2FyZyBtc2cgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IFJlamVjdGVkIChJbnZhbGlkX2FyZ3VtZW50IG1zZyl9XG5lbmRcbmluY2x1ZGUgVHJpdmlhbF9wcm9taXNlc1xuXG5cblxubW9kdWxlIFBlbmRpbmdfcHJvbWlzZXMgOlxuc2lnXG4gICgqIEludGVybmFsICopXG4gIHZhbCBuZXdfcGVuZGluZyA6XG4gICAgaG93X3RvX2NhbmNlbDpob3dfdG9fY2FuY2VsIC0+ICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZVxuICB2YWwgcHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIDogXyB0IGxpc3QgLT4gaG93X3RvX2NhbmNlbFxuXG4gICgqIEluaXRpYWwgcGVuZGluZyBwcm9taXNlcyAocHVibGljKSAqKVxuICB2YWwgd2FpdCA6IHVuaXQgLT4gJ2EgdCAqICdhIHVcbiAgdmFsIHRhc2sgOiB1bml0IC0+ICdhIHQgKiAnYSB1XG5cbiAgdmFsIGFkZF90YXNrX3IgOiAnYSB1IEx3dF9zZXF1ZW5jZS50IC0+ICdhIHRcbiAgdmFsIGFkZF90YXNrX2wgOiAnYSB1IEx3dF9zZXF1ZW5jZS50IC0+ICdhIHRcblxuICB2YWwgcHJvdGVjdGVkIDogJ2EgdCAtPiAnYSB0XG4gIHZhbCBub19jYW5jZWwgOiAnYSB0IC0+ICdhIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgbGV0IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsID1cbiAgICBsZXQgc3RhdGUgPVxuICAgICAgUGVuZGluZyB7XG4gICAgICAgIHJlZ3VsYXJfY2FsbGJhY2tzID0gUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5O1xuICAgICAgICBjYW5jZWxfY2FsbGJhY2tzID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgIGhvd190b19jYW5jZWw7XG4gICAgICAgIGNsZWFudXBzX2RlZmVycmVkID0gMDtcbiAgICAgIH1cbiAgICBpblxuICAgIHtzdGF0ZX1cblxuICBsZXQgcHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzID1cbiAgICAoKiBVc2luZyBhIGRpcnR5IGNhc3QgaGVyZSB0byBhdm9pZCByZWJ1aWxkaW5nIHRoZSBsaXN0IDooIE5vdCBib3RoZXJpbmdcbiAgICAgICB3aXRoIHRoZSBpbnZhcmlhbnRzLCBiZWNhdXNlIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdIHBhY2tzIHRoZW0sXG4gICAgICAgYW5kIGNvZGUgdGhhdCBtYXRjaGVzIG9uIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdIGRvZXNuJ3QgY2FyZSBhYm91dFxuICAgICAgIHRoZW0gYW55d2F5LiAqKVxuICAgIGxldCBjYXN0X3Byb21pc2VfbGlzdCA6ICdhIHQgbGlzdCAtPiAoJ2EsIF8sIF8pIHByb21pc2UgbGlzdCA9IE9iai5tYWdpYyBpblxuICAgIFByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCAoY2FzdF9wcm9taXNlX2xpc3QgcHMpXG5cblxuXG4gIGxldCB3YWl0ICgpID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOk5vdF9jYW5jZWxhYmxlIGluXG4gICAgdG9fcHVibGljX3Byb21pc2UgcCwgdG9fcHVibGljX3Jlc29sdmVyIHBcblxuICBsZXQgdGFzayAoKSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG4gICAgdG9fcHVibGljX3Byb21pc2UgcCwgdG9fcHVibGljX3Jlc29sdmVyIHBcblxuXG5cblxuICBsZXQgY2FzdF9zZXF1ZW5jZV9ub2RlXG4gICAgICAobm9kZSA6ICdhIHUgTHd0X3NlcXVlbmNlLm5vZGUpXG4gICAgICAoX2FjdHVhbF9jb250ZW50OignYSwgJ3UsICdjKSBwcm9taXNlKVxuICAgICAgICA6ICgnYSwgJ3UsICdjKSBwcm9taXNlIEx3dF9zZXF1ZW5jZS5ub2RlID1cbiAgICBPYmoubWFnaWMgbm9kZVxuXG4gIGxldCBhZGRfdGFza19yIHNlcXVlbmNlID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOkNhbmNlbF90aGlzX3Byb21pc2UgaW5cbiAgICBsZXQgbm9kZSA9IEx3dF9zZXF1ZW5jZS5hZGRfciAodG9fcHVibGljX3Jlc29sdmVyIHApIHNlcXVlbmNlIGluXG4gICAgbGV0IG5vZGUgPSBjYXN0X3NlcXVlbmNlX25vZGUgbm9kZSBwIGluXG5cbiAgICBsZXQgUGVuZGluZyBjYWxsYmFja3MgPSBwLnN0YXRlIGluXG4gICAgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MgPC1cbiAgICAgIENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGU7XG5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgbGV0IGFkZF90YXNrX2wgc2VxdWVuY2UgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuICAgIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9sICh0b19wdWJsaWNfcmVzb2x2ZXIgcCkgc2VxdWVuY2UgaW5cbiAgICBsZXQgbm9kZSA9IGNhc3Rfc2VxdWVuY2Vfbm9kZSBub2RlIHAgaW5cblxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyA8LVxuICAgICAgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgbm9kZTtcblxuICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuXG5cbiAgbGV0IHByb3RlY3RlZCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IHBcbiAgICB8IFJlamVjdGVkIF8gLT4gcFxuXG4gICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgIGxldCBwJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOkNhbmNlbF90aGlzX3Byb21pc2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJyA9IG1heV9ub3dfYmVfcHJveHkgcCcgaW5cbiAgICAgICAgbGV0IHAnID0gdW5kZXJseWluZyBwJyBpblxuICAgICAgICAoKiBJbiB0aGlzIGNhbGxiYWNrLCBbcCddIHdpbGwgZWl0aGVyIHN0aWxsIGl0c2VsZiBiZSBwZW5kaW5nLCBvciBpdFxuICAgICAgICAgICB3aWxsIGhhdmUgYmVjb21lIGEgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLiBUaGUgcmVhc29uaW5nIGZvclxuICAgICAgICAgICB0aGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBpbiB0aGUgY29tbWVudCBhdCBbbWF5X25vd19iZV9wcm94eV0uIFRoZVxuICAgICAgICAgICBkaWZmZXJlbmNlcyBhcmU6XG5cbiAgICAgICAgICAgLSBbcCddICppcyogYW4gaW5pdGlhbCBwcm9taXNlLCBzbyBpdCAqY2FuKiBnZXQgY2FuY2VsZWQuIEhvd2V2ZXIsIGlmXG4gICAgICAgICAgICAgaXQgZG9lcywgdGhlIFtvbl9jYW5jZWxdIGhhbmRsZXIgaW5zdGFsbGVkIGJlbG93IHdpbGwgcmVtb3ZlIHRoaXNcbiAgICAgICAgICAgICBjYWxsYmFjay5cbiAgICAgICAgICAgLSBbcCddIG5ldmVyIGdldHMgcGFzc2VkIHRvIFttYWtlX2ludG9fcHJveHldLCB0aGUgb25seSBlZmZlY3Qgb2ZcbiAgICAgICAgICAgICB3aGljaCBpcyB0aGF0IGl0IGNhbm5vdCBiZSB0aGUgdW5kZXJseWluZyBwcm9taXNlIG9mIGFub3RoZXJcbiAgICAgICAgICAgICAocHJveHkpIHByb21pc2UuIFNvLCBbcCddIGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgaGVhZCBvZiBhIGNoYWluIG9mXG4gICAgICAgICAgICAgW1Byb3h5IF9dIGxpbmtzLCBhbmQgaXQncyBub3QgbmVjZXNzYXJ5IHRvIHdvcnJ5IGFib3V0IHdoZXRoZXIgdGhlXG4gICAgICAgICAgICAgaW5kdWN0aXZlIHJlYXNvbmluZyBhdCBbbWF5X25vd19iZV9wcm94eV0gYXBwbGllcy4gKilcblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJyA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnIHBfcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwJ1xuICAgICAgaW5cblxuICAgICAgbGV0IHJlbW92ZV90aGVfY2FsbGJhY2sgPVxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfcmVtb3ZlX2Z1bmN0aW9uXG4gICAgICAgICAgW3BdIGNhbGxiYWNrXG4gICAgICBpblxuXG4gICAgICBsZXQgUGVuZGluZyBwJ19jYWxsYmFja3MgPSBwJy5zdGF0ZSBpblxuICAgICAgYWRkX2NhbmNlbF9jYWxsYmFjayBwJ19jYWxsYmFja3MgcmVtb3ZlX3RoZV9jYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcCdcblxuICBsZXQgbm9fY2FuY2VsIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT4gcFxuICAgIHwgUmVqZWN0ZWQgXyAtPiBwXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBwJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOk5vdF9jYW5jZWxhYmxlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcgPSBtYXlfbm93X2JlX3Byb3h5IHAnIGluXG4gICAgICAgIGxldCBwJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgICAgKCogSW4gdGhpcyBjYWxsYmFjaywgW3AnXSB3aWxsIGVpdGhlciBzdGlsbCBpdHNlbGYgYmUgcGVuZGluZywgb3IgaXRcbiAgICAgICAgICAgd2lsbCBoYXZlIGJlY29tZSBhIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS4gVGhlIHJlYXNvbmluZyBmb3JcbiAgICAgICAgICAgdGhpcyBpcyBhcyBpbiBbcHJvdGVjdGVkXSBhbmQgW21heV9ub3dfYmVfcHJveHldLCBidXQgZXZlbiBzaW1wbGVyLFxuICAgICAgICAgICBiZWNhdXNlIFtwJ10gaXMgbm90IGNhbmNlbGFibGUuICopXG5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJyBwX3Jlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcCdcbiAgICAgIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwJ1xuZW5kXG5pbmNsdWRlIFBlbmRpbmdfcHJvbWlzZXNcblxuXG5cbm1vZHVsZSBTZXF1ZW50aWFsX2NvbXBvc2l0aW9uIDpcbnNpZ1xuICAoKiBNYWluIGludGVyZmFjZSAocHVibGljKSAqKVxuICB2YWwgYmluZCA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcbiAgdmFsIG1hcCA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gIGV4dGVybmFsIHJlcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyZXJhaXNlXCJcbiAgdmFsIGNhdGNoIDogKHVuaXQgLT4gJ2EgdCkgLT4gKGV4biAtPiAnYSB0KSAtPiAnYSB0XG4gIHZhbCBmaW5hbGl6ZSA6ICh1bml0IC0+ICdhIHQpIC0+ICh1bml0IC0+IHVuaXQgdCkgLT4gJ2EgdFxuICB2YWwgdHJ5X2JpbmQgOiAodW5pdCAtPiAnYSB0KSAtPiAoJ2EgLT4gJ2IgdCkgLT4gKGV4biAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgKCogQ2FuY2VsIGNhbGxiYWNrcyAocHVibGljKS4gKilcbiAgdmFsIG9uX2NhbmNlbCA6ICdhIHQgLT4gKHVuaXQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqIE5vbi1wcm9taXNlIGNhbGxiYWNrcyAocHVibGljKSAqKVxuICB2YWwgb25fc3VjY2VzcyA6ICdhIHQgLT4gKCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX2ZhaWx1cmUgOiBfIHQgLT4gKGV4biAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBvbl90ZXJtaW5hdGlvbiA6IF8gdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBvbl9hbnkgOiAnYSB0IC0+ICgnYSAtPiB1bml0KSAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiBCYWNrdHJhY2Ugc3VwcG9ydCAoaW50ZXJuYWw7IGZvciB1c2UgYnkgdGhlIFBQWCkgKilcbiAgdmFsIGJhY2t0cmFjZV9iaW5kIDpcbiAgICAoZXhuIC0+IGV4bikgLT4gJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICB2YWwgYmFja3RyYWNlX2NhdGNoIDpcbiAgICAoZXhuIC0+IGV4bikgLT4gKHVuaXQgLT4gJ2EgdCkgLT4gKGV4biAtPiAnYSB0KSAtPiAnYSB0XG4gIHZhbCBiYWNrdHJhY2VfZmluYWxpemUgOlxuICAgIChleG4gLT4gZXhuKSAtPiAodW5pdCAtPiAnYSB0KSAtPiAodW5pdCAtPiB1bml0IHQpIC0+ICdhIHRcbiAgdmFsIGJhY2t0cmFjZV90cnlfYmluZCA6XG4gICAgKGV4biAtPiBleG4pIC0+ICh1bml0IC0+ICdhIHQpIC0+ICgnYSAtPiAnYiB0KSAtPiAoZXhuIC0+ICdiIHQpIC0+ICdiIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogVGhlcmUgYXJlIGZpdmUgcHJpbWFyeSBzZXF1ZW50aWFsIGNvbXBvc2l0aW9uIGZ1bmN0aW9uczogW2JpbmRdLCBbbWFwXSxcbiAgICAgW2NhdGNoXSwgW2ZpbmFsaXplXSwgYW5kIFt0cnlfYmluZF0uIE9mIHRoZXNlLCBbdHJ5X2JpbmRdIGlzIHRoZSBtb3N0XG4gICAgIGdlbmVyYWwgLS0gYWxsIHRoZSBvdGhlcnMgY2FuIGJlIGltcGxlbWVudGVkIGluIHRlcm1zIG9mIGl0LlxuXG4gICAgIEx3dCBjb25mbGF0ZXMgY29uY3VycmVuY3kgd2l0aCBlcnJvciBwcm9wYWdhdGlvbi4gSWYgTHd0IGRpZCBub3QgZG8gdGhpcyxcbiAgICAgdGhlcmUgd291bGQgYmUgb25seSB0d28gcHJpbWFyeSBmdW5jdGlvbnM6IFtiaW5kXSBhbmQgW21hcF0sIGFuZCwgb2YgdGhlc2VcbiAgICAgdHdvLCBbYmluZF0gaXMgdGhlIG1vc3QgZ2VuZXJhbC4gU2luY2UgW2JpbmRdIGlzIHRoZSBtb3N0IHJlbGV2YW50XG4gICAgIHNwZWNpZmljYWxseSB0byBjb25jdXJyZW5jeSwgYW5kIGlzIGFsc28gdGhlIG1vc3QgZmFtaWxpYXIgZnVuY3Rpb24gaW4gTHd0LFxuICAgICBpdHMgaW1wbGVtZW50YXRpb24gc2VydmVzIGFzIGEga2luZCBvZiBcIm1vZGVsXCIgZm9yIHRoZSByZXN0LiBJdCBpcyB0aGUgbW9zdFxuICAgICBjb21tZW50ZWQsIGFuZCBhbGwgdGhlIG90aGVyIGZ1bmN0aW9ucyBmb2xsb3cgYSBzaW1pbGFyIHBhdHRlcm4gdG8gW2JpbmRdLlxuXG4gICAgIEZvdXIgb2YgdGhlIHByaW1hcnkgZnVuY3Rpb25zIGhhdmUgW2JhY2t0cmFjZV8qXSB2ZXJzaW9ucywgd2hpY2ggYXJlIG5vdFxuICAgICB0cnVseSBwdWJsaWMsIGFuZCBleGlzdCB0byBzdXBwb3J0IHRoZSBQUFguIFtiYWNrdHJhY2VfbWFwXSBkb2VzIG5vdCBleGlzdFxuICAgICBiZWNhdXNlIHRoZSBQUFggZG9lcyBub3QgbmVlZCBpdC5cblxuICAgICBUaGUgcmVtYWluaW5nIGZvdXIgZnVuY3Rpb25zIGluIHRoaXMgc2VjdGlvbiBhdHRhY2ggXCJsb3dlci1sZXZlbC1pc2hcIlxuICAgICBub24tcHJvbWlzZS1wcm9kdWNpbmcgY2FsbGJhY2tzIHRvIHByb21pc2VzOiB0aGVzZSBhcmUgdGhlIFtvbl8qXVxuICAgICBmdW5jdGlvbnMuIE9mIHRoZXNlLCBbb25fYW55XSBpcyB0aGUgbW9zdCBnZW5lcmFsLiBJZiBMd3QgZGlkIG5vdCBjb25mbGF0ZVxuICAgICBjb25jdXJyZW5jeSB3aXRoIGVycm9yIGhhbmRsaW5nLCB0aGVyZSB3b3VsZCBvbmx5IGJlIG9uZTogW29uX3N1Y2Nlc3NdLiAqKVxuXG5cblxuICAoKiBNYWtlcyBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gaW50byBhIHByb3h5IG9mIFt+b3V0ZXJfcHJvbWlzZV0uIEFmdGVyXG4gICAgIFttYWtlX2ludG9fcHJveHldLCB0aGVzZSB0d28gcHJvbWlzZSByZWZlcmVuY2VzIFwiYmVoYXZlIGlkZW50aWNhbGx5LlwiXG5cbiAgICAgTm90ZSB0aGF0IHRoaXMgaXMgbm90IHN5bW1ldHJpYzogW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gYWx3YXlzIGJlY29tZXMgdGhlXG4gICAgIHByb3h5LiBbbWFrZV9pbnRvX3Byb3h5XSBpcyBjYWxsZWQgb25seSBieSBbYmluZF0gYW5kIHNpbWlsYXIgZnVuY3Rpb25zIGluXG4gICAgIHRoaXMgbW9kdWxlLiBUaGlzIG1lYW5zIHRoYXQ6XG5cbiAgICAgLSB0aGUgb25seSB3YXkgZm9yIGEgcHJvbWlzZSB0byBiZWNvbWUgYSBwcm94eSBpcyBieSBiZWluZyByZXR1cm5lZCBmcm9tXG4gICAgICAgdGhlIGNhbGxiYWNrIGdpdmVuIGJ5IHRoZSB1c2VyIHRvIFtiaW5kXSwgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uLCBhbmRcbiAgICAgLSB0aGUgb25seSB3YXkgZm9yIGEgcHJvbWlzZSB0byBiZWNvbWUgdW5kZXJseWluZyBmb3IgYSBwcm9taXNlIG90aGVyIHRoYW5cbiAgICAgICBpdHNlbGYgaXMgdG8gYmUgdGhlIG91dGVyIHByb21pc2Ugb3JpZ2luYWxseSByZXR1cm5lZCB0byB0aGUgdXNlciBmcm9tXG4gICAgICAgW2JpbmRdLCBvciBhIHNpbWlsYXIgZnVuY3Rpb24uXG5cbiAgICAgVGhlc2UgdHdvIGZhY3RzIGFyZSBpbXBvcnRhbnQgZm9yIHJlYXNvbmluZyBhYm91dCBob3cgYW5kIHdoaWNoIHByb21pc2VzXG4gICAgIGNhbiBiZWNvbWUgcHJveGllcywgdW5kZXJseWluZywgZXRjLjsgaW4gcGFydGljdWxhciwgaXQgaXMgdXNlZCBpbiB0aGVcbiAgICAgYXJndW1lbnQgaW4gW21heV9ub3dfYmVfcHJveHldIGZvciBjb3JyZWN0IHByZWRpY3Rpb25zIGFib3V0IHN0YXRlIGNoYW5nZXMuXG5cbiAgICAgW35vdXRlcl9wcm9taXNlXSBpcyBhbHdheXMgYSBwZW5kaW5nIHByb21pc2Ugd2hlbiBbbWFrZV9pbnRvX3Byb3h5XSBpc1xuICAgICBjYWxsZWQ7IGZvciB0aGUgZXhwbGFuYXRpb24sIHNlZSBbbWF5X25vd19iZV9wcm94eV0gKHRob3VnaCB0aGUgY2FsbGVyIG9mXG4gICAgIFttYWtlX2ludG9fcHJveHldIGFsd2F5cyBjYWxscyBbdW5kZXJseWluZ10gZmlyc3QgdG8gcGFzcyB0aGUgdW5kZXJseWluZ1xuICAgICBwZW5kaW5nIHByb21pc2UgdG8gW21ha2VfaW50b19wcm94eV0pLlxuXG4gICAgIFRoZSByZWFzb25zIHByb3h5aW5nIGlzIHVzZWQsIGluc3RlYWQgb2YgYWRkaW5nIGEgY2FsbGJhY2sgdG9cbiAgICAgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIHRvIHJlc29sdmUgW35vdXRlcl9wcm9taXNlXSB3aGVuIHRoZSBmb3JtZXJcbiAgICAgYmVjb21lcyByZXNvbHZlZCBwcm9iYWJseSBhcmU6XG5cbiAgICAgLSBQcm9taXNlcyBoYXZlIG1vcmUgYmVoYXZpb3JzIHRoYW4gcmVzb2x1dGlvbi4gT25lIHdvdWxkIGhhdmUgdG8gYWRkIGFcbiAgICAgICBjYW5jZWxsYXRpb24gaGFuZGxlciB0byBbfm91dGVyX3Byb21pc2VdIHRvIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uXG4gICAgICAgYmFjayB0byBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0sIGZvciBleGFtcGxlLiBJdCBtYXkgYmUgZWFzaWVyIHRvIGp1c3RcbiAgICAgICB0aGluayBvZiB0aGVtIGFzIHRoZSBzYW1lIHByb21pc2UuXG4gICAgIC0gSWYgdXNpbmcgY2FsbGJhY2tzLCByZXNvbHZpbmcgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIHdvdWxkIG5vdFxuICAgICAgIGltbWVkaWF0ZWx5IHJlc29sdmUgW35vdXRlcl9wcm9taXNlXS4gQW5vdGhlciBjYWxsYmFjayBhZGRlZCB0b1xuICAgICAgIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSBtaWdodCBzZWUgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIHJlc29sdmVkLFxuICAgICAgIGJ1dCBbfm91dGVyX3Byb21pc2VdIHN0aWxsIHBlbmRpbmcsIGRlcGVuZGluZyBvbiB0aGUgb3JkZXIgaW4gd2hpY2hcbiAgICAgICBjYWxsYmFja3MgYXJlIHJ1bi4gKilcbiAgbGV0IG1ha2VfaW50b19wcm94eVxuICAgICAgKHR5cGUgYylcbiAgICAgIH4ob3V0ZXJfcHJvbWlzZSA6ICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSlcbiAgICAgIH4odXNlcl9wcm92aWRlZF9wcm9taXNlIDogKCdhLCBfLCBjKSBwcm9taXNlKVxuICAgICAgICA6ICgnYSwgdW5kZXJseWluZywgYykgc3RhdGVfY2hhbmdlZCA9XG5cbiAgICAoKiBVc2luZyBbcCddIGFzIGl0J3MgdGhlIG5hbWUgdXNlZCBpbnNpZGUgW2JpbmRdLCBldGMuLCBmb3IgcHJvbWlzZXMgd2l0aFxuICAgICAgIHRoaXMgcm9sZSAtLSBbcCddIGlzIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSB1c2VyJ3MgZnVuY3Rpb24uICopXG4gICAgbGV0IHAnID0gdW5kZXJseWluZyB1c2VyX3Byb3ZpZGVkX3Byb21pc2UgaW5cblxuICAgIGlmIGlkZW50aWNhbCBwJyBvdXRlcl9wcm9taXNlIHRoZW5cbiAgICAgIFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCdcbiAgICAgICgqIFdlIHJlYWxseSB3YW50IHRvIHJldHVybiBbU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBvdXRlcl9wcm9taXNlXSwgYnV0XG4gICAgICAgICB0aGUgcmVmZXJlbmNlIHRocm91Z2ggW3AnXSBoYXMgdGhlIHJpZ2h0IHR5cGUuICopXG5cbiAgICBlbHNlXG4gICAgICBtYXRjaCBwJy5zdGF0ZSB3aXRoXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBvdXRlcl9wcm9taXNlIHAnLnN0YXRlXG4gICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIG91dGVyX3Byb21pc2UgcCcuc3RhdGVcblxuICAgICAgfCBQZW5kaW5nIHAnX2NhbGxiYWNrcyAtPlxuICAgICAgICBsZXQgUGVuZGluZyBvdXRlcl9jYWxsYmFja3MgPSBvdXRlcl9wcm9taXNlLnN0YXRlIGluXG5cbiAgICAgICAgbWVyZ2VfY2FsbGJhY2tzIH5mcm9tOnAnX2NhbGxiYWNrcyB+aW50bzpvdXRlcl9jYWxsYmFja3M7XG4gICAgICAgIG91dGVyX2NhbGxiYWNrcy5ob3dfdG9fY2FuY2VsIDwtIHAnX2NhbGxiYWNrcy5ob3dfdG9fY2FuY2VsO1xuXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICBzZXRfcHJvbWlzZV9zdGF0ZSBwJyAoUHJveHkgb3V0ZXJfcHJvbWlzZSkgaW5cbiAgICAgICAgaWdub3JlIHAnO1xuXG4gICAgICAgIFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb3V0ZXJfcHJvbWlzZVxuICAgICAgICAoKiBUaGUgc3RhdGUgaGFzbid0IGFjdHVhbGx5IGNoYW5nZWQsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIHdyYXBcbiAgICAgICAgICAgW291dGVyX3Byb21pc2VdIGZvciB0eXBlIGNoZWNraW5nLiAqKVxuXG4gICAgICAgICgqIFRoZSBzdGF0ZSBvZiBbcCddIG1heSBpbnN0ZWFkIGhhdmUgY2hhbmdlZCAtLSBpdCBtYXkgaGF2ZSBiZWNvbWUgYVxuICAgICAgICAgICBwcm94eS4gSG93ZXZlciwgY2FsbGVycyBvZiBbbWFrZV9pbnRvX3Byb3h5XSBkb24ndCBrbm93IGlmXG4gICAgICAgICAgIFt1c2VyX3Byb3ZpZGVkX3Byb21pc2VdIHdhcyBhIHByb3h5IG9yIG5vdCAodGhhdCdzIHdoeSB3ZSBjYWxsXG4gICAgICAgICAgIHVuZGVybHlpbmcgb24gaXQgYXQgdGhlIHRvcCBvZiB0aGlzIGZ1bmN0aW9uLCB0byBnZXQgW3AnXSkuIFdlIGNhblxuICAgICAgICAgICB0aGVyZWZvcmUgdGFrZSBhIGRhbmdlcm91cyBzaG9ydGN1dCBhbmQgbm90IGJvdGhlciByZXR1cm5pbmcgYSBuZXdcbiAgICAgICAgICAgcmVmZXJlbmNlIHRvIFt1c2VyX3Byb3ZpZGVkX3Byb21pc2VdIGZvciBzaGFkb3dpbmcuICopXG5cblxuXG4gICgqIE1haW50YWluZXIncyBub3RlOiBhIGxvdCBvZiB0aGUgY29kZSBiZWxvdyBjYW4gcHJvYmFibHkgYmUgZGVkdXBsaWNhdGVkIGluXG4gICAgIHNvbWUgd2F5LCBlc3BlY2lhbGx5IGlmIGFzc3VtaW5nIEZsYW1iZGEuICopXG5cbiAgbGV0IGJpbmQgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICAoKiBJbiBjYXNlIFtMd3QuYmluZF0gbmVlZHMgdG8gZGVmZXIgdGhlIGNhbGwgdG8gW2ZdLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmVcbiAgICAgICBjYWxsZWQgdG8gY3JlYXRlOlxuXG4gICAgICAgMS4gVGhlIHByb21pc2UsIFtwJyddLCB0aGF0IG11c3QgYmUgcmV0dXJuZWQgdG8gdGhlIGNhbGxlciBpbW1lZGlhdGVseS5cbiAgICAgICAyLiBUaGUgY2FsbGJhY2sgdGhhdCByZXNvbHZlcyBbcCcnXS5cblxuICAgICAgIFtMd3QuYmluZF0gZGVmZXJzIHRoZSBjYWxsIHRvIFtmXSBpbiB0d28gY2lyY3Vtc3RhbmNlczpcblxuICAgICAgIDEuIFRoZSBwcm9taXNlIFtwXSBpcyBwZW5kaW5nLlxuICAgICAgIDIuIFRoZSBwcm9taXNlIFtwXSBpcyBmdWxmaWxsZWQsIGJ1dCB0aGUgY3VycmVudCBjYWxsYmFjayBjYWxsIG5lc3RpbmdcbiAgICAgICAgICBkZXB0aCBpcyBzdWNoIHRoYXQgdGhlIGNhbGwgdG8gW2ZdIG11c3QgZ28gaW50byB0aGUgY2FsbGJhY2sgcXVldWUsIGluXG4gICAgICAgICAgb3JkZXIgdG8gYXZvaWQgc3RhY2sgb3ZlcmZsb3cuXG5cbiAgICAgIE1lY2hhbmlzbSAoMikgaXMgY3VycmVudGx5IGRpc2FibGVkLiBJdCBtYXkgYmUgdXNlZCBpbiBhbiBhbHRlcm5hdGl2ZSBMd3RcbiAgICAgIEFQSS5cblxuICAgICAgRnVuY3Rpb25zIG90aGVyIHRoYW4gW0x3dC5iaW5kXSBoYXZlIGFuYWxvZ291cyBkZWZlcnJhbCBiZWhhdmlvci4gKilcbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG4gICAgICAoKiBUaGUgcmVzdWx0IHByb21pc2UgaXMgYSBmcmVzaCBwZW5kaW5nIHByb21pc2UuXG5cbiAgICAgICAgIEluaXRpYWxseSwgdHJ5aW5nIHRvIGNhbmNlbCB0aGlzIGZyZXNoIHBlbmRpbmcgcHJvbWlzZSBbcCcnXSB3aWxsXG4gICAgICAgICBwcm9wYWdhdGUgdGhlIGNhbmNlbGxhdGlvbiBhdHRlbXB0IHRvIFtwXSAoYmFja3dhcmRzIHRocm91Z2ggdGhlXG4gICAgICAgICBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGgpLiBJZi93aGVuIFtwXSBpcyBmdWxmaWxsZWQsIEx3dCB3aWxsIGNhbGwgdGhlXG4gICAgICAgICB1c2VyJ3MgY2FsbGJhY2sgW2ZdIGJlbG93LCB3aGljaCB3aWxsIHByb3ZpZGUgYSBuZXcgcHJvbWlzZSBbcCddLCBhbmRcbiAgICAgICAgIFtwJ10gd2lsbCBiZWNvbWUgYSBwcm94eSBvZiBbcCcnXS4gQXQgdGhhdCBwb2ludCwgdHJ5aW5nIHRvIGNhbmNlbFxuICAgICAgICAgW3AnJ10gd2lsbCBiZSBlcXVpdmFsZW50IHRvIHRyeWluZyB0byBjYW5jZWwgW3AnXSwgc28gdGhlIGJlaGF2aW9yIHdpbGxcbiAgICAgICAgIGRlcGVuZCBvbiBob3cgdGhlIHVzZXIgb2J0YWluZWQgW3AnXS4gKilcblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmIHYgd2l0aCBleG5cbiAgICAgICAgICAgIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG4gICAgICAgICAgKCogUnVuIHRoZSB1c2VyJ3MgZnVuY3Rpb24gW2ZdLiAqKVxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuICAgICAgICAgICgqIFtwJyddIHdhcyBhbiB1bmRlcmx5aW5nIHByb21pc2Ugd2hlbiBpdCB3YXMgY3JlYXRlZCBhYm92ZSwgYnV0IGl0XG4gICAgICAgICAgICAgbWF5IGhhdmUgYmVjb21lIGEgcHJveHkgYnkgdGhlIHRpbWUgdGhpcyBjb2RlIGlzIGJlaW5nIGV4ZWN1dGVkLlxuICAgICAgICAgICAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIGVpdGhlciBhbiB1bmRlcmx5aW5nIHBlbmRpbmcgcHJvbWlzZSwgb3IgYVxuICAgICAgICAgICAgIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS4gVGhlcmVmb3JlLCBbbWF5X25vd19iZV9wcm94eV0gcHJvZHVjZXNcbiAgICAgICAgICAgICBhIHJlZmVyZW5jZSB3aXRoIHRoZSByaWdodCB0eXBlIHZhcmlhYmxlcy4gV2UgaW1tZWRpYXRlbHkgZ2V0XG4gICAgICAgICAgICAgW3AnJ10ncyBjdXJyZW50IHVuZGVybHlpbmcgcHJvbWlzZS4gKilcblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICAgICAgKCogTWFrZSB0aGUgb3V0ZXIgcHJvbWlzZSBbcCcnXSBiZWhhdmlvcmFsbHkgaWRlbnRpY2FsIHRvIHRoZSBwcm9taXNlXG4gICAgICAgICAgICAgW3AnXSByZXR1cm5lZCBieSBbZl0gYnkgbWFraW5nIFtwJ10gaW50byBhIHByb3h5IG9mIFtwJyddLiAqKVxuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHBfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX2JpbmQgYWRkX2xvYyBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmIHZcbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICAgICAgICAgIGZhaWwgKGFkZF9sb2MgZXhuKSBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyAoUmVqZWN0ZWQgKGFkZF9sb2MgZXhuKSkgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IFJlamVjdGVkIChhZGRfbG9jIGV4bil9XG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgbGV0IG1hcCBmIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnJ19yZXN1bHQgPVxuICAgICAgICAgICAgdHJ5IEZ1bGZpbGxlZCAoZiB2KSB3aXRoIGV4blxuICAgICAgICAgICAgd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gUmVqZWN0ZWQgZXhuXG4gICAgICAgICAgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHAnJ19yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlXG4gICAgICAgICAgICB7c3RhdGUgPVxuICAgICAgICAgICAgICB0cnkgRnVsZmlsbGVkIChmIHYpXG4gICAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IFJlamVjdGVkIGV4bn0pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGV4dGVybmFsIHJlcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyZXJhaXNlXCJcblxuICBsZXQgY2F0Y2ggZiBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHBfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGggZXhuXG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoIGV4bilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgbGV0IGJhY2t0cmFjZV9jYXRjaCBhZGRfbG9jIGYgaCA9XG4gICAgbGV0IHAgPVxuICAgICAgdHJ5IGYgKClcbiAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBoIGV4blxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICAgICAgICAgZmFpbCAoYWRkX2xvYyBleG4pXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggKGFkZF9sb2MgZXhuKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgbGV0IHRyeV9iaW5kIGYgZicgaCA9XG4gICAgbGV0IHAgPVxuICAgICAgdHJ5IGYgKClcbiAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgZicgdlxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gZicgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoIGV4bilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgbGV0IGJhY2t0cmFjZV90cnlfYmluZCBhZGRfbG9jIGYgZicgaCA9XG4gICAgbGV0IHAgPVxuICAgICAgdHJ5IGYgKClcbiAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgcCcnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KFByb3BhZ2F0ZV9jYW5jZWxfdG9fb25lIHApIGluXG5cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBtYXRjaCBwX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgZicgdlxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICAgICAgICAgZmFpbCAoYWRkX2xvYyBleG4pXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGggZXhuXG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmJyB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggKGFkZF9sb2MgZXhuKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgbGV0IGZpbmFsaXplIGYgZicgPVxuICAgIHRyeV9iaW5kIGZcbiAgICAgIChmdW4geCAtPiBiaW5kIChmJyAoKSkgKGZ1biAoKSAtPiByZXR1cm4geCkpXG4gICAgICAoZnVuIGUgLT4gYmluZCAoZicgKCkpIChmdW4gKCkgLT4gZmFpbCBlKSlcblxuICBsZXQgYmFja3RyYWNlX2ZpbmFsaXplIGFkZF9sb2MgZiBmJyA9XG4gICAgYmFja3RyYWNlX3RyeV9iaW5kIGFkZF9sb2MgZlxuICAgICAgKGZ1biB4IC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IHJldHVybiB4KSlcbiAgICAgIChmdW4gZSAtPiBiaW5kIChmJyAoKSkgKGZ1biAoKSAtPiBmYWlsIChhZGRfbG9jIGUpKSlcblxuXG5cbiAgbGV0IG9uX2NhbmNlbCBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICAoKCksIChmdW4gXyAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKSwgRnVsZmlsbGVkICgpKSlcblxuICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgKClcblxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG5cbiAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+XG4gICAgICBhZGRfY2FuY2VsX2NhbGxiYWNrIGNhbGxiYWNrcyBmXG5cblxuXG4gIGxldCBvbl9zdWNjZXNzIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBmdW4gcmVzdWx0IC0+XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHZcblxuICAgICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICAgICAoKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG4gIGxldCBvbl9mYWlsdXJlIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBmdW4gcmVzdWx0IC0+XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICAoKVxuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiBleG5cbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX3Rlcm1pbmF0aW9uIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBmdW4gX3Jlc3VsdCAtPlxuICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCkpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG4gIGxldCBvbl9hbnkgcCBmIGcgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSA9XG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgZnVuIHJlc3VsdCAtPlxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2XG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBnIGV4blxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZyBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcbmVuZFxuaW5jbHVkZSBTZXF1ZW50aWFsX2NvbXBvc2l0aW9uXG5cblxuKCogVGhpcyBiZWxvbmdzIHdpdGggdGhlIFtwcm90ZWN0ZWRdIGFuZCBzdWNoLCBidXQgaXQgZGVwZW5kcyBvbiBwcmltaXRpdmVzIGZyb21cbiAgIFtTZXF1ZW50aWFsX2NvbXBvc2l0aW9uXS4gKilcbmxldCB3cmFwX2luX2NhbmNlbGFibGUgcCA9XG4gbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiBsZXQgcF91bmRlcmx5aW5nID0gdW5kZXJseWluZyBwX2ludGVybmFsIGluXG4gbWF0Y2ggcF91bmRlcmx5aW5nLnN0YXRlIHdpdGhcbiB8IEZ1bGZpbGxlZCBfIC0+IHBcbiB8IFJlamVjdGVkIF8gLT4gcFxuIHwgUGVuZGluZyBfIC0+XG4gICBsZXQgcCcsIHIgPSB0YXNrICgpIGluXG4gICBvbl9jYW5jZWwgcCcgKGZ1biAoKSAtPiBjYW5jZWwgcCk7XG4gICBvbl9hbnkgcCAod2FrZXVwIHIpICh3YWtldXBfZXhuIHIpO1xuICAgcCdcblxuXG5tb2R1bGUgQ29uY3VycmVudF9jb21wb3NpdGlvbiA6XG5zaWdcbiAgdmFsIGRvbnRfd2FpdCA6ICh1bml0IC0+IF8gdCkgLT4gKGV4biAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBhc3luYyA6ICh1bml0IC0+IF8gdCkgLT4gdW5pdFxuICB2YWwgaWdub3JlX3Jlc3VsdCA6IF8gdCAtPiB1bml0XG5cbiAgdmFsIGJvdGggOiAnYSB0IC0+ICdiIHQgLT4gKCdhICogJ2IpIHRcbiAgdmFsIGpvaW4gOiB1bml0IHQgbGlzdCAtPiB1bml0IHRcbiAgdmFsIGFsbCA6ICgnYSB0KSBsaXN0IC0+ICgnYSBsaXN0KSB0XG5cbiAgdmFsIGNob29zZSA6ICdhIHQgbGlzdCAtPiAnYSB0XG4gIHZhbCBwaWNrIDogJ2EgdCBsaXN0IC0+ICdhIHRcblxuICB2YWwgbmNob29zZSA6ICdhIHQgbGlzdCAtPiAnYSBsaXN0IHRcbiAgdmFsIG5waWNrIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuXG4gIHZhbCBuY2hvb3NlX3NwbGl0IDogJ2EgdCBsaXN0IC0+ICgnYSBsaXN0ICogJ2EgdCBsaXN0KSB0XG5lbmQgPVxuc3RydWN0XG4gIGV4dGVybmFsIHJlcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyZXJhaXNlXCJcblxuICBsZXQgZG9udF93YWl0IGYgaCA9XG4gICAgbGV0IHAgPVxuICAgICAgdHJ5IGYgKClcbiAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIGggZXhuXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgICAgKClcbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBoIGV4blxuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgYXN5bmMgZiA9XG4gICAgbGV0IHAgPVxuICAgICAgdHJ5IGYgKClcbiAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgaW5cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICFhc3luY19leGNlcHRpb25faG9vayBleG5cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICAoKVxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgICFhc3luY19leGNlcHRpb25faG9vayBleG5cbiAgICAgIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IGlnbm9yZV9yZXN1bHQgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICByZXJhaXNlIGV4blxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuXG5cbiAgbGV0IGpvaW4gcHMgPVxuICAgIGxldCBwJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICBsZXQgbnVtYmVyX3BlbmRpbmdfaW5fcHMgPSByZWYgMCBpblxuICAgIGxldCBqb2luX3Jlc3VsdCA9IHJlZiAoRnVsZmlsbGVkICgpKSBpblxuXG4gICAgKCogQ2FsbGJhY2sgYXR0YWNoZWQgdG8gZWFjaCBwcm9taXNlIGluIFtwc10gdGhhdCBpcyBzdGlsbCBwZW5kaW5nIGF0IHRoZVxuICAgICAgIHRpbWUgW2pvaW5dIGlzIGNhbGxlZC4gKilcbiAgICBsZXQgY2FsbGJhY2sgbmV3X3Jlc3VsdCA9XG4gICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnID0gbWF5X25vd19iZV9wcm94eSBwJyBpblxuXG4gICAgICBiZWdpbiBtYXRjaCBuZXdfcmVzdWx0IHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkICgpIC0+ICgpXG4gICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICgqIEZvciB0aGUgZmlyc3QgcHJvbWlzZSBpbiBbcHNdIHRvIGJlIHJlamVjdGVkLCBzZXQgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgICAgIFtqb2luXSB0byByZWplY3RlZCB3aXRoIHRoZSBzYW1lIGV4Y2VwdGlvbi4uICopXG4gICAgICAgIG1hdGNoICFqb2luX3Jlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkICgpIC0+IGpvaW5fcmVzdWx0IDo9IG5ld19yZXN1bHRcbiAgICAgICAgfCBSZWplY3RlZCBfIC0+ICgpXG4gICAgICBlbmQ7XG5cbiAgICAgICgqIEluIGFsbCBjYXNlcywgZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcHJvbWlzZXMgc3RpbGwgcGVuZGluZywgYW5kXG4gICAgICAgICByZXNvbHZlIHRoZSBbam9pbl0gb25jZSBhbGwgcHJvbWlzZXMgcmVzb2x2ZS4gKilcbiAgICAgIG51bWJlcl9wZW5kaW5nX2luX3BzIDo9ICFudW1iZXJfcGVuZGluZ19pbl9wcyAtIDE7XG4gICAgICBpZiAhbnVtYmVyX3BlbmRpbmdfaW5fcHMgPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHAnID0gdW5kZXJseWluZyBwJyBpblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJyA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlICh1bmRlcmx5aW5nIHAnKSAham9pbl9yZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHAnXG4gICAgICBlbmRcbiAgICBpblxuXG4gICAgKCogQXR0YWNoIHRoZSBhYm92ZSBjYWxsYmFjay4gU2ltdWx0YW5lb3VzbHkgY291bnQgaG93IG1hbnkgcGVuZGluZyBwcm9taXNlc1xuICAgICAgIHRoZXJlIGFyZSBpbiBbcHNdIChpbml0aWFsbHkpLiBJZiB0aGF0IG51bWJlciBpcyB6ZXJvLCB0aGUgW2pvaW5dIG11c3RcbiAgICAgICByZXNvbHZlIGltbWVkaWF0ZWx5LiAqKVxuICAgIGxldCByZWMgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHMgPVxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBpZiAhbnVtYmVyX3BlbmRpbmdfaW5fcHMgPSAwIHRoZW5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSAham9pbl9yZXN1bHR9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwJ1xuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgICAgICBudW1iZXJfcGVuZGluZ19pbl9wcyA6PSAhbnVtYmVyX3BlbmRpbmdfaW5fcHMgKyAxO1xuICAgICAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICAgICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICAoKiBBcyBpbiB0aGUgY2FsbGJhY2sgYWJvdmUsIGJ1dCBmb3IgYWxyZWFkeS1yZXNvbHZlZCBwcm9taXNlcyBpblxuICAgICAgICAgICAgIFtwc106IHJlamVjdCB0aGUgW2pvaW5dIHdpdGggdGhlIHNhbWUgZXhjZXB0aW9uIGFzIGluIHRoZSBmaXJzdFxuICAgICAgICAgICAgIHJlamVjdGVkIHByb21pc2UgZm91bmQuIFtqb2luXSBzdGlsbCB3YWl0cyBmb3IgYW55IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgICAgICAgICBiZWZvcmUgYWN0dWFsbHkgcmVzb2x2aW5nLCB0aG91Z2guICopXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggIWpvaW5fcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IEZ1bGZpbGxlZCAoKSAtPiBqb2luX3Jlc3VsdCA6PSBwX3Jlc3VsdDtcbiAgICAgICAgICB8IFJlamVjdGVkIF8gLT4gKClcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcblxuICAgICAgICB8IEZ1bGZpbGxlZCAoKSAtPlxuICAgICAgICAgIGF0dGFjaF9jYWxsYmFja19vcl9yZXNvbHZlX2ltbWVkaWF0ZWx5IHBzXG4gICAgaW5cblxuICAgIGF0dGFjaF9jYWxsYmFja19vcl9yZXNvbHZlX2ltbWVkaWF0ZWx5IHBzXG5cbiAgKCogdGhpcyBpcyAzIHdvcmRzLCBzbWFsbGVyIHRoYW4gdGhlIDIgdGltZXMgMiB3b3JkcyBhIHBhaXIgb2YgcmVmZXJlbmNlc1xuICAgICB3b3VsZCB0YWtlLiAqKVxuICB0eXBlICgnYSwnYikgcGFpciA9IHtcbiAgICBtdXRhYmxlIHgxOiAnYSBvcHRpb247XG4gICAgbXV0YWJsZSB4MjogJ2Igb3B0aW9uO1xuICB9XG5cbiAgbGV0IGJvdGggcDEgcDIgPVxuICAgIGxldCBwYWlyID0ge3gxID0gTm9uZTsgeDIgPSBOb25lfSBpblxuICAgIGxldCBwMScgPSBiaW5kIHAxIChmdW4gdiAtPiBwYWlyLngxIDwtIFNvbWUgdjsgcmV0dXJuX3VuaXQpIGluXG4gICAgbGV0IHAyJyA9IGJpbmQgcDIgKGZ1biB2IC0+IHBhaXIueDIgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkgaW5cbiAgICBqb2luIFtwMSc7IHAyJ10gfD4gbWFwIChmdW4gKCkgLT5cbiAgICAgIG1hdGNoIHBhaXIueDEsIHBhaXIueDIgd2l0aFxuICAgICAgfCBTb21lIHYxLCBTb21lIHYyIC0+IHYxLCB2MlxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcblxuICBsZXQgYWxsIHBzID1cbiAgICBtYXRjaCBwcyB3aXRoXG4gICAgfCBbXSAtPiByZXR1cm5fbmlsXG4gICAgfCBbeF0gLT4gbWFwIChmdW4geSAtPiBbeV0pIHhcbiAgICB8IFt4OyB5XSAtPiBtYXAgKGZ1biAoeCwgeSkgLT4gW3g7IHldKSAoYm90aCB4IHkpXG4gICAgfCBfIC0+XG4gICAgICBsZXQgdnMgPSBBcnJheS5tYWtlIChMaXN0Lmxlbmd0aCBwcykgTm9uZSBpblxuICAgICAgcHNcbiAgICAgIHw+IExpc3QubWFwaSAoZnVuIGluZGV4IHAgLT5cbiAgICAgICAgYmluZCBwIChmdW4gdiAtPiB2cy4oaW5kZXgpIDwtIFNvbWUgdjsgcmV0dXJuX3VuaXQpKVxuICAgICAgfD4gam9pblxuICAgICAgfD4gbWFwIChmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgcmVjIHRvX2xpc3RfdW5vcHQgaSBhY2MgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgICBhY2NcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggQXJyYXkudW5zYWZlX2dldCB2cyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgICB8IFNvbWUgeCAtPiB0b19saXN0X3Vub3B0IChpIC0gMSkgKHg6OmFjYylcbiAgICAgICAgICBpblxuICAgICAgICAgIHRvX2xpc3RfdW5vcHQgKEFycmF5Lmxlbmd0aCB2cyAtIDEpIFtdKVxuXG4gICgqIE1haW50YWluZXIncyBub3RlOiB0aGUgbmV4dCBmZXcgZnVuY3Rpb25zIGFyZSBoZWxwZXJzIGZvciBbY2hvb3NlXSBhbmRcbiAgICAgW3BpY2tdLiBQZXJoYXBzIHRoZXkgc2hvdWxkIGJlIGZhY3RvcmVkIGludG8gc29tZSBraW5kIG9mIGdlbmVyaWNcbiAgICAgW2Nob29zZV0vW3BpY2tdIGltcGxlbWVudGF0aW9uLCB3aGljaCBtYXkgYWN0dWFsbHkgYmUgb3B0aW1hbCBhbnl3YXkgd2l0aFxuICAgICBGbGFtYmRhLiAqKVxuXG4gIGxldCBjb3VudF9yZXNvbHZlZF9wcm9taXNlc19pbiAocHMgOiAnYSB0IGxpc3QpID1cbiAgICBsZXQgcmVjIGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgdG90YWwgcmVqZWN0ZWQgcHMgPVxuICAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgICB8IFtdIC0+IEVycm9yICh0b3RhbCwgcmVqZWN0ZWQpXG4gICAgICAgfCBwIDo6IHBzIC0+XG4gICAgICAgICAgICBsZXQgSW50ZXJuYWwgcSA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcSkuc3RhdGUgd2l0aFxuICAgICAgICAgICAgfCBGdWxmaWxsZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIHRvdGFsIHJlamVjdGVkIHBzXG4gICAgICAgICAgICB8IFJlamVjdGVkIF8gLT4gY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCAodG90YWwgKyAxKSAocCA6OiByZWplY3RlZCkgcHNcbiAgICAgICAgICAgIHwgUGVuZGluZyBfIC0+IGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgdG90YWwgcmVqZWN0ZWQgcHNcbiAgICBpblxuICAgIGxldCByZWMgY291bnRfZnVsZmlsbGVkIHRvdGFsIHBzID1cbiAgICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICAgfCBbXSAtPiBPayB0b3RhbFxuICAgICAgIHwgcCA6OiBwcyAtPlxuICAgICAgICAgICAgbGV0IEludGVybmFsIHEgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHEpLnN0YXRlIHdpdGhcbiAgICAgICAgICAgIHwgRnVsZmlsbGVkIF8gLT4gY291bnRfZnVsZmlsbGVkICh0b3RhbCArIDEpIHBzXG4gICAgICAgICAgICB8IFJlamVjdGVkIF8gLT4gY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCAxIFtwXSBwc1xuICAgICAgICAgICAgfCBQZW5kaW5nIF8gLT4gY291bnRfZnVsZmlsbGVkIHRvdGFsIHBzXG4gICAgaW5cbiAgICBjb3VudF9mdWxmaWxsZWQgMCBwc1xuXG4gICgqIEV2YWx1YXRlcyB0byB0aGUgW25ddGggcHJvbWlzZSBpbiBbcHNdLCBhbW9uZyBvbmx5IHRob3NlIHByb21pc2VzIGluIFtwc11cbiAgICAgdGhhdCBhcmUgcmVzb2x2ZWQuIFRoZSBjYWxsZXIgaXMgZXhwZWN0ZWQgdG8gZW5zdXJlIHRoYXQgdGhlcmUgYXJlIGF0XG4gICAgIGxlYXN0IFtuXSByZXNvbHZlZCBwcm9taXNlcyBpbiBbcHNdLiAqKVxuICBsZXQgcmVjIG50aF9yZXNvbHZlZCAocHMgOiAnYSB0IGxpc3QpIChuIDogaW50KSA6ICdhIHQgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuICAgIHwgcDo6cHMgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCcpLnN0YXRlIHdpdGhcbiAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgIG50aF9yZXNvbHZlZCBwcyBuXG5cbiAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgaWYgbiA8PSAwIHRoZW4gcFxuICAgICAgICBlbHNlIG50aF9yZXNvbHZlZCBwcyAobiAtIDEpXG4gICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICAgaWYgbiA8PSAwIHRoZW4gcFxuICAgICAgICBlbHNlIG50aF9yZXNvbHZlZCBwcyAobiAtIDEpXG5cbiAgKCogTGlrZSBbbnRoX3Jlc29sdmVkXSwgYnV0IGNhbmNlbHMgYWxsIHBlbmRpbmcgcHJvbWlzZXMgZm91bmQgd2hpbGVcbiAgICAgdHJhdmVyc2luZyBbcHNdLiAqKVxuICBsZXQgcmVjIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgKHBzIDogJ2EgdCBsaXN0KSAobiA6IGludCkgOiAnYSB0ID1cbiAgICBtYXRjaCBwcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICB8IHA6OnBzIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHAnKS5zdGF0ZSB3aXRoXG4gICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICBjYW5jZWwgcDtcbiAgICAgICAgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyBwcyBuXG5cbiAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgaWYgbiA8PSAwIHRoZW4gKExpc3QuaXRlciBjYW5jZWwgcHM7IHApXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyBwcyAobiAtIDEpXG4gICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICAgaWYgbiA8PSAwIHRoZW4gKExpc3QuaXRlciBjYW5jZWwgcHM7IHApXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyBwcyAobiAtIDEpXG5cbiAgKCogVGhlIFBSTkcgc3RhdGUgaXMgaW5pdGlhbGl6ZWQgd2l0aCBhIGNvbnN0YW50IHRvIG1ha2Ugbm9uLUlPLWJhc2VkIHByb2dyYW1zXG4gICAgIGRldGVybWluaXN0aWMuICopXG4gICgqIE1haW50YWluZXIncyBub3RlOiBpcyB0aGlzIG5lY2Vzc2FyeT8gKilcbiAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZSBbfHxdKVxuXG4gIGxldCBjaG9vc2UgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmdcbiAgICAgICAgXCJMd3QuY2hvb3NlIFtdIHdvdWxkIHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXJcIjtcbiAgICBtYXRjaCBjb3VudF9yZXNvbHZlZF9wcm9taXNlc19pbiBwcyB3aXRoXG4gICAgfCBPayAwIC0+XG4gICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW5cbiAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAgcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwXG4gICAgICBpblxuICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgIHwgT2sgMSAtPlxuICAgICAgbnRoX3Jlc29sdmVkIHBzIDBcblxuICAgIHwgT2sgbiAtPlxuICAgICAgbnRoX3Jlc29sdmVkIHBzIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cbiAgICB8IEVycm9yIChuLCBwcykgLT5cbiAgICAgIG50aF9yZXNvbHZlZCBwcyAoUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSBwcm5nKSBuKVxuXG4gIGxldCBwaWNrIHBzID1cbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiTHd0LnBpY2sgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIG1hdGNoIGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIHBzIHdpdGhcbiAgICB8IE9rIDAgLT5cbiAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHBcbiAgICAgIGluXG4gICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBPayAxIC0+XG4gICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIDBcblxuICAgIHwgT2sgbiAtPlxuICAgICAgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyBwc1xuICAgICAgICAoUmFuZG9tLlN0YXRlLmludCAoTGF6eS5mb3JjZSBwcm5nKSBuKVxuXG4gICAgfCBFcnJvciAobiwgcXMpIC0+XG4gICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgbnRoX3Jlc29sdmVkIHFzIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cblxuXG4gICgqIElmIFtuY2hvb3NlIHBzXSBvciBbbnBpY2sgcHNdIGZvdW5kIGFsbCBwcm9taXNlcyBpbiBbcHNdIHBlbmRpbmcsIHRoZVxuICAgICBjYWxsYmFjayBhZGRlZCB0byBlYWNoIHByb21pc2UgaW4gW3BzXSBldmVudHVhbGx5IGNhbGxzIHRoaXMgZnVuY3Rpb24uIFRoZVxuICAgICBmdW5jdGlvbiBjb2xsZWN0cyBwcm9taXNlcyBpbiBbcHNdIHRoYXQgaGF2ZSBiZWNvbWUgZnVsZmlsbGVkLCBvciBmaW5kcyBvbmVcbiAgICAgcHJvbWlzZSBpbiBbcHNdIHRoYXQgaGFzIGJlZW4gcmVqZWN0ZWQuIEl0IHRoZW4gcmV0dXJucyB0aGUgZGVzaXJlZCBzdGF0ZVxuICAgICBvZiB0aGUgZmluYWwgcHJvbWlzZTogZWl0aGVyIHRoZSBsaXN0IG9mIHJlc3VsdHMgY29sbGVjdGVkLCBvciB0aGVcbiAgICAgZXhjZXB0aW9uIGZvdW5kLiAqKVxuICBsZXQgcmVjIGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmdcbiAgICAgIChyZXN1bHRzIDogJ2EgbGlzdClcbiAgICAgIChwcyA6ICdhIHQgbGlzdCkgOlxuICAgICAgICAoJ2EgbGlzdCByZXNvbHZlZF9zdGF0ZSkgPVxuXG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIEZ1bGZpbGxlZCAoTGlzdC5yZXYgcmVzdWx0cylcblxuICAgIHwgcDo6cHMgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyAodjo6cmVzdWx0cykgcHNcblxuICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICByZXN1bHRcblxuICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyByZXN1bHRzIHBzXG5cbiAgbGV0IG5jaG9vc2UgcHMgPVxuICAgICgqIElmIGF0IGxlYXN0IG9uZSBwcm9taXNlIGluIFtwc10gaXMgZm91bmQgZnVsZmlsbGVkLCB0aGlzIGZ1bmN0aW9uIGlzXG4gICAgICAgY2FsbGVkIHRvIGZpbmQgYWxsIHN1Y2ggcHJvbWlzZXMuICopXG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ1xuICAgICAgICBcIkx3dC5uY2hvb3NlIFtdIHdvdWxkIHJldHVybiBhIHByb21pc2UgdGhhdCBpcyBwZW5kaW5nIGZvcmV2ZXJcIjtcbiAgICBsZXQgcmVjIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBhY2MgcHMgPVxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICByZXR1cm4gKExpc3QucmV2IGFjYylcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgKHY6OmFjYykgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwc1xuICAgIGluXG5cbiAgICAoKiBMb29rcyBmb3IgYWxyZWFkeS1yZXNvbHZlZCBwcm9taXNlcyBpbiBbcHNdLiBJZiBub25lIGFyZSBmdWxmaWxsZWQgb3JcbiAgICAgICByZWplY3RlZCwgYWRkcyBhIGNhbGxiYWNrIHRvIGFsbCBwcm9taXNlcyBpbiBbcHNdIChhbGwgb2Ygd2hpY2ggYXJlXG4gICAgICAgcGVuZGluZykuICopXG4gICAgbGV0IHJlYyBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwcycgPVxuICAgICAgbWF0Y2ggcHMnIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICAgIGxldCBjYWxsYmFjayBfcmVzdWx0ID1cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAgPSBtYXlfbm93X2JlX3Byb3h5IHAgaW5cbiAgICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICAgIGxldCByZXN1bHQgPSBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nIFtdIHBzIGluXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIFt2XSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBwc1xuICAgIGluXG5cbiAgICBsZXQgcCA9IGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzIGluXG4gICAgcFxuXG4gICgqIFNlZSBbbmNob29zZV0uIFRoaXMgZnVuY3Rpb24gZGlmZmVycyBvbmx5IGluIGhhdmluZyBhZGRpdGlvbmFsIGNhbGxzIHRvXG4gICAgIFtjYW5jZWxdLiAqKVxuICBsZXQgbnBpY2sgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJMd3QubnBpY2sgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIGxldCByZWMgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwcycgPVxuICAgICAgbWF0Y2ggcHMnIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgICAgcmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCAodjo6YWNjKSBwcydcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgTGlzdC5pdGVyIGNhbmNlbCBwcztcbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzJ1xuICAgIGluXG5cbiAgICBsZXQgcmVjIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgICAgbGV0IGNhbGxiYWNrIF9yZXN1bHQgPVxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmcgW10gcHMgaW5cbiAgICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAgcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHBcbiAgICAgICAgaW5cbiAgICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgICB8IHA6OnBzJyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgW3ZdIHBzJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzJ1xuICAgIGluXG5cbiAgICBsZXQgcCA9IGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzIGluXG4gICAgcFxuXG5cblxuICAoKiBTYW1lIGdlbmVyYWwgcGF0dGVybiBhcyBbbnBpY2tdIGFuZCBbbmNob29zZV0uICopXG4gIGxldCBuY2hvb3NlX3NwbGl0IHBzID1cbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnXG4gICAgICAgIFwiTHd0Lm5jaG9vc2Vfc3BsaXQgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIGxldCByZWMgZmluaXNoXG4gICAgICAgICh0b19yZXNvbHZlIDogKCdhIGxpc3QgKiAnYSB0IGxpc3QsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2UpXG4gICAgICAgIChmdWxmaWxsZWQgOiAnYSBsaXN0KVxuICAgICAgICAocGVuZGluZyA6ICdhIHQgbGlzdClcbiAgICAgICAgKHBzIDogJ2EgdCBsaXN0KVxuICAgICAgICAgIDogKCdhIGxpc3QgKiAnYSB0IGxpc3QsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZV9jaGFuZ2VkID1cblxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgdG9fcmVzb2x2ZVxuICAgICAgICAgIChGdWxmaWxsZWQgKExpc3QucmV2IGZ1bGZpbGxlZCwgTGlzdC5yZXYgcGVuZGluZykpXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgZmluaXNoIHRvX3Jlc29sdmUgKHY6OmZ1bGZpbGxlZCkgcGVuZGluZyBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgdG9fcmVzb2x2ZSByZXN1bHRcblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGZpbmlzaCB0b19yZXNvbHZlIGZ1bGZpbGxlZCAocDo6cGVuZGluZykgcHNcbiAgICBpblxuXG4gICAgbGV0IHJlYyBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcmVzdWx0cyBwZW5kaW5nIHBzID1cbiAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgKCogTWFpbnRhaW5lcidzIG5vdGU6IHNob3VsZCB0aGUgcGVuZGluZyBwcm9taXNlIGxpc3QgYWxzbyBiZVxuICAgICAgICAgICByZXZlcnNlZD8gSXQgaXMgcmV2ZXJzZWQgaW4gZmluaXNoLiAqKVxuICAgICAgICByZXR1cm4gKExpc3QucmV2IHJlc3VsdHMsIHBlbmRpbmcpXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzICh2OjpyZXN1bHRzKSBwZW5kaW5nIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyByZXN1bHRzIChwOjpwZW5kaW5nKSBwc1xuICAgIGluXG5cbiAgICBsZXQgcmVjIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBlbmRpbmdfYWNjIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgICAgbGV0IGNhbGxiYWNrIF9yZXN1bHQgPVxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9IGZpbmlzaCBwIFtdIFtdIHBzIGluXG4gICAgICAgICAgaWdub3JlIHBcbiAgICAgICAgaW5cbiAgICAgICAgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgY2FsbGJhY2s7XG5cbiAgICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgICB8IHA6OnBzJyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgW3ZdIHBlbmRpbmdfYWNjIHBzJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjaGVja19mb3JfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyAocDo6cGVuZGluZ19hY2MpIHBzJ1xuICAgIGluXG5cbiAgICBsZXQgcCA9IGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIFtdIHBzIGluXG4gICAgcFxuZW5kXG5pbmNsdWRlIENvbmN1cnJlbnRfY29tcG9zaXRpb25cblxuXG5cbm1vZHVsZSBNaXNjZWxsYW5lb3VzIDpcbnNpZ1xuICAoKiBQcm9taXNlIHN0YXRlIHF1ZXJ5ICopXG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgUmV0dXJuIG9mICdhXG4gICAgfCBGYWlsIG9mIGV4blxuICAgIHwgU2xlZXBcblxuICB2YWwgc3RhdGUgOiAnYSB0IC0+ICdhIHN0YXRlXG4gIHZhbCBpc19zbGVlcGluZyA6ICdhIHQgLT4gYm9vbFxuICB2YWwgZGVidWdfc3RhdGVfaXMgOiAnYSBzdGF0ZSAtPiAnYSB0IC0+IGJvb2wgdFxuXG4gICgqIEZ1bmN0aW9uIGxpZnRlcnMgKilcbiAgdmFsIGFwcGx5IDogKCdhIC0+ICdiIHQpIC0+ICdhIC0+ICdiIHRcblxuICB2YWwgd3JhcCA6XG4gICAgKHVuaXQgLT4gJ2IpIC0+XG4gICAgJ2IgdFxuICB2YWwgd3JhcDEgOlxuICAgICgnYTEgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYiB0KVxuICB2YWwgd3JhcDIgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdiIHQpXG4gIHZhbCB3cmFwMyA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYiB0KVxuICB2YWwgd3JhcDQgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYiB0KVxuICB2YWwgd3JhcDUgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdiIHQpXG4gIHZhbCB3cmFwNiA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdiKSAtPlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYiB0KVxuICB2YWwgd3JhcDcgOlxuICAgICgnYTEgLT4gJ2EyIC0+ICdhMyAtPiAnYTQgLT4gJ2E1IC0+ICdhNiAtPiAnYTcgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYiB0KVxuXG4gICgqIFBhdXNlZCBwcm9taXNlcyAqKVxuICB2YWwgcGF1c2UgOiB1bml0IC0+IHVuaXQgdFxuICB2YWwgd2FrZXVwX3BhdXNlZCA6IHVuaXQgLT4gdW5pdFxuICB2YWwgcGF1c2VkX2NvdW50IDogdW5pdCAtPiBpbnRcbiAgdmFsIHJlZ2lzdGVyX3BhdXNlX25vdGlmaWVyIDogKGludCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBhYmFuZG9uX3BhdXNlZCA6IHVuaXQgLT4gdW5pdFxuXG4gICgqIEludGVybmFsIGludGVyZmFjZSBmb3Igb3RoZXIgbW9kdWxlcyBpbiBMd3QgKilcbiAgdmFsIHBvbGwgOiAnYSB0IC0+ICdhIG9wdGlvblxuZW5kID1cbnN0cnVjdFxuICB0eXBlICdhIHN0YXRlID1cbiAgICB8IFJldHVybiBvZiAnYVxuICAgIHwgRmFpbCBvZiBleG5cbiAgICB8IFNsZWVwXG5cbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBzdGF0ZSBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+IFJldHVybiB2XG4gICAgfCBSZWplY3RlZCBleG4gLT4gRmFpbCBleG5cbiAgICB8IFBlbmRpbmcgXyAtPiBTbGVlcFxuXG4gIGxldCBkZWJ1Z19zdGF0ZV9pcyBleHBlY3RlZF9zdGF0ZSBwID1cbiAgICByZXR1cm4gKHN0YXRlIHAgPSBleHBlY3RlZF9zdGF0ZSlcblxuICBsZXQgaXNfc2xlZXBpbmcgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiBmYWxzZVxuICAgIHwgUmVqZWN0ZWQgXyAtPiBmYWxzZVxuICAgIHwgUGVuZGluZyBfIC0+IHRydWVcblxuICBsZXQgcG9sbCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IFJlamVjdGVkIGUgLT4gcmVyYWlzZSBlXG4gICAgfCBGdWxmaWxsZWQgdiAtPiBTb21lIHZcbiAgICB8IFBlbmRpbmcgXyAtPiBOb25lXG5cblxuXG4gIGxldCBhcHBseSBmIHggPVxuICAgIHRyeSBmIHggd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcCBmID1cbiAgICB0cnkgcmV0dXJuIChmICgpKVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAxIGYgeDEgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDIgZiB4MSB4MiA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MilcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwMyBmIHgxIHgyIHgzID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzKVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA0IGYgeDEgeDIgeDMgeDQgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDUgZiB4MSB4MiB4MyB4NCB4NSA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NCB4NSlcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwNiBmIHgxIHgyIHgzIHg0IHg1IHg2ID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzIHg0IHg1IHg2KVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA3IGYgeDEgeDIgeDMgeDQgeDUgeDYgeDcgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQgeDUgeDYgeDcpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuXG5cbiAgbGV0IHBhdXNlX2hvb2sgPSByZWYgaWdub3JlXG5cbiAgbGV0IHBhdXNlZCA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKClcbiAgbGV0IHBhdXNlZF9jb3VudCA9IHJlZiAwXG5cbiAgbGV0IHBhdXNlICgpID1cbiAgICBsZXQgcCA9IGFkZF90YXNrX3IgcGF1c2VkIGluXG4gICAgaW5jciBwYXVzZWRfY291bnQ7XG4gICAgIXBhdXNlX2hvb2sgIXBhdXNlZF9jb3VudDtcbiAgICBwXG5cbiAgbGV0IHdha2V1cF9wYXVzZWQgKCkgPVxuICAgIGlmIEx3dF9zZXF1ZW5jZS5pc19lbXB0eSBwYXVzZWQgdGhlblxuICAgICAgcGF1c2VkX2NvdW50IDo9IDBcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgdG1wID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSBpblxuICAgICAgTHd0X3NlcXVlbmNlLnRyYW5zZmVyX3IgcGF1c2VkIHRtcDtcbiAgICAgIHBhdXNlZF9jb3VudCA6PSAwO1xuICAgICAgTHd0X3NlcXVlbmNlLml0ZXJfbCAoZnVuIHIgLT4gd2FrZXVwIHIgKCkpIHRtcFxuICAgIGVuZFxuXG4gIGxldCByZWdpc3Rlcl9wYXVzZV9ub3RpZmllciBmID0gcGF1c2VfaG9vayA6PSBmXG5cbiAgbGV0IGFiYW5kb25fcGF1c2VkICgpID1cbiAgICBMd3Rfc2VxdWVuY2UuY2xlYXIgcGF1c2VkO1xuICAgIHBhdXNlZF9jb3VudCA6PSAwXG5cbiAgbGV0IHBhdXNlZF9jb3VudCAoKSA9ICFwYXVzZWRfY291bnRcbmVuZFxuaW5jbHVkZSBNaXNjZWxsYW5lb3VzXG5cbm1vZHVsZSBMZXRfc3ludGF4ID1cbnN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9XG4gIHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwIHQgfmYgPSBtYXAgZiB0XG4gICAgbGV0IGJpbmQgdCB+ZiA9IGJpbmQgdCBmXG4gICAgbGV0IGJvdGggPSBib3RoXG5cbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPVxuICAgIHN0cnVjdFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgSW5maXggPVxuc3RydWN0XG4gIGxldCAoPj49KSA9IGJpbmRcbiAgbGV0ICg9PDwpIGYgcCA9IGJpbmQgcCBmXG4gIGxldCAoPnw9KSBwIGYgPSBtYXAgZiBwXG4gIGxldCAoPXw8KSA9IG1hcFxuICBsZXQgKDwmPikgcCBwJyA9IGpvaW4gW3A7IHAnXVxuICBsZXQgKDw/PikgcCBwJyA9IGNob29zZSBbcDsgcCddXG5cbiAgaW5jbHVkZSBMZXRfc3ludGF4XG5lbmRcbmluY2x1ZGUgKCBJbmZpeCA6IG1vZHVsZSB0eXBlIG9mIEluZml4IHdpdGggbW9kdWxlIExldF9zeW50YXggOj0gTGV0X3N5bnRheC5MZXRfc3ludGF4IClcblxubW9kdWxlIFN5bnRheCA9XG5zdHJ1Y3RcbiAgbGV0IChsZXQqKSA9IGJpbmRcbiAgbGV0IChhbmQqKSA9IGJvdGhcblxuICBsZXQgKGxldCspIHggZiA9IG1hcCBmIHhcbiAgbGV0IChhbmQrKSA9IGJvdGhcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJMd3QiLCJTdGRsaWJfTGlzdCIsIk9mZiIsImNyZWF0ZSIsInBhcmFtIiwiaXNfb24iLCJzd2l0Y2giLCJjaGVjayIsImFkZF9ob29rIiwiaG9vayIsIm1hdGNoIiwib3MiLCJhZGRfaG9va19vcl9leGVjIiwidHVybl9vZmYiLCJob29rcyIsIndpdGhfc3dpdGNoIiwiZm4iLCJMd3Rfc3dpdGNoIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvbHd0L2x3dF9zd2l0Y2gubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLFlBQUFDLE9BQUFDLE9DaUJnQix3QkFBZ0M7QUFBQSxZQUFBQyxNQUFBQyxVQUc5QywwQkFFaUI7QUFBQSxZQUFBQyxNQUFBSDtBQUFBQSxJQUVQLDJCQUNrQjtBQUFBLElBQ087QUFBQSxHQUFFO0FBQUEsWUFBQUksU0FBQUYsVUFBQUc7QUFBQUEsSUFHckMsZUFNRTtBQUFBLFFBQUFDLFFBTkY7QUFBQSxnQkFJRTtBQUFBLFFBQUFDLEtBSkY7QUFBQSxJQUVFO0FBQUE7QUFBQSxHQUlFO0FBQUEsWUFBQUMsaUJBQUFOLFVBQUFHO0FBQUFBLElBR0osZUFPRTtBQUFBLFFBQUFDLFFBUEY7QUFBQSxnQkFLRSwwQkFFZTtBQUFBLFFBQUFDLEtBUGpCO0FBQUEsSUFFRTtBQUFBLElBQ0E7QUFBQSxHQUllO0FBQUEsWUFBQUUsU0FBQVA7QUFBQUEsUUFBQSxNQUdqQjtBQUFBLGNBS0U7QUFBQSxRQUFBUSxRQUxGO0FBQUEsSUFFRTtBQUFBO0FBQUE7QUFBQSxPQUNTO0FBQUE7QUFBQSxrQkFBQUwsTUFBdUIsbUNBQWlCO0FBQUE7QUFBQSxJQUFRLCtCQUUxQztBQUFBO0FBQUEsWUFBQU0sWUFBQUM7QUFBQUEsUUFBQVYsV0FHSjtBQUFBLElBQ2I7QUFBQTtBQUFBLHNCQUFBRixPQUNhLCtCQUFTO0FBQUEsc0JBQUFBLE9BQ1QseUJBQWUsR0FBQztBQUFBO0FBQUE7QUFBQSxJQUFBYTtBQUFBQSxNRDNEL0IiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuZXhjZXB0aW9uIE9mZlxuXG50eXBlIG9uX3N3aXRjaCA9IHtcbiAgbXV0YWJsZSBob29rcyA6ICh1bml0IC0+IHVuaXQgTHd0LnQpIGxpc3Q7XG59XG5cbnR5cGUgc3RhdGUgPVxuICB8IFN0X29uIG9mIG9uX3N3aXRjaFxuICB8IFN0X29mZlxuXG50eXBlIHQgPSB7IG11dGFibGUgc3RhdGUgOiBzdGF0ZSB9XG5cbmxldCBjcmVhdGUgKCkgPSB7IHN0YXRlID0gU3Rfb24geyBob29rcyA9IFtdIH0gfVxuXG5sZXQgaXNfb24gc3dpdGNoID1cbiAgbWF0Y2ggc3dpdGNoLnN0YXRlIHdpdGhcbiAgfCBTdF9vbiBfIC0+IHRydWVcbiAgfCBTdF9vZmYgLT4gZmFsc2VcblxubGV0IGNoZWNrID0gZnVuY3Rpb25cbiAgfCBTb21leyBzdGF0ZSA9IFN0X29mZiB9IC0+IHJhaXNlIE9mZlxuICB8IFNvbWUge3N0YXRlID0gU3Rfb24gX30gfCBOb25lIC0+ICgpXG5cbmxldCBhZGRfaG9vayBzd2l0Y2ggaG9vayA9XG4gIG1hdGNoIHN3aXRjaCB3aXRoXG4gIHwgU29tZSB7IHN0YXRlID0gU3Rfb24gb3MgfSAtPlxuICAgIG9zLmhvb2tzIDwtIGhvb2sgOjogb3MuaG9va3NcbiAgfCBTb21lIHsgc3RhdGUgPSBTdF9vZmYgfSAtPlxuICAgIHJhaXNlIE9mZlxuICB8IE5vbmUgLT5cbiAgICAoKVxuXG5sZXQgYWRkX2hvb2tfb3JfZXhlYyBzd2l0Y2ggaG9vayA9XG4gIG1hdGNoIHN3aXRjaCB3aXRoXG4gIHwgU29tZSB7IHN0YXRlID0gU3Rfb24gb3MgfSAtPlxuICAgIG9zLmhvb2tzIDwtIGhvb2sgOjogb3MuaG9va3M7XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgU29tZSB7IHN0YXRlID0gU3Rfb2ZmIH0gLT5cbiAgICBob29rICgpXG4gIHwgTm9uZSAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgdHVybl9vZmYgc3dpdGNoID1cbiAgbWF0Y2ggc3dpdGNoLnN0YXRlIHdpdGhcbiAgfCBTdF9vbiB7IGhvb2tzID0gaG9va3MgfSAtPlxuICAgIHN3aXRjaC5zdGF0ZSA8LSBTdF9vZmY7XG4gICAgTHd0LmpvaW4gKExpc3QubWFwIChmdW4gaG9vayAtPiBMd3QuYXBwbHkgaG9vayAoKSkgaG9va3MpXG4gIHwgU3Rfb2ZmIC0+XG4gICAgTHd0LnJldHVybl91bml0XG5cbmxldCB3aXRoX3N3aXRjaCBmbiA9XG4gIGxldCBzd2l0Y2ggPSBjcmVhdGUgKCkgaW5cbiAgTHd0LmZpbmFsaXplXG4gICAgKGZ1biAoKSAtPiBmbiBzd2l0Y2gpXG4gICAgKGZ1biAoKSAtPiB0dXJuX29mZiBzd2l0Y2gpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQ1MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJMd3QiLCJTdGRsaWJfTGlzdCIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWIiLCJyZXR1cm5fbmlsIiwiZW1wdHkiLCJwYXJhbSIsInJldHVybiIsIngiLCJyZXR1cm5fbHd0IiwiY29ucyIsInQiLCJjb25zX2x3dCIsInNlcTEiLCJzZXEyIiwibmV4dCIsImFwcGVuZCIsInNlcSIsIm1hcCIsIm1hcF9zIiwieSIsImZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwX3MiLCJvayIsImZpbHRlciIsImZpbHRlcl9zIiwiZmxhdF9tYXBfYXBwIiwidGFpbCIsImZsYXRfbWFwIiwiZm9sZF9sZWZ0IiwiYWNjIiwiYXV4IiwiZm9sZF9sZWZ0X3MiLCJpdGVyIiwiaXRlcl9zIiwiaXRlcl9wIiwicCIsIml0ZXJfbiIsIm9wdCIsIm1heF9jb25jdXJyZW5jeSIsIm1lc3NhZ2UiLCJsb29wIiwicnVubmluZyIsImF2YWlsYWJsZSIsImVsdCIsImNvbXBsZXRlIiwidW5mb2xkIiwidSIsInZhbCIsImV4YyIsIm1hdGNoIiwidW5mb2xkX2x3dCIsIm9mX2xpc3QiLCJsIiwiaCIsInRvX2xpc3QiLCJvZl9zZXEiLCJleG4iLCJvZl9zZXFfbHd0IiwiTHd0X3NlcSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL2x3dC9sd3Rfc2VxLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUNZaUI7QUFBQTtBQUFBLE1BQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLE1BQUFDLE9BRUYsa0JBQVU7QUFBQSxZQUFBQyxTQUFBQztBQUFBQSxJQUVWLGdCQUFBRixPQUFVLHdDQUE0QixFQUF0QztBQUFBLEdBQXNDO0FBQUEsWUFBQUcsV0FBQUQ7QUFBQUEsSUFFNUIsZ0JBQUFGO0FBQUFBLEtBQ3BDLDBDQUFBRSxHQUNBLHFCQUFlLElBRnFCO0FBQUEsR0FF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QURiLFFBQUFQLElBQUE7QUFBQSxLQUdHO0FBQUE7QUFBQTtBQUFBLHVCQUFBQTtBQUFBQSxtQkFBQU8sU0FDVztBQUFBLGVBQ1g7QUFBQSxjQUFjLEVBQ21ELEVBUDNCO0FBQUEsR0FPMkI7QUFBQTtBQUFBLElBQUE0QztBQUFBQSxNQWpUekM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRFovQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5vcGVuIEx3dC5TeW50YXhcbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgKydhIG5vZGUgPSBOaWwgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZSBMd3QudFxuXG5sZXQgcmV0dXJuX25pbCA9IEx3dC5yZXR1cm4gTmlsXG5cbmxldCBlbXB0eSA6ICdhIHQgPSBmdW4gKCkgLT4gcmV0dXJuX25pbFxuXG5sZXQgcmV0dXJuICh4IDogJ2EpIDogJ2EgdCA9IGZ1biAoKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCBlbXB0eSkpXG5cbmxldCByZXR1cm5fbHd0ICh4IDogJ2EgTHd0LnQpIDogJ2EgdCA9IGZ1biAoKSAtPlxuICAgbGV0KyB4ID0geCBpblxuICAgQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggdCAoKSA9IEx3dC5yZXR1cm4gKENvbnMgKHgsIHQpKVxuXG5sZXQgY29uc19sd3QgeCB0ICgpID1cbiAgIGxldCsgeCA9IHggaW5cbiAgIENvbnMgKHgsIHQpXG5cbigqIEEgbm90ZSBvbiByZWN1cnNpbmcgdGhyb3VnaCB0aGUgc2VxczpcbiAgIFdoZW4gdHJhdmVyc2luZyBhIHNlcSwgdGhlIGZpcnN0IHRpbWUgd2UgZXZhbHVhdGUgYSBzdXNwZW5kZWQgbm9kZSB3ZSBhcmVcbiAgIG9uIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBiaW5kICg+Pj0pLiBJbiB0aGF0IGNhc2UsIHdlIHVzZSBhcHBseSB0byBjYXB0dXJlXG4gICBleGNlcHRpb25zIGludG8gcHJvbWlzZSByZWplY3Rpb24uXG5cbiAgIFRoaXMgaXMgb25seSBuZWVkZWQgb24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBiZWNhdXNlIHdlIGFyZSB3aXRoaW4gYSBjYWxsYmFja1xuICAgcGFzc2VkIHRvIEx3dCBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGEgYmluZCBhZnRlciB0aGF0LlxuXG4gICBUaHJvdWdob3V0IHRoaXMgZmlsZSB3ZSB1c2UgdGhlIHNhbWUgY29kZSBwYXR0ZXJuIHRvIGFjaGlldmUgdGhpczogd2VcbiAgIHNoYWRvdyB0aGUgcmVjdXJzaXZlIHRyYXZlcnNhbCBmdW5jdGlvbiB3aXRoIGFuIGlkZW50aWNhbC1idXQtZm9yLXRoZS1hcHBseVxuICAgbm9uLXJlY3Vyc2l2ZSBjb3B5LiAqKVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5sZXQgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIEx3dC5hcHBseSBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID58PSBmdW5jdGlvblxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcCBmIG5leHQpXG5sZXQgbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+fD0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBDb25zICh4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIG1hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCsgeCA9IGYgeCBpblxuICAgICAgQ29ucyAoeCwgbWFwX3MgZiBuZXh0KVxubGV0IG1hcF9zIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQrIHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcF9zIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dCkgKSlcbmxldCBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IChcbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgfCBTb21lIHkgLT4gTHd0LnJldHVybiAoQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyX21hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0KiB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwX3MgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwX3MgZiBuZXh0KSApKVxubGV0IGZpbHRlcl9tYXBfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiAoXG4gICAgICBsZXQqIHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXBfcyBmIG5leHQgKClcbiAgICAgIHwgU29tZSB5IC0+IEx3dC5yZXR1cm4gKENvbnMgKHksIGZpbHRlcl9tYXBfcyBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXIgZiBuZXh0KSkgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5sZXQgZmlsdGVyIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQgb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyIGYgbmV4dCkpIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZpbHRlcl9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCogb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyX3MgZiBuZXh0KSkgZWxzZSBmaWx0ZXJfcyBmIG5leHQgKClcbmxldCBmaWx0ZXJfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0KiBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXJfcyBmIG5leHQpKSBlbHNlIGZpbHRlcl9zIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxuKCogdGhpcyBpcyBbYXBwZW5kIHNlcSAoZmxhdF9tYXAgZiB0YWlsKV0gKilcbmFuZCBmbGF0X21hcF9hcHAgZiBzZXEgdGFpbCAoKSA9XG4gIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gZmxhdF9tYXAgZiB0YWlsICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmxhdF9tYXBfYXBwIGYgbmV4dCB0YWlsKSlcblxubGV0IGZsYXRfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbmxldCBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbGV0IHJlYyBhdXggZiBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBmb2xkX2xlZnRfcyBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPVxuICAgIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuIGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqIGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBsZXQgYXV4IHNlcSA9XG4gICAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuX3VuaXRcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuXG5sZXQgaXRlcl9zIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybl91bml0XG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqICgpID0gZiB4IGluXG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGxldCBhdXggc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiAoKSA9IGYgeCBpblxuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG5cbmxldCBpdGVyX3AgZiBzZXEgPVxuICBsZXQgcmVjIGF1eCBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBsZXQgYXV4IGFjYyBzZXEgPVxuICAgIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBhdXggW10gc2VxXG5cbmxldCBpdGVyX24gPyhtYXhfY29uY3VycmVuY3kgPSAxKSBmIHNlcSA9XG4gIGJlZ2luXG4gICAgaWYgbWF4X2NvbmN1cnJlbmN5IDw9IDAgdGhlblxuICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgIFwiTHd0X3NlcS5pdGVyX246IG1heF9jb25jdXJyZW5jeSBtdXN0IGJlID4gMCwgJWQgZ2l2ZW5cIlxuICAgICAgICAgIG1heF9jb25jdXJyZW5jeVxuICAgICAgaW5cbiAgICAgIGludmFsaWRfYXJnIG1lc3NhZ2VcbiAgZW5kO1xuICBsZXQgcmVjIGxvb3AgcnVubmluZyBhdmFpbGFibGUgc2VxID1cbiAgICBiZWdpblxuICAgICAgaWYgYXZhaWxhYmxlID4gMCB0aGVuIChcbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlKVxuICAgICAgKVxuICAgICAgZWxzZSAoXG4gICAgICAgIEx3dC5uY2hvb3NlX3NwbGl0IHJ1bm5pbmcgPj49IGZ1biAoY29tcGxldGUsIHJ1bm5pbmcpIC0+XG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSArIExpc3QubGVuZ3RoIGNvbXBsZXRlKVxuICAgICAgKVxuICAgIGVuZCA+Pj0gZnVuIChydW5uaW5nLCBhdmFpbGFibGUpIC0+XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+XG4gICAgICBMd3Quam9pbiBydW5uaW5nXG4gICAgfCBDb25zIChlbHQsIHNlcSkgLT5cbiAgICAgIGxvb3AgKGYgZWx0IDo6IHJ1bm5pbmcpIChwcmVkIGF2YWlsYWJsZSkgc2VxXG4gIGluXG4gICgqIGJlY2F1c2UgdGhlIHJlY3Vyc2lvbiBpcyBtb3JlIGNvbXBsaWNhdGVkIGhlcmUsIHdlIGFwcGx5IHRoZSBzZXEgZGlyZWN0bHkgYXRcbiAgICAgdGhlIGNhbGwtc2l0ZSBpbnN0ZWFkICopXG4gIGxvb3AgW10gbWF4X2NvbmN1cnJlbmN5IChmdW4gKCkgLT4gTHd0LmFwcGx5IHNlcSAoKSlcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkIGYgdScpKVxuICB8IGV4Y2VwdGlvbiBleGMgd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhjIC0+IEx3dC5yZXJhaXNlIGV4Y1xuXG5sZXQgcmVjIHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gZiB1IGluXG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gcmV0dXJuX25pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCB1bmZvbGRfbHd0IGYgdScpKVxubGV0IHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gTHd0LmFwcGx5IGYgdSBpblxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkX2x3dCBmIHUnKSlcblxubGV0IHJlYyBvZl9saXN0IGwgKCkgPVxuICBMd3QucmV0dXJuIChtYXRjaCBsIHdpdGggW10gLT4gTmlsIHwgaCA6OiB0IC0+IENvbnMgKGgsIG9mX2xpc3QgdCkpXG5cbmxldCB0b19saXN0IChzZXEgOiAnYSB0KSA9XG4gIGxldCByZWMgYXV4IGYgc2VxID1cbiAgICBMd3QuYmluZCAoc2VxICgpKSAoZnVuY3Rpb25cbiAgICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gKGYgW10pXG4gICAgICB8IENvbnMgKGgsIHQpIC0+IGF1eCAoZnVuIHggLT4gZiAoaCA6OiB4KSkgdClcbiAgaW5cbiAgYXV4IChmdW4geCAtPiB4KSAoTHd0LmFwcGx5IHNlcSlcblxubGV0IHJlYyBvZl9zZXEgc2VxICgpID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBMd3QucmV0dXJuIChDb25zICh4LCAob2Zfc2VxIG5leHQpKSlcbiAgfCBleGNlcHRpb24gZXhuIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBMd3QucmVyYWlzZSBleG5cblxubGV0IHJlYyBvZl9zZXFfbHd0IChzZXE6ICdhIEx3dC50IFNlcS50KTogJ2EgdCA9IGZ1biAoKSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPlxuICAgICAgIGxldCsgeCA9IHggaW5cbiAgICAgICBsZXQgbmV4dCA9IG9mX3NlcV9sd3QgbmV4dCBpblxuICAgICAgIENvbnMgKHgsIG5leHQpXG5sZXQgb2Zfc2VxX2x3dCAoc2VxOiAnYSBMd3QudCBTZXEudCk6ICdhIHQgPSBmdW4gKCkgLT5cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgU2VxLk5pbCAtPiByZXR1cm5fbmlsXG4gICAgfCBTZXEuQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICBsZXQrIHggPSB4IGluXG4gICAgICAgbGV0IG5leHQgPSBvZl9zZXFfbHd0IG5leHQgaW5cbiAgICAgICBDb25zICh4LCBuZXh0KVxuICAgIHwgZXhjZXB0aW9uIGV4YyB3aGVuIEx3dC5FeGNlcHRpb25fZmlsdGVyLnJ1biBleGMgLT4gTHd0LnJlcmFpc2UgZXhjXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzA1NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9ibG9ja2VkIiwiY3N0X2Nsb3NlIiwiY3N0X2Nsb3NlZCIsImNzdF9jb3VudCIsImNzdF9wdXNoIiwiY3N0X3Jlc2l6ZSIsImNzdF9zZXRfcmVmZXJlbmNlIiwiY3N0X3NpemUiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsInNoYXJlZCIsIkx3dCIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9QcmludGYiLCJTdGRsaWIiLCJDYW1saW50ZXJuYWxPTyIsIlN0ZGxpYl9TdHJpbmciLCJTdGRsaWJfQXJyYXkiLCJDbG9zZWQiLCJGdWxsIiwiRW1wdHkiLCJjc3RfTHd0X3N0cmVhbV9jbG9uZSIsImNzdF9Md3Rfc3RyZWFtX2JvdW5kZWRfcHVzaF9yZSIsIm5ld19ub2RlIiwicGFyYW0iLCJub2RlIiwiY2xvbmUiLCJzIiwiZnJvbV9zb3VyY2UiLCJzb3VyY2UiLCJtYXRjaCIsImNsb3NlIiwiY2xvc2VkIiwiZnJvbSIsImZyb21fZGlyZWN0IiwiaXNfY2xvc2VkIiwiZW5xdWV1ZSIsImUiLCJsYXN0IiwibmV3X2xhc3QiLCJjcmVhdGVfd2l0aF9yZWZlcmVuY2UiLCJwdXNoX3NpZ25hbF9yZXNvbHZlciIsInB1c2hfc2lnbmFsIiwidCIsInB1c2giLCJ4Iiwib2xkX3B1c2hfc2lnbmFsX3Jlc29sdmVyIiwibmV3X3B1c2hfc2lnbmFsX3Jlc29sdmVyIiwibmV3X3dhaXRlciIsInJldHVybiIsImEiLCJzdHJlYW0iLCJyZXR1cm5fbHd0IiwiZXhjIiwib2Zfc2VxIiwiZ2V0IiwiZWx0Iiwib2ZfbHd0X3NlcSIsImNyZWF0ZSIsIm9mX2l0ZXIiLCJpdGVyIiwiaSIsIm9mX2xpc3QiLCJsIiwib2ZfYXJyYXkiLCJvZl9zdHJpbmciLCJub3RpZnlfcHVzaGVyIiwiaW5mbyIsIm9sZF93YWtlbmVyIiwid2FrZW5lciIsIndhaXRlciIsImJvdW5kZWRfcHVzaF9pbXBsIiwic2VsZl8xIiwic2l6ZSIsImV4biIsIm5ld193YWtlbmVyIiwiY3N0X0x3dF9zdHJlYW1fY3JlYXRlX2JvdW5kZWQiLCJjc3RfTHd0X3N0cmVhbV9wYXJzZSIsImNyZWF0ZV9ib3VuZGVkIiwicHVzaF93YWtlbmVyIiwicHVzaF93YWl0ZXIiLCJ3YWtlbmVyX2NlbGwiLCJmZWVkIiwidGhyZWFkIiwiY29uc3VtZSIsInBlZWtfcmVjIiwicGVlayIsIm5wZWVrX3JlYyIsImFjYyIsIm4iLCJucGVlayIsImdldF9yZWMiLCJnZXRfZXhuX3JlYyIsInZhbHVlIiwid3JhcF9leG4iLCJuZ2V0X3JlYyIsIm5nZXQiLCJnZXRfd2hpbGVfcmVjIiwidGVzdCIsImdldF93aGlsZSIsImdldF93aGlsZV9zX3JlYyIsImdldF93aGlsZV9zIiwibmV4dF9yZWMiLCJuZXh0IiwibGFzdF9uZXdfcmVjIiwibGFzdF9uZXciLCJ0b19saXN0X3JlYyIsInRvX2xpc3QiLCJ0b19zdHJpbmdfcmVjIiwiYnVmIiwidG9fc3RyaW5nIiwianVuayIsIm5qdW5rX3JlYyIsIm5qdW5rIiwianVua193aGlsZV9yZWMiLCJqdW5rX3doaWxlIiwianVua193aGlsZV9zX3JlYyIsImp1bmtfd2hpbGVfcyIsImp1bmtfYXZhaWxhYmxlIiwianVua19vbGQiLCJnZXRfYXZhaWxhYmxlIiwiZ2V0X2F2YWlsYWJsZV91cF90byIsImlzX2VtcHR5IiwibWFwIiwibWFwX3MiLCJmaWx0ZXIiLCJmaWx0ZXJfcyIsImZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwX3MiLCJtYXBfbGlzdCIsInBlbmRpbmdzIiwibWFwX2xpc3RfcyIsImZsYXR0ZW4iLCJmb2xkX3JlYyIsImZvbGQiLCJmb2xkX3NfcmVjIiwiZm9sZF9zIiwiaXRlcl9yZWMiLCJpdGVyX3NfcmVjIiwiaXRlcl9zIiwiaXRlcl9wX3JlYyIsInJlcyIsInJlc3QiLCJpdGVyX3AiLCJpdGVyX24iLCJvcHQiLCJtYXhfY29uY3VycmVuY3kiLCJtZXNzYWdlIiwibG9vcCIsInJ1bm5pbmciLCJhdmFpbGFibGUiLCJjb21wbGV0ZSIsImZpbmRfcmVjIiwiZmluZCIsImZpbmRfc19yZWMiLCJmaW5kX3MiLCJmaW5kX21hcF9yZWMiLCJmaW5kX21hcCIsImZpbmRfbWFwX3NfcmVjIiwiZmluZF9tYXBfcyIsImNvbWJpbmUiLCJzMSIsInMyIiwidDEiLCJ0MiIsIm4xIiwibjIiLCJ4MiIsIngxIiwiYXBwZW5kIiwiY3VycmVudF9zIiwiY29uY2F0Iiwic190b3AiLCJjaG9vc2UiLCJzdHJlYW1zIiwicGFyc2UiLCJoZXhkdW1wIiwibnVtIiwicG9zIiwiY2giLCJMd3Rfc3RyZWFtIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvbHd0L2x3dF9zdHJlYW0ubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFB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QUQsT0FDYSx1QkFBRztBQUFBLHNCQUFBa0Q7QUFBQUEsY0FFWDtBQUFBLGNBQ0E7QUFBQSxhQUFlLEVBQUM7QUFBQTtBQUFBLFlBQUFzRyxRQUFBN0g7QUFBQUEsUUFBQTBELE1BR1gsa0NBQUFvRSxNQUFnQjtBQUFBLElBQzFCO0FBQUEsc0JBQUF6SjtBQUFBQSxrQkFBQSxNQUNFO0FBQUEsY0FBYztBQUFBO0FBQUE7QUFBQSxnQ0FBQXVDO0FBQUFBLHdCQUFLLFFBRWpCO0FBQUEsd0JBRUE7QUFBQSx3QkFDQTtBQUFBLHdCQUFpQztBQUFBLDRCQUFBbUgsTUFrQmpDLEdBQUExSixRQUFBO0FBQUE7QUFBQSx5QkFoQmM7QUFBQSw2QkFBQXVDLE1BQUEsVUFBQWxCLElBQUE7QUFBQSx5QkFJVixjQUFnQjtBQUFBLHlCQUNoQjtBQUFBLDZCQUFBcUksUUFBd0M7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFBQUEsUUFIeEM7QUFBQTtBQUFBLHlCQU1GO0FBQUEseUJBQWlCO0FBQUEsMEJBRWI7QUFBQTtBQUFBLDBCQUVBO0FBQUEsNkJBQUFBLFFBQ0Y7QUFBQTtBQUFBO0FBQUEsd0JBSUo7QUFBQSx3QkFDQTtBQUFBO0FBQUEsbUNBQUFDO0FBQUFBO0FBQUFBO0FBQUFBLDRCQUFxQixvQ0FBMEQ7QUFBQSxzQ0FBUTtBQUFBO0FBQUEsMkJBQWxFLDhDQUFzRTtBQUFBO0FBQUE7QUFBQSx3QkFDM0Y7QUFBQSxrQ0FDZ0I7QUFBQSx3QkFBcUIsOEJBQUM7QUFBQTtBQUFBLGVBQ3ZDO0FBQUE7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EMWxDTCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cbm9wZW4gTHd0LkluZml4XG5cbmV4Y2VwdGlvbiBDbG9zZWRcbmV4Y2VwdGlvbiBGdWxsXG5leGNlcHRpb24gRW1wdHlcblxuKCogQSBub2RlIGluIGEgcXVldWUgb2YgcGVuZGluZyBkYXRhLiAqKVxudHlwZSAnYSBub2RlID0ge1xuICBtdXRhYmxlIG5leHQgOiAnYSBub2RlO1xuICAoKiBOZXh0IG5vZGUgaW4gdGhlIHF1ZXVlLiBGb3IgdGhlIGxhc3Qgbm9kZSBpdCBwb2ludHMgdG8gaXRzZWxmLiAqKVxuICBtdXRhYmxlIGRhdGEgOiAnYSBvcHRpb247XG4gICgqIERhdGEgb2YgdGhpcyBub2RlLiBGb3IgdGhlIGxhc3Qgbm9kZSBpdCBpcyBhbHdheXMgW05vbmVdLiAqKVxufVxuXG4oKiBOb3RlOiBhIHF1ZXVlIGZvciBhbiBleGhhdXN0ZWQgc3RyZWFtIGlzIHJlcHJlc2VudGVkIGJ5IGEgbm9kZVxuICAgY29udGFpbmluZyBbTm9uZV0gZm9sbG93ZWQgYnkgYSBub2RlIHdpdGggaXRzZWxmIGFzIG5leHQgYW5kIFtOb25lXVxuICAgYXMgZGF0YS4gKilcblxubGV0IG5ld19ub2RlICgpID1cbiAgbGV0IHJlYyBub2RlID0geyBuZXh0ID0gbm9kZTsgZGF0YSA9IE5vbmUgfSBpblxuICBub2RlXG5cbigqIFR5cGUgb2YgYSBzdHJlYW0gc291cmNlIHVzaW5nIGEgZnVuY3Rpb24gdG8gY3JlYXRlIG5ldyBlbGVtZW50cy4gKilcbnR5cGUgJ2EgZnJvbSA9IHtcbiAgZnJvbV9jcmVhdGUgOiB1bml0IC0+ICdhIG9wdGlvbiBMd3QudDtcbiAgKCogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgbmV3IGVsZW1lbnRzLiAqKVxuICBtdXRhYmxlIGZyb21fdGhyZWFkIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHdoaWNoOlxuXG4gICAgIC0gd2FpdCBmb3IgdGhlIHRocmVhZCByZXR1cm5lZCBieSB0aGUgbGFzdCBjYWxsIHRvIFtmcm9tX25leHRdLFxuICAgICAtIGFkZCB0aGUgbmV4dCBlbGVtZW50IHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlLlxuXG4gICAgIElmIGl0IGlzIGEgc2xlZXBpbmcgdGhyZWFkLCB0aGVuIGl0IG11c3QgYmUgdXNlZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGFcbiAgICAgbmV3IG9uZSB3aXRoIFtmcm9tX2NyZWF0ZV0uICopXG59XG5cbigqIFR5cGUgb2YgYSBzdHJlYW0gc291cmNlIGZvciBwdXNoIHN0cmVhbXMuICopXG50eXBlIHB1c2ggPSB7XG4gIG11dGFibGUgcHVzaF9zaWduYWwgOiB1bml0IEx3dC50O1xuICAoKiBUaHJlYWQgc2lnbmFsZWQgd2hlbiBhIG5ldyBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBzdHJlYW0uICopXG4gIG11dGFibGUgcHVzaF93YWl0aW5nIDogYm9vbDtcbiAgKCogSXMgYSB0aHJlYWQgd2FpdGluZyBvbiBbcHVzaF9zaWduYWxdID8gKilcbiAgbXV0YWJsZSBwdXNoX2V4dGVybmFsIDogT2JqLnQgW0BvY2FtbC53YXJuaW5nIFwiLTY5XCJdO1xuICAoKiBSZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgc291cmNlLiAqKVxufVxuXG4oKiBUeXBlIG9mIGEgc3RyZWFtIHNvdXJjZSBmb3IgYm91bmRlZC1wdXNoIHN0cmVhbXMuICopXG50eXBlICdhIHB1c2hfYm91bmRlZCA9IHtcbiAgbXV0YWJsZSBwdXNoYl9zaWduYWwgOiB1bml0IEx3dC50O1xuICAoKiBUaHJlYWQgc2lnbmFsZWQgd2hlbiBhIG5ldyBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBzdHJlYW0uICopXG4gIG11dGFibGUgcHVzaGJfd2FpdGluZyA6IGJvb2w7XG4gICgqIElzIGEgdGhyZWFkIHdhaXRpbmcgb24gW3B1c2hiX3NpZ25hbF0gPyAqKVxuICBtdXRhYmxlIHB1c2hiX3NpemUgOiBpbnQ7XG4gICgqIFNpemUgb2YgdGhlIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHB1c2hiX2NvdW50IDogaW50O1xuICAoKiBDdXJyZW50IGxlbmd0aCBvZiB0aGUgcXVldWUuICopXG4gIG11dGFibGUgcHVzaGJfcGVuZGluZyA6ICdhIG9wdGlvbjtcbiAgKCogVGhlIG5leHQgZWxlbWVudCB0byBwdXNoIGlmIGEgdGhyZWFkIGJsb2NrZWQgb24gcHVzaC4gV2Ugc3RvcmUgaXRcbiAgICAgaGVyZSB0byBiZSBzdXJlIGl0IHdpbGwgYmUgdGhlIGZpcnN0IGVsZW1lbnQgdG8gYmUgYWRkZWQgd2hlblxuICAgICBzcGFjZSBiZWNvbWVzIGF2YWlsYWJsZS4gKilcbiAgbXV0YWJsZSBwdXNoYl9wdXNoX3dhaXRlciA6IHVuaXQgTHd0LnQ7XG4gIG11dGFibGUgcHVzaGJfcHVzaF93YWtlbmVyIDogdW5pdCBMd3QudTtcbiAgKCogVGhyZWFkIGJsb2NrZWQgb24gcHVzaC4gKilcbiAgbXV0YWJsZSBwdXNoYl9leHRlcm5hbCA6IE9iai50IFtAb2NhbWwud2FybmluZyBcIi02OVwiXTtcbiAgKCogUmVmZXJlbmNlIHRvIGFuIGV4dGVybmFsIHNvdXJjZS4gKilcbn1cblxuKCogU291cmNlIG9mIGEgc3RyZWFtLiAqKVxudHlwZSAnYSBzb3VyY2UgPVxuICB8IEZyb20gb2YgJ2EgZnJvbVxuICB8IEZyb21fZGlyZWN0IG9mICh1bml0IC0+ICdhIG9wdGlvbilcbiAgfCBQdXNoIG9mIHB1c2hcbiAgfCBQdXNoX2JvdW5kZWQgb2YgJ2EgcHVzaF9ib3VuZGVkXG5cbnR5cGUgJ2EgdCA9IHtcbiAgc291cmNlIDogJ2Egc291cmNlO1xuICAoKiBUaGUgc291cmNlIG9mIHRoZSBzdHJlYW0uICopXG4gIGNsb3NlIDogdW5pdCBMd3QudTtcbiAgKCogQSB3YWtlbmVyIGZvciBhIHRocmVhZCB0aGF0IHNsZWVwcyB1bnRpbCB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gKilcbiAgY2xvc2VkIDogdW5pdCBMd3QudDtcbiAgKCogQSB3YWl0ZXIgZm9yIGEgdGhyZWFkIHRoYXQgc2xlZXBzIHVudGlsIHRoZSBzdHJlYW0gaXMgY2xvc2VkLiAqKVxuICBtdXRhYmxlIG5vZGUgOiAnYSBub2RlO1xuICAoKiBQb2ludGVyIHRvIGZpcnN0IHBlbmRpbmcgZWxlbWVudCwgb3IgdG8gW2xhc3RdIGlmIHRoZXJlIGlzIG5vXG4gICAgIHBlbmRpbmcgZWxlbWVudC4gKilcbiAgbGFzdCA6ICdhIG5vZGUgcmVmO1xuICAoKiBOb2RlIG1hcmtpbmcgdGhlIGVuZCBvZiB0aGUgcXVldWUgb2YgcGVuZGluZyBlbGVtZW50cy4gKilcbn1cblxuY2xhc3MgdHlwZSBbJ2FdIGJvdW5kZWRfcHVzaCA9IG9iamVjdFxuICBtZXRob2Qgc2l6ZSA6IGludFxuICBtZXRob2QgcmVzaXplIDogaW50IC0+IHVuaXRcbiAgbWV0aG9kIHB1c2ggOiAnYSAtPiB1bml0IEx3dC50XG4gIG1ldGhvZCBjbG9zZSA6IHVuaXRcbiAgbWV0aG9kIGNvdW50IDogaW50XG4gIG1ldGhvZCBibG9ja2VkIDogYm9vbFxuICBtZXRob2QgY2xvc2VkIDogYm9vbFxuICBtZXRob2Qgc2V0X3JlZmVyZW5jZSA6ICdhLiAnYSAtPiB1bml0XG5lbmRcblxuKCogVGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBjbG9uZXMgaXMgdGhlIHBvaW50ZXIgdG8gdGhlIGZpcnN0XG4gICBwZW5kaW5nIGVsZW1lbnQuICopXG5sZXQgY2xvbmUgcyA9XG4gIChtYXRjaCBzLnNvdXJjZSB3aXRoXG4gICB8IFB1c2hfYm91bmRlZCBfIC0+IGludmFsaWRfYXJnIFwiTHd0X3N0cmVhbS5jbG9uZVwiXG4gICB8IEZyb20gXyB8IEZyb21fZGlyZWN0IF8gfCBQdXNoIF8gLT4gKCkpO1xuICB7XG4gICAgc291cmNlID0gcy5zb3VyY2U7XG4gICAgY2xvc2UgPSBzLmNsb3NlO1xuICAgIGNsb3NlZCA9IHMuY2xvc2VkO1xuICAgIG5vZGUgPSBzLm5vZGU7XG4gICAgbGFzdCA9IHMubGFzdDtcbiAgfVxuXG5sZXQgZnJvbV9zb3VyY2Ugc291cmNlID1cbiAgbGV0IG5vZGUgPSBuZXdfbm9kZSAoKSBpblxuICBsZXQgY2xvc2VkLCBjbG9zZSA9IEx3dC53YWl0ICgpIGluXG4gIHsgc291cmNlIDsgY2xvc2UgOyBjbG9zZWQgOyBub2RlIDsgbGFzdCA9IHJlZiBub2RlIH1cblxubGV0IGZyb20gZiA9XG4gIGZyb21fc291cmNlIChGcm9tIHsgZnJvbV9jcmVhdGUgPSBmOyBmcm9tX3RocmVhZCA9IEx3dC5yZXR1cm5fdW5pdCB9KVxuXG5sZXQgZnJvbV9kaXJlY3QgZiA9XG4gIGZyb21fc291cmNlIChGcm9tX2RpcmVjdCBmKVxuXG5sZXQgY2xvc2VkIHMgPSBzLmNsb3NlZFxuXG5sZXQgaXNfY2xvc2VkIHMgPVxuICBub3QgKEx3dC5pc19zbGVlcGluZyAoY2xvc2VkIHMpKVxuXG5sZXQgZW5xdWV1ZScgZSBsYXN0ID1cbiAgbGV0IG5vZGUgPSAhbGFzdFxuICBhbmQgbmV3X2xhc3QgPSBuZXdfbm9kZSAoKSBpblxuICBub2RlLmRhdGEgPC0gZTtcbiAgbm9kZS5uZXh0IDwtIG5ld19sYXN0O1xuICBsYXN0IDo9IG5ld19sYXN0XG5cbmxldCBlbnF1ZXVlIGUgcyA9XG4gIGVucXVldWUnIGUgcy5sYXN0XG5cbmxldCBjcmVhdGVfd2l0aF9yZWZlcmVuY2UgKCkgPVxuICAoKiBDcmVhdGUgdGhlIHNvdXJjZSBmb3Igbm90aWZpY2F0aW9ucyBvZiBuZXcgZWxlbWVudHMuICopXG4gIGxldCBzb3VyY2UsIHB1c2hfc2lnbmFsX3Jlc29sdmVyID1cbiAgICBsZXQgcHVzaF9zaWduYWwsIHB1c2hfc2lnbmFsX3Jlc29sdmVyID0gTHd0LndhaXQgKCkgaW5cbiAgICAoeyBwdXNoX3NpZ25hbDtcbiAgICAgICBwdXNoX3dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICBwdXNoX2V4dGVybmFsID0gT2JqLnJlcHIgKCkgfSxcbiAgICAgcmVmIHB1c2hfc2lnbmFsX3Jlc29sdmVyKVxuICBpblxuICBsZXQgdCA9IGZyb21fc291cmNlIChQdXNoIHNvdXJjZSkgaW5cbiAgKCogW3B1c2hdIHNob3VsZCBub3QgY2xvc2Ugb3ZlciBbdF0gc28gdGhhdCBpdCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgZXZlblxuICAgKiB0aGVyZSBhcmUgc3RpbGwgcmVmZXJlbmNlcyB0byBbcHVzaF0uIFVucGFjayBhbGwgdGhlIGNvbXBvbmVudHMgb2YgW3RdXG4gICAqIHRoYXQgW3B1c2hdIG5lZWRzIGFuZCByZWZlcmVuY2UgdGhvc2UgaWRlbnRpZmllcnMgaW5zdGVhZC4gKilcbiAgbGV0IGNsb3NlID0gdC5jbG9zZSBhbmQgY2xvc2VkID0gdC5jbG9zZWQgYW5kIGxhc3QgPSB0Lmxhc3QgaW5cbiAgKCogVGhlIHB1c2ggZnVuY3Rpb24uIEl0IGRvZXMgbm90IGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN0cmVhbS4gKilcbiAgbGV0IHB1c2ggeCA9XG4gICAgaWYgbm90IChMd3QuaXNfc2xlZXBpbmcgY2xvc2VkKSB0aGVuIHJhaXNlIENsb3NlZDtcbiAgICAoKiBQdXNoIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiAqKVxuICAgIGVucXVldWUnIHggbGFzdDtcbiAgICAoKiBTZW5kIGEgc2lnbmFsIGlmIGF0IGxlYXN0IG9uZSB0aHJlYWQgaXMgd2FpdGluZyBmb3IgYSBuZXdcbiAgICAgICBlbGVtZW50LiAqKVxuICAgIGlmIHNvdXJjZS5wdXNoX3dhaXRpbmcgdGhlbiBiZWdpblxuICAgICAgc291cmNlLnB1c2hfd2FpdGluZyA8LSBmYWxzZTtcbiAgICAgICgqIFVwZGF0ZSB0aHJlYWRzLiAqKVxuICAgICAgbGV0IG9sZF9wdXNoX3NpZ25hbF9yZXNvbHZlciA9ICFwdXNoX3NpZ25hbF9yZXNvbHZlciBpblxuICAgICAgbGV0IG5ld193YWl0ZXIsIG5ld19wdXNoX3NpZ25hbF9yZXNvbHZlciA9IEx3dC53YWl0ICgpIGluXG4gICAgICBzb3VyY2UucHVzaF9zaWduYWwgPC0gbmV3X3dhaXRlcjtcbiAgICAgIHB1c2hfc2lnbmFsX3Jlc29sdmVyIDo9IG5ld19wdXNoX3NpZ25hbF9yZXNvbHZlcjtcbiAgICAgICgqIFNpZ25hbCB0aGF0IGEgbmV3IHZhbHVlIGhhcyBiZWVuIHJlY2VpdmVkLiAqKVxuICAgICAgTHd0Lndha2V1cF9sYXRlciBvbGRfcHVzaF9zaWduYWxfcmVzb2x2ZXIgKClcbiAgICBlbmQ7XG4gICAgKCogRG8gdGhpcyBhdCB0aGUgZW5kIGluIGNhc2Ugb25lIG9mIHRoZSBmdW5jdGlvbiByYWlzZSBhblxuICAgICAgIGV4Y2VwdGlvbi4gKilcbiAgICBpZiB4ID0gTm9uZSB0aGVuIEx3dC53YWtldXAgY2xvc2UgKClcbiAgaW5cbiAgKHQsIHB1c2gsIGZ1biB4IC0+IHNvdXJjZS5wdXNoX2V4dGVybmFsIDwtIE9iai5yZXByIHgpXG5cbmxldCByZXR1cm4gYSA9XG4gIGxldCBzdHJlYW0sIHB1c2gsIF8gPSBjcmVhdGVfd2l0aF9yZWZlcmVuY2UgKCkgaW5cbiAgcHVzaCAoU29tZSBhKTtcbiAgcHVzaCBOb25lO1xuICBzdHJlYW1cblxubGV0IHJldHVybl9sd3QgYSA9XG4gIGxldCBzb3VyY2UsIHB1c2gsIF8gPSBjcmVhdGVfd2l0aF9yZWZlcmVuY2UgKCkgaW5cbiAgTHd0LmRvbnRfd2FpdFxuICAgIChmdW4gKCkgLT5cbiAgICAgIEx3dC5iaW5kIGEgKGZ1biB4IC0+XG4gICAgICAgIHB1c2ggKFNvbWUgeCk7XG4gICAgICAgIHB1c2ggTm9uZTtcbiAgICAgICAgTHd0LnJldHVybl91bml0KSlcbiAgICAoZnVuIF9leGMgLT4gcHVzaCBOb25lKTtcbiAgc291cmNlXG5cbmxldCBvZl9zZXEgcyA9XG4gIGxldCBzID0gcmVmIHMgaW5cbiAgbGV0IGdldCAoKSA9XG4gICAgbWF0Y2ggIXMgKCkgd2l0aFxuICAgIHwgU2VxLk5pbCAtPiBOb25lXG4gICAgfCBTZXEuQ29ucyAoZWx0LCBzJykgLT4gcyA6PSBzJzsgU29tZSBlbHRcbiAgaW5cbiAgZnJvbV9kaXJlY3QgZ2V0XG5cbmxldCBvZl9sd3Rfc2VxIHMgPVxuICBsZXQgcyA9IHJlZiBzIGluXG4gIGxldCBnZXQgKCkgPVxuICAgICFzICgpID58PSBmdW5jdGlvblxuICAgIHwgTHd0X3NlcS5OaWwgLT4gTm9uZVxuICAgIHwgTHd0X3NlcS5Db25zIChlbHQsIHMnKSAtPiBzIDo9IHMnOyBTb21lIGVsdFxuICBpblxuICBmcm9tIGdldFxuXG5cbmxldCBjcmVhdGUgKCkgPVxuICBsZXQgc291cmNlLCBwdXNoLCBfID0gY3JlYXRlX3dpdGhfcmVmZXJlbmNlICgpIGluXG4gIChzb3VyY2UsIHB1c2gpXG5cbmxldCBvZl9pdGVyIGl0ZXIgaSA9XG4gIGxldCBzdHJlYW0sIHB1c2ggPSBjcmVhdGUgKCkgaW5cbiAgaXRlciAoZnVuIHggLT4gcHVzaCAoU29tZSB4KSkgaTtcbiAgcHVzaCBOb25lO1xuICBzdHJlYW1cblxubGV0IG9mX2xpc3QgbCA9XG4gIG9mX2l0ZXIgTGlzdC5pdGVyIGxcblxubGV0IG9mX2FycmF5IGEgPVxuICBvZl9pdGVyIEFycmF5Lml0ZXIgYVxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBvZl9pdGVyIFN0cmluZy5pdGVyIHNcblxuKCogQWRkIHRoZSBwZW5kaW5nIGVsZW1lbnQgdG8gdGhlIHF1ZXVlIGFuZCBub3RpZnkgdGhlIGJsb2NrZWQgcHVzaGVkLlxuXG4gICBQcmVjb25kaXRpb246IGluZm8ucHVzaGJfcGVuZGluZyA9IFNvbWUgX1xuXG4gICBUaGlzIGRvZXMgbm90IG1vZGlmeSBpbmZvLnB1c2hiX2NvdW50LiAqKVxubGV0IG5vdGlmeV9wdXNoZXIgaW5mbyBsYXN0ID1cbiAgKCogUHVzaCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgZW5xdWV1ZScgaW5mby5wdXNoYl9wZW5kaW5nIGxhc3Q7XG4gICgqIENsZWFyIHBlbmRpbmcgZWxlbWVudC4gKilcbiAgaW5mby5wdXNoYl9wZW5kaW5nIDwtIE5vbmU7XG4gICgqIFdha2V1cCB0aGUgcHVzaGVyLiAqKVxuICBsZXQgb2xkX3dha2VuZXIgPSBpbmZvLnB1c2hiX3B1c2hfd2FrZW5lciBpblxuICBsZXQgd2FpdGVyLCB3YWtlbmVyID0gTHd0LnRhc2sgKCkgaW5cbiAgaW5mby5wdXNoYl9wdXNoX3dhaXRlciA8LSB3YWl0ZXI7XG4gIGluZm8ucHVzaGJfcHVzaF93YWtlbmVyIDwtIHdha2VuZXI7XG4gIEx3dC53YWtldXBfbGF0ZXIgb2xkX3dha2VuZXIgKClcblxuY2xhc3MgWydhXSBib3VuZGVkX3B1c2hfaW1wbCAoaW5mbyA6ICdhIHB1c2hfYm91bmRlZCkgd2FrZW5lcl9jZWxsIGxhc3QgY2xvc2UgPSBvYmplY3RcbiAgdmFsIG11dGFibGUgY2xvc2VkID0gZmFsc2VcblxuICBtZXRob2Qgc2l6ZSA9XG4gICAgaW5mby5wdXNoYl9zaXplXG5cbiAgbWV0aG9kIHJlc2l6ZSBzaXplID1cbiAgICBpZiBzaXplIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTHd0X3N0cmVhbS5ib3VuZGVkX3B1c2gjcmVzaXplXCI7XG4gICAgaW5mby5wdXNoYl9zaXplIDwtIHNpemU7XG4gICAgaWYgaW5mby5wdXNoYl9jb3VudCA8IGluZm8ucHVzaGJfc2l6ZSAmJiBpbmZvLnB1c2hiX3BlbmRpbmcgPD4gTm9uZSB0aGVuIGJlZ2luXG4gICAgICBpbmZvLnB1c2hiX2NvdW50IDwtIGluZm8ucHVzaGJfY291bnQgKyAxO1xuICAgICAgbm90aWZ5X3B1c2hlciBpbmZvIGxhc3RcbiAgICBlbmRcblxuICBtZXRob2QgcHVzaCB4ID1cbiAgICBpZiBjbG9zZWQgdGhlblxuICAgICAgTHd0LmZhaWwgQ2xvc2VkXG4gICAgZWxzZSBpZiBpbmZvLnB1c2hiX3BlbmRpbmcgPD4gTm9uZSB0aGVuXG4gICAgICBMd3QuZmFpbCBGdWxsXG4gICAgZWxzZSBpZiBpbmZvLnB1c2hiX2NvdW50ID49IGluZm8ucHVzaGJfc2l6ZSB0aGVuIGJlZ2luXG4gICAgICBpbmZvLnB1c2hiX3BlbmRpbmcgPC0gU29tZSB4O1xuICAgICAgTHd0LmNhdGNoXG4gICAgICAgIChmdW4gKCkgLT4gaW5mby5wdXNoYl9wdXNoX3dhaXRlcilcbiAgICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICAgbWF0Y2ggZXhuIHdpdGhcbiAgICAgICAgICAgfCBMd3QuQ2FuY2VsZWQgLT5cbiAgICAgICAgICAgICBpbmZvLnB1c2hiX3BlbmRpbmcgPC0gTm9uZTtcbiAgICAgICAgICAgICBsZXQgd2FpdGVyLCB3YWtlbmVyID0gTHd0LnRhc2sgKCkgaW5cbiAgICAgICAgICAgICBpbmZvLnB1c2hiX3B1c2hfd2FpdGVyIDwtIHdhaXRlcjtcbiAgICAgICAgICAgICBpbmZvLnB1c2hiX3B1c2hfd2FrZW5lciA8LSB3YWtlbmVyO1xuICAgICAgICAgICAgIEx3dC5yZXJhaXNlIGV4blxuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICBMd3QucmVyYWlzZSBleG4pXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFB1c2ggdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gICAgICBlbnF1ZXVlJyAoU29tZSB4KSBsYXN0O1xuICAgICAgaW5mby5wdXNoYl9jb3VudCA8LSBpbmZvLnB1c2hiX2NvdW50ICsgMTtcbiAgICAgICgqIFNlbmQgYSBzaWduYWwgaWYgYXQgbGVhc3Qgb25lIHRocmVhZCBpcyB3YWl0aW5nIGZvciBhIG5ld1xuICAgICAgICAgZWxlbWVudC4gKilcbiAgICAgIGlmIGluZm8ucHVzaGJfd2FpdGluZyB0aGVuIGJlZ2luXG4gICAgICAgIGluZm8ucHVzaGJfd2FpdGluZyA8LSBmYWxzZTtcbiAgICAgICAgKCogVXBkYXRlIHRocmVhZHMuICopXG4gICAgICAgIGxldCBvbGRfd2FrZW5lciA9ICF3YWtlbmVyX2NlbGwgaW5cbiAgICAgICAgbGV0IG5ld193YWl0ZXIsIG5ld193YWtlbmVyID0gTHd0LndhaXQgKCkgaW5cbiAgICAgICAgaW5mby5wdXNoYl9zaWduYWwgPC0gbmV3X3dhaXRlcjtcbiAgICAgICAgd2FrZW5lcl9jZWxsIDo9IG5ld193YWtlbmVyO1xuICAgICAgICAoKiBTaWduYWwgdGhhdCBhIG5ldyB2YWx1ZSBoYXMgYmVlbiByZWNlaXZlZC4gKilcbiAgICAgICAgTHd0Lndha2V1cF9sYXRlciBvbGRfd2FrZW5lciAoKVxuICAgICAgZW5kO1xuICAgICAgTHd0LnJldHVybl91bml0XG4gICAgZW5kXG5cbiAgbWV0aG9kIGNsb3NlID1cbiAgICBpZiBub3QgY2xvc2VkIHRoZW4gYmVnaW5cbiAgICAgIGNsb3NlZCA8LSB0cnVlO1xuICAgICAgbGV0IG5vZGUgPSAhbGFzdCBhbmQgbmV3X2xhc3QgPSBuZXdfbm9kZSAoKSBpblxuICAgICAgbm9kZS5kYXRhIDwtIE5vbmU7XG4gICAgICBub2RlLm5leHQgPC0gbmV3X2xhc3Q7XG4gICAgICBsYXN0IDo9IG5ld19sYXN0O1xuICAgICAgaWYgaW5mby5wdXNoYl9wZW5kaW5nIDw+IE5vbmUgdGhlbiBiZWdpblxuICAgICAgICBpbmZvLnB1c2hiX3BlbmRpbmcgPC0gTm9uZTtcbiAgICAgICAgTHd0Lndha2V1cF9sYXRlcl9leG4gaW5mby5wdXNoYl9wdXNoX3dha2VuZXIgQ2xvc2VkXG4gICAgICBlbmQ7XG4gICAgICAoKiBTZW5kIGEgc2lnbmFsIGlmIGF0IGxlYXN0IG9uZSB0aHJlYWQgaXMgd2FpdGluZyBmb3IgYSBuZXdcbiAgICAgICAgIGVsZW1lbnQuICopXG4gICAgICBpZiBpbmZvLnB1c2hiX3dhaXRpbmcgdGhlbiBiZWdpblxuICAgICAgICBpbmZvLnB1c2hiX3dhaXRpbmcgPC0gZmFsc2U7XG4gICAgICAgIGxldCBvbGRfd2FrZW5lciA9ICF3YWtlbmVyX2NlbGwgaW5cbiAgICAgICAgKCogU2lnbmFsIHRoYXQgYSBuZXcgdmFsdWUgaGFzIGJlZW4gcmVjZWl2ZWQuICopXG4gICAgICAgIEx3dC53YWtldXBfbGF0ZXIgb2xkX3dha2VuZXIgKClcbiAgICAgIGVuZDtcbiAgICAgIEx3dC53YWtldXAgY2xvc2UgKCk7XG4gICAgZW5kXG5cbiAgbWV0aG9kIGNvdW50ID1cbiAgICBpbmZvLnB1c2hiX2NvdW50XG5cbiAgbWV0aG9kIGJsb2NrZWQgPVxuICAgIGluZm8ucHVzaGJfcGVuZGluZyA8PiBOb25lXG5cbiAgbWV0aG9kIGNsb3NlZCA9XG4gICAgY2xvc2VkXG5cbiAgbWV0aG9kIHNldF9yZWZlcmVuY2UgOiAnYS4gJ2EgLT4gdW5pdCA9XG4gICAgZnVuIHggLT4gaW5mby5wdXNoYl9leHRlcm5hbCA8LSBPYmoucmVwciB4XG5lbmRcblxubGV0IGNyZWF0ZV9ib3VuZGVkIHNpemUgPVxuICBpZiBzaXplIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTHd0X3N0cmVhbS5jcmVhdGVfYm91bmRlZFwiO1xuICAoKiBDcmVhdGUgdGhlIHNvdXJjZSBmb3Igbm90aWZpY2F0aW9ucyBvZiBuZXcgZWxlbWVudHMuICopXG4gIGxldCBpbmZvLCB3YWtlbmVyX2NlbGwgPVxuICAgIGxldCB3YWl0ZXIsIHdha2VuZXIgPSBMd3Qud2FpdCAoKSBpblxuICAgIGxldCBwdXNoX3dhaXRlciwgcHVzaF93YWtlbmVyID0gTHd0LnRhc2sgKCkgaW5cbiAgICAoeyBwdXNoYl9zaWduYWwgPSB3YWl0ZXI7XG4gICAgICAgcHVzaGJfd2FpdGluZyA9IGZhbHNlO1xuICAgICAgIHB1c2hiX3NpemUgPSBzaXplO1xuICAgICAgIHB1c2hiX2NvdW50ID0gMDtcbiAgICAgICBwdXNoYl9wZW5kaW5nID0gTm9uZTtcbiAgICAgICBwdXNoYl9wdXNoX3dhaXRlciA9IHB1c2hfd2FpdGVyO1xuICAgICAgIHB1c2hiX3B1c2hfd2FrZW5lciA9IHB1c2hfd2FrZW5lcjtcbiAgICAgICBwdXNoYl9leHRlcm5hbCA9IE9iai5yZXByICgpIH0sXG4gICAgIHJlZiB3YWtlbmVyKVxuICBpblxuICBsZXQgdCA9IGZyb21fc291cmNlIChQdXNoX2JvdW5kZWQgaW5mbykgaW5cbiAgKHQsIG5ldyBib3VuZGVkX3B1c2hfaW1wbCBpbmZvIHdha2VuZXJfY2VsbCB0Lmxhc3QgdC5jbG9zZSlcblxuKCogV2FpdCBmb3IgYSBuZXcgZWxlbWVudCB0byBiZSBhZGRlZCB0byB0aGUgcXVldWUgb2YgcGVuZGluZyBlbGVtZW50XG4gICBvZiB0aGUgc3RyZWFtLiAqKVxubGV0IGZlZWQgcyA9XG4gIG1hdGNoIHMuc291cmNlIHdpdGhcbiAgfCBGcm9tIGZyb20gLT5cbiAgICAoKiBUaGVyZSBpcyBhbHJlYWR5IGEgdGhyZWFkIHN0YXJ0ZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnQsXG4gICAgICAgd2FpdCBmb3IgdGhpcyBvbmUgdG8gdGVybWluYXRlLiAqKVxuICAgIGlmIEx3dC5pc19zbGVlcGluZyBmcm9tLmZyb21fdGhyZWFkIHRoZW5cbiAgICAgIEx3dC5wcm90ZWN0ZWQgZnJvbS5mcm9tX3RocmVhZFxuICAgIGVsc2UgYmVnaW5cbiAgICAgICgqIE90aGVyd2lzZSByZXF1ZXN0IGEgbmV3IGVsZW1lbnQuICopXG4gICAgICBsZXQgdGhyZWFkID1cbiAgICAgICAgKCogVGhlIGZ1bmN0aW9uIFtmcm9tX2NyZWF0ZV0gY2FuIHJhaXNlIGFuIGV4Y2VwdGlvbiAod2l0aFxuICAgICAgICAgICBbcmFpc2VdLCByYXRoZXIgdGhhbiByZXR1cm5pbmcgYSBmYWlsZWQgcHJvbWlzZSB3aXRoXG4gICAgICAgICAgIFtMd3QuZmFpbF0pLiBJbiB0aGlzIGNhc2UsIHdlIGhhdmUgdG8gY2F0Y2ggdGhlIGV4Y2VwdGlvblxuICAgICAgICAgICBhbmQgdHVybiBpdCBpbnRvIGEgc2FmZSBmYWlsZWQgcHJvbWlzZS4gKilcbiAgICAgICAgTHd0LmNhdGNoXG4gICAgICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgICAgZnJvbS5mcm9tX2NyZWF0ZSAoKSA+Pj0gZnVuIHggLT5cbiAgICAgICAgICAgICgqIFB1c2ggdGhlIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gICAgICAgICAgICBlbnF1ZXVlIHggcztcbiAgICAgICAgICAgIGlmIHggPSBOb25lIHRoZW4gTHd0Lndha2V1cCBzLmNsb3NlICgpO1xuICAgICAgICAgICAgTHd0LnJldHVybl91bml0KVxuICAgICAgICAgIEx3dC5yZXJhaXNlXG4gICAgICBpblxuICAgICAgKCogQWxsb3cgb3RoZXIgdGhyZWFkcyB0byBhY2Nlc3MgdGhpcyB0aHJlYWQuICopXG4gICAgICBmcm9tLmZyb21fdGhyZWFkIDwtIHRocmVhZDtcbiAgICAgIEx3dC5wcm90ZWN0ZWQgdGhyZWFkXG4gICAgZW5kXG4gIHwgRnJvbV9kaXJlY3QgZiAtPlxuICAgIGxldCB4ID0gZiAoKSBpblxuICAgICgqIFB1c2ggdGhlIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gICAgZW5xdWV1ZSB4IHM7XG4gICAgaWYgeCA9IE5vbmUgdGhlbiBMd3Qud2FrZXVwIHMuY2xvc2UgKCk7XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgUHVzaCBwdXNoIC0+XG4gICAgcHVzaC5wdXNoX3dhaXRpbmcgPC0gdHJ1ZTtcbiAgICBMd3QucHJvdGVjdGVkIHB1c2gucHVzaF9zaWduYWxcbiAgfCBQdXNoX2JvdW5kZWQgcHVzaCAtPlxuICAgIHB1c2gucHVzaGJfd2FpdGluZyA8LSB0cnVlO1xuICAgIEx3dC5wcm90ZWN0ZWQgcHVzaC5wdXNoYl9zaWduYWxcblxuKCogUmVtb3ZlIFtub2RlXSBmcm9tIHRoZSB0b3Agb2YgdGhlIHF1ZXVlLCBvciBkbyBub3RoaW5nIGlmIGl0IHdhc1xuICAgYWxyZWFkeSBjb25zdW1lZC5cblxuICAgUHJlY29uZGl0aW9uOiBub2RlLmRhdGEgPD4gTm9uZVxuKilcbmxldCBjb25zdW1lIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gcy5ub2RlIHRoZW4gYmVnaW5cbiAgICBzLm5vZGUgPC0gbm9kZS5uZXh0O1xuICAgIG1hdGNoIHMuc291cmNlIHdpdGhcbiAgICB8IFB1c2hfYm91bmRlZCBpbmZvIC0+XG4gICAgICBpZiBpbmZvLnB1c2hiX3BlbmRpbmcgPSBOb25lIHRoZW5cbiAgICAgICAgaW5mby5wdXNoYl9jb3VudCA8LSBpbmZvLnB1c2hiX2NvdW50IC0gMVxuICAgICAgZWxzZVxuICAgICAgICBub3RpZnlfcHVzaGVyIGluZm8gcy5sYXN0XG4gICAgfCBGcm9tIF8gfCBGcm9tX2RpcmVjdCBfIHwgUHVzaCBfIC0+XG4gICAgICAoKVxuICBlbmRcblxubGV0IHJlYyBwZWVrX3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gcGVla19yZWMgcyBub2RlXG4gIGVsc2VcbiAgICBMd3QucmV0dXJuIG5vZGUuZGF0YVxuXG5sZXQgcGVlayBzID0gcGVla19yZWMgcyBzLm5vZGVcblxubGV0IHJlYyBucGVla19yZWMgbm9kZSBhY2MgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW5cbiAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG4gIGVsc2UgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IG5wZWVrX3JlYyBub2RlIGFjYyBuIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIG5wZWVrX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSAobiAtIDEpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IG5wZWVrIG4gcyA9IG5wZWVrX3JlYyBzLm5vZGUgW10gbiBzXG5cbmxldCByZWMgZ2V0X3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZ2V0X3JlYyBzIG5vZGVcbiAgZWxzZSBiZWdpblxuICAgIGlmIG5vZGUuZGF0YSA8PiBOb25lIHRoZW4gY29uc3VtZSBzIG5vZGU7XG4gICAgTHd0LnJldHVybiBub2RlLmRhdGFcbiAgZW5kXG5cbmxldCBnZXQgcyA9IGdldF9yZWMgcyBzLm5vZGVcblxubGV0IHJlYyBnZXRfZXhuX3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgTHd0LnRyeV9iaW5kXG4gICAgICAoZnVuICgpIC0+IGZlZWQgcylcbiAgICAgIChmdW4gKCkgLT4gZ2V0X2V4bl9yZWMgcyBub2RlKVxuICAgICAgKGZ1biBleG4gLT4gTHd0LnJldHVybiAoU29tZSAoUmVzdWx0LkVycm9yIGV4bikpKVxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgdmFsdWUgLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgTHd0LnJldHVybiAoU29tZSAoUmVzdWx0Lk9rIHZhbHVlKSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgd3JhcF9leG4gcyA9IGZyb20gKGZ1biAoKSAtPiBnZXRfZXhuX3JlYyBzIHMubm9kZSlcblxubGV0IHJlYyBuZ2V0X3JlYyBub2RlIGFjYyBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbmdldF9yZWMgbm9kZSBhY2MgbiBzXG4gIGVsc2VcbiAgICBtYXRjaCBzLm5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbmdldF9yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgKG4gLSAxKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbmxldCBuZ2V0IG4gcyA9IG5nZXRfcmVjIHMubm9kZSBbXSBuIHNcblxubGV0IHJlYyBnZXRfd2hpbGVfcmVjIG5vZGUgYWNjIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBnZXRfd2hpbGVfcmVjIG5vZGUgYWNjIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHRlc3QgPSBmIHggaW5cbiAgICAgIGlmIHRlc3QgdGhlbiBiZWdpblxuICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgZ2V0X3doaWxlX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBmIHNcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IGdldF93aGlsZSBmIHMgPSBnZXRfd2hpbGVfcmVjIHMubm9kZSBbXSBmIHNcblxubGV0IHJlYyBnZXRfd2hpbGVfc19yZWMgbm9kZSBhY2MgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGdldF93aGlsZV9zX3JlYyBub2RlIGFjYyBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT4gYmVnaW5cbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgICBnZXRfd2hpbGVfc19yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgZiBzXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IGdldF93aGlsZV9zIGYgcyA9IGdldF93aGlsZV9zX3JlYyBzLm5vZGUgW10gZiBzXG5cbmxldCByZWMgbmV4dF9yZWMgcyBub2RlID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IG5leHRfcmVjIHMgbm9kZVxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBMd3QucmV0dXJuIHhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5mYWlsIEVtcHR5XG5cbmxldCBuZXh0IHMgPSBuZXh0X3JlYyBzIHMubm9kZVxuXG5sZXQgcmVjIGxhc3RfbmV3X3JlYyBub2RlIHggcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gZmVlZCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlIHggc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICBMd3QuZmFpbCBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgTHd0LnJldHVybiB4XG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlLm5leHQgeCBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIHhcblxubGV0IGxhc3RfbmV3IHMgPVxuICBsZXQgbm9kZSA9IHMubm9kZSBpblxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IG5leHQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiB4IC0+XG4gICAgICBsYXN0X25ld19yZWMgbm9kZSB4IHNcbiAgICB8IEx3dC5GYWlsIF8gfCBMd3QuU2xlZXAgLT5cbiAgICAgIHRocmVhZFxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsYXN0X25ld19yZWMgbm9kZS5uZXh0IHggc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LmZhaWwgRW1wdHlcblxubGV0IHJlYyB0b19saXN0X3JlYyBub2RlIGFjYyBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IHRvX2xpc3RfcmVjIG5vZGUgYWNjIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgdG9fbGlzdF9yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgdG9fbGlzdCBzID0gdG9fbGlzdF9yZWMgcy5ub2RlIFtdIHNcblxubGV0IHJlYyB0b19zdHJpbmdfcmVjIG5vZGUgYnVmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gdG9fc3RyaW5nX3JlYyBub2RlIGJ1ZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgeDtcbiAgICAgIHRvX3N0cmluZ19yZWMgbm9kZS5uZXh0IGJ1ZiBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChCdWZmZXIuY29udGVudHMgYnVmKVxuXG5sZXQgdG9fc3RyaW5nIHMgPSB0b19zdHJpbmdfcmVjIHMubm9kZSAoQnVmZmVyLmNyZWF0ZSAxMjgpIHNcblxubGV0IGp1bmsgcyA9XG4gIGxldCBub2RlID0gcy5ub2RlIGluXG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW4gYmVnaW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPlxuICAgIGlmIG5vZGUuZGF0YSA8PiBOb25lIHRoZW4gY29uc3VtZSBzIG5vZGU7XG4gICAgTHd0LnJldHVybl91bml0XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgaWYgbm9kZS5kYXRhIDw+IE5vbmUgdGhlbiBjb25zdW1lIHMgbm9kZTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZW5kXG5cbmxldCByZWMgbmp1bmtfcmVjIG5vZGUgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW5cbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbmp1bmtfcmVjIG5vZGUgbiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSBfIC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIG5qdW5rX3JlYyBub2RlLm5leHQgKG4gLSAxKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IG5qdW5rIG4gcyA9IG5qdW5rX3JlYyBzLm5vZGUgbiBzXG5cbmxldCByZWMganVua193aGlsZV9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4ganVua193aGlsZV9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB0ZXN0ID0gZiB4IGluXG4gICAgICBpZiB0ZXN0IHRoZW4gYmVnaW5cbiAgICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICAgIGp1bmtfd2hpbGVfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBqdW5rX3doaWxlIGYgcyA9IGp1bmtfd2hpbGVfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBqdW5rX3doaWxlX3NfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGp1bmtfd2hpbGVfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT4gYmVnaW5cbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgICBqdW5rX3doaWxlX3NfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgICAgZW5kXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGp1bmtfd2hpbGVfcyBmIHMgPSBqdW5rX3doaWxlX3NfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBqdW5rX2F2YWlsYWJsZV9yZWMgbm9kZSBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBmZWVkIHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4gXyAtPlxuICAgICAganVua19hdmFpbGFibGVfcmVjIG5vZGUgc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICByYWlzZSBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgKClcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIF8gLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAganVua19hdmFpbGFibGVfcmVjIG5vZGUubmV4dCBzXG4gICAgfCBOb25lIC0+XG4gICAgICAoKVxuXG5sZXQganVua19hdmFpbGFibGUgcyA9IGp1bmtfYXZhaWxhYmxlX3JlYyBzLm5vZGUgc1xuXG5sZXQganVua19vbGQgcyA9IEx3dC5yZXR1cm4gKGp1bmtfYXZhaWxhYmxlIHMpXG5cbmxldCByZWMgZ2V0X2F2YWlsYWJsZV9yZWMgbm9kZSBhY2MgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gZmVlZCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgIGdldF9hdmFpbGFibGVfcmVjIG5vZGUgYWNjIHNcbiAgICB8IEx3dC5GYWlsIGV4biAtPlxuICAgICAgcmFpc2UgZXhuXG4gICAgfCBMd3QuU2xlZXAgLT5cbiAgICAgIExpc3QucmV2IGFjY1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBnZXRfYXZhaWxhYmxlX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMaXN0LnJldiBhY2NcblxubGV0IGdldF9hdmFpbGFibGUgcyA9IGdldF9hdmFpbGFibGVfcmVjIHMubm9kZSBbXSBzXG5cbmxldCByZWMgZ2V0X2F2YWlsYWJsZV91cF90b19yZWMgbm9kZSBhY2MgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW5cbiAgICBMaXN0LnJldiBhY2NcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IGZlZWQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiBfIC0+XG4gICAgICBnZXRfYXZhaWxhYmxlX3VwX3RvX3JlYyBub2RlIGFjYyBuIHNcbiAgICB8IEx3dC5GYWlsIGV4biAtPlxuICAgICAgcmFpc2UgZXhuXG4gICAgfCBMd3QuU2xlZXAgLT5cbiAgICAgIExpc3QucmV2IGFjY1xuICBlbHNlXG4gICAgbWF0Y2ggcy5ub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGdldF9hdmFpbGFibGVfdXBfdG9fcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIChuIC0gMSkgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTGlzdC5yZXYgYWNjXG5cbmxldCBnZXRfYXZhaWxhYmxlX3VwX3RvIG4gcyA9IGdldF9hdmFpbGFibGVfdXBfdG9fcmVjIHMubm9kZSBbXSBuIHNcblxubGV0IHJlYyBpc19lbXB0eSBzID1cbiAgaWYgcy5ub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gaXNfZW1wdHkgc1xuICBlbHNlXG4gICAgTHd0LnJldHVybiAocy5ub2RlLmRhdGEgPSBOb25lKVxuXG5sZXQgbWFwIGYgcyA9XG4gIGZyb20gKGZ1biAoKSAtPiBnZXQgcyA+fD0gZnVuY3Rpb25cbiAgfCBTb21lIHggLT5cbiAgICBsZXQgeCA9IGYgeCBpblxuICAgIFNvbWUgeFxuICB8IE5vbmUgLT5cbiAgICBOb25lKVxuXG5sZXQgbWFwX3MgZiBzID1cbiAgZnJvbSAoZnVuICgpIC0+IGdldCBzID4+PSBmdW5jdGlvblxuICB8IFNvbWUgeCAtPlxuICAgIGYgeCA+fD0gKGZ1biB4IC0+IFNvbWUgeClcbiAgfCBOb25lIC0+XG4gICAgTHd0LnJldHVybl9ub25lKVxuXG5sZXQgZmlsdGVyIGYgcyA9XG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbGV0IHQgPSBnZXQgcyBpblxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB0ZXN0ID0gZiB4IGluXG4gICAgICBpZiB0ZXN0IHRoZW5cbiAgICAgICAgdFxuICAgICAgZWxzZVxuICAgICAgICBuZXh0ICgpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmaWx0ZXJfcyBmIHMgPVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGxldCB0ID0gZ2V0IHMgaW5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+IGJlZ2luXG4gICAgICAgIGYgeCA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgdFxuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgbmV4dCAoKVxuICAgICAgZW5kXG4gICAgfCBOb25lIC0+XG4gICAgICB0XG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgZmlsdGVyX21hcCBmIHMgPVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGdldCBzID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgeCA9IGYgeCBpblxuICAgICAgKG1hdGNoIHggd2l0aFxuICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICBMd3QucmV0dXJuIHhcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIG5leHQgKCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmaWx0ZXJfbWFwX3MgZiBzID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHQgPSBmIHggaW5cbiAgICAgICh0ID4+PSBmdW5jdGlvblxuICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICB0XG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBuZXh0ICgpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgbWFwX2xpc3QgZiBzID1cbiAgbGV0IHBlbmRpbmdzID0gcmVmIFtdIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbWF0Y2ggIXBlbmRpbmdzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICAoZ2V0IHMgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBTb21lIHggLT5cbiAgICAgICAgIGxldCBsID0gZiB4IGluXG4gICAgICAgICBwZW5kaW5ncyA6PSBsO1xuICAgICAgICAgbmV4dCAoKVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgTHd0LnJldHVybl9ub25lKVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICBwZW5kaW5ncyA6PSBsO1xuICAgICAgTHd0LnJldHVybiAoU29tZSB4KVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IG1hcF9saXN0X3MgZiBzID1cbiAgbGV0IHBlbmRpbmdzID0gcmVmIFtdIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbWF0Y2ggIXBlbmRpbmdzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICAoZ2V0IHMgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBTb21lIHggLT5cbiAgICAgICAgIGYgeCA+Pj0gZnVuIGwgLT5cbiAgICAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICAgICBuZXh0ICgpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBMd3QucmV0dXJuX25vbmUpXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICBMd3QucmV0dXJuIChTb21lIHgpXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgZmxhdHRlbiBzID1cbiAgbWFwX2xpc3QgKGZ1biBsIC0+IGwpIHNcblxubGV0IHJlYyBmb2xkX3JlYyBub2RlIGYgcyBhY2MgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZm9sZF9yZWMgbm9kZSBmIHMgYWNjXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCBhY2MgPSBmIHggYWNjIGluXG4gICAgICBmb2xkX3JlYyBub2RlLm5leHQgZiBzIGFjY1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiBhY2NcblxubGV0IGZvbGQgZiBzIGFjYyA9IGZvbGRfcmVjIHMubm9kZSBmIHMgYWNjXG5cbmxldCByZWMgZm9sZF9zX3JlYyBub2RlIGYgcyBhY2MgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZm9sZF9zX3JlYyBub2RlIGYgcyBhY2NcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgZiB4IGFjYyA+Pj0gZnVuIGFjYyAtPlxuICAgICAgZm9sZF9zX3JlYyBub2RlLm5leHQgZiBzIGFjY1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiBhY2NcblxubGV0IGZvbGRfcyBmIHMgYWNjID0gZm9sZF9zX3JlYyBzLm5vZGUgZiBzIGFjY1xuXG5sZXQgcmVjIGl0ZXJfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGl0ZXJfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCAoKSA9IGYgeCBpblxuICAgICAgaXRlcl9yZWMgbm9kZS5uZXh0IGYgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBpdGVyIGYgcyA9IGl0ZXJfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBpdGVyX3NfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGl0ZXJfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgZiB4ID4+PSBmdW4gKCkgLT5cbiAgICAgIGl0ZXJfc19yZWMgbm9kZS5uZXh0IGYgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBpdGVyX3MgZiBzID0gaXRlcl9zX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgaXRlcl9wX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBpdGVyX3BfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCByZXMgPSBmIHggaW5cbiAgICAgIGxldCByZXN0ID0gaXRlcl9wX3JlYyBub2RlLm5leHQgZiBzIGluXG4gICAgICByZXMgPj49IGZ1biAoKSAtPiByZXN0XG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGl0ZXJfcCBmIHMgPSBpdGVyX3BfcmVjIHMubm9kZSBmIHNcblxubGV0IGl0ZXJfbiA/KG1heF9jb25jdXJyZW5jeSA9IDEpIGYgc3RyZWFtID1cbiAgYmVnaW5cbiAgICBpZiBtYXhfY29uY3VycmVuY3kgPD0gMCB0aGVuXG4gICAgICBsZXQgbWVzc2FnZSA9XG4gICAgICAgIFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgXCJMd3Rfc3RyZWFtLml0ZXJfbjogbWF4X2NvbmN1cnJlbmN5IG11c3QgYmUgPiAwLCAlZCBnaXZlblwiXG4gICAgICAgICAgbWF4X2NvbmN1cnJlbmN5XG4gICAgICBpblxuICAgICAgaW52YWxpZF9hcmcgbWVzc2FnZVxuICBlbmQ7XG4gIGxldCByZWMgbG9vcCBydW5uaW5nIGF2YWlsYWJsZSA9XG4gICAgYmVnaW5cbiAgICAgIGlmIGF2YWlsYWJsZSA+IDAgdGhlbiAoXG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSlcbiAgICAgIClcbiAgICAgIGVsc2UgKFxuICAgICAgICBMd3QubmNob29zZV9zcGxpdCBydW5uaW5nID4+PSBmdW4gKGNvbXBsZXRlLCBydW5uaW5nKSAtPlxuICAgICAgICBMd3QucmV0dXJuIChydW5uaW5nLCBhdmFpbGFibGUgKyBMaXN0Lmxlbmd0aCBjb21wbGV0ZSlcbiAgICAgIClcbiAgICBlbmQgPj49IGZ1biAocnVubmluZywgYXZhaWxhYmxlKSAtPlxuICAgIGdldCBzdHJlYW0gPj49IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3Quam9pbiBydW5uaW5nXG4gICAgfCBTb21lIGVsdCAtPlxuICAgICAgbG9vcCAoZiBlbHQgOjogcnVubmluZykgKHByZWQgYXZhaWxhYmxlKVxuICBpblxuICBsb29wIFtdIG1heF9jb25jdXJyZW5jeVxuXG5sZXQgcmVjIGZpbmRfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZpbmRfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IGFzIG9wdCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgdGVzdCA9IGYgeCBpblxuICAgICAgaWYgdGVzdCB0aGVuXG4gICAgICAgIEx3dC5yZXR1cm4gb3B0XG4gICAgICBlbHNlXG4gICAgICAgIGZpbmRfcmVjIG5vZGUubmV4dCBmIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmluZCBmIHMgPSBmaW5kX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgZmluZF9zX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmaW5kX3NfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IGFzIG9wdCAtPiBiZWdpblxuICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBMd3QucmV0dXJuIG9wdFxuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgZmluZF9zX3JlYyBub2RlLm5leHQgZiBzXG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmluZF9zIGYgcyA9IGZpbmRfc19yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGZpbmRfbWFwX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmaW5kX21hcF9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIGlmIHggPSBOb25lIHRoZW5cbiAgICAgICAgZmluZF9tYXBfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgIGVsc2VcbiAgICAgICAgTHd0LnJldHVybiB4XG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbmRfbWFwIGYgcyA9IGZpbmRfbWFwX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgZmluZF9tYXBfc19yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZmluZF9tYXBfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IHQgPSBmIHggaW5cbiAgICAgICh0ID4+PSBmdW5jdGlvblxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgZmluZF9tYXBfc19yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICB0KVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaW5kX21hcF9zIGYgcyA9IGZpbmRfbWFwX3NfcmVjIHMubm9kZSBmIHNcblxubGV0IGNvbWJpbmUgczEgczIgPVxuICBsZXQgbmV4dCAoKSA9XG4gICAgbGV0IHQxID0gZ2V0IHMxIGFuZCB0MiA9IGdldCBzMiBpblxuICAgIHQxID4+PSBmdW4gbjEgLT5cbiAgICB0MiA+Pj0gZnVuIG4yIC0+XG4gICAgbWF0Y2ggbjEsIG4yIHdpdGhcbiAgICB8IFNvbWUgeDEsIFNvbWUgeDIgLT5cbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUoeDEsIHgyKSlcbiAgICB8IF8gLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGFwcGVuZCBzMSBzMiA9XG4gIGxldCBjdXJyZW50X3MgPSByZWYgczEgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBsZXQgdCA9IGdldCAhY3VycmVudF9zIGluXG4gICAgdCA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgXyAtPlxuICAgICAgdFxuICAgIHwgTm9uZSAtPlxuICAgICAgaWYgIWN1cnJlbnRfcyA9PSBzMiB0aGVuXG4gICAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBjdXJyZW50X3MgOj0gczI7XG4gICAgICAgIG5leHQgKClcbiAgICAgIGVuZFxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGNvbmNhdCBzX3RvcCA9XG4gIGxldCBjdXJyZW50X3MgPSByZWYgKGZyb20gKGZ1biAoKSAtPiBMd3QucmV0dXJuX25vbmUpKSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGxldCB0ID0gZ2V0ICFjdXJyZW50X3MgaW5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSBfIC0+XG4gICAgICB0XG4gICAgfCBOb25lIC0+XG4gICAgICBnZXQgc190b3AgPj49IGZ1bmN0aW9uXG4gICAgICB8IFNvbWUgcyAtPlxuICAgICAgICBjdXJyZW50X3MgOj0gcztcbiAgICAgICAgbmV4dCAoKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGNob29zZSBzdHJlYW1zID1cbiAgbGV0IHNvdXJjZSBzID0gKHMsIGdldCBzID58PSBmdW4geCAtPiAocywgeCkpIGluXG4gIGxldCBzdHJlYW1zID0gcmVmIChMaXN0Lm1hcCBzb3VyY2Ugc3RyZWFtcykgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhc3RyZWFtcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gICAgfCBsIC0+XG4gICAgICBMd3QuY2hvb3NlIChMaXN0Lm1hcCBzbmQgbCkgPj49IGZ1biAocywgeCkgLT5cbiAgICAgIGxldCBsID0gTGlzdC5yZW1vdmVfYXNzcSBzIGwgaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgc3RyZWFtcyA6PSBzb3VyY2UgcyA6OiBsO1xuICAgICAgICBMd3QucmV0dXJuIHhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBzdHJlYW1zIDo9IGw7XG4gICAgICAgIG5leHQgKClcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBwYXJzZSBzIGYgPVxuICAobWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICAgfCBQdXNoX2JvdW5kZWQgXyAtPiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0ucGFyc2VcIlxuICAgfCBGcm9tIF8gfCBGcm9tX2RpcmVjdCBfIHwgUHVzaCBfIC0+ICgpKTtcbiAgbGV0IG5vZGUgPSBzLm5vZGUgaW5cbiAgTHd0LmNhdGNoXG4gICAgKGZ1biAoKSAtPiBmIHMpXG4gICAgKGZ1biBleG4gLT5cbiAgICAgICBzLm5vZGUgPC0gbm9kZTtcbiAgICAgICBMd3QucmVyYWlzZSBleG4pXG5cbmxldCBoZXhkdW1wIHN0cmVhbSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDgwIGFuZCBudW0gPSByZWYgMCBpblxuICBmcm9tIGJlZ2luIGZ1biBfIC0+XG4gICAgbmdldCAxNiBzdHJlYW0gPj49IGZ1bmN0aW9uXG4gICAgfCBbXSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gICAgfCBsIC0+XG4gICAgICBCdWZmZXIuY2xlYXIgYnVmO1xuICAgICAgUHJpbnRmLmJwcmludGYgYnVmIFwiJTA4eHwgIFwiICFudW07XG4gICAgICBudW0gOj0gIW51bSArIDE2O1xuICAgICAgbGV0IHJlYyBieXRlcyBwb3MgPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgYmxhbmtzIHBvc1xuICAgICAgICB8IHggOjogbCAtPlxuICAgICAgICAgIGlmIHBvcyA9IDggdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgICBQcmludGYuYnByaW50ZiBidWYgXCIlMDJ4IFwiIChDaGFyLmNvZGUgeCk7XG4gICAgICAgICAgYnl0ZXMgKHBvcyArIDEpIGxcbiAgICAgIGFuZCBibGFua3MgcG9zID1cbiAgICAgICAgaWYgcG9zIDwgMTYgdGhlbiBiZWdpblxuICAgICAgICAgIGlmIHBvcyA9IDggdGhlblxuICAgICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiICAgIFwiXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiICAgXCI7XG4gICAgICAgICAgYmxhbmtzIChwb3MgKyAxKVxuICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBieXRlcyAwIGw7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIgfFwiO1xuICAgICAgTGlzdC5pdGVyIChmdW4gY2ggLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAoaWYgY2ggPj0gJ1xceDIwJyAmJiBjaCA8PSAnXFx4N2UnIHRoZW4gY2ggZWxzZSAnLicpKSBsO1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnfCc7XG4gICAgICBMd3QucmV0dXJuIChTb21lKEJ1ZmZlci5jb250ZW50cyBidWYpKVxuICBlbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo0NDI3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiTHd0IiwiQXNzZXJ0X2ZhaWx1cmUiLCJyZXR1cm4iLCJ4IiwiZmFpbCIsImUiLCJsaWZ0Iiwib2siLCJ5IiwiZXJyb3IiLCJtYXAiLCJwYXJhbSIsIm1hcF9lcnJvciIsIm1hcF9lcnIiLCJjYXRjaCIsImdldF9leG4iLCJzeW1ib2xfYmluZCIsImJpbmRfZXJyb3IiLCJiaW5kX2x3dCIsImJpbmRfcmVzdWx0IiwiYmluZF9sd3RfZXJyb3IiLCJiaW5kX2x3dF9lcnIiLCJib3RoIiwiYSIsImIiLCJzIiwic2V0X29uY2UiLCJtYXRjaCIsIml0ZXIiLCJyIiwiaXRlcl9lcnJvciIsInN5bWJvbCIsInQiLCJiaW5kIiwiT3Blbl9vbl9yaHMiLCJMZXRfc3ludGF4IiwibGV0IiwiU3ludGF4IiwiTHd0X3Jlc3VsdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL2x3dC9sd3RfcmVzdWx0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxZQUFBQyxTQUFBQyxHQ1NlLGlDQUFpQjtBQUFBLFlBQUFDLEtBQUFDLEdBQ25CLGlDQUFvQjtBQUFBLE9BQUFDLE9EVmpDO0FBQUEsWUFBQUMsR0FBQUosR0NhVyxvQ0FBQUssR0FBa0IsY0FBSSxLQUFHO0FBQUEsWUFBQUMsTUFBQU47QUFBQUEsSUFDdEIs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bkMsR0FBQWtDO0FBQUFBLElBR2pDO0FBQUE7QUFBQTtBQUFBLHNCQUFBbEI7QUFBQUEsY0FDRSxtQkFFWTtBQUFBLGtCQUFBTixJQUZaO0FBQUEsY0FDZSx1QkFDYTtBQUFBO0FBQUE7QUFBQSxZQUFBMEIsT0FBQTFCLEdBQUFWLEdBSWQsZ0JBQU87QUFBQSxZQUFBZSxNQUFBc0IsR0FBQXJDLEdBTU4sZ0JBQU87QUFBQSxZQUFBc0MsS0FBQUQsR0FBQXJDLEdBQ04sd0JBQVE7QUFBQTtBQUFBLElBQUF1QyxjRG5INUI7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUEsZUFBQTtBQUFBLFlBQUFDLE1BQUFqQyxHQUFBUixHQzhIbUIsZ0JBQU87QUFBQTtBQUFBLElBQUEwQyxTRDlIMUI7QUFBQSxJQUFBQztBQUFBQSxNQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuKCoqIE1vZHVsZSBbTHd0X3Jlc3VsdF06IGV4cGxpY2l0IGVycm9yIGhhbmRsaW5nICopXG5cbm9wZW4gUmVzdWx0XG5cbnR5cGUgKCsnYSwgKydiKSB0ID0gKCdhLCAnYikgUmVzdWx0LnQgTHd0LnRcblxubGV0IHJldHVybiB4ID0gTHd0LnJldHVybiAoT2sgeClcbmxldCBmYWlsIGUgPSBMd3QucmV0dXJuIChFcnJvciBlKVxuXG5sZXQgbGlmdCA9IEx3dC5yZXR1cm5cbmxldCBvayB4ID0gTHd0Lm1hcCAoZnVuIHkgLT4gT2sgeSkgeFxubGV0IGVycm9yIHggPSBMd3QubWFwIChmdW4geSAtPiBFcnJvciB5KSB4XG5cbmxldCBtYXAgZiBlID1cbiAgTHd0Lm1hcFxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IEVycm9yIGVcbiAgICAgIHwgT2sgeCAtPiBPayAoZiB4KSlcbiAgICBlXG5cbmxldCBtYXBfZXJyb3IgZiBlID1cbiAgTHd0Lm1hcFxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IEVycm9yIChmIGUpXG4gICAgICB8IE9rIHggLT4gT2sgeClcbiAgICBlXG5sZXQgbWFwX2VyciBmIGUgPSBtYXBfZXJyb3IgZiBlXG5cbmxldCBjYXRjaCBlID1cbiAgTHd0LmNhdGNoXG4gICAgKGZ1biAoKSAtPiBvayAoZSAoKSkpXG4gICAgZmFpbFxuXG5sZXQgZ2V0X2V4biBlID1cbiAgTHd0LmJpbmQgZVxuICAgIChmdW5jdGlvblxuICAgICAgfCBPayB4IC0+IEx3dC5yZXR1cm4geFxuICAgICAgfCBFcnJvciBlIC0+IEx3dC5mYWlsIGUpXG5cbmxldCBiaW5kIGUgZiA9XG4gIEx3dC5iaW5kIGVcbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgRXJyb3IgZSAtPiBMd3QucmV0dXJuIChFcnJvciBlKVxuICAgICAgfCBPayB4IC0+IGYgeClcbiAgICAgIFxubGV0IGJpbmRfZXJyb3IgZSBmID1cbiAgTHd0LmJpbmQgZVxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IGYgZVxuICAgICAgfCBPayB4IC0+IEx3dC5yZXR1cm4gKE9rIHgpKVxuICAgICAgXG5sZXQgYmluZF9sd3QgZSBmID1cbiAgTHd0LmJpbmQgZVxuICAgIChmdW5jdGlvblxuICAgICAgfCBPayB4IC0+IG9rIChmIHgpXG4gICAgICB8IEVycm9yIGUgLT4gZmFpbCBlKVxuXG5sZXQgYmluZF9yZXN1bHQgZSBmID1cbiAgTHd0Lm1hcFxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IEVycm9yIGVcbiAgICAgIHwgT2sgeCAtPiBmIHgpXG4gICAgZVxuXG5sZXQgYmluZF9sd3RfZXJyb3IgZSBmID1cbiAgTHd0LmJpbmQgZVxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IEx3dC5iaW5kIChmIGUpIGZhaWxcbiAgICAgIHwgT2sgeCAtPiByZXR1cm4geClcbmxldCBiaW5kX2x3dF9lcnIgZSBmID0gYmluZF9sd3RfZXJyb3IgZSBmXG5cbmxldCBib3RoIGEgYiA9XG4gIGxldCBzID0gcmVmIE5vbmUgaW5cbiAgbGV0IHNldF9vbmNlIGUgPVxuICAgIG1hdGNoICFzIHdpdGhcbiAgICB8IE5vbmUgLT4gczo9IFNvbWUgZVxuICAgIHwgU29tZSBfIC0+ICgpXG4gIGluXG4gIGxldCAoYSxiKSA9IG1hcF9lcnJvciBzZXRfb25jZSBhLG1hcF9lcnJvciBzZXRfb25jZSBiIGluXG4gIGxldCBzb21lX2Fzc2VydCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgU29tZSBlIC0+IEVycm9yIGVcbiAgaW5cbiAgTHd0Lm1hcFxuICAgIChmdW5jdGlvblxuICAgICAgfCBPayB4LCBPayB5IC0+IE9rICh4LHkpXG4gICAgICB8IEVycm9yIF8sIE9rIF9cbiAgICAgIHwgT2sgXyxFcnJvciBfXG4gICAgICB8IEVycm9yIF8sIEVycm9yIF8gLT4gc29tZV9hc3NlcnQgIXMpXG4gICAgKEx3dC5ib3RoIGEgYilcblxubGV0IGl0ZXIgZiByID1cbiAgTHd0LmJpbmQgclxuICAgIChmdW5jdGlvblxuICAgICAgfCBPayB4IC0+IGYgeFxuICAgICAgfCBFcnJvciBfIC0+IEx3dC5yZXR1cm5fdW5pdClcblxubGV0IGl0ZXJfZXJyb3IgZiByID1cbiAgTHd0LmJpbmQgclxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IGYgZVxuICAgICAgfCBPayBfIC0+IEx3dC5yZXR1cm5fdW5pdClcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoPj49KSA9IGJpbmRcbiAgbGV0ICg+fD0pIGUgZiA9IG1hcCBmIGVcbmVuZFxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICBsZXQgbWFwIHQgfmYgPSBtYXAgZiB0XG4gICAgbGV0IGJpbmQgdCB+ZiA9IGJpbmQgdCBmXG4gICAgbGV0IGJvdGggPSBib3RoXG4gICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0XG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBTeW50YXggPSBzdHJ1Y3RcbiAgbGV0IChsZXQqKSA9IGJpbmRcbiAgbGV0IChhbmQqKSA9IGJvdGhcblxuICBsZXQgKGxldCspIHggZiA9IG1hcCBmIHhcbiAgbGV0IChhbmQrKSA9IGJvdGhcbmVuZFxuXG5pbmNsdWRlIEluZml4XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDYzOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYiIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0xpc3QiLCJNYWtlIiwiT3JkIiwibGluayIsInQxIiwidDIiLCJjMiIsInIyIiwieDIiLCJjMSIsInIxIiwieDEiLCJjIiwiaW5zIiwidCIsInRzIiwiciIsImlzX2VtcHR5IiwiYWRkIiwieCIsInVuaW9uIiwidHMyIiwidHMxIiwiZmluZF9taW4iLCJwYXJhbSIsImxvb2t1cF9taW4iLCJyZXN1bHQiLCJnZXRfbWluIiwibWF0Y2giLCJyZW1vdmVfbWluIiwic2l6ZSIsImwiLCJzIiwidGwiLCJMd3RfcHF1ZXVlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvbHd0L2x3dF9wcXVldWUubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEs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LGdCQUFLO0FBQUE7QUFBQSxJRGhHbEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUFBQyxhQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbnNpZ1xuICB0eXBlIHRcbiAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbnNpZ1xuICB0eXBlIGVsdFxuICB0eXBlIHRcbiAgdmFsIGVtcHR5OiB0XG4gIHZhbCBpc19lbXB0eTogdCAtPiBib29sXG4gIHZhbCBhZGQ6IGVsdCAtPiB0IC0+IHRcbiAgdmFsIHVuaW9uOiB0IC0+IHQgLT4gdFxuICB2YWwgZmluZF9taW46IHQgLT4gZWx0XG4gIHZhbCBsb29rdXBfbWluOiB0IC0+IGVsdCBvcHRpb25cbiAgdmFsIHJlbW92ZV9taW46IHQgLT4gdFxuICB2YWwgc2l6ZTogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA6IChTIHdpdGggdHlwZSBlbHQgPSBPcmQudCkgPVxuc3RydWN0XG4gIHR5cGUgZWx0ID0gT3JkLnRcblxuICB0eXBlIHQgPSB0cmVlIGxpc3RcbiAgYW5kIHRyZWUgPSBOb2RlIG9mIGVsdCAqIGludCAqIHRyZWUgbGlzdFxuXG4gIGxldCByb290IChOb2RlICh4LCBfLCBfKSkgPSB4XG4gIGxldCByYW5rIChOb2RlIChfLCByLCBfKSkgPSByXG4gIGxldCBsaW5rIChOb2RlICh4MSwgcjEsIGMxKSBhcyB0MSkgKE5vZGUgKHgyLCByMiwgYzIpIGFzIHQyKSA9XG4gICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4MSB4MiBpblxuICAgIGlmIGMgPD0gMCB0aGVuIE5vZGUgKHgxLCByMSArIDEsIHQyOjpjMSkgZWxzZSBOb2RlKHgyLCByMiArIDEsIHQxOjpjMilcbiAgbGV0IHJlYyBpbnMgdCA9XG4gICAgZnVuY3Rpb25cbiAgICAgIFtdICAgICAtPlxuICAgICAgW3RdXG4gICAgfCAodCc6Ol8pIGFzIHRzIHdoZW4gcmFuayB0IDwgcmFuayB0JyAtPlxuICAgICAgdDo6dHNcbiAgICB8IHQnOjp0cyAtPlxuICAgICAgaW5zIChsaW5rIHQgdCcpIHRzXG5cbiAgbGV0IGVtcHR5ID0gW11cbiAgbGV0IGlzX2VtcHR5IHRzID0gdHMgPSBbXVxuICBsZXQgYWRkIHggdHMgPSBpbnMgKE5vZGUgKHgsIDAsIFtdKSkgdHNcbiAgbGV0IHJlYyB1bmlvbiB0cyB0cycgPVxuICAgIG1hdGNoIHRzLCB0cycgd2l0aFxuICAgICAgKFtdLCBfKSAtPiB0cydcbiAgICB8IChfLCBbXSkgLT4gdHNcbiAgICB8ICh0MTo6dHMxLCB0Mjo6dHMyKSAgLT5cbiAgICAgIGlmIHJhbmsgdDEgPCByYW5rIHQyIHRoZW4gdDEgOjogdW5pb24gdHMxICh0Mjo6dHMyKVxuICAgICAgZWxzZSBpZiByYW5rIHQyIDwgcmFuayB0MSB0aGVuIHQyIDo6IHVuaW9uICh0MTo6dHMxKSB0czJcbiAgICAgIGVsc2UgaW5zIChsaW5rIHQxIHQyKSAodW5pb24gdHMxIHRzMilcblxuICBsZXQgcmVjIGZpbmRfbWluID1cbiAgICBmdW5jdGlvblxuICAgICAgW10gICAgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCBbdF0gICAtPiByb290IHRcbiAgICB8IHQ6OnRzIC0+XG4gICAgICBsZXQgeCA9IGZpbmRfbWluIHRzIGluXG4gICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIChyb290IHQpIHggaW5cbiAgICAgIGlmIGMgPCAwIHRoZW4gcm9vdCB0IGVsc2UgeFxuXG4gIGxldCByZWMgbG9va3VwX21pbiA9XG4gICAgZnVuY3Rpb25cbiAgICB8IFtdICAgIC0+IE5vbmVcbiAgICB8IFt0XSAgIC0+IFNvbWUgKHJvb3QgdClcbiAgICB8IHQ6OnRzIC0+XG4gICAgICBtYXRjaCBsb29rdXBfbWluIHRzIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgeCBhcyByZXN1bHQgLT5cbiAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSAocm9vdCB0KSB4IGluXG4gICAgICAgIGlmIGMgPCAwIHRoZW4gU29tZSAocm9vdCB0KSBlbHNlIHJlc3VsdFxuXG4gIGxldCByZWMgZ2V0X21pbiA9XG4gICAgZnVuY3Rpb25cbiAgICAgIFtdICAgIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgW3RdICAgLT4gKHQsIFtdKVxuICAgIHwgdDo6dHMgLT5cbiAgICAgIGxldCAodCcsIHRzJykgPSBnZXRfbWluIHRzIGluXG4gICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIChyb290IHQpIChyb290IHQnKSBpblxuICAgICAgaWYgYyA8IDAgdGhlbiAodCwgdHMpIGVsc2UgKHQnLCB0Ojp0cycpXG5cbiAgbGV0IHJlbW92ZV9taW4gPVxuICAgIGZ1bmN0aW9uXG4gICAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IHRzIC0+XG4gICAgICBsZXQgKE5vZGUgKF8sIF8sIGMpLCB0cykgPSBnZXRfbWluIHRzIGluXG4gICAgICB1bmlvbiAoTGlzdC5yZXYgYykgdHNcblxuICBsZXQgcmVjIHNpemUgbCA9XG4gICAgbGV0IHNpemV0cmVlIChOb2RlIChfLF8sdGwpKSA9IDEgKyBzaXplIHRsIGluXG4gICAgTGlzdC5mb2xkX2xlZnQgKGZ1biBzIHQgLT4gcyArIHNpemV0cmVlIHQpIDAgbFxuZW5kXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDc3OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkx3dCIsIlN0ZGxpYiIsIlN0ZGxpYl9MaXN0IiwidGFpbF9yZWN1cnNpdmVfbWFwIiwibCIsInRhaWxfcmVjdXJzaXZlX21hcGlfcmV2IiwiYWNjIiwiaSIsInBhcmFtIiwidGwiLCJoZCIsIml0ZXJfcyIsIngiLCJpdGVyX3AiLCJ0cyIsIml0ZXJpX3MiLCJpdGVyaV9wIiwibWFwX3MiLCJpbm5lciIsInIiLCJjb2xsZWN0X3JldiIsInQiLCJtYXBfcCIsImZpbHRlcl9tYXBfcyIsInYiLCJmaWx0ZXJfbWFwX3AiLCJjb2xsZWN0X29wdGlvbmFsX3JldiIsIm1hcGlfcyIsIm1hcGlfcCIsInJldl9tYXBfYXBwZW5kX3MiLCJyZXZfbWFwX3MiLCJyZXZfbWFwX3AiLCJmb2xkX2xlZnRfcyIsImZvbGRfcmlnaHRfcyIsImEiLCJmb3JfYWxsX3MiLCJmb3JfYWxsX3AiLCJibCIsImV4aXN0c19zIiwiZXhpc3RzX3AiLCJmaW5kX3MiLCJvcHRpb25hbGl6ZSIsImIiLCJmaWx0ZXJfcyIsImZpbHRlcl9wIiwicGFydGl0aW9uX3MiLCJhY2MxIiwiYWNjMiIsInBhcnRpdGlvbl9wIiwiZyIsImdyb3VwMSIsImdyb3VwMiIsIkx3dF9saXN0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvbHd0L2x3dF9saXN0Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsWUFBQUMsbUJBQUFSLEdB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U0FBQWpELEdBQUFTO0FBQUFBLElBR0Qsa0NBQWhCLGdDQUFrQjtBQUFBO0FBQUEsWUFBQXlDLFlBQUFsRCxHQUFBUztBQUFBQSxhQUFBYyxNQUFBNEIsTUFBQUMsTUFBQXZDO0FBQUFBLEtBR2xCO0FBQUEsVUFBQUMsS0FBQSxVQUFBQyxLQUFBLGdCQUVBO0FBQUEsTUFBYztBQUFBO0FBQUE7QUFBQSx3QkFBQWdDO0FBQUFBLGdCQUN0QjtBQUFBLDBCQUNFO0FBQUEsMEJBRUEsOEJBQXdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFMUztBQUFBLFlBQWY7QUFBQSxLQUFhLDhCQUtQO0FBQUE7QUFBQSxJQUVoQyxxQkFBYTtBQUFBO0FBQUEsWUFBQU0sWUFBQXJELEdBQUFTO0FBQUFBLGFBQUE2QyxFQUFBckM7QUFBQUEsU0FBQSxNQUdIO0FBQUEsS0FBYTtBQUFBO0FBQUE7QUFBQSx1QkFBQThCLEdBQWMsb0NBQWlCO0FBQUE7QUFBQSxjQUN0RDtBQUFBLElBQVM7QUFBQTtBQUFBO0FBQUEsc0JBQUFqQztBQUFBQTtBQUFBQSxlQUFBeUM7QUFBQUEsaUJBQ0k7QUFBQSxpQ0Q5TWY7QUFBQSxtQkM4TXlDO0FBQUEsb0REOU16QztBQUFBLGVBQUFDO0FBQUFBLGlCQ2dOSTtBQUFBLGlDRGhOSjtBQUFBLG1CQ2dOOEI7QUFBQSwrQ0FBQXZDLEdBQXNCLGdCQUFZO0FBQUEsY0FDOUQsOENBQTJCO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQXdDO0FBQUFBLE1Eak43QiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG4oKiBBIHN1cnZleSBhbmQgbWVhc3VyZW1lbnRzIG9mIG1vcmUgb3B0aW1pemVkIGltcGxlbWVudGF0aW9ucyBjYW4gYmUgZm91bmQgYXQ6XG5cbiAgICBodHRwczovL2pzdGhvbWFzLmdpdGh1Yi5pby9tYXAtY29tcGFyaXNvbi5odG1sXG5cbiAgIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzM0Ny4gKilcbmxldCB0YWlsX3JlY3Vyc2l2ZV9tYXAgZiBsID1cbiAgTGlzdC5yZXYgKExpc3QucmV2X21hcCBmIGwpXG5cbmxldCB0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYyBpID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQ6OnRsIC0+IChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgKChmIGkgaGQpOjphY2MpIChpICsgMSkgdGxcbiAgaW5cbiAgaW5uZXIgW10gMCBsXG5cbm9wZW4gTHd0LkluZml4XG5cbmxldCByZWMgaXRlcl9zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuICgpIC0+XG4gICAgaXRlcl9zIGYgbFxuXG5sZXQgaXRlcl9wIGYgbCA9XG4gIGxldCB0cyA9IExpc3QucmV2X21hcCAoTHd0LmFwcGx5IGYpIGwgaW5cbiAgTHd0LmpvaW4gdHNcblxubGV0IHJlYyBpdGVyaV9zIGkgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgKGYgaSkgeCA+Pj0gZnVuICgpIC0+XG4gICAgaXRlcmlfcyAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmlfcyBmIGwgPSBpdGVyaV9zIDAgZiBsXG5cbmxldCBpdGVyaV9wIGYgbCA9XG4gIGxldCBmJyBpID0gTHd0LmFwcGx5IChmIGkpIGluXG4gIGxldCB0cyA9IHRhaWxfcmVjdXJzaXZlX21hcGlfcmV2IGYnIGwgaW5cbiAgTHd0LmpvaW4gdHNcblxubGV0IG1hcF9zIGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IExpc3QucmV2IGFjYyB8PiBMd3QucmV0dXJuXG4gICAgfCBoZDo6dGwgLT5cbiAgICAgIEx3dC5hcHBseSBmIGhkID4+PSBmdW4gciAtPlxuICAgICAgKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSAocjo6YWNjKSB0bFxuICBpblxuICBpbm5lciBbXSBsXG5cbmxldCByZWMgX2NvbGxlY3RfcmV2IGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuIGFjY1xuICB8IHQ6OnRzIC0+XG4gICAgdCA+Pj0gZnVuIGkgLT5cbiAgICAoX2NvbGxlY3RfcmV2IFtAb2NhbWwudGFpbGNhbGxdKSAoaTo6YWNjKSB0c1xuXG5sZXQgbWFwX3AgZiBsID1cbiAgbGV0IHRzID0gTGlzdC5yZXZfbWFwIChMd3QuYXBwbHkgZikgbCBpblxuICBfY29sbGVjdF9yZXYgW10gdHNcblxubGV0IGZpbHRlcl9tYXBfcyBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgICAgLT4gTGlzdC5yZXYgYWNjIHw+IEx3dC5yZXR1cm5cbiAgICB8IGhkOjp0bCAtPlxuICAgICAgTHd0LmFwcGx5IGYgaGQgPj49IGZ1bmN0aW9uXG4gICAgICB8IFNvbWUgdiAtPiAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pICh2OjphY2MpIHRsXG4gICAgICB8IE5vbmUgLT4gKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSBhY2MgdGxcbiAgaW5cbiAgaW5uZXIgW10gbFxuXG5sZXQgZmlsdGVyX21hcF9wIGYgbCA9XG4gIGxldCByZWMgX2NvbGxlY3Rfb3B0aW9uYWxfcmV2IGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gICAgLT4gTHd0LnJldHVybiBhY2NcbiAgfCB0Ojp0cyAtPlxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHYgLT4gKF9jb2xsZWN0X29wdGlvbmFsX3JldiBbQG9jYW1sLnRhaWxjYWxsXSkgKHY6OmFjYykgdHNcbiAgICB8IE5vbmUgLT4gKF9jb2xsZWN0X29wdGlvbmFsX3JldiBbQG9jYW1sLnRhaWxjYWxsXSkgYWNjIHRzXG4gIGluXG4gIGxldCB0cyA9IExpc3QucmV2X21hcCAoTHd0LmFwcGx5IGYpIGwgaW5cbiAgX2NvbGxlY3Rfb3B0aW9uYWxfcmV2IFtdIHRzXG5cbmxldCBtYXBpX3MgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MgaSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgICAgLT4gTGlzdC5yZXYgYWNjIHw+IEx3dC5yZXR1cm5cbiAgICB8IGhkOjp0bCAtPlxuICAgICAgTHd0LmFwcGx5IChmIGkpIGhkID4+PSBmdW4gdiAtPlxuICAgICAgKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSAodjo6YWNjKSAoaSsxKSB0bFxuICBpblxuICBpbm5lciBbXSAwIGxcblxubGV0IG1hcGlfcCBmIGwgPVxuICBsZXQgZicgaSA9IEx3dC5hcHBseSAoZiBpKSBpblxuICBsZXQgdHMgPSB0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiBmJyBsIGluXG4gIF9jb2xsZWN0X3JldiBbXSB0c1xuXG5sZXQgcmVjIHJldl9tYXBfYXBwZW5kX3MgYWNjIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybiBhY2NcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW4geCAtPlxuICAgIHJldl9tYXBfYXBwZW5kX3MgKHggOjogYWNjKSBmIGxcblxubGV0IHJldl9tYXBfcyBmIGwgPVxuICByZXZfbWFwX2FwcGVuZF9zIFtdIGYgbFxuXG5sZXQgcmVjIHJldl9tYXBfYXBwZW5kX3AgYWNjIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgYWNjXG4gIHwgeCA6OiBsIC0+XG4gICAgcmV2X21hcF9hcHBlbmRfcFxuICAgICAgKEx3dC5hcHBseSBmIHggPj49IGZ1biB4IC0+XG4gICAgICAgYWNjID58PSBmdW4gbCAtPlxuICAgICAgIHggOjogbCkgZiBsXG5cbmxldCByZXZfbWFwX3AgZiBsID1cbiAgcmV2X21hcF9hcHBlbmRfcCBMd3QucmV0dXJuX25pbCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnRfcyBmIGFjYyBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuIGFjY1xuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSAoZiBhY2MpIHggPj49IGZ1biBhY2MgLT5cbiAgICAoZm9sZF9sZWZ0X3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgYWNjIGxcblxubGV0IGZvbGRfcmlnaHRfcyBmIGwgYWNjID1cbiAgbGV0IHJlYyBpbm5lciBmIGEgPSBmdW5jdGlvblxuICAgIHwgW10gICAgIC0+IEx3dC5yZXR1cm4gYVxuICAgIHwgaGQ6OnRsIC0+IChMd3QuYXBwbHkgKGYgaGQpIGEpID4+PSBmdW4gYScgLT5cbiAgICAgIChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgZiBhJyB0bFxuICBpblxuICBpbm5lciBmIGFjYyAoTGlzdC5yZXYgbClcblxubGV0IHJlYyBmb3JfYWxsX3MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QucmV0dXJuX3RydWVcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgKGZvcl9hbGxfcyBbQG9jYW1sLnRhaWxjYWxsXSkgZiBsXG4gICAgfCBmYWxzZSAtPlxuICAgICAgTHd0LnJldHVybl9mYWxzZVxuXG5sZXQgZm9yX2FsbF9wIGYgbCA9XG4gIG1hcF9wIGYgbCA+Pj0gZnVuIGJsIC0+IExpc3QuZm9yX2FsbCAoZnVuIHggLT4geCkgYmwgfD4gTHd0LnJldHVyblxuXG5sZXQgcmVjIGV4aXN0c19zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl9mYWxzZVxuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSBmIHggPj49IGZ1bmN0aW9uXG4gICAgfCB0cnVlIC0+XG4gICAgICBMd3QucmV0dXJuX3RydWVcbiAgICB8IGZhbHNlIC0+XG4gICAgICAoZXhpc3RzX3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgbFxuXG5sZXQgZXhpc3RzX3AgZiBsID1cbiAgbWFwX3AgZiBsID4+PSBmdW4gYmwgLT4gTGlzdC5leGlzdHMgKGZ1biB4IC0+IHgpIGJsIHw+IEx3dC5yZXR1cm5cblxubGV0IHJlYyBmaW5kX3MgZiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBMd3QuZmFpbCBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgTHd0LnJldHVybiB4XG4gICAgfCBmYWxzZSAtPlxuICAgICAgKGZpbmRfcyBbQG9jYW1sLnRhaWxjYWxsXSkgZiBsXG5cbmxldCBfb3B0aW9uYWxpemUgZiB4ID1cbiAgZiB4ID4+PSBmdW4gYiAtPiBpZiBiIHRoZW4gTHd0LnJldHVybiAoU29tZSB4KSBlbHNlIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmlsdGVyX3MgZiBsID1cbiAgZmlsdGVyX21hcF9zIChfb3B0aW9uYWxpemUgZikgbFxuXG5sZXQgZmlsdGVyX3AgZiBsID1cbiAgIGZpbHRlcl9tYXBfcCAoX29wdGlvbmFsaXplIGYpIGxcblxubGV0IHBhcnRpdGlvbl9zIGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjMSBhY2MyID0gZnVuY3Rpb25cbiAgICB8IFtdICAgICAtPiBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MxLCBMaXN0LnJldiBhY2MyKVxuICAgIHwgaGQ6OnRsIC0+IEx3dC5hcHBseSBmIGhkID4+PSBmdW4gYiAtPlxuICAgICAgICBpZiBiIHRoZW5cbiAgICAgICAgICBpbm5lciAoaGQ6OmFjYzEpIGFjYzIgdGxcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlubmVyIGFjYzEgKGhkOjphY2MyKSB0bFxuICBpblxuICBpbm5lciBbXSBbXSBsXG5cbmxldCBwYXJ0aXRpb25fcCBmIGwgPVxuICBsZXQgZyB4ID0gTHd0LmFwcGx5IGYgeCA+Pj0gZnVuIGIgLT4gTHd0LnJldHVybiAoYiwgeCkgaW5cbiAgbWFwX3AgZyBsID4+PSBmdW4gdGwgLT5cbiAgbGV0IGdyb3VwMSA9IHRhaWxfcmVjdXJzaXZlX21hcCBzbmQgQEAgTGlzdC5maWx0ZXIgZnN0IHRsIGluXG4gIGxldCBncm91cDIgPVxuICAgIHRhaWxfcmVjdXJzaXZlX21hcCBzbmQgQEAgTGlzdC5maWx0ZXIgKGZ1biB4IC0+IG5vdCBAQCBmc3QgeCkgdGwgaW5cbiAgTHd0LnJldHVybiAoZ3JvdXAxLCBncm91cDIpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTEyNiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkx3dF9zZXF1ZW5jZSIsIlN0ZGxpYl9RdWV1ZSIsIkx3dF9saXN0IiwiTHd0IiwiY3JlYXRlIiwibSIsIm9wdCIsInZhbGlkYXRlIiwicGFyYW0iLCJjaGVjayIsImRpc3Bvc2UiLCJjcmVhdGVfbWVtYmVyIiwicCIsImV4biIsInJlbGVhc2UiLCJjIiwibWF0Y2giLCJ3YWtlbmVyIiwidmFsaWRhdGVfYW5kX3JldHVybiIsImUiLCJ1c2UiLCJjbGVhcmVkIiwicHJvbWlzZSIsIm9rIiwicmVzdWx0IiwiY2xlYXIiLCJlbGVtZW50cyIsImwiLCJlbGVtZW50Iiwib2xkX2NsZWFyZWQiLCJ3YWl0X3F1ZXVlX2xlbmd0aCIsIkx3dF9wb29sIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvbHd0L2x3dF9wb29sLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLFlBQUFDLE9BQUFDLEdBQUEsVUFBQUMsS0FBQUY7QUFBQUE7QUFBQUEsS0FBQUcsV0NxQ1csd0JBQUFDLE9BQXdCLGVBQWU7QUFBQSxLQUFBQyxRQUF2Qyx3QkFBQUQsT0FBQWYsR0FBOEQsdUJBQU07QUFBQSxLQUFBaUIsVUFBcEUsd0JBQUFGLE9BQTJGLGVBQWU7QUFBQSxXQVN2RztBQUFBLElBREg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQWU7QUFBQSxHQUNZO0FBQUEsWUFBQUcsY0FBQUM7QUFBQUEsSUFJcEM7QUFBQTtBQUFBLHNCQUFBSixPQUlLLHFCQUNBLDBCQUFXO0FBQUEsc0JBQUFLO0FBQUFBLGNBR1g7QUFBQSxjQUNBLDhCQUFZO0FBQUEsZUFBQztBQUFBO0FBQUEsWUFBQUMsUUFBQUYsR0FBQUc7QUFBQUEsUUFBQUMsUUFJWjtBQUFBLElBQWlDLFlBTXJDLDJDQUFtQjtBQUFBLFFBQUFDLFVBTmtCO0FBQUEsSUFHckMscUNBR21CO0FBQUE7QUFBQSxZQUFBUCxRQUFBRSxHQUFBRztBQUFBQSxRQUFBLE1BSXJCO0FBQUEsSUFBVztBQUFBO0FBQUE7QUFBQSxzQkFBQVAsT0FDWCxxQkFDQSxlQUFlO0FBQUE7QUFBQSxZQUFBVSxvQkFBQU4sR0FBQUc7QUFBQUEsSUFvQmY7QUFBQTtBQUFBLHNCQUFBUCxPQUVPLDBCQUFZO0FBQUEsc0JBQUFBO0FBQUFBLGNBQ2YsVUFFSSw0QkFJZ0I7QUFBQSx3QkFEaEI7QUFBQSxjQUFXO0FBQUEsaURBQUFBLE9BQ1gsdUJBQWUsR0FBQztBQUFBO0FBQUEsc0JBQUFXO0FBQUFBLGtCQUFBLE1BSWpCO0FBQUEsY0FBVztBQUFBO0FBQUE7QUFBQSxnQ0FBQVg7QUFBQUEsNEJBQUFRLFFBN0JaO0FBQUEsd0JBQWlDO0FBQUEsNkJBQUFDLFVBQUEsZ0JBT25DO0FBQUEseUJBQXVCO0FBQUE7QUFBQTtBQUFBLG9DQUFBRixHQUVwQixxQ0FBMEI7QUFBQSxvQ0FBQUYsS0FHMUIsdUNBQWdDO0FBQUE7QUFBQSx3QkFrQmQ7QUFBQSx1QkFDTDtBQUFBLGVBQUM7QUFBQTtBQUFBLFlBQUFPLElBQUFSLEdBQUFuQjtBQUFBQSxhQUFBLElBQUFzQjtBQUFBQTtBQUFBQSxNQUFBTSxVQW9DckI7QUFBQSxNQUFBQztBQUFBQSxRQUVFO0FBQUE7QUFBQSxtQkFBQWQsT0FDYSx1QkFBRztBQUFBLG1CQUFBVztBQUFBQSxlQUFBRSxZQUVYLFlBQUFFLEtBckJQO0FBQUEsV0FDQSw2QkFBQUMsUUFBeUIseUJBQVk7QUFBQTtBQUFBO0FBQUEsc0JBQUMsU0FBQWhCLE9BcUIvQiw0QkFBVTtBQUFBLFlBckJxQjtBQUFBLGFBT3BDO0FBQUEsdUJBQVc7QUFBQTtBQUFBO0FBQUEsc0JBTmM7QUFBQTtBQUFBLFdBbUJVLHVDQUNwQjtBQUFBO0FBQUEsS0FFakI7QUFBQTtBQUFBO0FBQUEsdUJBQUFBO0FBQUFBLGVBQ0E7QUFBQSwwQkFFRTtBQUFBLGdCQUFXO0FBQUEsbURBQUFBLE9BQ1gsZUFBTyxFQUtSO0FBQUE7QUFBQSxlQUZDO0FBQUEsZUFBVztBQUFBLGNBRVo7QUFBQTtBQUFBLElBakRFO0FBQUEsS0FFRDtBQUFBLGdCQUVFO0FBQUE7QUFBQTtBQUFBLGFBR0E7QUFBQTtBQUFBLFNBQWdEO0FBQUE7QUFBQTtBQUFBLHlCQUFLO0FBQUE7QUFBQTtBQUFBLE1BQUFPLElBRy9DO0FBQUEsWUFDUjtBQUFBLElBa0JPLHVDQW9CUjtBQUFBO0FBQUEsWUFBQVUsTUFBQWI7QUFBQUE7QUFBQUEsS0FBQWM7QUFBQUEsT0FHYztBQUFBO0FBQUEsa0JBQUFDLEdBQUFDLFNBQTZCLHVCQUFZO0FBQUE7QUFBQTtBQUFBLElBQ3hEO0FBQUEsUUFBQUMsY0FBa0I7QUFBQSxJQUdsQjtBQUFBLElBQ0E7QUFBQSxJQUMyQjtBQUFBLHdDQUFYLG1DQUFvQjtBQUFBO0FBQUEsWUFBQUMsa0JBQUFsQixHQUVaLHdDQUE2QjtBQUFBLE9BQUFtQixXRDlLdkQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxub3BlbiBMd3QuSW5maXhcblxudHlwZSAnYSB0ID0ge1xuICBjcmVhdGUgOiB1bml0IC0+ICdhIEx3dC50O1xuICAoKiBDcmVhdGUgYSBuZXcgcG9vbCBtZW1iZXIuICopXG4gIGNoZWNrIDogJ2EgLT4gKGJvb2wgLT4gdW5pdCkgLT4gdW5pdDtcbiAgKCogQ2hlY2sgdmFsaWRpdHkgb2YgYSBwb29sIG1lbWJlciB3aGVuIHVzZSByZXN1bHRlZCBpbiBmYWlsZWQgcHJvbWlzZS4gKilcbiAgdmFsaWRhdGUgOiAnYSAtPiBib29sIEx3dC50O1xuICAoKiBWYWxpZGF0ZSBhbiBleGlzdGluZyBmcmVlIHBvb2wgbWVtYmVyIGJlZm9yZSB1c2UuICopXG4gIGRpc3Bvc2UgOiAnYSAtPiB1bml0IEx3dC50O1xuICAoKiBEaXNwb3NlIG9mIGEgcG9vbCBtZW1iZXIuICopXG4gIGNsZWFyZWQgOiBib29sIHJlZiByZWY7XG4gICgqIEhhdmUgdGhlIGN1cnJlbnQgcG9vbCBlbGVtZW50cyBiZWVuIGNsZWFyZWQgb3V0PyAqKVxuICBtYXggOiBpbnQ7XG4gICgqIFNpemUgb2YgdGhlIHBvb2wuICopXG4gIG11dGFibGUgY291bnQgOiBpbnQ7XG4gICgqIE51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgcG9vbC4gKilcbiAgbGlzdCA6ICdhIFF1ZXVlLnQ7XG4gICgqIEF2YWlsYWJsZSBwb29sIG1lbWJlcnMuICopXG4gIHdhaXRlcnMgOiAnYSBMd3QudSBMd3Rfc2VxdWVuY2UudDtcbiAgKCogUHJvbWlzZSByZXNvbHZlcnMgd2FpdGluZyBmb3IgYSBmcmVlIG1lbWJlci4gKilcbn1cblxubGV0IGNyZWF0ZSBtID8odmFsaWRhdGUgPSBmdW4gXyAtPiBMd3QucmV0dXJuX3RydWUpID8oY2hlY2sgPSBmdW4gXyBmIC0+IGYgdHJ1ZSkgPyhkaXNwb3NlID0gZnVuIF8gLT4gTHd0LnJldHVybl91bml0KSBjcmVhdGUgPVxuICB7IG1heCA9IG07XG4gICAgY3JlYXRlID0gY3JlYXRlO1xuICAgIHZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgY2hlY2sgPSBjaGVjaztcbiAgICBkaXNwb3NlID0gZGlzcG9zZTtcbiAgICBjbGVhcmVkID0gcmVmIChyZWYgZmFsc2UpO1xuICAgIGNvdW50ID0gMDtcbiAgICBsaXN0ID0gUXVldWUuY3JlYXRlICgpO1xuICAgIHdhaXRlcnMgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIH1cblxuKCogQ3JlYXRlIGEgcG9vbCBtZW1iZXIuICopXG5sZXQgY3JlYXRlX21lbWJlciBwID1cbiAgTHd0LmNhdGNoXG4gICAgKGZ1biAoKSAtPlxuICAgICAgICgqIE11c3QgYmUgZG9uZSBiZWZvcmUgcC5jcmVhdGUgdG8gcHJldmVudCBvdGhlciByZXNvbHZlcnMgZnJvbVxuICAgICAgICAgIGNyZWF0aW5nIG5ldyBtZW1iZXJzIGlmIHRoZSBsaW1pdCBpcyByZWFjaGVkLiAqKVxuICAgICAgIHAuY291bnQgPC0gcC5jb3VudCArIDE7XG4gICAgICAgcC5jcmVhdGUgKCkpXG4gICAgKGZ1biBleG4gLT5cbiAgICAgICAoKiBDcmVhdGlvbiBmYWlsZWQsIHNvIGRvbid0IGluY3JlbWVudCBjb3VudC4gKilcbiAgICAgICBwLmNvdW50IDwtIHAuY291bnQgLSAxO1xuICAgICAgIEx3dC5mYWlsIGV4bilcblxuKCogUmVsZWFzZSBhIHBvb2wgbWVtYmVyLiAqKVxubGV0IHJlbGVhc2UgcCBjID1cbiAgbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgcC53YWl0ZXJzIHdpdGhcbiAgfCBTb21lIHdha2VuZXIgLT5cbiAgICAoKiBBIHByb21pc2UgcmVzb2x2ZXIgaXMgd2FpdGluZywgZ2l2ZSBpdCB0aGUgcG9vbCBtZW1iZXIuICopXG4gICAgTHd0Lndha2V1cF9sYXRlciB3YWtlbmVyIGNcbiAgfCBOb25lIC0+XG4gICAgKCogTm8gb25lIGlzIHdhaXRpbmcsIHF1ZXVlIGl0LiAqKVxuICAgIFF1ZXVlLnB1c2ggYyBwLmxpc3RcblxuKCogRGlzcG9zZSBvZiBhIHBvb2wgbWVtYmVyLiAqKVxubGV0IGRpc3Bvc2UgcCBjID1cbiAgcC5kaXNwb3NlIGMgPj49IGZ1biAoKSAtPlxuICBwLmNvdW50IDwtIHAuY291bnQgLSAxO1xuICBMd3QucmV0dXJuX3VuaXRcblxuKCogQ3JlYXRlIGEgbmV3IG1lbWJlciB3aGVuIG9uZSBpcyB0aHJvd24gYXdheS4gKilcbmxldCByZXBsYWNlX2Rpc3Bvc2VkIHAgPVxuICBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCBwLndhaXRlcnMgd2l0aFxuICB8IE5vbmUgLT5cbiAgICAoKiBObyBvbmUgaXMgd2FpdGluZywgZG8gbm90IGNyZWF0ZSBhIG5ldyBtZW1iZXIgdG8gYXZvaWRcbiAgICAgICBsb3NpbmcgYW4gZXJyb3IgaWYgY3JlYXRpb24gZmFpbHMuICopXG4gICAgKClcbiAgfCBTb21lIHdha2VuZXIgLT5cbiAgICBMd3Qub25fYW55XG4gICAgICAoTHd0LmFwcGx5IHAuY3JlYXRlICgpKVxuICAgICAgKGZ1biBjIC0+XG4gICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIHdha2VuZXIgYylcbiAgICAgIChmdW4gZXhuIC0+XG4gICAgICAgICAoKiBDcmVhdGlvbiBmYWlsZWQsIG5vdGlmeSB0aGUgd2FpdGVyIG9mIHRoZSBmYWlsdXJlLiAqKVxuICAgICAgICAgTHd0Lndha2V1cF9sYXRlcl9leG4gd2FrZW5lciBleG4pXG5cbigqIFZlcmlmeSBhIG1lbWJlciBpcyBzdGlsbCB2YWxpZCBiZWZvcmUgdXNpbmcgaXQuICopXG5sZXQgdmFsaWRhdGVfYW5kX3JldHVybiBwIGMgPVxuICBMd3QudHJ5X2JpbmRcbiAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgIHAudmFsaWRhdGUgYylcbiAgICAgIChmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBMd3QucmV0dXJuIGNcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICgqIFJlbW92ZSB0aGlzIG1lbWJlciBhbmQgY3JlYXRlIGEgbmV3IG9uZS4gKilcbiAgICAgICAgICBkaXNwb3NlIHAgYyA+Pj0gZnVuICgpIC0+XG4gICAgICAgICAgY3JlYXRlX21lbWJlciBwKVxuICAgICAgKGZ1biBlIC0+XG4gICAgICAgICAoKiBWYWxpZGF0aW9uIGZhaWxlZDogY3JlYXRlIGEgbmV3IG1lbWJlciBpZiBhdCBsZWFzdCBvbmVcbiAgICAgICAgICAgIHJlc29sdmVyIGlzIHdhaXRpbmcuICopXG4gICAgICAgICBkaXNwb3NlIHAgYyA+Pj0gZnVuICgpIC0+XG4gICAgICAgICByZXBsYWNlX2Rpc3Bvc2VkIHA7XG4gICAgICAgICBMd3QucmVyYWlzZSBlKVxuXG4oKiBBY3F1aXJlIGEgcG9vbCBtZW1iZXIuICopXG5sZXQgYWNxdWlyZSBwID1cbiAgaWYgUXVldWUuaXNfZW1wdHkgcC5saXN0IHRoZW5cbiAgICAoKiBObyBtb3JlIGF2YWlsYWJsZSBtZW1iZXIuICopXG4gICAgaWYgcC5jb3VudCA8IHAubWF4IHRoZW5cbiAgICAgICgqIExpbWl0IG5vdCByZWFjaGVkOiBjcmVhdGUgYSBuZXcgb25lLiAqKVxuICAgICAgY3JlYXRlX21lbWJlciBwXG4gICAgZWxzZVxuICAgICAgKCogTGltaXQgcmVhY2hlZDogd2FpdCBmb3IgYSBmcmVlIG9uZS4gKilcbiAgICAgIChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgcC53YWl0ZXJzID4+PSB2YWxpZGF0ZV9hbmRfcmV0dXJuIHBcbiAgZWxzZVxuICAgICgqIFRha2UgdGhlIGZpcnN0IGZyZWUgbWVtYmVyIGFuZCB2YWxpZGF0ZSBpdC4gKilcbiAgICBsZXQgYyA9IFF1ZXVlLnRha2UgcC5saXN0IGluXG4gICAgdmFsaWRhdGVfYW5kX3JldHVybiBwIGNcblxuKCogUmVsZWFzZSBhIG1lbWJlciB3aGVuIHVzZSByZXN1bHRlZCBpbiBmYWlsZWQgcHJvbWlzZSBpZiB0aGUgbWVtYmVyXG4gICBpcyBzdGlsbCB2YWxpZC4gKilcbmxldCBjaGVja19hbmRfcmVsZWFzZSBwIGMgY2xlYXJlZCA9XG4gIGxldCBvayA9IHJlZiBmYWxzZSBpblxuICBwLmNoZWNrIGMgKGZ1biByZXN1bHQgLT4gb2sgOj0gcmVzdWx0KTtcbiAgaWYgY2xlYXJlZCB8fCBub3QgIW9rIHRoZW4gKFxuICAgICgqIEVsZW1lbnQgaXMgbm90IG9rIG9yIHRoZSBwb29sIHdhcyBjbGVhcmVkIC0gZGlzcG9zZSBvZiBpdCAqKVxuICAgIGRpc3Bvc2UgcCBjXG4gIClcbiAgZWxzZSAoXG4gICAgKCogRWxlbWVudCBpcyBvayAtIHJlbGVhc2UgaXQgYmFjayB0byB0aGUgcG9vbCAqKVxuICAgIHJlbGVhc2UgcCBjO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICApXG5cbmxldCB1c2UgcCBmID1cbiAgYWNxdWlyZSBwID4+PSBmdW4gYyAtPlxuICAoKiBDYXB0dXJlIHRoZSBjdXJyZW50IGNsZWFyZWQgc3RhdGUgc28gd2UgY2FuIHNlZSBpZiBpdCBjaGFuZ2VzIHdoaWxlIHRoaXNcbiAgICAgZWxlbWVudCBpcyBpbiB1c2UgKilcbiAgbGV0IGNsZWFyZWQgPSAhKHAuY2xlYXJlZCkgaW5cbiAgbGV0IHByb21pc2UgPVxuICAgIEx3dC5jYXRjaFxuICAgICAgKGZ1biAoKSAtPiBmIGMpXG4gICAgICAoZnVuIGUgLT5cbiAgICAgICAgIGNoZWNrX2FuZF9yZWxlYXNlIHAgYyAhY2xlYXJlZCA+Pj0gZnVuICgpIC0+XG4gICAgICAgICBMd3QuZmFpbCBlKVxuICBpblxuICBwcm9taXNlID4+PSBmdW4gXyAtPlxuICBpZiAhY2xlYXJlZCB0aGVuIChcbiAgICAoKiBwIHdhcyBjbGVhcmVkIHdoaWxlIHByb21pc2Ugd2FzIHJlc29sdmluZyAtIGRpc3Bvc2Ugb2YgdGhpcyBlbGVtZW50ICopXG4gICAgZGlzcG9zZSBwIGMgPj49IGZ1biAoKSAtPlxuICAgIHByb21pc2VcbiAgKVxuICBlbHNlIChcbiAgICByZWxlYXNlIHAgYztcbiAgICBwcm9taXNlXG4gIClcblxubGV0IGNsZWFyIHAgPVxuICBsZXQgZWxlbWVudHMgPSBRdWV1ZS5mb2xkIChmdW4gbCBlbGVtZW50IC0+IGVsZW1lbnQgOjogbCkgW10gcC5saXN0IGluXG4gIFF1ZXVlLmNsZWFyIHAubGlzdDtcbiAgKCogSW5kaWNhdGUgdG8gYW55IGN1cnJlbnRseSBpbi11c2UgZWxlbWVudHMgdGhhdCB3ZSBjbGVhcmVkIHRoZSBwb29sICopXG4gIGxldCBvbGRfY2xlYXJlZCA9ICEocC5jbGVhcmVkKSBpblxuICBvbGRfY2xlYXJlZCA6PSB0cnVlO1xuICBwLmNsZWFyZWQgOj0gcmVmIGZhbHNlO1xuICBMd3RfbGlzdC5pdGVyX3MgKGRpc3Bvc2UgcCkgZWxlbWVudHNcblxubGV0IHdhaXRfcXVldWVfbGVuZ3RoIHAgPSBMd3Rfc2VxdWVuY2UubGVuZ3RoIHAud2FpdGVyc1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjUyOTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHd0LmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJMd3QiLCJMd3Rfc2VxdWVuY2UiLCJjcmVhdGVfZW1wdHkiLCJwYXJhbSIsImNyZWF0ZSIsInYiLCJwdXQiLCJtdmFyIiwibWF0Y2giLCJ3IiwicmVzIiwibm9kZSIsInRha2VfYXZhaWxhYmxlIiwidGFrZSIsImlzX2VtcHR5IiwiTHd0X212YXIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9sd3QvbHd0X212YXIubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLFlBQUFDLGFBQUFDO0FBQUFBLFFBQUEsTUNzRGM7QUFBQSxJQURBLGtEQUFzQjtBQUFBLEdBQ0U7QUFBQSxZQUFBQyxPQUFBQztBQUFBQSxRQUFBLE1BS3hCO0FBQUEsSUFEQSx1REFBc0I7QUFBQSxHQUNFO0FBQUEsWUFBQUMsSUFBQUMsTUFBQUY7QUFBQUEsSUFHcEM7QUFBQTtBQUFBLE1BQUFHLFFBVWlCO0FBQUEsTUFBQUMsSUFBVztBQUFBLE1BQUFDLE1BQUE7QUFBQSxNQUFBQyxPQUNmO0FBQUEsS0FDWDtBQUFBO0FBQUE7QUFBQSxnQkFBQVIsT0FBNEIsd0NBQXdCO0FBQUEsS0FBQztBQUFBO0FBQUEsUUFBQUssVUFWekM7QUFBQSxJQUFvQztBQUFBLFNBQUFDLE1BQUE7QUFBQSxLQUk1QztBQUFBO0FBQUE7QUFBQSxLQUZBO0FBQUEsSUFJSjtBQUFBLEdBS0c7QUFBQSxZQUFBRyxlQUFBTDtBQUFBQSxRQUFBQyxVQVdMO0FBQUEsa0JBS0U7QUFBQSxRQUFBSCxNQUxGLFlBQUFHLFFBUk07QUFBQSxJQUFvQztBQUFBLFNBQUFBLFVBQUEsVUFBQUMsSUFBQSxZQUFBSixJQUFBO0FBQUEsS0FFeEM7QUFBQSxLQUNBO0FBQUE7QUFBQTtBQUFBLEtBRUE7QUFBQSxJQUtnQjtBQUFBLEdBR1o7QUFBQSxZQUFBUSxLQUFBTjtBQUFBQSxRQUFBQyxRQUdBO0FBQUEsSUFBbUIsWUFFZixtQ0FBbUQ7QUFBQSxRQUFBSCxJQUZwQztBQUFBLElBQ2IsNEJBQ2lEO0FBQUE7QUFBQSxZQUFBUyxTQUFBUCxNQUc3RCxzQkFFYztBQUFBO0FBQUEsSUFBQVEsV0RyR2hCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBPQ2FtbCBwcm9taXNlIGxpYnJhcnlcbiAqIGh0dHBzOi8vb2NzaWdlbi5vcmcvbHd0XG4gKiBDb3B5cmlnaHQgKGMpIDIwMDksIE1ldGF3ZWIgVGVjaG5vbG9naWVzLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIE1FVEFXRUIgVEVDSE5PTE9HSUVTIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBNRVRBV0VCIFRFQ0hOT0xPR0lFUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTlxuICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKilcblxuKCogVGhpcyBjb2RlIGlzIGFkYXB0ZWQgZnJvbVxuICAgaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAxMDAxMjE1NDI1L2h0dHA6Ly9laWdlbmNsYXNzLm9yZzo4MC9oaWtpL2xpZ2h0d2VpZ2h0LXRocmVhZHMtd2l0aC1sd3QuICopXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbnR5cGUgJ2EgdCA9IHtcbiAgbXV0YWJsZSBtdmFyX2NvbnRlbnRzIDogJ2Egb3B0aW9uO1xuICAoKiBDdXJyZW50IGNvbnRlbnRzICopXG5cbiAgd3JpdGVycyA6ICgnYSAqIHVuaXQgTHd0LnUpIEx3dF9zZXF1ZW5jZS50O1xuICAoKiBUaHJlYWRzIHdhaXRpbmcgdG8gcHV0IGEgdmFsdWUgKilcblxuICByZWFkZXJzIDogJ2EgTHd0LnUgTHd0X3NlcXVlbmNlLnQ7XG4gICgqIFRocmVhZHMgd2FpdGluZyBmb3IgYSB2YWx1ZSAqKVxufVxuXG5sZXQgY3JlYXRlX2VtcHR5ICgpID1cbiAgeyBtdmFyX2NvbnRlbnRzID0gTm9uZTtcbiAgICB3cml0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKTtcbiAgICByZWFkZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbmxldCBjcmVhdGUgdiA9XG4gIHsgbXZhcl9jb250ZW50cyA9IFNvbWUgdjtcbiAgICB3cml0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKTtcbiAgICByZWFkZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbmxldCBwdXQgbXZhciB2ID1cbiAgbWF0Y2ggbXZhci5tdmFyX2NvbnRlbnRzIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgYmVnaW4gbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgbXZhci5yZWFkZXJzIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBtdmFyLm12YXJfY29udGVudHMgPC0gU29tZSB2XG4gICAgICB8IFNvbWUgdyAtPlxuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIHcgdlxuICAgIGVuZDtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCBTb21lIF8gLT5cbiAgICBsZXQgKHJlcywgdykgPSBMd3QudGFzayAoKSBpblxuICAgIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9yICh2LCB3KSBtdmFyLndyaXRlcnMgaW5cbiAgICBMd3Qub25fY2FuY2VsIHJlcyAoZnVuIF8gLT4gTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKTtcbiAgICByZXNcblxubGV0IG5leHRfd3JpdGVyIG12YXIgPVxuICBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCBtdmFyLndyaXRlcnMgd2l0aFxuICB8IFNvbWUodicsIHcpIC0+XG4gICAgbXZhci5tdmFyX2NvbnRlbnRzIDwtIFNvbWUgdic7XG4gICAgTHd0Lndha2V1cF9sYXRlciB3ICgpXG4gIHwgTm9uZSAtPlxuICAgIG12YXIubXZhcl9jb250ZW50cyA8LSBOb25lXG5cbmxldCB0YWtlX2F2YWlsYWJsZSBtdmFyID1cbiAgbWF0Y2ggbXZhci5tdmFyX2NvbnRlbnRzIHdpdGhcbiAgfCBTb21lIHYgLT5cbiAgICBuZXh0X3dyaXRlciBtdmFyO1xuICAgIFNvbWUgdlxuICB8IE5vbmUgLT5cbiAgICBOb25lXG5cbmxldCB0YWtlIG12YXIgPVxuICBtYXRjaCB0YWtlX2F2YWlsYWJsZSBtdmFyIHdpdGhcbiAgfCBTb21lIHYgLT4gTHd0LnJldHVybiB2XG4gIHwgTm9uZSAtPiAoTHd0LmFkZF90YXNrX3IgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl0pIG12YXIucmVhZGVyc1xuXG5sZXQgaXNfZW1wdHkgbXZhciA9XG4gIG1hdGNoIG12YXIubXZhcl9jb250ZW50cyB3aXRoXG4gIHwgU29tZSBfIC0+IGZhbHNlXG4gIHwgTm9uZSAtPiB0cnVlXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTM3NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJsd3QuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsIkx3dF9zZXF1ZW5jZSIsIkx3dCIsImNyZWF0ZSIsInBhcmFtIiwibG9jayIsIm0iLCJ1bmxvY2siLCJ3aXRoX2xvY2siLCJpc19sb2NrZWQiLCJpc19lbXB0eSIsIkx3dF9tdXRleCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL2x3dC9sd3RfbXV0ZXgubWwiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLFlBQUFDLE9BQUFDLE9Da0I0Qyw2Q0FBc0IsQ0FBRTtBQUFBLFlBQUFDLEtBQUFDO0FBQUFBLElBR2xFLGNBQ0UsK0NBSUM7QUFBQTtBQUFBLFlBQUFDLE9BQUFEO0FBQUFBLFFBQUEsTUFHSDtBQUFBO0FBQUEsSUFDSyxzQ0FDRDtBQUFBLGNBSWlCO0FBQUEsSUFBK0IsaUNBQ2pEO0FBQUE7QUFBQSxZQUFBRSxVQUFBRixHQUFBVjtBQUFBQSxRQUFBLE1BR0g7QUFBQSxJQUFNO0FBQUE7QUFBQTtBQUFBLHNCQUFBUTtBQUFBQSxjQUNOO0FBQUEsMkNBQUFBLE9BQTBCLFdBQVEsZUFBaUIsRUFBQztBQUFBO0FBQUE7QUFBQSxZQUFBSyxVQUFBSCxHQUVwQyxZQUFRO0FBQUEsWUFBQUksU0FBQUosR0FDVCx3Q0FBK0I7QUFBQSxPQUFBSyxZRDNDaEQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxub3BlbiBMd3QuSW5maXhcblxudHlwZSB0ID0geyBtdXRhYmxlIGxvY2tlZCA6IGJvb2w7IHdhaXRlcnMgOiB1bml0IEx3dC51IEx3dF9zZXF1ZW5jZS50ICB9XG5cbmxldCBjcmVhdGUgKCkgPSB7IGxvY2tlZCA9IGZhbHNlOyB3YWl0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbmxldCBsb2NrIG0gPVxuICBpZiBtLmxvY2tlZCB0aGVuXG4gICAgKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSBtLndhaXRlcnNcbiAgZWxzZSBiZWdpblxuICAgIG0ubG9ja2VkIDwtIHRydWU7XG4gICAgTHd0LnJldHVybl91bml0XG4gIGVuZFxuXG5sZXQgdW5sb2NrIG0gPVxuICBpZiBtLmxvY2tlZCB0aGVuIGJlZ2luXG4gICAgaWYgTHd0X3NlcXVlbmNlLmlzX2VtcHR5IG0ud2FpdGVycyB0aGVuXG4gICAgICBtLmxvY2tlZCA8LSBmYWxzZVxuICAgIGVsc2VcbiAgICAgICgqIFdlIGRvIG5vdCB1c2UgW0x3dC53YWtldXBdIGhlcmUgdG8gYXZvaWQgYSBzdGFjayBvdmVyZmxvd1xuICAgICAgICAgd2hlbiB1bmxvY2tpbmcgYSBsb3Qgb2YgdGhyZWFkcy4gKilcbiAgICAgIEx3dC53YWtldXBfbGF0ZXIgKEx3dF9zZXF1ZW5jZS50YWtlX2wgbS53YWl0ZXJzKSAoKVxuICBlbmRcblxubGV0IHdpdGhfbG9jayBtIGYgPVxuICBsb2NrIG0gPj49IGZ1biAoKSAtPlxuICBMd3QuZmluYWxpemUgZiAoZnVuICgpIC0+IHVubG9jayBtOyBMd3QucmV0dXJuX3VuaXQpXG5cbmxldCBpc19sb2NrZWQgbSA9IG0ubG9ja2VkXG5sZXQgaXNfZW1wdHkgbSA9IEx3dF9zZXF1ZW5jZS5pc19lbXB0eSBtLndhaXRlcnNcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1NDI0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imx3dC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIkx3dCIsIkx3dF9zZXF1ZW5jZSIsIlN0ZGxpYl9MaXN0IiwiTHd0X211dGV4IiwiY3JlYXRlIiwid2FpdCIsIm11dGV4IiwiY3ZhciIsIndhaXRlciIsIm0iLCJwYXJhbSIsInNpZ25hbCIsImFyZyIsImJyb2FkY2FzdCIsIndha2VuZXJzIiwieCIsImwiLCJ3YWtlbmVyIiwiYnJvYWRjYXN0X2V4biIsImV4biIsIkx3dF9jb25kaXRpb24iXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9sd3QvbHd0X2NvbmRpdGlvbi5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxZQUFBQyxLQUFBQyxPQUFBQztBQUFBQSxRQUFBQyxTQzBDZTtBQUFBLElBQ2IsY0FBQUMsSUFBQSxVQUVjO0FBQUEsSUFHZDtBQUFBO0FBQUEsc0JBQUFDLE9BQ2EsY0FBTTtBQUFBLHNCQUFBQTtBQUFBQSxjQUVkLFlBRVU7QUFBQSxrQkFBQUQsSUFGVjtBQUFBLGNBQ1ksa0NBQ2E7QUFBQSxlQUFDO0FBQUE7QUFBQSxZQUFBRSxPQUFBSixNQUFBSztBQUFBQSxJQUcvQjtBQUFBO0FBQUEsWUFDbUI7QUFBQSxZQUFqQjtBQUFBO0FBQUE7QUFBQTtBQUFBLGVEekRKO0FBQUEsa0NDMkRJO0FBQUEsS0QzREo7QUFBQTtBQUFBLEdDMkRNO0FBQUEsWUFBQUMsVUFBQU4sTUFBQUs7QUFBQUE7QUFBQUEsS0FBQUU7QUFBQUEsT0FHVztBQUFBLG9DQUFBQyxHQUFBQyxHQUFnQyxpQkFBTTtBQUFBLElBQ3JEO0FBQUEsSUFBaUQ7QUFBQTtBQUFBLHNCQUFBQyxTQUN2Qix1Q0FBNEI7QUFBQSxzQkFBVTtBQUFBO0FBQUEsWUFBQUMsY0FBQVgsTUFBQVk7QUFBQUE7QUFBQUEsS0FBQUw7QUFBQUEsT0FHakQ7QUFBQSxvQ0FBQUMsR0FBQUMsR0FBZ0MsaUJBQU07QUFBQSxJQUNyRDtBQUFBLElBQWlEO0FBQUE7QUFBQSxzQkFBQUMsU0FDdkIsdUNBQWdDO0FBQUEsc0JBQVU7QUFBQTtBQUFBLE9BQUFHLGdCRHJFdEUiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIE9DYW1sIHByb21pc2UgbGlicmFyeVxuICogaHR0cHM6Ly9vY3NpZ2VuLm9yZy9sd3RcbiAqIENvcHlyaWdodCAoYykgMjAwOSwgTWV0YXdlYiBUZWNobm9sb2dpZXMsIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgTUVUQVdFQiBURUNITk9MT0dJRVMgYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIE1FVEFXRUIgVEVDSE5PTE9HSUVTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SXG4gKiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFXG4gKiBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOXG4gKiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqKVxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG50eXBlICdhIHQgPSAnYSBMd3QudSBMd3Rfc2VxdWVuY2UudFxuXG5sZXQgY3JlYXRlID0gTHd0X3NlcXVlbmNlLmNyZWF0ZVxuXG5sZXQgd2FpdCA/bXV0ZXggY3ZhciA9XG4gIGxldCB3YWl0ZXIgPSAoTHd0LmFkZF90YXNrX3IgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl0pIGN2YXIgaW5cbiAgbGV0ICgpID1cbiAgICBtYXRjaCBtdXRleCB3aXRoXG4gICAgfCBTb21lIG0gLT4gTHd0X211dGV4LnVubG9jayBtXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIEx3dC5maW5hbGl6ZVxuICAgIChmdW4gKCkgLT4gd2FpdGVyKVxuICAgIChmdW4gKCkgLT5cbiAgICAgICBtYXRjaCBtdXRleCB3aXRoXG4gICAgICAgfCBTb21lIG0gLT4gTHd0X211dGV4LmxvY2sgbVxuICAgICAgIHwgTm9uZSAtPiBMd3QucmV0dXJuX3VuaXQpXG5cbmxldCBzaWduYWwgY3ZhciBhcmcgPVxuICB0cnlcbiAgICBMd3Qud2FrZXVwX2xhdGVyIChMd3Rfc2VxdWVuY2UudGFrZV9sIGN2YXIpIGFyZ1xuICB3aXRoIEx3dF9zZXF1ZW5jZS5FbXB0eSAtPlxuICAgICgpXG5cbmxldCBicm9hZGNhc3QgY3ZhciBhcmcgPVxuICBsZXQgd2FrZW5lcnMgPSBMd3Rfc2VxdWVuY2UuZm9sZF9yIChmdW4geCBsIC0+IHggOjogbCkgY3ZhciBbXSBpblxuICBMd3Rfc2VxdWVuY2UuaXRlcl9ub2RlX2wgTHd0X3NlcXVlbmNlLnJlbW92ZSBjdmFyO1xuICBMaXN0Lml0ZXIgKGZ1biB3YWtlbmVyIC0+IEx3dC53YWtldXBfbGF0ZXIgd2FrZW5lciBhcmcpIHdha2VuZXJzXG5cbmxldCBicm9hZGNhc3RfZXhuIGN2YXIgZXhuID1cbiAgbGV0IHdha2VuZXJzID0gTHd0X3NlcXVlbmNlLmZvbGRfciAoZnVuIHggbCAtPiB4IDo6IGwpIGN2YXIgW10gaW5cbiAgTHd0X3NlcXVlbmNlLml0ZXJfbm9kZV9sIEx3dF9zZXF1ZW5jZS5yZW1vdmUgY3ZhcjtcbiAgTGlzdC5pdGVyIChmdW4gd2FrZW5lciAtPiBMd3Qud2FrZXVwX2xhdGVyX2V4biB3YWtlbmVyIGV4bikgd2FrZW5lcnNcbiJdLCJpZ25vcmVMaXN0IjpbMF19fV19
