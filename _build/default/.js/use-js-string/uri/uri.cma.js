// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Uri
//# unitInfo: Requires: Angstrom, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__Lazy, Stdlib__List, Stdlib__Option, Stdlib__Printf, Stdlib__Result, Stdlib__String, Stringext
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$34 = "",
    cst$37 = ",",
    cst$36 = ".",
    cst$39 = "..",
    cst$33 = "/",
    cst$38 = "//",
    cst$35 = ":",
    cst_http = "http",
    cst_https = "https",
    cst_int_of_hex_char$1 = "int_of_hex_char",
    cst_localhost$0 = "localhost",
    caml_check_bound = runtime.caml_check_bound,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$33,
    x = cst_http,
    x$0 = cst_https,
    cst$31 = cst$34,
    cst$30 = cst$33,
    cst$28 = cst$34,
    cst$24 = cst$35,
    cst$25 = cst$35,
    cst$26 = "::",
    cst$23 = cst$34,
    cst$21 = cst$36,
    cst$22 = cst$36,
    cst$20 = cst$34,
    cst$19 = cst$34,
    cst$18 = cst$33,
    cst$17 = cst$37,
    cst$16 = cst$33,
    cst$15 = cst$34,
    cst$13 = cst$34,
    cst$14 = cst$34,
    cst$12 = cst$34,
    cst$9 = cst$38,
    cst$10 = cst$35,
    cst$11 = "./",
    cst$8 = cst$37,
    cst$7 = "&",
    cst$6 = cst$33,
    cst$5 = cst$33,
    cst$4 = cst$34,
    cst$2 = cst$33,
    cst$3 = cst$33,
    cst$0 = cst$33,
    cst$1 = cst$33,
    cst = cst$34,
    cst$27 = cst$34,
    cst$29 = cst$38,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom = global_data.Angstrom,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stringext = global_data.Stringext,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Result = global_data.Stdlib__Result;
   function iter_concat(fn, sep, buf, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var last = param$0[1];
     if(! param$0[2]) return caml_call2(fn, buf, last);
     var rest = param$0[2];
     caml_call2(fn, buf, last);
     caml_call2(Stdlib_Buffer[16], buf, sep);
     param$0 = rest;
    }
   }
   function compare_opt(c, t$0, t){
    if(! t$0) return t ? -1 : 0;
    var a = t$0[1];
    if(! t) return 1;
    var b = t[1];
    return caml_call2(c, a, b);
   }
   function compare_list(f, t$0, t){
    var t$2 = t$0, t$1 = t;
    for(;;){
     if(! t$2) return t$1 ? -1 : 0;
     var xs = t$2[2], x = t$2[1];
     if(! t$1) return 1;
     var ys = t$1[2], y = t$1[1], c = caml_call2(f, x, y);
     if(0 !== c) return c;
     t$2 = xs;
     t$1 = ys;
    }
   }
   function sub_delims(a){
    var i = 0;
    for(;;){
     var c = caml_string_get("!$&'()*+,;=", i);
     caml_check_bound(a, c)[1 + c] = 1;
     var _dg_ = i + 1 | 0;
     if(10 === i) return a;
     i = _dg_;
    }
   }
   var
    safe_chars = caml_make_vect(256, 0),
    i = 0,
    _au_ = [0, 0],
    _ap_ = [0, 3854881, "host is required for HTTP(S) uris"],
    _ar_ = [0, -1042355253],
    _as_ = [0, 804243368],
    _aq_ =
      [0,
       [11,
        "Only http and https URIs are supported. ",
        [2, 0, [11, " is invalid.", 0]]],
       "Only http and https URIs are supported. %s is invalid."],
    _at_ = [1, [0, 3854881, "No scheme present in URI"]],
    _ao_ = [0, cst$34],
    _an_ = [0, 0],
    _v_ = [0, 0, 0],
    cst_too_many_parts_in_IPv6_add = "too many parts in IPv6 address",
    _u_ = [0, cst$34, 0],
    cst_invalid_octect = "invalid octect",
    _k_ = [0, [11, "/?", [2, 0, 0]], "/?%s"],
    _j_ = [0, [2, 0, [12, 63, [2, 0, 0]]], "%s?%s"],
    cst_localhost = cst_localhost$0,
    _f_ = [0, cst$34, 0],
    _g_ = [0, cst$34, 0],
    _h_ = [0, 2],
    _i_ = [0, [0, cst$34, 0], 0],
    _c_ = [0, 2],
    _d_ = [0, cst$34, 0],
    cst_int_of_hex_char = cst_int_of_hex_char$1,
    cst_int_of_hex_char$0 = cst_int_of_hex_char$1,
    _b_ = [0, [12, 37, [4, 8, [0, 2, 2], 0, 0]], "%%%02X"],
    _a_ = [0, cst$33, 0],
    _W_ = [0, 0, 0, 0];
   for(;;){
    var
     c =
       caml_string_get
        ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~",
         i);
    caml_check_bound(safe_chars, c)[1 + c] = 1;
    var _av_ = i + 1 | 0;
    if(65 === i) break;
    i = _av_;
   }
   var pchar = sub_delims(caml_call1(Stdlib_Array[7], safe_chars));
   caml_check_bound(pchar, 58)[59] = 1;
   caml_check_bound(pchar, 64)[65] = 1;
   var safe_chars_for_scheme = caml_call1(Stdlib_Array[7], safe_chars);
   caml_check_bound(safe_chars_for_scheme, 43)[44] = 1;
   var safe_chars_for_path = sub_delims(caml_call1(Stdlib_Array[7], pchar));
   caml_check_bound(safe_chars_for_path, 47)[48] = 0;
   var safe_chars_for_query = caml_call1(Stdlib_Array[7], pchar);
   caml_check_bound(safe_chars_for_query, 47)[48] = 1;
   caml_check_bound(safe_chars_for_query, 63)[64] = 1;
   caml_check_bound(safe_chars_for_query, 38)[39] = 0;
   caml_check_bound(safe_chars_for_query, 59)[60] = 0;
   caml_check_bound(safe_chars_for_query, 43)[44] = 0;
   var
    safe_chars_for_query_key =
      caml_call1(Stdlib_Array[7], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_key, 61)[62] = 0;
   var
    safe_chars_for_query_value =
      caml_call1(Stdlib_Array[7], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_value, 44)[45] = 0;
   var safe_chars_for_userinfo = caml_call1(Stdlib_Array[7], safe_chars);
   caml_check_bound(safe_chars_for_userinfo, 58)[59] = 0;
   function safe_chars_for_component(param){
    if(typeof param === "number")
     if(-145160102 <= param){
      if(127343601 <= param){
       if(795008922 === param) return safe_chars_for_query_value;
       if(892015045 === param) return safe_chars_for_path;
      }
      else if(61643255 !== param && 127343600 <= param)
       return safe_chars_for_query;
     }
     else if(-250086679 <= param){
      if(-178940859 === param) return safe_chars_for_scheme;
      if(-145160103 <= param) return safe_chars_for_userinfo;
     }
     else{
      if(-911188600 === param) return safe_chars_for_query_key;
      if(-250086680 <= param) return safe_chars_for_query;
     }
    else if(-198771759 === param[1]){
     var
      match = param[2],
      unsafe = match[3],
      safe = match[2],
      component = match[1],
      _c$_ = safe_chars_for_component(component),
      safe_chars$0 = caml_call1(Stdlib_Array[7], _c$_),
      _db_ = caml_ml_string_length(safe) - 1 | 0,
      _da_ = 0;
     if(_db_ >= 0){
      var i$0 = _da_;
      for(;;){
       var c$0 = caml_string_get(safe, i$0);
       caml_check_bound(safe_chars$0, c$0)[1 + c$0] = 1;
       var _df_ = i$0 + 1 | 0;
       if(_db_ === i$0) break;
       i$0 = _df_;
      }
     }
     var _dd_ = caml_ml_string_length(unsafe) - 1 | 0, _dc_ = 0;
     if(_dd_ >= 0){
      var i = _dc_;
      for(;;){
       var c = caml_string_get(unsafe, i);
       caml_check_bound(safe_chars$0, c)[1 + c] = 0;
       var _de_ = i + 1 | 0;
       if(_dd_ === i) break;
       i = _de_;
      }
     }
     return safe_chars$0;
    }
    return safe_chars;
   }
   function normalize_host(hso){return hso;}
   function canonicalize_port(port){return port;}
   function canonicalize_path(path){return path;}
   var
    Generic =
      [0,
       safe_chars_for_component,
       normalize_host,
       canonicalize_port,
       canonicalize_path],
    safe_chars_for_component$0 = Generic[1];
   function normalize_host$0(hs){return caml_call1(Stdlib_String[27], hs);}
   function canonicalize_port$0(param){
    if(! param) return 0;
    var x = param[1];
    return 80 === x ? 0 : [0, x];
   }
   function canonicalize_path$0(x){return x ? x : _a_;}
   var
    Http =
      [0,
       safe_chars_for_component$0,
       normalize_host$0,
       canonicalize_port$0,
       canonicalize_path$0],
    safe_chars_for_component$1 = Http[1],
    normalize_host$1 = Http[2],
    canonicalize_path$1 = Http[4];
   function canonicalize_port$1(param){
    if(! param) return 0;
    var x = param[1];
    return 443 === x ? 0 : [0, x];
   }
   var
    Https =
      [0,
       safe_chars_for_component$1,
       normalize_host$1,
       canonicalize_port$1,
       canonicalize_path$1],
    safe_chars_for_component$2 = Generic[1],
    canonicalize_port$2 = Generic[3],
    canonicalize_path$2 = Generic[4];
   function normalize_host$2(hs){
    var hs$0 = caml_call1(Stdlib_String[27], hs);
    return hs$0 === cst_localhost$0 ? cst : hs$0;
   }
   var
    File =
      [0,
       safe_chars_for_component$2,
       normalize_host$2,
       canonicalize_port$2,
       canonicalize_path$2],
    safe_chars_for_component$3 = Generic[1],
    normalize_host$3 = Generic[2],
    canonicalize_port$3 = Generic[3],
    canonicalize_path$3 = Generic[4],
    Urn =
      [0,
       safe_chars_for_component$3,
       normalize_host$3,
       canonicalize_port$3,
       canonicalize_path$3];
   function module_of_scheme(param){
    if(! param) return Generic;
    var s = param[1], match = caml_call1(Stdlib_String[27], s);
    return match !== "file"
            ? match
              !== cst_http
              ? match !== cst_https ? match !== "urn" ? Generic : Urn : Https
              : Http
            : File;
   }
   function encode(scheme, opt, b){
    var
     component = opt ? opt[1] : 892015045,
     Scheme = module_of_scheme(scheme),
     safe_chars = Scheme[1].call(null, component),
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur){
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var c = caml_string_get(b, cur);
     if(caml_check_bound(safe_chars, c)[1 + c]){var cur$0 = cur + 1 | 0; cur = cur$0;}
     else{
      if(start < cur)
       caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var _c__ = caml_call2(Stdlib_Printf[4], _b_, c);
      caml_call2(Stdlib_Buffer[16], buf, _c__);
      var cur$1 = cur + 1 | 0, start$0 = cur + 1 | 0;
      start = start$0;
      cur = cur$1;
     }
    }
   }
   function int_of_hex_char(c){
    var c$0 = caml_call1(Stdlib_Char[4], c) - 48 | 0;
    if(9 >= c$0)
     return 0 <= c$0 ? c$0 : caml_call1(Stdlib[2], cst_int_of_hex_char$0);
    if(16 < c$0 && 23 > c$0) return c$0 - 7 | 0;
    return caml_call1(Stdlib[2], cst_int_of_hex_char);
   }
   function decode(b){
    var
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur)
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
     else{
      if(37 !== caml_string_get(b, cur)){
       var cur$1 = cur + 1 | 0;
       cur = cur$1;
       continue;
      }
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var start$0 = cur + 1 | 0;
      if(len <= start$0)
       caml_call2(Stdlib_Buffer[12], buf, 37);
      else{
       try{var highbits = int_of_hex_char(caml_string_get(b, start$0));}
       catch(_c9_){
        caml_call2(Stdlib_Buffer[12], buf, 37);
        start = start$0;
        cur = start$0;
        continue;
       }
       var cur$0 = start$0 + 1 | 0;
       if(len > cur$0){
        a:
        {
         try{var lowbits = int_of_hex_char(caml_string_get(b, cur$0));}
         catch(_c8_){
          caml_call2(Stdlib_Buffer[12], buf, 37);
          var _c6_ = caml_string_get(b, cur$0 - 1 | 0);
          caml_call2(Stdlib_Buffer[12], buf, _c6_);
          var start_at = cur$0;
          break a;
         }
         var _c7_ = caml_call1(Stdlib_Char[1], (highbits << 4) + lowbits | 0);
         caml_call2(Stdlib_Buffer[12], buf, _c7_);
         var start_at = cur$0 + 1 | 0;
        }
        start = start_at;
        cur = start_at;
        continue;
       }
       caml_call2(Stdlib_Buffer[12], buf, 37);
       var _c5_ = caml_string_get(b, cur$0 - 1 | 0);
       caml_call2(Stdlib_Buffer[12], buf, _c5_);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function pct_encode(scheme, opt, s){
    var
     component = opt ? opt[1] : 892015045,
     x = encode(scheme, [0, component], s);
    return x;
   }
   function pct_encoder(_c4_, _c3_, _c2_, _c1_, _c0_, _cZ_, opt, param){
    var
     scheme = _c4_ ? _c4_[1] : -178940859,
     userinfo = _c3_ ? _c3_[1] : -145160103,
     host = _c2_ ? _c2_[1] : 803994504,
     path = _c1_ ? _c1_[1] : 892015045,
     query_key = _c0_ ? _c0_[1] : -911188600,
     query_value = _cZ_ ? _cZ_[1] : 795008922,
     fragment = opt ? opt[1] : 127343600;
    return [0, scheme, userinfo, host, path, query_key, query_value, fragment];
   }
   function pct_decode(s){var x = decode(s); return x;}
   function compare(_cY_, param){
    var
     p = param[2],
     u = param[1],
     p$0 = _cY_[2],
     u$0 = _cY_[1],
     c = caml_call2(Stdlib_String[10], u$0, u);
    return 0 === c ? compare_opt(Stdlib_String[10], p$0, p) : c;
   }
   function userinfo_of_encoded(us){
    var match = caml_call3(Stringext[3], _c_, us, 58);
    if(! match) return _d_;
    var match$0 = match[2], u = match[1];
    if(match$0){
     var p = match$0[1], x$0 = decode(p), x = decode(u);
     return [0, x, [0, x$0]];
    }
    var x$1 = decode(u);
    return [0, x$1, 0];
   }
   function encoded_of_userinfo(scheme, component){
    return function(param){
     var po = param[2], u = param[1];
     if(po) var p = po[1], _cV_ = caml_ml_string_length(p); else var _cV_ = 0;
     var
      len = (1 + caml_ml_string_length(u) | 0) + _cV_ | 0,
      buf = caml_call1(Stdlib_Buffer[1], len),
      _cW_ = pct_encode(scheme, [0, component], u);
     caml_call2(Stdlib_Buffer[16], buf, _cW_);
     if(po){
      var p$0 = po[1];
      caml_call2(Stdlib_Buffer[12], buf, 58);
      var _cX_ = pct_encode(scheme, [0, component], p$0);
      caml_call2(Stdlib_Buffer[16], buf, _cX_);
     }
     var x = caml_call1(Stdlib_Buffer[2], buf);
     return x;};
   }
   function path_of_encoded(ps){
    var tokl = caml_call2(Stringext[4], ps, 47);
    return caml_call2(Stdlib_List[20], pct_decode, tokl);
   }
   function remove_dot_segments(p){
    var
     revp = caml_call1(Stdlib_List[10], p),
     ascension = 0,
     outp = 0,
     param$0 = revp;
    for(;;){
     a:
     {
      b:
      if(param$0){
       var _cR_ = param$0[1];
       c:
       {
        if(_cR_ !== cst$36){
         if(_cR_ !== cst$39){
          if(_cR_ !== cst$33) break a;
          var _cT_ = param$0[2];
          if(! _cT_) break b;
          var _cU_ = _cT_[1];
          if(_cU_ === cst$36){var r$3 = _cT_[2]; break c;}
          if(_cU_ !== cst$39){
           if(_cU_ === cst$33){
            var r$1 = _cT_[2];
            if(0 < ascension){
             var ascension$1 = ascension - 1 | 0;
             ascension = ascension$1;
             param$0 = [0, cst$2, r$1];
             continue;
            }
           }
           var r$0 = _cT_[2];
           if(0 >= ascension) break a;
           var ascension$0 = ascension - 1 | 0;
           ascension = ascension$0;
           param$0 = r$0;
           continue;
          }
          var r$2 = _cT_[2];
         }
         else
          var r$2 = param$0[2];
         var ascension$2 = ascension + 1 | 0;
         ascension = ascension$2;
         param$0 = r$2;
         continue;
        }
        var r$3 = param$0[2];
       }
       param$0 = r$3;
       continue;
      }
      if
       (0 < caml_call1(Stdlib_List[1], p)
        && caml_call1(Stdlib_List[6], p) === cst$33)
       return [0, cst$3, outp];
     }
     if(! param$0) break;
     var r = param$0[2], s = param$0[1], outp$0 = [0, s, outp];
     ascension = 0;
     outp = outp$0;
     param$0 = r;
    }
    if(0 >= ascension){
     if
      (0 < caml_call1(Stdlib_List[1], outp)
       && caml_call1(Stdlib_List[6], outp) === cst$33)
      return caml_call1(Stdlib_List[7], outp);
     return outp;
    }
    var lst = caml_call1(Stdlib_Array[10], caml_make_vect(ascension, cst$39));
    if(lst){
     var t = lst[2], h = lst[1], acc$1 = [0, h, 0], acc = acc$1, param = t;
     for(;;){
      if(! param){var _cS_ = acc; break;}
      var xs = param[2], x = param[1], acc$0 = [0, x, [0, cst$0, acc]];
      acc = acc$0;
      param = xs;
     }
    }
    else
     var _cS_ = 0;
    return caml_call2(Stdlib_List[13], [0, cst$1, _cS_], outp);
   }
   function encoded_of_path(scheme, component){
    return function(p){
     var
      len =
        caml_call3
         (Stdlib_List[26],
          function(c, tok){return caml_ml_string_length(tok) + c | 0;},
          0,
          p),
      buf = caml_call1(Stdlib_Buffer[1], len);
     iter_concat
      (function(buf, seg){
        if(seg === cst$33) return caml_call2(Stdlib_Buffer[12], buf, 47);
        var _cQ_ = pct_encode(scheme, [0, component], seg);
        return caml_call2(Stdlib_Buffer[16], buf, _cQ_);
       },
       cst$4,
       buf,
       p);
     var x = caml_call1(Stdlib_Buffer[2], buf);
     return x;};
   }
   function query_of_encoded(qs){
    var els = caml_call3(Stringext[3], 0, qs, 38);
    function plus_to_space(s){
     var
      s$0 = caml_call1(Stdlib_Bytes[45], s),
      _cO_ = runtime.caml_ml_bytes_length(s$0) - 1 | 0,
      _cN_ = 0;
     if(_cO_ >= 0){
      var i = _cN_;
      for(;;){
       if(43 === runtime.caml_bytes_get(s$0, i))
        runtime.caml_bytes_set(s$0, i, 32);
       var _cP_ = i + 1 | 0;
       if(_cO_ === i) break;
       i = _cP_;
      }
     }
     return caml_call1(Stdlib_Bytes[44], s$0);
    }
    if(els){
     var
      acc = 0,
      param =
        caml_call2
         (Stdlib_List[22],
          function(el){return caml_call3(Stringext[3], _h_, el, 61);},
          els);
     for(;;){
      if(! param) break;
      var _cJ_ = param[1];
      if(_cJ_){
       var match = _cJ_[2], k = _cJ_[1];
       if(match){
        var
         tl = param[2],
         v = match[1],
         _cK_ = plus_to_space(v),
         l = caml_call3(Stringext[3], 0, _cK_, 44),
         l$0 = l || _f_,
         n = [0, plus_to_space(k), l$0],
         acc$0 = [0, n, acc];
        acc = acc$0;
        param = tl;
       }
       else{
        var
         tl$0 = param[2],
         n$0 = [0, plus_to_space(k), 0],
         acc$1 = [0, n$0, acc];
        acc = acc$1;
        param = tl$0;
       }
      }
      else{
       var tl$1 = param[2], acc$2 = [0, _g_, acc];
       acc = acc$2;
       param = tl$1;
      }
     }
     var _cL_ = acc;
    }
    else
     var _cL_ = _i_;
    return caml_call2
            (Stdlib_List[20],
             function(param){
              var
               v = param[2],
               k = param[1],
               _cM_ = caml_call2(Stdlib_List[20], pct_decode, v),
               x = decode(k);
              return [0, x, _cM_];
             },
             _cL_);
   }
   function encoded_of_query(scheme, opt, l){
    var
     pct_encoder$0 = opt ? opt[1] : pct_encoder(0, 0, 0, 0, 0, 0, 0, 0),
     len =
       caml_call3
        (Stdlib_List[26],
         function(a, param){
          var v = param[2], k = param[1];
          return ((a + caml_ml_string_length(k) | 0)
                 +
                  caml_call3
                   (Stdlib_List[26],
                    function(a, s){
                     return (a + caml_ml_string_length(s) | 0) + 1 | 0;
                    },
                    0,
                    v)
                 | 0)
                 + 2
                 | 0;
         },
         -1,
         l),
     buf = caml_call1(Stdlib_Buffer[1], len);
    iter_concat
     (function(buf, param){
       var
        v = param[2],
        k = param[1],
        _cG_ = pct_encode(scheme, [0, pct_encoder$0[5]], k);
       caml_call2(Stdlib_Buffer[16], buf, _cG_);
       var _cH_ = 0 !== v ? 1 : 0;
       return _cH_
               ? (caml_call2
                  (Stdlib_Buffer[12], buf, 61),
                 iter_concat
                  (function(buf, s){
                    var _cI_ = pct_encode(scheme, [0, pct_encoder$0[6]], s);
                    return caml_call2(Stdlib_Buffer[16], buf, _cI_);
                   },
                   cst$8,
                   buf,
                   v))
               : _cH_;
      },
      cst$7,
      buf,
      l);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function of_raw(qs){
    var
     lazy_query =
       caml_call1
        (Stdlib_Lazy[6], function(param){return query_of_encoded(qs);});
    return [1, [0, qs], lazy_query];
   }
   function kv(param){
    if(0 === param[0])
     var kv = param[1];
    else{
     var _cD_ = param[2], _cE_ = caml_obj_tag(_cD_);
     a:
     if(250 === _cE_)
      var _cF_ = _cD_[1];
     else{
      if(246 !== _cE_ && 244 !== _cE_){var _cF_ = _cD_; break a;}
      var _cF_ = caml_call1(CamlinternalLazy[2], _cD_);
     }
     var kv = _cF_;
    }
    return kv;
   }
   function encoded_of_query$0(scheme){
    return function(_cB_, _cC_){return encoded_of_query(scheme, _cB_, _cC_);};
   }
   var
    _e_ = Stdlib_String[10],
    empty = [0, 0, 0, 0, 0, 0, [1, 0, caml_call1(Stdlib_Lazy[4], 0)], 0],
    compare_decoded = Stdlib_String[10];
   function compare_host(h1, h2){
    if(typeof h1 !== "number"){
     var _cA_ = h1[1];
     if(-367671627 === _cA_){
      if(typeof h2 !== "number" && -367671627 === h2[1]){
       var ip2 = h2[2], ip1 = h1[2];
       return caml_call2(Stdlib_String[10], ip1, ip2);
      }
     }
     else
      if(267950263 === _cA_){
       if(typeof h2 !== "number" && 267950263 === h2[1]){
        var ip2$0 = h2[2], ip1$0 = h1[2];
        return caml_call2(Stdlib_String[10], ip1$0, ip2$0);
       }
      }
      else if
       (803994504 === _cA_ && typeof h2 !== "number" && 803994504 === h2[1]){
       var h2$0 = h2[2], h1$0 = h1[2];
       return caml_call2(compare_decoded, h1$0, h2$0);
      }
    }
    return -1;
   }
   function compare$0(t$0, t){
    var c$4 = compare_opt(compare_host, t$0[3], t[3]);
    if(0 !== c$4) return c$4;
    var c$3 = compare_opt(compare_decoded, t$0[1], t[1]);
    if(0 !== c$3) return c$3;
    var
     c =
       compare_opt
        (function(p$0, p){return p$0 < p ? -1 : p < p$0 ? 1 : 0;},
         t$0[4],
         t[4]);
    if(0 !== c) return c;
    var c$0 = compare_opt(compare, t$0[2], t[2]);
    if(0 !== c$0) return c$0;
    var c$2 = compare_list(_e_, t$0[5], t[5]);
    if(0 !== c$2) return c$2;
    var y = t[6], x = t$0[6];
    a:
    {
     if(0 === x[0]){
      var _cs_ = x[1];
      if(0 === y[0])
       var kvl$0 = y[1], kvl = _cs_;
      else{
       var _ct_ = y[2], _cu_ = caml_obj_tag(_ct_);
       b:
       if(250 === _cu_)
        var _cv_ = _ct_[1];
       else{
        if(246 !== _cu_ && 244 !== _cu_){var _cv_ = _ct_; break b;}
        var _cv_ = caml_call1(CamlinternalLazy[2], _ct_);
       }
       var kvl$0 = _cv_, kvl = _cs_;
      }
     }
     else{
      var _cw_ = x[2], raw = x[1];
      if(0 !== y[0]){
       var raw$0 = y[1], c$1 = compare_opt(Stdlib_String[10], raw, raw$0);
       break a;
      }
      var _cx_ = caml_obj_tag(_cw_);
      b:
      if(250 === _cx_)
       var _cy_ = _cw_[1];
      else{
       if(246 !== _cx_ && 244 !== _cx_){var _cy_ = _cw_; break b;}
       var _cy_ = caml_call1(CamlinternalLazy[2], _cw_);
      }
      var kvl$0 = y[1], kvl = _cy_;
     }
     var
      c$1 =
        compare_list
         (function(_cz_, param){
           var
            vl = param[2],
            k = param[1],
            vl$0 = _cz_[2],
            k$0 = _cz_[1],
            c = caml_call2(Stdlib_String[10], k$0, k);
           return 0 === c ? compare_list(Stdlib_String[10], vl$0, vl) : c;
          },
          kvl,
          kvl$0);
    }
    return 0 === c$1 ? compare_opt(compare_decoded, t$0[7], t[7]) : c$1;
   }
   function equal(t$0, t){return 0 === compare$0(t$0, t) ? 1 : 0;}
   function uncast_opt(param){
    if(! param) return 0;
    var h = param[1];
    return [0, h];
   }
   function normalize(schem, init){
    var
     Scheme = module_of_scheme(uncast_opt(schem)),
     _cm_ = init[3],
     _ci_ = init[7],
     _cj_ = init[6],
     _ck_ = init[5],
     _cl_ = init[4];
    if(_cm_){
     var match = _cm_[1], _cn_ = match[1];
     if(267950263 === _cn_)
      var
       host = match[2],
       _co_ = [0, [0, 267950263, Scheme[2].call(null, host)]];
     else if(803994504 <= _cn_)
      var
       host$0 = match[2],
       x$0 = Scheme[2].call(null, host$0),
       _co_ = [0, [0, 803994504, x$0]];
     else
      var
       host$1 = match[2],
       _co_ = [0, [0, -367671627, Scheme[2].call(null, host$1)]];
     var _cp_ = _co_;
    }
    else
     var _cp_ = 0;
    var param = init[1], f = Stdlib_String[27], _cq_ = init[2];
    if(param)
     var x = param[1], _cr_ = [0, caml_call1(f, x)];
    else
     var _cr_ = 0;
    return [0, _cr_, _cq_, _cp_, _cl_, _ck_, _cj_, _ci_];
   }
   function to_string(opt, uri){
    var
     pct_encoder$0 = opt ? opt[1] : pct_encoder(0, 0, 0, 0, 0, 0, 0, 0),
     match = uri[1];
    if(match) var s = match[1], scheme = [0, s]; else var scheme = 0;
    var buf = caml_call1(Stdlib_Buffer[1], 128);
    function add_pct_string(opt, x){
     var
      component = opt ? opt[1] : 892015045,
      x$0 = encode(scheme, [0, component], x);
     return caml_call2(Stdlib_Buffer[16], buf, x$0);
    }
    var match$0 = uri[1];
    if(match$0){
     var x = match$0[1];
     add_pct_string([0, pct_encoder$0[1]], x);
     caml_call2(Stdlib_Buffer[12], buf, 58);
    }
    a:
    {
     var _b5_ = uri[3], _b6_ = uri[4];
     if(! uri[2] && ! _b5_ && ! _b6_){var _b7_ = 0; break a;}
     var _b7_ = 1;
    }
    if(_b7_) caml_call2(Stdlib_Buffer[16], buf, cst$9);
    var match$1 = uri[2];
    if(match$1){
     var
      userinfo = match$1[1],
      x$0 = encoded_of_userinfo(scheme, pct_encoder$0[2])(userinfo);
     caml_call2(Stdlib_Buffer[16], buf, x$0);
     caml_call2(Stdlib_Buffer[12], buf, 64);
    }
    var _b8_ = uri[3];
    if(_b8_){
     var match$2 = _b8_[1], _b9_ = match$2[1];
     if(267950263 === _b9_){
      var host = match$2[2];
      caml_call2(Stdlib_Buffer[12], buf, 91);
      caml_call2(Stdlib_Buffer[16], buf, host);
      caml_call2(Stdlib_Buffer[12], buf, 93);
     }
     else if(803994504 <= _b9_){
      var host$0 = match$2[2];
      add_pct_string([0, pct_encoder$0[3]], host$0);
     }
     else{var host$1 = match$2[2]; caml_call2(Stdlib_Buffer[16], buf, host$1);
     }
    }
    var match$3 = uri[4];
    if(match$3){
     var port = match$3[1];
     caml_call2(Stdlib_Buffer[12], buf, 58);
     var _b__ = caml_call1(Stdlib[33], port);
     caml_call2(Stdlib_Buffer[16], buf, _b__);
    }
    var _b$_ = uri[5];
    if(_b$_){
     var first_segment = _b$_[1];
     if(first_segment !== cst$33){
      if(uri[3])
       caml_call2(Stdlib_Buffer[12], buf, 47);
      else if(caml_call3(Stringext[12], 0, first_segment, cst$10) && ! scheme)
       caml_call2(Stdlib_Buffer[16], buf, cst$11);
      var
       _ca_ = uri[5],
       x$1 = encoded_of_path(scheme, pct_encoder$0[4])(_ca_);
      caml_call2(Stdlib_Buffer[16], buf, x$1);
     }
     else{
      var
       _ch_ = uri[5],
       x$2 = encoded_of_path(scheme, pct_encoder$0[4])(_ch_);
      caml_call2(Stdlib_Buffer[16], buf, x$2);
     }
    }
    var _cb_ = uri[6];
    a:
    {
     b:
     {
      if(0 === _cb_[0]){
       var _cc_ = _cb_[1];
       if(_cc_){var q = _cc_; break b;}
      }
      else if(_cb_[1]){
       var _ce_ = _cb_[2], _cf_ = caml_obj_tag(_ce_);
       c:
       if(250 === _cf_)
        var _cg_ = _ce_[1];
       else{
        if(246 !== _cf_ && 244 !== _cf_){var _cg_ = _ce_; break c;}
        var _cg_ = caml_call1(CamlinternalLazy[2], _ce_);
       }
       var q = _cg_;
       break b;
      }
      break a;
     }
     caml_call2(Stdlib_Buffer[12], buf, 63);
     var _cd_ = encoded_of_query(scheme, [0, pct_encoder$0], q);
     caml_call2(Stdlib_Buffer[16], buf, _cd_);
    }
    var match$4 = uri[7];
    if(match$4){
     var f = match$4[1];
     caml_call2(Stdlib_Buffer[12], buf, 35);
     add_pct_string([0, pct_encoder$0[7]], f);
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function get_decoded_opt(param){
    if(! param) return 0;
    var x = param[1];
    return [0, x];
   }
   function scheme(uri){return get_decoded_opt(uri[1]);}
   function with_scheme(uri, param){
    if(! param) return [0, 0, uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
    var scheme = param[1];
    return [0, [0, scheme], uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
   }
   function host(uri){
    var _b4_ = uri[3];
    if(! _b4_) return 0;
    var match = _b4_[1];
    if(803994504 <= match[1]){var h = match[2]; return [0, h];}
    var h$0 = match[2];
    return [0, h$0];
   }
   function host_with_default(opt, uri){
    var default$0 = opt ? opt[1] : cst_localhost, match = host(uri);
    if(! match) return default$0;
    var h = match[1];
    return h;
   }
   function userinfo(opt, uri){
    var
     pct_encoder$0 = opt ? opt[1] : pct_encoder(0, 0, 0, 0, 0, 0, 0, 0),
     match = uri[2];
    if(! match) return 0;
    var userinfo = match[1], match$0 = uri[1];
    if(match$0)
     var
      s = match$0[1],
      x = encoded_of_userinfo([0, s], pct_encoder$0[2])(userinfo);
    else
     var x = encoded_of_userinfo(0, pct_encoder$0[2])(userinfo);
    return [0, x];
   }
   function with_userinfo(uri, userinfo){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    return host(uri)
            ? [0, uri[1], userinfo$0, uri[3], uri[4], uri[5], uri[6], uri[7]]
            : [0,
              uri[1],
              userinfo$0,
              [0, [0, 803994504, cst$12]],
              uri[4],
              uri[5],
              uri[6],
              uri[7]];
   }
   function user(uri){
    var _b3_ = uri[2];
    if(! _b3_) return 0;
    var user = _b3_[1][1];
    return [0, user];
   }
   function password(uri){
    var _b2_ = uri[2];
    if(_b2_){
     var match = _b2_[1][2];
     if(match){var pass = match[1]; return [0, pass];}
    }
    return 0;
   }
   function with_password(uri, password){
    function result(userinfo){
     return host(uri)
             ? [0, uri[1], userinfo, uri[3], uri[4], uri[5], uri[6], uri[7]]
             : [0,
               uri[1],
               userinfo,
               [0, [0, 803994504, cst$13]],
               uri[4],
               uri[5],
               uri[6],
               uri[7]];
    }
    var _b1_ = uri[2];
    if(! _b1_) return password ? result([0, [0, cst$14, password]]) : uri;
    var user = _b1_[1][1];
    return result([0, [0, user, password]]);
   }
   function port(uri){return uri[4];}
   function with_port(uri, port){
    return host(uri)
            ? [0, uri[1], uri[2], uri[3], port, uri[5], uri[6], uri[7]]
            : port
              ? [0,
                uri[1],
                uri[2],
                [0, [0, 803994504, cst$15]],
                port,
                uri[5],
                uri[6],
                uri[7]]
              : [0, uri[1], uri[2], 0, 0, uri[5], uri[6], uri[7]];
   }
   function path(opt, uri){
    var
     pct_encoder$0 = opt ? opt[1] : pct_encoder(0, 0, 0, 0, 0, 0, 0, 0),
     match = uri[1];
    if(match)
     var
      s = match[1],
      _bZ_ = uri[5],
      x = encoded_of_path([0, s], pct_encoder$0[4])(_bZ_);
    else
     var _b0_ = uri[5], x = encoded_of_path(0, pct_encoder$0[4])(_b0_);
    return x;
   }
   function with_path(uri, path){
    var path$0 = path_of_encoded(path);
    if(host(uri) && path$0 && path$0[1] !== cst$33)
     return [0,
             uri[1],
             uri[2],
             uri[3],
             uri[4],
             [0, cst$16, path$0],
             uri[6],
             uri[7]];
    return [0, uri[1], uri[2], uri[3], uri[4], path$0, uri[6], uri[7]];
   }
   function fragment(uri){return get_decoded_opt(uri[7]);}
   function with_fragment(uri, param){
    if(! param) return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], 0];
    var frag = param[1];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], [0, frag]];
   }
   function query(uri){return kv(uri[6]);}
   function verbatim_query(opt, uri){
    var
     pct_encoder$0 = opt ? opt[1] : pct_encoder(0, 0, 0, 0, 0, 0, 0, 0),
     match = uri[6];
    if(0 === match[0]){
     var kv = match[1];
     return kv
             ? [0, encoded_of_query(scheme(uri), [0, pct_encoder$0], kv)]
             : 0;
    }
    var qs = match[1];
    return qs;
   }
   function get_query_param(uri, k){
    var q = kv(uri[6]);
    try{var _bX_ = [0, caml_call2(Stdlib_List[49], k, q)]; return _bX_;}
    catch(_bY_){
     var _bW_ = caml_wrap_exception(_bY_);
     if(_bW_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_bW_, 0);
    }
   }
   function get_query_param$0(uri, k){
    var match = get_query_param(uri, k);
    if(! match) return 0;
    var v = match[1];
    return [0, caml_call2(Stdlib_String[7], cst$17, v)];
   }
   function with_query(uri, query){
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], [0, query], uri[7]];
   }
   function q_s(q){
    return caml_call2
            (Stdlib_List[20],
             function(param){
              var v = param[2], k = param[1];
              return [0, k, [0, v, 0]];
             },
             q);
   }
   function with_query$0(uri, query){return with_query(uri, q_s(query));}
   function add_query_param(uri, p){
    var _bU_ = uri[7], _bV_ = [0, [0, p, kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bV_, _bU_];
   }
   function add_query_param$0(uri, param){
    var
     v = param[2],
     k = param[1],
     _bS_ = uri[7],
     _bT_ = [0, [0, [0, k, [0, v, 0]], kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bT_, _bS_];
   }
   function add_query_params(uri, ps){
    var
     _bP_ = uri[7],
     _bQ_ = kv(uri[6]),
     _bR_ = [0, caml_call2(Stdlib[37], ps, _bQ_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bR_, _bP_];
   }
   function add_query_params$0(uri, ps){
    var
     _bL_ = uri[7],
     _bM_ = kv(uri[6]),
     _bN_ = q_s(ps),
     _bO_ = [0, caml_call2(Stdlib[37], _bN_, _bM_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bO_, _bL_];
   }
   function remove_query_param(uri, k){
    var
     _bI_ = uri[7],
     _bJ_ = kv(uri[6]),
     _bK_ =
       [0,
        caml_call2
         (Stdlib_List[44],
          function(param){var k$0 = param[1]; return k !== k$0 ? 1 : 0;},
          _bJ_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _bK_, _bI_];
   }
   function path_and_query(uri){
    var p = path(0, uri), match = query(uri);
    if(p !== cst$34){
     if(! match) return p;
     var
      scheme = uncast_opt(uri[1]),
      _bG_ = encoded_of_query$0(scheme)(0, match);
     return caml_call3(Stdlib_Printf[4], _j_, p, _bG_);
    }
    if(! match) return cst$18;
    var
     scheme$0 = uncast_opt(uri[1]),
     _bH_ = encoded_of_query$0(scheme$0)(0, match);
    return caml_call2(Stdlib_Printf[4], _k_, _bH_);
   }
   function resolve(schem, base, uri){
    var match$0 = scheme(base);
    if(match$0)
     var scheme$0 = match$0[1], scheme$1 = scheme$0;
    else
     var scheme$1 = schem;
    var
     schem$0 = [0, scheme$1],
     match$1 = scheme(uri),
     match$2 = userinfo(0, uri);
    a:
    {
     var match$3 = host(uri);
     if(match$1)
      var
       _bp_ = uri[7],
       _bq_ = uri[6],
       _br_ = remove_dot_segments(uri[5]),
       _bs_ = [0, uri[1], uri[2], uri[3], uri[4], _br_, _bq_, _bp_];
     else{
      if(! match$2 && ! match$3){
       var
        init = [0, base[1], base[2], base[3], base[4], uri[5], uri[6], uri[7]],
        path_str = path(0, init);
       if(path_str === cst$34)
        var
         _bw_ = init[7],
         _bx_ = init[6][1] ? init[6] : base[6],
         _by_ = [0, init[1], init[2], init[3], init[4], base[5], _bx_, _bw_];
       else if(47 === caml_string_get(path_str, 0))
        var
         _bz_ = init[7],
         _bA_ = init[6],
         _bB_ = remove_dot_segments(init[5]),
         _by_ = [0, init[1], init[2], init[3], init[4], _bB_, _bA_, _bz_];
       else{
        var
         relpath = init[5],
         bpath = base[5],
         bhost = base[3],
         _bC_ = init[7],
         _bD_ = init[6],
         match = caml_call1(Stdlib_List[10], bpath);
        b:
        {
         if(bhost && ! match){var _bE_ = [0, cst$6, relpath]; break b;}
         c:
         if(match){
          if(match[1] !== cst$33){
           var _bo_ = match[2];
           if(! _bo_) break c;
           if(_bo_[1] !== cst$33) break c;
           var rbpath = _bo_[2];
          }
          else
           var rbpath = match[2];
          var _bE_ = caml_call2(Stdlib_List[13], [0, cst$5, rbpath], relpath);
          break b;
         }
         var _bE_ = relpath;
        }
        var
         _bF_ = remove_dot_segments(_bE_),
         _by_ = [0, init[1], init[2], init[3], init[4], _bF_, _bD_, _bC_];
       }
       var _bs_ = _by_;
       break a;
      }
      var
       _bt_ = uri[7],
       _bu_ = uri[6],
       _bv_ = remove_dot_segments(uri[5]),
       _bs_ = [0, base[1], uri[2], uri[3], uri[4], _bv_, _bu_, _bt_];
     }
    }
    return normalize(schem$0, _bs_);
   }
   function canonicalize(uri){
    var
     uri$0 = resolve(cst$19, empty, uri),
     Scheme = module_of_scheme(uncast_opt(uri$0[1])),
     _bk_ = uri$0[7],
     _bl_ = uri$0[6],
     _bm_ = Scheme[4].call(null, uri$0[5]),
     _bn_ = Scheme[3].call(null, uri$0[4]);
    return [0, uri$0[1], uri$0[2], uri$0[3], _bn_, _bm_, _bl_, _bk_];
   }
   function pp(ppf, uri){
    var _bj_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bj_);
   }
   function pp_hum(ppf, uri){
    var _bi_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bi_);
   }
   var string_of_char = caml_call1(Stdlib_String[1], 1);
   function string_of_char_list(chars){
    var _bh_ = caml_call2(Stdlib_List[20], string_of_char, chars);
    return caml_call2(Stdlib_String[7], cst$20, _bh_);
   }
   var
    _l_ = caml_call1(Angstrom[51], 0),
    _m_ = caml_call1(Angstrom[4], 58),
    _n_ =
      caml_call1
       (Angstrom[13],
        function(c){
         var _bd_ = 58 !== c ? 1 : 0;
         if(_bd_){
          var _be_ = 47 !== c ? 1 : 0;
          if(_be_)
           var _bf_ = 63 !== c ? 1 : 0, _bg_ = _bf_ ? 35 !== c ? 1 : 0 : _bf_;
          else
           var _bg_ = _be_;
         }
         else
          var _bg_ = _bd_;
         return _bg_;
        }),
    _o_ = caml_call2(Angstrom[59], _n_, _m_),
    _p_ = caml_call2(Angstrom[60], function(s){return [0, decode(s)];}, _o_),
    scheme$0 = caml_call2(Angstrom[47], _p_, _l_);
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   var
    hex_digit =
      caml_call1
       (Angstrom[7],
        function(param){
         var _bc_ = param - 48 | 0;
         a:
         {
          if(22 < _bc_ >>> 0){
           if(5 < _bc_ - 49 >>> 0) break a;
          }
          else if(6 >= _bc_ - 10 >>> 0) break a;
          return 1;
         }
         return 0;
        }),
    _q_ = caml_call1(Angstrom[38], hex_digit),
    hexadecimal = caml_call2(Angstrom[60], string_of_char_list, _q_),
    c_dot = caml_call1(Angstrom[4], 46),
    c_at = caml_call1(Angstrom[4], 64),
    c_colon = caml_call1(Angstrom[4], 58),
    _r_ =
      caml_call1
       (Angstrom[14], function(param){return 9 < param - 48 >>> 0 ? 0 : 1;}),
    dec_octet =
      caml_call2
       (Angstrom[53],
        _r_,
        function(num){
         return 256 <= caml_int_of_string(num)
                 ? caml_call1(Angstrom[52], cst_invalid_octect)
                 : caml_call1(Angstrom[51], num);
        }),
    _s_ = caml_call2(Angstrom[59], dec_octet, c_dot),
    _t_ = caml_call2(Angstrom[37], 3, _s_),
    ipv4_address =
      caml_call3
       (Angstrom[61],
        function(three, one){
         var
          _ba_ = caml_call2(Stdlib[28], cst$21, one),
          _bb_ = caml_call2(Stdlib_String[7], cst$22, three);
         return caml_call2(Stdlib[28], _bb_, _ba_);
        },
        _t_,
        dec_octet),
    after_double_colon =
      caml_call1
       (Angstrom[45],
        function(f){
         var
          _a7_ = caml_call1(Angstrom[51], 0),
          _a8_ = caml_call2(Angstrom[58], c_colon, f),
          _a9_ = caml_call2(Angstrom[47], _a8_, _a7_),
          _a__ =
            caml_call3
             (Angstrom[61],
              function(x, y){return [0, x, y];},
              hexadecimal,
              _a9_),
          _a$_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
         return caml_call2(Angstrom[47], _a$_, _a__);
        });
   function double_colon(count){
    var
     _a5_ = caml_call1(Angstrom[51], _u_),
     _a6_ =
       caml_call2
        (Angstrom[53],
         after_double_colon,
         function(rest){
          var
           filler_length =
             (8 - count | 0) - caml_call1(Stdlib_List[1], rest) | 0;
          return 0 < filler_length
                  ? caml_call1(Angstrom[51], [0, cst$23, rest])
                  : caml_call1(Angstrom[52], cst_too_many_parts_in_IPv6_add);
         });
    return caml_call2(Angstrom[47], _a6_, _a5_);
   }
   function part(n){
    if(6 !== n)
     return 7 === n
             ? caml_call2
               (Angstrom[60], function(x){return [0, x, 0];}, hexadecimal)
             : hex_part(n);
    var
     _a3_ = hex_part(6),
     _a4_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
    return caml_call2(Angstrom[47], _a4_, _a3_);
   }
   function hex_part(n){
    var
     _aY_ = part(n + 1 | 0),
     _aZ_ = double_colon(n + 1 | 0),
     _a0_ = caml_call2(Angstrom[58], c_colon, _aZ_),
     _a1_ = caml_call2(Angstrom[47], _a0_, _aY_),
     _a2_ = caml_call2(Angstrom[58], c_colon, _a1_);
    return caml_call3
            (Angstrom[61],
             function(x, y){return [0, x, y];},
             hexadecimal,
             _a2_);
   }
   function split_with(f, xs){
    if(! xs) return _v_;
    var ys = xs[2], y = xs[1];
    if(! caml_call1(f, y)) return [0, 0, xs];
    var match = split_with(f, ys), ts = match[2], zs = match[1];
    return [0, [0, y, zs], ts];
   }
   function format_addr(segments){
    var
     match =
       split_with
        (function(segment){return segment !== cst$34 ? 1 : 0;}, segments),
     after_double_colon = match[2],
     before_double_colon = match[1],
     before = caml_call2(Stdlib_String[7], cst$24, before_double_colon);
    a:
    {
     if(after_double_colon && after_double_colon[1] === cst$34){
      var
       xs = after_double_colon[2],
       _aW_ = caml_call2(Stdlib_String[7], cst$25, xs),
       _aX_ = caml_call2(Stdlib[28], cst$26, _aW_),
       res = caml_call2(Stdlib[28], before, _aX_);
      break a;
     }
     var res = before;
    }
    return res;
   }
   var
    _w_ = part(0),
    _x_ = double_colon(0),
    _y_ = caml_call2(Angstrom[58], c_colon, c_colon),
    _z_ = caml_call2(Angstrom[58], _y_, _x_),
    _A_ = caml_call2(Angstrom[47], _z_, _w_),
    ipv6 = caml_call2(Angstrom[60], format_addr, _A_),
    _B_ = caml_call1(Angstrom[4], 93),
    _C_ = caml_call1(Angstrom[4], 91),
    _D_ = caml_call2(Angstrom[58], _C_, ipv6),
    ipv6_address = caml_call2(Angstrom[59], _D_, _B_),
    _E_ = caml_call2(Angstrom[37], 2, hex_digit),
    _F_ = caml_call1(Angstrom[4], 37),
    pct_encoded =
      caml_call3
       (Angstrom[61],
        function(pct, digits){return string_of_char_list([0, pct, digits]);},
        _F_,
        _E_),
    sub_delims$0 =
      caml_call1
       (Angstrom[7],
        function(param){
         var _aU_ = param - 59 | 0;
         a:
         {
          if(2 < _aU_ >>> 0){
           var _aV_ = _aU_ + 26 | 0;
           if(11 < _aV_ >>> 0) break a;
           switch(_aV_){case 1:case 2:case 4: break a;
           }
          }
          else if(1 === _aU_) break a;
          return 1;
         }
         return 0;
        }),
    unreserved =
      caml_call1
       (Angstrom[7],
        function(param){
         a:
         {
          if(91 <= param){
           var _aS_ = param - 95 | 0;
           if(27 < _aS_ >>> 0){
            if(31 !== _aS_) break a;
           }
           else if(1 === _aS_) break a;
          }
          else{
           var _aT_ = param - 45 | 0;
           if(12 < _aT_ >>> 0){
            if(20 > _aT_) break a;
           }
           else if(2 === _aT_) break a;
          }
          return 1;
         }
         return 0;
        }),
    _G_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), 0]],
    _H_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _G_],
    _I_ = caml_call2(Angstrom[48], 0, _H_),
    _J_ = caml_call1(Angstrom[38], _I_),
    _K_ = caml_call1(Stdlib_String[7], cst$27),
    reg_name = caml_call2(Angstrom[60], _K_, _J_),
    _L_ =
      [0,
       caml_call2
        (Angstrom[55],
         reg_name,
         function(s){return [0, 803994504, decode(s)];}),
       0],
    _M_ =
      [0,
       caml_call2
        (Angstrom[55], ipv6_address, function(h){return [0, 267950263, h];}),
       _L_],
    _N_ =
      [0,
       caml_call2
        (Angstrom[55], ipv4_address, function(h){return [0, -367671627, h];}),
       _M_],
    host$0 = caml_call2(Angstrom[48], 0, _N_),
    _O_ = caml_call1(Angstrom[51], 0),
    _P_ = [0, caml_call2(Angstrom[57], string_of_char, c_colon), 0],
    _Q_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), _P_]],
    _R_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _Q_],
    _S_ = caml_call2(Angstrom[48], 0, _R_),
    _T_ = caml_call1(Angstrom[38], _S_),
    _U_ = caml_call2(Angstrom[59], _T_, c_at),
    _V_ =
      caml_call2
       (Angstrom[60],
        function(x){
         var s = caml_call2(Stdlib_String[7], cst$28, x);
         return [0, userinfo_of_encoded(s)];
        },
        _U_),
    userinfo$0 = caml_call2(Angstrom[47], _V_, _O_),
    port$0 =
      caml_call2
       (Angstrom[53],
        Angstrom[1],
        function(param){
         if(param && 58 === param[1]){
          var
           _aO_ = caml_call1(Angstrom[13], is_digit),
           _aP_ = caml_call2(Angstrom[58], c_colon, _aO_);
          return caml_call2
                  (Angstrom[55],
                   _aP_,
                   function(port){
                    var decoded = decode(port);
                    try{
                     var _aQ_ = [0, caml_int_of_string(decoded)];
                     return _aQ_;
                    }
                    catch(_aR_){return 0;}
                   });
         }
         return caml_call1(Angstrom[51], 0);
        }),
    _X_ = caml_call1(Angstrom[51], _W_),
    _Y_ =
      caml_call4
       (Angstrom[62],
        function(userinfo, host, port){return [0, userinfo, [0, host], port];},
        userinfo$0,
        host$0,
        port$0),
    _Z_ = caml_call1(Angstrom[8], cst$29),
    ___ = caml_call2(Angstrom[58], _Z_, _Y_),
    authority = caml_call2(Angstrom[47], ___, _X_),
    _$_ =
      caml_call1
       (Angstrom[13],
        function(param){if(35 !== param && 63 !== param) return 1; return 0;}),
    path$0 = caml_call2(Angstrom[60], path_of_encoded, _$_),
    _aa_ = [1, 0, caml_call1(Stdlib_Lazy[4], 0)],
    _ab_ = caml_call1(Angstrom[51], _aa_),
    _ac_ =
      caml_call1(Angstrom[15], function(param){return 35 === param ? 1 : 0;}),
    _ad_ = caml_call1(Angstrom[4], 63),
    _ae_ = caml_call2(Angstrom[58], _ad_, _ac_),
    _af_ = caml_call2(Angstrom[60], of_raw, _ae_),
    query$0 = caml_call2(Angstrom[47], _af_, _ab_),
    _ag_ = caml_call1(Angstrom[51], 0),
    _ah_ = caml_call1(Angstrom[13], function(param){return 1;}),
    _ai_ = caml_call1(Angstrom[4], 35),
    _aj_ = caml_call2(Angstrom[58], _ai_, _ah_),
    _ak_ = caml_call2(Angstrom[60], function(s){return [0, decode(s)];}, _aj_),
    fragment$0 = caml_call2(Angstrom[47], _ak_, _ag_),
    _al_ =
      caml_call5
       (Angstrom[63],
        function(scheme, param, path, query, fragment){
         var port = param[3], host = param[2], userinfo = param[1];
         return normalize
                 (scheme,
                  [0, scheme, userinfo, host, port, path, query, fragment]);
        },
        scheme$0,
        authority,
        path$0,
        query$0),
    uri_reference = caml_call2(Angstrom[56], _al_, fragment$0),
    _am_ =
      caml_call1(Angstrom[13], function(param){return 10 === param ? 0 : 1;}),
    uri_reference$0 =
      caml_call2
       (Angstrom[55],
        _am_,
        function(s){
         var match = caml_call3(Angstrom[75], 1, uri_reference, s);
         if(0 !== match[0]) return empty;
         var t = match[1];
         return t;
        });
   function decode_host(host){
    var match = caml_call3(Angstrom[75], 1, host$0, host);
    if(0 === match[0]){var parsed = match[1]; return parsed;}
    var match$0 = caml_call3(Angstrom[75], 1, ipv6, host);
    if(0 !== match$0[0]) return [0, 803994504, host];
    var parsed$0 = match$0[1];
    return [0, 267950263, parsed$0];
   }
   function make(scheme, userinfo, host, port, path, query, fragment, param){
    function decode(param){
     if(! param) return 0;
     var x = param[1];
     return [0, x];
    }
    a:
    {
     b:
     if(! host){if(! port && ! userinfo) break b; var host$0 = _ao_; break a;}
     var host$0 = host;
    }
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(host$0 && path$0 && path$0[1] !== cst$33){var _aL_ = [0, cst$30, path$0]; break a;}
      var _aL_ = path$0;
     }
     var path$1 = _aL_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _an_;
    var scheme$0 = decode(scheme), _aM_ = decode(fragment);
    if(host$0)
     var host$1 = host$0[1], _aN_ = [0, decode_host(host$1)];
    else
     var _aN_ = 0;
    return normalize
            (scheme$0,
             [0, scheme$0, userinfo$0, _aN_, port, path$1, query$0, _aM_]);
   }
   function with_host(init, host){
    var _aG_ = init[7], _aH_ = init[6], _aI_ = init[5], _aJ_ = init[4];
    if(host)
     var host$0 = host[1], _aK_ = [0, decode_host(host$0)];
    else
     var _aK_ = 0;
    return [0, init[1], init[2], _aK_, _aJ_, _aI_, _aH_, _aG_];
   }
   function with_uri(scheme, userinfo, host, port, path, query, fragment, uri){
    function with$0(f, o, u){
     if(! o) return u;
     var x = o[1];
     return caml_call2(f, u, x);
    }
    var
     u =
       with$0
        (with_port,
         port,
         with$0
          (with_host,
           host,
           with$0(with_userinfo, userinfo, with$0(with_scheme, scheme, uri))));
    if(path){
     var x$0 = path[1];
     if(x$0)
      var p = x$0[1], _aF_ = with_path(u, p);
     else
      var _aF_ = with_path(u, cst$31);
     var u$0 = _aF_;
    }
    else
     var u$0 = u;
    if(query){
     var x = query[1];
     if(x)
      var q = x[1], _aE_ = with_query(u$0, q);
     else
      var _aE_ = with_query(u$0, 0);
     var _aD_ = _aE_;
    }
    else
     var _aD_ = u$0;
    return with$0(with_fragment, fragment, _aD_);
   }
   function of_string(s){
    var match = caml_call3(Angstrom[75], 0, uri_reference$0, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   var let$0 = Stdlib_Result[6];
   function to_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1],
     scheme$0 = 804243368 <= scheme ? x : x$0;
    return [0,
            [0, scheme$0],
            userinfo,
            [0, host],
            port,
            path,
            query,
            fragment];
   }
   function of_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1];
    function _aA_(scheme){
     return caml_call2
             (let$0,
              caml_call2(Stdlib_Option[14], _ap_, host),
              function(host){
               return [0,
                       [0, scheme, userinfo, host, port, path, query, fragment]];
              });
    }
    if(scheme)
     var
      unsupported_scheme = scheme[1],
      _aB_ =
        unsupported_scheme !== cst_http
         ? unsupported_scheme
           !== cst_https
           ? [1,
             [0,
              3854881,
              caml_call2(Stdlib_Printf[4], _aq_, unsupported_scheme)]]
           : _ar_
         : _as_,
      _aC_ = _aB_;
    else
     var _aC_ = _at_;
    return caml_call2(let$0, _aC_, _aA_);
   }
   function of_string$0(s){
    var match = of_uri(of_string(s));
    if(0 === match[0]){var t = match[1]; return t;}
    var error = match[1][2];
    return caml_call1(Stdlib[2], error);
   }
   function to_string$0(pct_encoder, t){
    return to_string(pct_encoder, to_uri(t));
   }
   function make$0
   (scheme, host$2, userinfo, port, path, query, fragment, param){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(path$0 && path$0[1] !== cst$33){
       var _ay_ = [0, cst$32, path$0];
       break a;
      }
      var _ay_ = path$0;
     }
     var path$1 = _ay_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _au_;
    if(fragment) var x$0 = fragment[1], _az_ = [0, x$0]; else var _az_ = 0;
    var match = decode_host(host$2), _aw_ = match[1];
    if(267950263 === _aw_)
     var
      host = match[2],
      _ax_ = [0, 267950263, caml_call1(Stdlib_String[27], host)];
    else if(803994504 <= _aw_)
     var
      host$0 = match[2],
      x = caml_call1(Stdlib_String[27], host$0),
      _ax_ = [0, 803994504, x];
    else
     var
      host$1 = match[2],
      _ax_ = [0, -367671627, caml_call1(Stdlib_String[27], host$1)];
    return [0, scheme, userinfo$0, _ax_, port, path$1, query$0, _az_];
   }
   function host$1(t){
    var match = t[3];
    if(803994504 <= match[1]){var h = match[2]; return h;}
    var h$0 = match[2];
    return h$0;
   }
   function scheme$1(t){return t[1];}
   var
    Uri =
      [0,
       empty,
       compare$0,
       equal,
       pct_encode,
       pct_encoder,
       pct_decode,
       of_string,
       to_string,
       resolve,
       canonicalize,
       make,
       with_uri,
       query,
       verbatim_query,
       encoded_of_query$0,
       query_of_encoded,
       with_query,
       with_query$0,
       get_query_param,
       get_query_param$0,
       add_query_param,
       add_query_param$0,
       add_query_params,
       add_query_params$0,
       remove_query_param,
       path,
       path_and_query,
       with_path,
       scheme,
       with_scheme,
       userinfo,
       with_userinfo,
       user,
       password,
       with_password,
       host,
       with_host,
       host_with_default,
       port,
       with_port,
       fragment,
       with_fragment,
       pp,
       pp_hum,
       [0, ipv6, uri_reference$0],
       [0, of_uri, to_uri, of_string$0, to_string$0, make$0, host$1, scheme$1]];
   runtime.caml_register_global(107, Uri, "Uri");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJpLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJ1cmkuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9odHRwIiwiY3N0X2h0dHBzIiwiY3N0X2ludF9vZl9oZXhfY2hhciIsImNzdF9sb2NhbGhvc3QiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9pbnRfb2Zfc3RyaW5nIiwiY2FtbF9tYWtlX3ZlY3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX29ial90YWciLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwieCIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliIiwiU3RkbGliX09wdGlvbiIsIlN0ZGxpYl9QcmludGYiLCJBbmdzdHJvbSIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0Zvcm1hdCIsIlN0cmluZ2V4dCIsIkNhbWxpbnRlcm5hbExhenkiLCJTdGRsaWJfTGF6eSIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYl9BcnJheSIsIlN0ZGxpYl9DaGFyIiwiU3RkbGliX1Jlc3VsdCIsIml0ZXJfY29uY2F0IiwiZm4iLCJzZXAiLCJidWYiLCJwYXJhbSIsImxhc3QiLCJyZXN0IiwiY29tcGFyZV9vcHQiLCJjIiwidCIsImEiLCJiIiwiY29tcGFyZV9saXN0IiwieHMiLCJ5cyIsInkiLCJzdWJfZGVsaW1zIiwiaSIsInNhZmVfY2hhcnMiLCJjc3RfdG9vX21hbnlfcGFydHNfaW5fSVB2Nl9hZGQiLCJjc3RfaW52YWxpZF9vY3RlY3QiLCJwY2hhciIsInNhZmVfY2hhcnNfZm9yX3NjaGVtZSIsInNhZmVfY2hhcnNfZm9yX3BhdGgiLCJzYWZlX2NoYXJzX2Zvcl9xdWVyeSIsInNhZmVfY2hhcnNfZm9yX3F1ZXJ5X2tleSIsInNhZmVfY2hhcnNfZm9yX3F1ZXJ5X3ZhbHVlIiwic2FmZV9jaGFyc19mb3JfdXNlcmluZm8iLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQiLCJtYXRjaCIsInVuc2FmZSIsInNhZmUiLCJjb21wb25lbnQiLCJub3JtYWxpemVfaG9zdCIsImhzbyIsImNhbm9uaWNhbGl6ZV9wb3J0IiwicG9ydCIsImNhbm9uaWNhbGl6ZV9wYXRoIiwicGF0aCIsIkdlbmVyaWMiLCJocyIsIkh0dHAiLCJIdHRwcyIsIkZpbGUiLCJVcm4iLCJtb2R1bGVfb2Zfc2NoZW1lIiwicyIsImVuY29kZSIsInNjaGVtZSIsIm9wdCIsIlNjaGVtZSIsImxlbiIsInN0YXJ0IiwiY3VyIiwiaW50X29mX2hleF9jaGFyIiwiZGVjb2RlIiwiaGlnaGJpdHMiLCJsb3diaXRzIiwic3RhcnRfYXQiLCJwY3RfZW5jb2RlIiwicGN0X2VuY29kZXIiLCJ1c2VyaW5mbyIsImhvc3QiLCJxdWVyeV9rZXkiLCJxdWVyeV92YWx1ZSIsImZyYWdtZW50IiwicGN0X2RlY29kZSIsImNvbXBhcmUiLCJwIiwidSIsInVzZXJpbmZvX29mX2VuY29kZWQiLCJ1cyIsImVuY29kZWRfb2ZfdXNlcmluZm8iLCJwbyIsInBhdGhfb2ZfZW5jb2RlZCIsInBzIiwidG9rbCIsInJlbW92ZV9kb3Rfc2VnbWVudHMiLCJyZXZwIiwiYXNjZW5zaW9uIiwib3V0cCIsInIiLCJsc3QiLCJoIiwiYWNjIiwiZW5jb2RlZF9vZl9wYXRoIiwidG9rIiwic2VnIiwicXVlcnlfb2ZfZW5jb2RlZCIsInFzIiwiZWxzIiwicGx1c190b19zcGFjZSIsImVsIiwiayIsInRsIiwidiIsImwiLCJuIiwiZW5jb2RlZF9vZl9xdWVyeSIsIm9mX3JhdyIsImxhenlfcXVlcnkiLCJrdiIsImVtcHR5IiwiY29tcGFyZV9kZWNvZGVkIiwiY29tcGFyZV9ob3N0IiwiaDEiLCJoMiIsImlwMiIsImlwMSIsImt2bCIsInJhdyIsInZsIiwiZXF1YWwiLCJ1bmNhc3Rfb3B0Iiwibm9ybWFsaXplIiwic2NoZW0iLCJpbml0IiwidG9fc3RyaW5nIiwidXJpIiwiYWRkX3BjdF9zdHJpbmciLCJmaXJzdF9zZWdtZW50IiwicSIsImdldF9kZWNvZGVkX29wdCIsIndpdGhfc2NoZW1lIiwiaG9zdF93aXRoX2RlZmF1bHQiLCJkZWZhdWx0Iiwid2l0aF91c2VyaW5mbyIsInVzZXIiLCJwYXNzd29yZCIsInBhc3MiLCJ3aXRoX3Bhc3N3b3JkIiwicmVzdWx0Iiwid2l0aF9wb3J0Iiwid2l0aF9wYXRoIiwid2l0aF9mcmFnbWVudCIsImZyYWciLCJxdWVyeSIsInZlcmJhdGltX3F1ZXJ5IiwiZ2V0X3F1ZXJ5X3BhcmFtIiwid2l0aF9xdWVyeSIsInFfcyIsImFkZF9xdWVyeV9wYXJhbSIsImFkZF9xdWVyeV9wYXJhbXMiLCJyZW1vdmVfcXVlcnlfcGFyYW0iLCJwYXRoX2FuZF9xdWVyeSIsInJlc29sdmUiLCJiYXNlIiwicGF0aF9zdHIiLCJyZWxwYXRoIiwiYnBhdGgiLCJiaG9zdCIsInJicGF0aCIsImNhbm9uaWNhbGl6ZSIsInBwIiwicHBmIiwicHBfaHVtIiwic3RyaW5nX29mX2NoYXIiLCJzdHJpbmdfb2ZfY2hhcl9saXN0IiwiY2hhcnMiLCJpc19kaWdpdCIsImhleF9kaWdpdCIsImhleGFkZWNpbWFsIiwiY19kb3QiLCJjX2F0IiwiY19jb2xvbiIsImRlY19vY3RldCIsIm51bSIsImlwdjRfYWRkcmVzcyIsInRocmVlIiwib25lIiwiYWZ0ZXJfZG91YmxlX2NvbG9uIiwiZG91YmxlX2NvbG9uIiwiY291bnQiLCJmaWxsZXJfbGVuZ3RoIiwicGFydCIsImhleF9wYXJ0Iiwic3BsaXRfd2l0aCIsInRzIiwienMiLCJmb3JtYXRfYWRkciIsInNlZ21lbnRzIiwic2VnbWVudCIsImJlZm9yZV9kb3VibGVfY29sb24iLCJiZWZvcmUiLCJyZXMiLCJpcHY2IiwiaXB2Nl9hZGRyZXNzIiwicGN0X2VuY29kZWQiLCJwY3QiLCJkaWdpdHMiLCJ1bnJlc2VydmVkIiwicmVnX25hbWUiLCJkZWNvZGVkIiwiYXV0aG9yaXR5IiwidXJpX3JlZmVyZW5jZSIsImRlY29kZV9ob3N0IiwicGFyc2VkIiwibWFrZSIsIndpdGhfaG9zdCIsIndpdGhfdXJpIiwid2l0aCIsIm8iLCJvZl9zdHJpbmciLCJsZXQiLCJ0b191cmkiLCJvZl91cmkiLCJ1bnN1cHBvcnRlZF9zY2hlbWUiLCJlcnJvciIsIlVyaSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3VyaS91cmkubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMscUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBUixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQXhCLFNBQUE7QUFBQSxJQUFBeUIsSUFBQTtBQUFBLElBQUFBLE1BQUE7QUFBQSxJQUFBekIsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsTUFBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQTBCLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGVBQUE7QUFB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEN2lDYiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0IEFuaWwgTWFkaGF2YXBlZGR5IDxhbmlsQHJlY29pbC5vcmc+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBEYXZpZCBTaGVldHMgPHNoZWV0c0BhbHVtLm1pdC5lZHU+XG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKilcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cblxudHlwZSBjb21wb25lbnQgPSBbXG4gIHwgYFNjaGVtZVxuICB8IGBBdXRob3JpdHlcbiAgfCBgVXNlcmluZm8gKCogc3ViY29tcG9uZW50IG9mIGF1dGhvcml0eSBpbiBzb21lIHNjaGVtZXMgKilcbiAgfCBgSG9zdCAoKiBzdWJjb21wb25lbnQgb2YgYXV0aG9yaXR5IGluIHNvbWUgc2NoZW1lcyAqKVxuICB8IGBQYXRoXG4gIHwgYFF1ZXJ5XG4gIHwgYFF1ZXJ5X2tleVxuICB8IGBRdWVyeV92YWx1ZVxuICB8IGBGcmFnbWVudFxuICB8IGBHZW5lcmljXG4gIHwgYEN1c3RvbSBvZiAoY29tcG9uZW50ICogc3RyaW5nICogc3RyaW5nKSAoKiAoY29tcG9uZW50ICogc2FmZSBjaGFycyAqIHVuc2FmZSBjaGFycykgKilcbl1cblxudHlwZSBwY3RfZW5jb2RlciA9IHtcbiAgICBzY2hlbWU6IGNvbXBvbmVudDtcbiAgICB1c2VyaW5mbzogY29tcG9uZW50O1xuICAgIGhvc3Q6IGNvbXBvbmVudDtcbiAgICBwYXRoOiBjb21wb25lbnQ7XG4gICAgcXVlcnlfa2V5OiBjb21wb25lbnQ7XG4gICAgcXVlcnlfdmFsdWU6IGNvbXBvbmVudDtcbiAgICBmcmFnbWVudDogY29tcG9uZW50O1xuICB9XG5cbmxldCByZWMgaXRlcl9jb25jYXQgZm4gc2VwIGJ1ZiA9IGZ1bmN0aW9uXG4gIHwgbGFzdDo6W10gLT4gZm4gYnVmIGxhc3RcbiAgfCBlbDo6cmVzdCAtPlxuICAgIGZuIGJ1ZiBlbDtcbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgc2VwO1xuICAgIGl0ZXJfY29uY2F0IGZuIHNlcCBidWYgcmVzdFxuICB8IFtdIC0+ICgpXG5cbmxldCByZXZfaW50ZXJqZWN0IGUgbHN0ID1cbiAgbGV0IHJlYyBhdXggYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdICAtPiBhY2NcbiAgICB8IHg6OnhzIC0+IGF1eCAoeDo6ZTo6YWNjKSB4c1xuICBpbiBtYXRjaCBsc3Qgd2l0aFxuICB8IFtdICAtPiBbXVxuICB8IGg6OnQgLT4gYXV4IFtoXSB0XG5cbmxldCBjb21wYXJlX29wdCBjIHQgdCcgPSBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTm9uZSwgICBOb25lICAgLT4gMFxuICB8IFNvbWUgXywgTm9uZSAgIC0+IDFcbiAgfCBOb25lLCAgIFNvbWUgXyAtPiAtMVxuICB8IFNvbWUgYSwgU29tZSBiIC0+IGMgYSBiXG5cbmxldCByZWMgY29tcGFyZV9saXN0IGYgdCB0JyA9IG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBbXSwgICAgW10gICAgLT4gIDBcbiAgfCBfOjpfLCAgW10gICAgLT4gIDFcbiAgfCBbXSwgICAgXzo6XyAgLT4gLTFcbiAgfCB4Ojp4cywgeTo6eXMgLT5cbiAgICBtYXRjaCBmIHggeSB3aXRoIDAgLT4gY29tcGFyZV9saXN0IGYgeHMgeXMgfCBjIC0+IGNcblxuKCoqIFNhZmUgY2hhcmFjdGVycyB0aGF0IGFyZSBhbHdheXMgYWxsb3dlZCBpbiBhIFVSSVxuICAqIFVuZm9ydHVuYXRlbHksIHRoaXMgdmFyaWVzIGRlcGVuZGluZyBvbiB3aGljaCBiaXQgb2YgdGhlIFVSSVxuICAqIGlzIGJlaW5nIHBhcnNlZCwgc28gdGhlcmUgYXJlIG11bHRpcGxlIHZhcmlhbnRzIChhbmQgdGhpc1xuICAqIHNldCBpcyBwcm9iYWJseSBub3QgZXhoYXVzdGl2ZS4gVE9ETzogY2hlY2suXG4qKVxudHlwZSBzYWZlX2NoYXJzID0gYm9vbCBhcnJheVxuXG5tb2R1bGUgdHlwZSBTY2hlbWUgPSBzaWdcbiAgdmFsIHNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCA6IGNvbXBvbmVudCAtPiBzYWZlX2NoYXJzXG4gIHZhbCBub3JtYWxpemVfaG9zdCA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIGNhbm9uaWNhbGl6ZV9wb3J0IDogaW50IG9wdGlvbiAtPiBpbnQgb3B0aW9uXG4gIHZhbCBjYW5vbmljYWxpemVfcGF0aCA6IHN0cmluZyBsaXN0IC0+IHN0cmluZyBsaXN0XG5lbmRcblxubW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgbGV0IHN1Yl9kZWxpbXMgYSA9XG4gICAgbGV0IHN1YmQgPSBcIiEkJicoKSorLDs9XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdWJkIC0gMSBkb1xuICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgc3ViZC5baV0gaW5cbiAgICAgIGEuKGMpIDwtIHRydWVcbiAgICBkb25lO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFycyA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkubWFrZSAyNTYgZmFsc2UgaW5cbiAgICBsZXQgYWx3YXlzX3NhZmUgPVxuICAgICAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8uLX5cIiBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIGFsd2F5c19zYWZlIC0gMSBkb1xuICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgYWx3YXlzX3NhZmUuW2ldIGluXG4gICAgICBhLihjKSA8LSB0cnVlXG4gICAgZG9uZTtcbiAgICBhXG5cbiAgbGV0IHBjaGFyIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBzdWJfZGVsaW1zIChBcnJheS5jb3B5IHNhZmVfY2hhcnMpIGluXG4gICAgYS4oQ2hhci5jb2RlICc6JykgPC0gdHJ1ZTtcbiAgICBhLihDaGFyLmNvZGUgJ0AnKSA8LSB0cnVlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3Jfc2NoZW1lIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnMgaW5cbiAgICBhLihDaGFyLmNvZGUgJysnKSA8LSB0cnVlO1xuICAgIGFcblxuICAoKiogU2FmZSBjaGFyYWN0ZXJzIGZvciB0aGUgcGF0aCBjb21wb25lbnQgb2YgYSBVUkkgKilcbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3BhdGggOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IHN1Yl9kZWxpbXMgKEFycmF5LmNvcHkgcGNoYXIpIGluXG4gICAgKCogZGVsaW1pdGVyOiBub24tc2VnbWVudCBkZWxpbWl0aW5nIHVzZXMgc2hvdWxkIGJlIHBjdCBlbmNvZGVkICopXG4gICAgYS4oQ2hhci5jb2RlICcvJykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9xdWVyeSA6IHNhZmVfY2hhcnMgPVxuICAgICgqIFRPRE86IFdoYXQgYWJvdXQge1wiIVwiLFwiJFwiLFwiLFwifT8gU2VlIDxodHRwczovL2dpdGh1Yi5jb20vYXZzbS9vY2FtbC11cmkvY29tbWl0LzFlZjNmMWRmYjQxYmRiNGYzM2YyMjNmZmUxNmU2MmEzMzk3NTY2MWEjZGlmZi03NDBmMmRlNTNjOWViMzZlOTY3MGRkZmJkYjliYTkxNFIxNzE+ICopXG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHBjaGFyIGluXG4gICAgYS4oQ2hhci5jb2RlICcvJykgPC0gdHJ1ZTtcbiAgICBhLihDaGFyLmNvZGUgJz8nKSA8LSB0cnVlO1xuICAgICgqICcmJyBpcyBzYWZlIGJ1dCB3ZSBzaG91bGQgZW5jb2RlIGxpdGVyYWxzIHRvIGF2b2lkIGFtYmlndWl0eVxuICAgICAgIHdpdGggdGhlIGFscmVhZHkgcGFyc2VkIHFzIHBhcmFtcyAqKVxuICAgIGEuKENoYXIuY29kZSAnJicpIDwtIGZhbHNlO1xuICAgICgqICc7JyBpcyBzYWZlIGJ1dCBzb21lIHN5c3RlbXMgdHJlYXQgaXQgbGlrZSAnJicuICopXG4gICAgYS4oQ2hhci5jb2RlICc7JykgPC0gZmFsc2U7XG4gICAgYS4oQ2hhci5jb2RlICcrJykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9xdWVyeV9rZXkgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFyc19mb3JfcXVlcnkgaW5cbiAgICBhLihDaGFyLmNvZGUgJz0nKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X3ZhbHVlIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5IGluXG4gICAgYS4oQ2hhci5jb2RlICcsJykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9mcmFnbWVudCA6IHNhZmVfY2hhcnMgPSBzYWZlX2NoYXJzX2Zvcl9xdWVyeVxuXG4gICgqKiBTYWZlIGNoYXJhY3RlcnMgZm9yIHRoZSB1c2VyaW5mbyBzdWJjb21wb25lbnQgb2YgYSBVUkkuXG4gICAgICBUT0RPOiB0aGlzIG5lZWRzIG1vcmUgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhZGRlZCAqKVxuICBsZXQgc2FmZV9jaGFyc19mb3JfdXNlcmluZm8gOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFycyBpblxuICAgICgqIGRlbGltaXRlcjogbm9uLXNlZ21lbnQgZGVsaW1pdGluZyB1c2VzIHNob3VsZCBiZSBwY3QgZW5jb2RlZCAqKVxuICAgIGEuKENoYXIuY29kZSAnOicpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgcmVjIHNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCA9IGZ1bmN0aW9uXG4gICAgfCBgUGF0aCAtPiBzYWZlX2NoYXJzX2Zvcl9wYXRoXG4gICAgfCBgVXNlcmluZm8gLT4gc2FmZV9jaGFyc19mb3JfdXNlcmluZm9cbiAgICB8IGBRdWVyeSAtPiBzYWZlX2NoYXJzX2Zvcl9xdWVyeVxuICAgIHwgYFF1ZXJ5X2tleSAtPiBzYWZlX2NoYXJzX2Zvcl9xdWVyeV9rZXlcbiAgICB8IGBRdWVyeV92YWx1ZSAtPiBzYWZlX2NoYXJzX2Zvcl9xdWVyeV92YWx1ZVxuICAgIHwgYEZyYWdtZW50IC0+IHNhZmVfY2hhcnNfZm9yX2ZyYWdtZW50XG4gICAgfCBgU2NoZW1lIC0+IHNhZmVfY2hhcnNfZm9yX3NjaGVtZVxuICAgIHwgYEN1c3RvbSAoKGNvbXBvbmVudCA6IGNvbXBvbmVudCksIHNhZmUsIHVuc2FmZSkgLT5cbiAgICAgICBsZXQgc2FmZV9jaGFycyA9IEFycmF5LmNvcHkgKHNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCBjb21wb25lbnQpIGluXG4gICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc2FmZSAtIDEgZG9cbiAgICAgICAgIGxldCBjID0gQ2hhci5jb2RlIHNhZmUuW2ldIGluXG4gICAgICAgICBzYWZlX2NoYXJzLihjKSA8LSB0cnVlXG4gICAgICAgZG9uZTtcbiAgICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCB1bnNhZmUgLSAxIGRvXG4gICAgICAgICBsZXQgYyA9IENoYXIuY29kZSB1bnNhZmUuW2ldIGluXG4gICAgICAgICBzYWZlX2NoYXJzLihjKSA8LSBmYWxzZVxuICAgICAgIGRvbmU7XG4gICAgICAgc2FmZV9jaGFyc1xuICAgIHwgYEdlbmVyaWNcbiAgICB8IF8gLT4gc2FmZV9jaGFyc1xuXG4gIGxldCBub3JtYWxpemVfaG9zdCBoc28gPSBoc29cblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgcG9ydCA9IHBvcnRcbiAgbGV0IGNhbm9uaWNhbGl6ZV9wYXRoIHBhdGggPSBwYXRoXG5lbmRcblxubW9kdWxlIEh0dHAgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IG5vcm1hbGl6ZV9ob3N0IGhzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBoc1xuXG4gIGxldCBjYW5vbmljYWxpemVfcG9ydCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgODAgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IFNvbWUgeFxuXG4gIGxldCBjYW5vbmljYWxpemVfcGF0aCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXCIvXCJdXG4gICAgfCB4ICAtPiB4XG5lbmRcblxubW9kdWxlIEh0dHBzIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgSHR0cFxuXG4gIGxldCBjYW5vbmljYWxpemVfcG9ydCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgNDQzIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIHhcbmVuZFxuXG5tb2R1bGUgRmlsZSA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEdlbmVyaWNcblxuICBsZXQgbm9ybWFsaXplX2hvc3QgaHMgPVxuICAgIGxldCBocyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaHMgaW5cbiAgICBpZiBocz1cImxvY2FsaG9zdFwiIHRoZW4gXCJcIiBlbHNlIGhzXG5lbmRcblxubW9kdWxlIFVybiA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEdlbmVyaWNcblxuZW5kXG5cbmxldCBtb2R1bGVfb2Zfc2NoZW1lID0gZnVuY3Rpb25cbiAgfCBTb21lIHMgLT4gYmVnaW4gbWF0Y2ggU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzIHdpdGhcbiAgICAgIHwgXCJodHRwXCIgLT4gKG1vZHVsZSBIdHRwIDogU2NoZW1lKVxuICAgICAgfCBcImh0dHBzXCIgIC0+IChtb2R1bGUgSHR0cHMgOiBTY2hlbWUpXG4gICAgICB8IFwiZmlsZVwiIC0+IChtb2R1bGUgRmlsZSA6IFNjaGVtZSlcbiAgICAgIHwgXCJ1cm5cIiAgLT4gKG1vZHVsZSBVcm4gOiBTY2hlbWUpXG4gICAgICB8IF8gLT4gKG1vZHVsZSBHZW5lcmljIDogU2NoZW1lKVxuICAgIGVuZFxuICB8IE5vbmUgLT4gKG1vZHVsZSBHZW5lcmljIDogU2NoZW1lKVxuXG4oKiogUG9ydGlvbnMgb2YgdGhlIFVSTCBtdXN0IGJlIGNvbnZlcnRlZCB0by1hbmQtZnJvbSBwZXJjZW50LWVuY29kaW5nXG4gICogYW5kIHRoaXMgcmVhbGx5LCByZWFsbHkgc2hvdWxkbid0IGJlIG1peGVkIHVwLiBTbyB0aGlzIFBjdCBtb2R1bGVcbiAgKiBkZWZpbmVzIGFic3RyYWN0IFBjdC5lbmNvZGVkIGFuZCBQY3QuZGVjb2RlZCB0eXBlcyB3aGljaCBzZXRzIHRoZVxuICAqIHN0YXRlIG9mIHRoZSB1bmRlcmx5aW5nIHN0cmluZy4gIFRoZXJlIGFyZSBmdW5jdGlvbnMgdG8gXCJjYXN0XCIgdG9cbiAgKiBhbmQgZnJvbSB0aGVzZSBhbmQgbm9ybWFsIHN0cmluZ3MsIGFuZCB0aGlzIHByb21vdGVzIGEgYml0IG9mXG4gICogaW50ZXJuYWwgc2FmZXR5LiAgVGhlc2UgdHlwZXMgYXJlIG5vdCBleHBvc2VkIHRvIHRoZSBleHRlcm5hbFxuICAqIGludGVyZmFjZSwgYXMgY2FzdGluZyB0by1hbmQtZnJvbSBpcyBxdWl0ZSBhIGJpdCBvZiBoYXNzbGUgYW5kXG4gICogcHJvYmFibHkgbm90IGEgbG90IG9mIHVzZSB0byB0aGUgYXZlcmFnZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnlcbiopXG5tb2R1bGUgUGN0IDogc2lnXG4gIHR5cGUgZW5jb2RlZFxuICB0eXBlIGRlY29kZWRcblxuICB2YWwgZW5jb2RlIDogP3NjaGVtZTpzdHJpbmcgLT4gP2NvbXBvbmVudDpjb21wb25lbnQgLT4gZGVjb2RlZCAtPiBlbmNvZGVkXG4gIHZhbCBkZWNvZGUgOiBlbmNvZGVkIC0+IGRlY29kZWRcblxuICAoKiBUaGUgZW1wdHkgZGVjb2RlZCBzdHJpbmcgKilcbiAgdmFsIGVtcHR5X2RlY29kZWQgOiBkZWNvZGVkXG4gICgqIElkZW50aXR5IGZ1bmN0aW9ucyBzbyB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FzdCB3aGVuIHVzaW5nIHRoZW0gYmVsb3cgKilcbiAgdmFsIGNhc3RfZW5jb2RlZCA6IHN0cmluZyAtPiBlbmNvZGVkXG4gIHZhbCBjYXN0X2RlY29kZWQgOiBzdHJpbmcgLT4gZGVjb2RlZFxuICB2YWwgdW5jYXN0X2VuY29kZWQgOiBlbmNvZGVkIC0+IHN0cmluZ1xuICB2YWwgdW5jYXN0X2RlY29kZWQgOiBkZWNvZGVkIC0+IHN0cmluZ1xuICAoKiBMaWZ0IEhPRnMgZm9yIG1hcHMgb3ZlciBlbmNvZGluZ3MsIGRlY29kaW5ncywgYW5kIHN0cmluZ3MgKilcbiAgdmFsIGxpZnRfZW5jb2RlZCA6IChlbmNvZGVkIC0+IGVuY29kZWQpIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIGxpZnRfZGVjb2RlZCA6IChkZWNvZGVkIC0+IGRlY29kZWQpIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIHVubGlmdF9lbmNvZGVkIDogKHN0cmluZyAtPiBzdHJpbmcpIC0+IGVuY29kZWQgLT4gZW5jb2RlZFxuICB2YWwgdW5saWZ0X2RlY29kZWQgOiAoc3RyaW5nIC0+IHN0cmluZykgLT4gZGVjb2RlZCAtPiBkZWNvZGVkXG4gIHZhbCB1bmxpZnRfZGVjb2RlZDIgOiAoc3RyaW5nIC0+IHN0cmluZyAtPiAnYSkgLT4gZGVjb2RlZCAtPiBkZWNvZGVkIC0+ICdhXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSBlbmNvZGVkID0gc3RyaW5nXG4gIHR5cGUgZGVjb2RlZCA9IHN0cmluZ1xuICBsZXQgY2FzdF9lbmNvZGVkIHggPSB4XG4gIGxldCBjYXN0X2RlY29kZWQgeCA9IHhcbiAgbGV0IGVtcHR5X2RlY29kZWQgPSBcIlwiXG4gIGxldCB1bmNhc3RfZGVjb2RlZCB4ID0geFxuICBsZXQgdW5jYXN0X2VuY29kZWQgeCA9IHhcblxuICBsZXQgbGlmdF9lbmNvZGVkIGYgPSBmXG4gIGxldCBsaWZ0X2RlY29kZWQgZiA9IGZcbiAgbGV0IHVubGlmdF9lbmNvZGVkIGYgPSBmXG4gIGxldCB1bmxpZnRfZGVjb2RlZCBmID0gZlxuICBsZXQgdW5saWZ0X2RlY29kZWQyIGYgPSBmXG5cbiAgKCoqIFNjYW4gZm9yIHJlc2VydmVkIGNoYXJhY3RlcnMgYW5kIHJlcGxhY2UgdGhlbSB3aXRoXG4gICAgICBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHMuXG4gICAgICBAcmV0dXJuIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZyAqKVxuICBsZXQgZW5jb2RlID9zY2hlbWUgPyhjb21wb25lbnQ9YFBhdGgpIGIgPVxuICAgIGxldCBtb2R1bGUgU2NoZW1lID0gKHZhbCAobW9kdWxlX29mX3NjaGVtZSBzY2hlbWUpIDogU2NoZW1lKSBpblxuICAgIGxldCBzYWZlX2NoYXJzID0gU2NoZW1lLnNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCBjb21wb25lbnQgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBiIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBzY2FuIHN0YXJ0IGN1ciA9XG4gICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydCk7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYyA9IENoYXIuY29kZSBiLltjdXJdIGluXG4gICAgICAgIGlmIHNhZmVfY2hhcnMuKGMpIHRoZW5cbiAgICAgICAgICBzY2FuIHN0YXJ0IChjdXIrMSlcbiAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgIGlmIGN1ciA+IHN0YXJ0IHRoZW4gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydCk7XG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChQcmludGYuc3ByaW50ZiBcIiUlJTAyWFwiIGMpO1xuICAgICAgICAgIHNjYW4gKGN1cisxKSAoY3VyKzEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgaW5cbiAgICBzY2FuIDAgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbiAgbGV0IGludF9vZl9oZXhfY2hhciBjID1cbiAgICBsZXQgYyA9IGludF9vZl9jaGFyIChDaGFyLnVwcGVyY2FzZV9hc2NpaSBjKSAtIDQ4IGluXG4gICAgaWYgYyA+IDlcbiAgICB0aGVuIGlmIGMgPiAxNiAmJiBjIDwgMjNcbiAgICAgIHRoZW4gYyAtIDdcbiAgICAgIGVsc2UgZmFpbHdpdGggXCJpbnRfb2ZfaGV4X2NoYXJcIlxuICAgIGVsc2UgaWYgYyA+PSAwXG4gICAgdGhlbiBjXG4gICAgZWxzZSBmYWlsd2l0aCBcImludF9vZl9oZXhfY2hhclwiXG5cbiAgKCoqIFNjYW4gZm9yIHBlcmNlbnQtZW5jb2RpbmcgYW5kIGNvbnZlcnQgdGhlbSBpbnRvIEFTQ0lJLlxuICAgICAgQHJldHVybiBhIHBlcmNlbnQtZGVjb2RlZCBzdHJpbmcgKilcbiAgbGV0IGRlY29kZSBiID1cbiAgICAoKiBUT0RPOiBTaG91bGQgYm90aCBzdHJpY3QgYW5kIG5vbi1zdHJpY3QgdmVyc2lvbnMgYmUgZXhwb3NlZD8gKilcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBiIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBzY2FuIHN0YXJ0IGN1ciA9XG4gICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydClcbiAgICAgIGVsc2UgaWYgYi5bY3VyXSA9ICclJyB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpO1xuICAgICAgICBsZXQgY3VyID0gY3VyICsgMSBpblxuICAgICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSdcbiAgICAgICAgZWxzZSBtYXRjaCBpbnRfb2ZfaGV4X2NoYXIgYi5bY3VyXSB3aXRoXG4gICAgICAgIHwgZXhjZXB0aW9uIF8gLT5cbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICclJztcbiAgICAgICAgICBzY2FuIGN1ciBjdXJcbiAgICAgICAgfCBoaWdoYml0cyAtPiBiZWdpblxuICAgICAgICAgIGxldCBjdXIgPSBjdXIgKyAxIGluXG4gICAgICAgICAgaWYgY3VyID49IGxlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICclJztcbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgYi5bY3VyLTFdXG4gICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgIGxldCBzdGFydF9hdCA9XG4gICAgICAgICAgICAgIG1hdGNoIGludF9vZl9oZXhfY2hhciBiLltjdXJdIHdpdGhcbiAgICAgICAgICAgICAgfCBsb3diaXRzIC0+XG4gICAgICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAoQ2hhci5jaHIgKGhpZ2hiaXRzIGxzbCA0ICsgbG93Yml0cykpO1xuICAgICAgICAgICAgICAgIGN1cisxXG4gICAgICAgICAgICAgIHwgZXhjZXB0aW9uIF8gLT5cbiAgICAgICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICclJztcbiAgICAgICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGIuW2N1ci0xXTtcbiAgICAgICAgICAgICAgICBjdXJcbiAgICAgICAgICAgIGluIHNjYW4gc3RhcnRfYXQgc3RhcnRfYXRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBzY2FuIHN0YXJ0IChjdXIrMSlcbiAgICBpblxuICAgIHNjYW4gMCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbmVuZFxuXG4oKiBQZXJjZW50IGVuY29kZSBhIHN0cmluZyAqKVxubGV0IHBjdF9lbmNvZGUgP3NjaGVtZSA/KGNvbXBvbmVudD1gUGF0aCkgcyA9XG4gIFBjdC4odW5jYXN0X2VuY29kZWQgKGVuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgKGNhc3RfZGVjb2RlZCBzKSkpXG5cbmxldCBwY3RfZW5jb2RlclxuICAgICAgPyhzY2hlbWU9YFNjaGVtZSlcbiAgICAgID8odXNlcmluZm89YFVzZXJpbmZvKVxuICAgICAgPyhob3N0PWBIb3N0KVxuICAgICAgPyhwYXRoPWBQYXRoKVxuICAgICAgPyhxdWVyeV9rZXk9YFF1ZXJ5X2tleSlcbiAgICAgID8ocXVlcnlfdmFsdWU9YFF1ZXJ5X3ZhbHVlKVxuICAgICAgPyhmcmFnbWVudD1gRnJhZ21lbnQpXG4gICAgICAoKSA9XG4gIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcGF0aDsgcXVlcnlfa2V5OyBxdWVyeV92YWx1ZTsgZnJhZ21lbnQgfVxuXG4oKiBQZXJjZW50IGRlY29kZSBhIHN0cmluZyAqKVxubGV0IHBjdF9kZWNvZGUgcyA9IFBjdC4odW5jYXN0X2RlY29kZWQgKGRlY29kZSAoY2FzdF9lbmNvZGVkIHMpKSlcblxuKCogVXNlcmluZm8gc3RyaW5nIGhhbmRsaW5nLCB0byBhbmQgZnJvbSBhbiBpZCAqIGNyZWRlbnRpYWwgcGFpciAqKVxubW9kdWxlIFVzZXJpbmZvID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyAqIHN0cmluZyBvcHRpb25cblxuICBsZXQgY29tcGFyZSAodSxwKSAodScscCcpID1cbiAgICBtYXRjaCBTdHJpbmcuY29tcGFyZSB1IHUnIHdpdGhcbiAgICB8IDAgLT4gY29tcGFyZV9vcHQgU3RyaW5nLmNvbXBhcmUgcCBwJ1xuICAgIHwgYyAtPiBjXG5cbiAgbGV0IHVzZXJpbmZvX29mX2VuY29kZWQgdXMgPVxuICAgIG1hdGNoIFN0cmluZ2V4dC5zcGxpdCB+bWF4OjIgfm9uOic6JyB1cyB3aXRoXG4gICAgfCBbXSAtPiAoXCJcIixOb25lKVxuICAgIHwgW3VdIC0+IChwY3RfZGVjb2RlIHUsTm9uZSlcbiAgICB8IHU6OnA6Ol8gLT4gKHBjdF9kZWNvZGUgdSxTb21lIChwY3RfZGVjb2RlIHApKVxuXG4gIGxldCBlbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudCAodSxwbykgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcuKFxuICAgICAgMSArIChsZW5ndGggdSkgKyAobWF0Y2ggcG8gd2l0aCBOb25lIC0+IDAgfCBTb21lIHAgLT4gbGVuZ3RoIHApKVxuICAgIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCB1KTtcbiAgICBiZWdpbiBtYXRjaCBwbyB3aXRoIE5vbmUgLT4gKCk7XG4gICAgfCBTb21lIHAgLT5cbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCBwKVxuICAgIGVuZDtcbiAgICBQY3QuY2FzdF9lbmNvZGVkIChCdWZmZXIuY29udGVudHMgYnVmKVxuZW5kXG5cbmxldCB1c2VyaW5mb19vZl9lbmNvZGVkID0gVXNlcmluZm8udXNlcmluZm9fb2ZfZW5jb2RlZFxubGV0IGVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50ID0gVXNlcmluZm8uZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnRcblxuKCogUGF0aCBzdHJpbmcgaGFuZGxpbmcsIHRvIGFuZCBmcm9tIGEgbGlzdCBvZiBwYXRoIHRva2VucyAqKVxubW9kdWxlIFBhdGggPSBzdHJ1Y3RcbiAgKCogSW52YXJpYW50OiBldmVyeSBlbGVtZW50IGlzIG5vbi16ZXJvLCBzbGFzaGVzICgvKSBvbmx5IG9jY3VyIGFsb25lLiAqKVxuICAoKiBZZXMsIGl0J3MgYmV0dGVyIHRoaXMgd2F5LiBUaGlzIG1lYW5zIHlvdSBjYW4gcmV0YWluIHNlcGFyYXRvclxuICAgICBjb250ZXh0IGluIHJlY3Vyc2lvbiAoZS5nLiByZW1vdmVfZG90X3NlZ21lbnRzIGZvciByZWxhdGl2ZSByZXNvbHV0aW9uKS4gKilcblxuICB0eXBlIHQgPSBzdHJpbmcgbGlzdFxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZV9saXN0IFN0cmluZy5jb21wYXJlXG5cbiAgKCogTWFrZSBhIHBhdGggdG9rZW4gbGlzdCBmcm9tIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZyAqKVxuICBsZXQgcGF0aF9vZl9lbmNvZGVkIHBzID1cbiAgICBsZXQgdG9rbCA9IFN0cmluZ2V4dC5mdWxsX3NwbGl0IHBzIH5vbjonLycgaW5cbiAgICBMaXN0Lm1hcCBwY3RfZGVjb2RlIHRva2xcblxuICAoKiBTdWJyb3V0aW5lIGZvciByZXNvbHZlIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yLjQ+ICopXG4gIGxldCByZW1vdmVfZG90X3NlZ21lbnRzIHAgPVxuICAgIGxldCByZXZwID0gTGlzdC5yZXYgcCBpblxuICAgIGxldCByZWMgbG9vcCBhc2NlbnNpb24gb3V0cCA9IGZ1bmN0aW9uXG4gICAgICB8IFwiL1wiOjpcIi4uXCI6OnIgfCBcIi4uXCI6OnIgLT4gbG9vcCAoYXNjZW5zaW9uICsgMSkgb3V0cCByXG4gICAgICB8IFwiL1wiOjpcIi5cIjo6ciAgfCBcIi5cIjo6ciAgLT4gbG9vcCBhc2NlbnNpb24gb3V0cCByXG4gICAgICB8IFwiL1wiOjpbXSB8IFtdIHdoZW4gTGlzdC4obGVuZ3RoIHAgPiAwICYmIGhkIHAgPSBcIi9cIikgLT4gXCIvXCI6Om91dHBcbiAgICAgIHwgW10gd2hlbiBhc2NlbnNpb24gPiAwIC0+IExpc3QucmV2X2FwcGVuZFxuICAgICAgICAoXCIvXCI6OihyZXZfaW50ZXJqZWN0IFwiL1wiIEFycmF5Lih0b19saXN0IChtYWtlIGFzY2Vuc2lvbiBcIi4uXCIpKSkpIG91dHBcbiAgICAgIHwgW10gLT4gTGlzdC4oaWYgbGVuZ3RoIG91dHAgPiAwICYmIGhkIG91dHAgPSBcIi9cIiB0aGVuIHRsIG91dHAgZWxzZSBvdXRwKVxuICAgICAgfCBcIi9cIjo6XCIvXCI6OnIgd2hlbiBhc2NlbnNpb24gPiAwIC0+IGxvb3AgKGFzY2Vuc2lvbiAtIDEpIG91dHAgKFwiL1wiOjpyKVxuICAgICAgfCBcIi9cIjo6Xzo6ciB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gbG9vcCAoYXNjZW5zaW9uIC0gMSkgb3V0cCByXG4gICAgICB8IHM6OnIgLT4gbG9vcCAwIChzOjpvdXRwKSByXG4gICAgaW4gbG9vcCAwIFtdIHJldnBcblxuICBsZXQgZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudCBwID1cbiAgICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBjIHRvayAtPiBTdHJpbmcubGVuZ3RoIHRvayArIGMpIDAgcCBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGl0ZXJfY29uY2F0IChmdW4gYnVmIC0+IGZ1bmN0aW9uXG4gICAgfCBcIi9cIiAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcvJ1xuICAgIHwgc2VnIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgc2VnKVxuICAgICkgXCJcIiBidWYgcDtcbiAgICBQY3QuY2FzdF9lbmNvZGVkIChCdWZmZXIuY29udGVudHMgYnVmKVxuXG4gICgqIFN1YnJvdXRpbmUgZm9yIHJlc29sdmUgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuMz4gKilcbiAgbGV0IG1lcmdlIGJob3N0IGJwYXRoIHJlbHBhdGggPVxuICAgIG1hdGNoIGJob3N0LCBMaXN0LnJldiBicGF0aCB3aXRoXG4gICAgfCBTb21lIF8sIFtdIC0+IFwiL1wiOjpyZWxwYXRoXG4gICAgfCBfLCAoXCIvXCI6OnJicGF0aCB8IF86OlwiL1wiOjpyYnBhdGgpIC0+IExpc3QucmV2X2FwcGVuZCAoXCIvXCI6OnJicGF0aCkgcmVscGF0aFxuICAgIHwgXywgXyAtPiByZWxwYXRoXG5lbmRcblxubGV0IHBhdGhfb2ZfZW5jb2RlZCA9IFBhdGgucGF0aF9vZl9lbmNvZGVkXG5sZXQgZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudCA9IFBhdGguZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudFxuXG4oKiBRdWVyeSBzdHJpbmcgaGFuZGxpbmcsIHRvIGFuZCBmcm9tIGFuIGFzc29jIGxpc3Qgb2Yga2V5L3ZhbHVlcyAqKVxubW9kdWxlIFF1ZXJ5ID0gc3RydWN0XG5cbiAgdHlwZSBrdiA9IChzdHJpbmcgKiBzdHJpbmcgbGlzdCkgbGlzdFxuXG4gIHR5cGUgdCA9XG4gICAgfCBLViBvZiBrdlxuICAgIHwgUmF3IG9mIHN0cmluZyBvcHRpb24gKiBrdiBMYXp5LnRcblxuICBsZXQgY29tcGFyZSB4IHkgPSBtYXRjaCB4LCB5IHdpdGhcbiAgICB8IEtWIGt2bCwgS1Yga3ZsJ1xuICAgIHwgUmF3IChfLCBsYXp5IGt2bCksIEtWIGt2bCdcbiAgICB8IEtWIGt2bCwgUmF3IChfLCBsYXp5IGt2bCcpIC0+XG4gICAgICBjb21wYXJlX2xpc3QgKGZ1biAoayx2bCkgKGsnLHZsJykgLT5cbiAgICAgICAgbWF0Y2ggU3RyaW5nLmNvbXBhcmUgayBrJyB3aXRoXG4gICAgICAgIHwgMCAtPiBjb21wYXJlX2xpc3QgU3RyaW5nLmNvbXBhcmUgdmwgdmwnXG4gICAgICAgIHwgYyAtPiBjXG4gICAgICApIGt2bCBrdmwnXG4gICAgfCBSYXcgKHJhdyxfKSwgUmF3IChyYXcnLF8pIC0+IGNvbXBhcmVfb3B0IFN0cmluZy5jb21wYXJlIHJhdyByYXcnXG5cbiAgbGV0IGZpbmQgcSBrID0gdHJ5IFNvbWUgKExpc3QuYXNzb2MgayBxKSB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG5cbiAgbGV0IHNwbGl0X3F1ZXJ5IHFzID1cbiAgICBsZXQgZWxzID0gU3RyaW5nZXh0LnNwbGl0IH5vbjonJicgcXMgaW5cbiAgICAoKiBSZXBsYWNlIGEgKyBpbiBhIHF1ZXJ5IHN0cmluZyB3aXRoIGEgc3BhY2UgaW4tcGxhY2UgKilcbiAgICBsZXQgcGx1c190b19zcGFjZSBzID1cbiAgICAgIGxldCBzID0gQnl0ZXMudW5zYWZlX29mX3N0cmluZyBzIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQnl0ZXMubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIGlmIEJ5dGVzLmdldCBzIGkgPSAnKycgdGhlbiBCeXRlcy5zZXQgcyBpICcgJ1xuICAgICAgZG9uZTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgc1xuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IChrOjp2OjpfKTo6dGwgLT5cbiAgICAgICAgbGV0IG4gPSBwbHVzX3RvX3NwYWNlIGssXG4gICAgICAgICAgICAgICAgKG1hdGNoIFN0cmluZ2V4dC5zcGxpdCB+b246JywnIChwbHVzX3RvX3NwYWNlIHYpIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBbXSAtPiBbXCJcIl0gfCBsIC0+IGwpIGluXG4gICAgICAgIGxvb3AgKG46OmFjYykgdGxcbiAgICAgIHwgW2tdOjp0bCAtPlxuICAgICAgICBsZXQgbiA9IHBsdXNfdG9fc3BhY2UgaywgW10gaW5cbiAgICAgICAgbG9vcCAobjo6YWNjKSB0bFxuICAgICAgfCBbXTo6dGwgLT4gbG9vcCAoKFwiXCIsIFtdKTo6YWNjKSB0bFxuICAgICAgfCBbXSAtPiBhY2NcbiAgICBpblxuICAgIG1hdGNoIGVscyB3aXRoXG4gICAgfCBbXSAgLT4gW1wiXCIsW11dXG4gICAgfCBlbHMgLT4gbG9vcCBbXVxuICAgICAgKExpc3QucmV2X21hcCAoZnVuIGVsIC0+IFN0cmluZ2V4dC5zcGxpdCB+b246Jz0nIGVsIH5tYXg6MikgZWxzKVxuXG4gICgqIE1ha2UgYSBxdWVyeSB0dXBsZSBsaXN0IGZyb20gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBxdWVyeV9vZl9lbmNvZGVkIHFzID1cbiAgICBMaXN0Lm1hcFxuICAgICAgKGZ1biAoaywgdikgLT4gKHBjdF9kZWNvZGUgaywgTGlzdC5tYXAgcGN0X2RlY29kZSB2KSlcbiAgICAgIChzcGxpdF9xdWVyeSBxcylcblxuICAoKiBBc3NlbWJsZSBhIHF1ZXJ5IHN0cmluZyBzdWl0YWJsZSBmb3IgcHV0dGluZyBpbnRvIGEgVVJJLlxuICAgKiBUdXBsZSBpbnB1dHMgYXJlIHBlcmNlbnQgZGVjb2RlZCBhbmQgd2lsbCBiZSBlbmNvZGVkIGJ5XG4gICAqIHRoaXMgZnVuY3Rpb24uXG4gICopXG4gIGxldCBlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgbCA9XG4gICAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYSAoayx2KSAtPlxuICAgICAgICBhICsgKFN0cmluZy5sZW5ndGggaylcbiAgICAgICAgKyAoTGlzdC5mb2xkX2xlZnQgKGZ1biBhIHMgLT4gYSsoU3RyaW5nLmxlbmd0aCBzKSsxKSAwIHYpICsgMikgKC0xKSBsIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgaXRlcl9jb25jYXQgKGZ1biBidWYgKGssdikgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5xdWVyeV9rZXkgayk7XG4gICAgICAgIGlmIHYgPD4gW10gdGhlbiAoXG4gICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnPSc7XG4gICAgICAgICAgaXRlcl9jb25jYXQgKGZ1biBidWYgcyAtPlxuICAgICAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWZcbiAgICAgICAgICAgICAgICAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucXVlcnlfdmFsdWUgcylcbiAgICAgICAgICAgICkgXCIsXCIgYnVmIHYpXG4gICAgICApIFwiJlwiIGJ1ZiBsO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcblxuICBsZXQgb2ZfcmF3IHFzID1cbiAgICBsZXQgbGF6eV9xdWVyeSA9IExhenkuZnJvbV9mdW4gKGZ1biAoKSAtPiBxdWVyeV9vZl9lbmNvZGVkIHFzKSBpblxuICAgIFJhdyAoU29tZSBxcywgbGF6eV9xdWVyeSlcblxuICBsZXQga3YgPSBmdW5jdGlvbiBSYXcgKF8sIGxhenkga3YpIHwgS1Yga3YgLT4ga3ZcbmVuZFxuXG5sZXQgcXVlcnlfb2ZfZW5jb2RlZCA9IFF1ZXJ5LnF1ZXJ5X29mX2VuY29kZWRcbmxldCBlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgPSBRdWVyeS5lbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWVcblxuKCogVHlwZSBvZiB0aGUgVVJJLCB3aXRoIG1vc3QgYml0cyBiZWluZyBvcHRpb25hbCAqKVxudHlwZSB0ID0ge1xuICBzY2hlbWU6IFBjdC5kZWNvZGVkIG9wdGlvbjtcbiAgdXNlcmluZm86IFVzZXJpbmZvLnQgb3B0aW9uO1xuICBob3N0OiBbIGBJcHY0X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgIHwgYElwdjZfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgfCBgSG9zdCBvZiBQY3QuZGVjb2RlZF0gb3B0aW9uIDtcbiAgcG9ydDogaW50IG9wdGlvbjtcbiAgcGF0aDogUGF0aC50O1xuICBxdWVyeTogUXVlcnkudDtcbiAgZnJhZ21lbnQ6IFBjdC5kZWNvZGVkIG9wdGlvbjtcbn1cblxubGV0IGVtcHR5ID0ge1xuICBzY2hlbWUgPSBOb25lO1xuICB1c2VyaW5mbyA9IE5vbmU7XG4gIGhvc3QgPSBOb25lO1xuICBwb3J0ID0gTm9uZTtcbiAgcGF0aCA9IFtdO1xuICBxdWVyeSA9IFF1ZXJ5LlJhdyAoTm9uZSwgTGF6eS5mcm9tX3ZhbCBbXSk7XG4gIGZyYWdtZW50ID0gTm9uZTtcbn1cblxubGV0IGNvbXBhcmVfZGVjb2RlZCA9IFBjdC51bmxpZnRfZGVjb2RlZDIgU3RyaW5nLmNvbXBhcmVcbmxldCBjb21wYXJlX2RlY29kZWRfb3B0ID0gY29tcGFyZV9vcHQgY29tcGFyZV9kZWNvZGVkXG5sZXQgY29tcGFyZV9ob3N0IGgxIGgyID1cbiAgbWF0Y2ggaDEsIGgyIHdpdGhcbiAgfCBgSXB2NF9saXRlcmFsIGlwMSwgYElwdjRfbGl0ZXJhbCBpcDIgLT4gU3RyaW5nLmNvbXBhcmUgaXAxIGlwMlxuICB8IGBJcHY2X2xpdGVyYWwgaXAxLCBgSXB2Nl9saXRlcmFsIGlwMiAtPiBTdHJpbmcuY29tcGFyZSBpcDEgaXAyXG4gIHwgYEhvc3QgaDEsIGBIb3N0IGgyIC0+IGNvbXBhcmVfZGVjb2RlZCBoMSBoMlxuICB8IF8gLT4gLTFcbmxldCBjb21wYXJlX2hvc3Rfb3B0ID0gY29tcGFyZV9vcHQgY29tcGFyZV9ob3N0XG5cbmxldCBjb21wYXJlIHQgdCcgPVxuICAobWF0Y2ggY29tcGFyZV9ob3N0X29wdCB0Lmhvc3QgdCcuaG9zdCB3aXRoXG4gIHwgMCAtPiAobWF0Y2ggY29tcGFyZV9kZWNvZGVkX29wdCB0LnNjaGVtZSB0Jy5zY2hlbWUgd2l0aFxuICAgIHwgMCAtPiAobWF0Y2ggY29tcGFyZV9vcHQgKGZ1biBwIHAnIC0+XG4gICAgICBpZiBwIDwgcCcgdGhlbiAtMSBlbHNlIGlmIHAgPiBwJyB0aGVuIDEgZWxzZSAwXG4gICAgKSB0LnBvcnQgdCcucG9ydCB3aXRoXG4gICAgICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfb3B0IFVzZXJpbmZvLmNvbXBhcmUgdC51c2VyaW5mbyB0Jy51c2VyaW5mbyB3aXRoXG4gICAgICAgIHwgMCAtPiAobWF0Y2ggUGF0aC5jb21wYXJlIHQucGF0aCB0Jy5wYXRoIHdpdGhcbiAgICAgICAgICB8IDAgLT4gKG1hdGNoIFF1ZXJ5LmNvbXBhcmUgdC5xdWVyeSB0Jy5xdWVyeSB3aXRoXG4gICAgICAgICAgICB8IDAgLT4gY29tcGFyZV9kZWNvZGVkX29wdCB0LmZyYWdtZW50IHQnLmZyYWdtZW50XG4gICAgICAgICAgICB8IGMgLT4gYylcbiAgICAgICAgICB8IGMgLT4gYylcbiAgICAgICAgfCBjIC0+IGMpXG4gICAgICB8IGMgLT4gYylcbiAgICB8IGMgLT4gYylcbiAgfCBjIC0+IGMpXG5cbmxldCBlcXVhbCB0IHQnID0gY29tcGFyZSB0IHQnID0gMFxuXG5sZXQgdW5jYXN0X29wdCA9IGZ1bmN0aW9uXG4gIHwgU29tZSBoIC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCBoKVxuICB8IE5vbmUgLT4gTm9uZVxuXG5sZXQgbm9ybWFsaXplIHNjaGVtIHVyaSA9XG4gIGxldCBtb2R1bGUgU2NoZW1lID1cbiAgICAodmFsIChtb2R1bGVfb2Zfc2NoZW1lICh1bmNhc3Rfb3B0IHNjaGVtKSkgOiBTY2hlbWUpIGluXG4gIGxldCBkb2IgZiA9IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT4gU29tZSAoUGN0LnVubGlmdF9kZWNvZGVkIGYgeClcbiAgICB8IE5vbmUgLT4gTm9uZVxuICBpbiB7dXJpIHdpdGhcbiAgICAgIHNjaGVtZT1kb2IgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSB1cmkuc2NoZW1lO1xuICAgICAgaG9zdD0gbWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICAgICAgIHwgU29tZSAoYElwdjRfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgU29tZSAoYElwdjRfbGl0ZXJhbCAoU2NoZW1lLm5vcm1hbGl6ZV9ob3N0IGhvc3QpKVxuICAgICAgIHwgU29tZSAoYElwdjZfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgU29tZSAoYElwdjZfbGl0ZXJhbCAoU2NoZW1lLm5vcm1hbGl6ZV9ob3N0IGhvc3QpKVxuICAgICAgIHwgU29tZSAoYEhvc3QgaG9zdCkgLT5cbiAgICAgICAgIFNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIChTY2hlbWUubm9ybWFsaXplX2hvc3QgKFBjdC51bmNhc3RfZGVjb2RlZCBob3N0KSkpKVxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgIH1cblxuKCoqIENvbnZlcnQgYSBVUkkgc3RydWN0dXJlIGludG8gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nXG4gICAgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjM+XG4qKVxubGV0IHRvX3N0cmluZyA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPVxuICBsZXQgc2NoZW1lID0gbWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIHMpXG4gICAgfCBOb25lIC0+IE5vbmUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTI4IGluXG4gICgqIFBlcmNlbnQgZW5jb2RlIGEgZGVjb2RlZCBzdHJpbmcgYW5kIGFkZCBpdCB0byB0aGUgYnVmZmVyICopXG4gIGxldCBhZGRfcGN0X3N0cmluZyA/KGNvbXBvbmVudD1gUGF0aCkgeCA9XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChQY3QudW5jYXN0X2VuY29kZWQgKFBjdC5lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHgpKVxuICBpblxuICAobWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gICB8Tm9uZSAtPiAoKVxuICAgfFNvbWUgeCAtPlxuICAgICBhZGRfcGN0X3N0cmluZyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnNjaGVtZSB4O1xuICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc6J1xuICApO1xuICAoKiBVUkkgaGFzIGEgaG9zdCBpZiBhbnkgaG9zdC1yZWxhdGVkIGNvbXBvbmVudCBpcyBzZXQuIERlZmF1bHRzIHRvIFwiXCIuICopXG4gIGlmIChtYXRjaCB1cmkudXNlcmluZm8sIHVyaS5ob3N0LCB1cmkucG9ydCB3aXRoXG4gIHwgU29tZSBfLCBfLCBfIHwgXywgU29tZSBfLCBfIHwgXywgXywgU29tZSBfIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICB0aGVuIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIi8vXCI7XG4gIChtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8Tm9uZSAtPiAoKVxuICB8U29tZSB1c2VyaW5mbyAtPlxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZlxuICAgICAgKFBjdC51bmNhc3RfZW5jb2RlZCAoZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIudXNlcmluZm8gdXNlcmluZm8pKTtcbiAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdAJ1xuICApO1xuICAobWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICB8Tm9uZSAtPiAoKVxuICB8U29tZSAoYEhvc3QgaG9zdCkgLT5cbiAgICBhZGRfcGN0X3N0cmluZyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLmhvc3QgaG9zdDtcbiAgfFNvbWUgKGBJcHY0X2xpdGVyYWwgaG9zdCkgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIGhvc3RcbiAgfFNvbWUgKGBJcHY2X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1snO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIGhvc3Q7XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICddJ1xuICApO1xuICAobWF0Y2ggdXJpLnBvcnQgd2l0aFxuICB8Tm9uZSAtPiAoKVxuICB8U29tZSBwb3J0IC0+XG4gICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnOic7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IHBvcnQpXG4gICk7XG4gIChtYXRjaCB1cmkucGF0aCB3aXRoICgqIEhhbmRsZSByZWxhdGl2ZSBwYXRocyBjb3JyZWN0bHkgKilcbiAgfCBbXSAtPiAoKVxuICB8IFwiL1wiOjpfIC0+XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChQY3QudW5jYXN0X2VuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpKVxuICB8IGZpcnN0X3NlZ21lbnQ6Ol8gLT5cbiAgICAobWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICAgICB8IFNvbWUgXyAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcvJ1xuICAgICB8IE5vbmUgLT5cbiAgICAgICAoKiBlbnN1cmUgcm91bmR0cmlwIGJ5IGZvcmNpbmcgcmVsYXRpdmUgcGF0aCBpbnRlcnByZXRhdGlvbiBub3Qgc2NoZW1lICopXG4gICAgICAgbWF0Y2ggU3RyaW5nZXh0LmZpbmRfZnJvbSBmaXJzdF9zZWdtZW50IH5wYXR0ZXJuOlwiOlwiIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICB8IFNvbWUgXyAtPiBtYXRjaCBzY2hlbWUgd2l0aFxuICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgIHwgTm9uZSAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIuL1wiXG4gICAgKTtcbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWZcbiAgICAgIChQY3QudW5jYXN0X2VuY29kZWQgKGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aCkpXG4gICk7XG4gIFF1ZXJ5LihtYXRjaCB1cmkucXVlcnkgd2l0aFxuICAgIHwgUmF3IChOb25lLF8pIHwgS1YgW10gLT4gKClcbiAgICB8IFJhdyAoXyxsYXp5IHEpIHwgS1YgcSAtPiAoKiBub3JtYWxpemUgZS5nLiBwZXJjZW50IGNhcGl0YWxpemF0aW9uICopXG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lIH5wY3RfZW5jb2RlciBxKVxuICApO1xuICAobWF0Y2ggdXJpLmZyYWdtZW50IHdpdGhcbiAgIHxOb25lIC0+ICgpXG4gICB8U29tZSBmIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJyMnOyBhZGRfcGN0X3N0cmluZyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLmZyYWdtZW50IGZcbiAgKTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG4oKiBWYXJpb3VzIGFjY2Vzc29yIGZ1bmN0aW9ucywgYXMgdGhlIGV4dGVybmFsIHVyaSB0eXBlIGlzIGFic3RyYWN0ICAqKVxubGV0IGdldF9kZWNvZGVkX29wdCA9IGZ1bmN0aW9uIE5vbmUgLT4gTm9uZSB8U29tZSB4IC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCB4KVxubGV0IHNjaGVtZSB1cmkgPSBnZXRfZGVjb2RlZF9vcHQgdXJpLnNjaGVtZVxubGV0IHdpdGhfc2NoZW1lIHVyaSA9XG4gIGZ1bmN0aW9uXG4gIHxTb21lIHNjaGVtZSAtPiB7IHVyaSB3aXRoIHNjaGVtZT1Tb21lIChQY3QuY2FzdF9kZWNvZGVkIHNjaGVtZSkgfVxuICB8Tm9uZSAtPiB7IHVyaSB3aXRoIHNjaGVtZT1Ob25lIH1cblxubGV0IGhvc3QgdXJpID1cbiAgbWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGBJcHY0X2xpdGVyYWwgaCB8IGBJcHY2X2xpdGVyYWwgaCkgLT4gU29tZSBoXG4gIHwgU29tZSAoYEhvc3QgaCkgLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIGgpXG5cbmxldCBob3N0X3dpdGhfZGVmYXVsdCA/KGRlZmF1bHQ9XCJsb2NhbGhvc3RcIikgdXJpID1cbiAgbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICB8Tm9uZSAtPiBkZWZhdWx0XG4gIHxTb21lIGggLT4gaFxuXG5sZXQgdXNlcmluZm8gPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID0gbWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHVzZXJpbmZvIC0+IFNvbWUgKFBjdC51bmNhc3RfZW5jb2RlZCAobWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gICAgfCBOb25lIC0+IGVuY29kZWRfb2ZfdXNlcmluZm8gfmNvbXBvbmVudDpwY3RfZW5jb2Rlci51c2VyaW5mbyB1c2VyaW5mb1xuICAgIHwgU29tZSBzIC0+IGVuY29kZWRfb2ZfdXNlcmluZm8gfnNjaGVtZTooUGN0LnVuY2FzdF9kZWNvZGVkIHMpIH5jb21wb25lbnQ6cGN0X2VuY29kZXIudXNlcmluZm8gdXNlcmluZm8pKVxubGV0IHdpdGhfdXNlcmluZm8gdXJpIHVzZXJpbmZvID1cbiAgbGV0IHVzZXJpbmZvID0gbWF0Y2ggdXNlcmluZm8gd2l0aFxuICAgIHwgU29tZSB1IC0+IFNvbWUgKHVzZXJpbmZvX29mX2VuY29kZWQgdSlcbiAgICB8IE5vbmUgLT4gTm9uZVxuICBpblxuICBtYXRjaCBob3N0IHVyaSB3aXRoXG4gIHwgTm9uZSAtPiB7IHVyaSB3aXRoIGhvc3Q9U29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgXCJcIikpOyB1c2VyaW5mbz11c2VyaW5mbyB9XG4gIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggdXNlcmluZm89dXNlcmluZm8gfVxuXG5sZXQgdXNlciB1cmkgPSBtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKHVzZXIsIF8pIC0+IFNvbWUgdXNlclxuXG5sZXQgcGFzc3dvcmQgdXJpID0gbWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfCBOb25lIHwgU29tZSAoXywgTm9uZSkgLT4gTm9uZVxuICB8IFNvbWUgKF8sIFNvbWUgcGFzcykgLT4gU29tZSBwYXNzXG5sZXQgd2l0aF9wYXNzd29yZCB1cmkgcGFzc3dvcmQgPVxuICBsZXQgcmVzdWx0IHVzZXJpbmZvID0gbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICAgIHwgTm9uZSAtPiB7IHVyaSB3aXRoIGhvc3Q9U29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgXCJcIikpOyB1c2VyaW5mbz11c2VyaW5mbyB9XG4gICAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCB1c2VyaW5mbz11c2VyaW5mbyB9XG4gIGluXG4gIG1hdGNoIHVyaS51c2VyaW5mbywgcGFzc3dvcmQgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gdXJpXG4gIHwgTm9uZSwgU29tZSBfIC0+IHJlc3VsdCAoU29tZSAoXCJcIixwYXNzd29yZCkpXG4gIHwgU29tZSAodXNlcixfKSwgXyAtPiByZXN1bHQgKFNvbWUgKHVzZXIsIHBhc3N3b3JkKSlcblxubGV0IHBvcnQgdXJpID0gdXJpLnBvcnRcbmxldCB3aXRoX3BvcnQgdXJpIHBvcnQgPVxuICBtYXRjaCBob3N0IHVyaSB3aXRoXG4gIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggcG9ydD1wb3J0IH1cbiAgfCBOb25lIC0+IGJlZ2luXG4gICAgIG1hdGNoIHBvcnQgd2l0aFxuICAgICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PU5vbmU7IHBvcnQ9Tm9uZSB9XG4gICAgIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBcIlwiKSk7IHBvcnQ9cG9ydCB9XG4gIGVuZFxuXG4oKiBSZXR1cm4gdGhlIHBhdGggY29tcG9uZW50ICopXG5sZXQgcGF0aCA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPSBQY3QudW5jYXN0X2VuY29kZWQgKG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICB8IE5vbmUgLT4gZW5jb2RlZF9vZl9wYXRoIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aFxuICB8IFNvbWUgcyAtPiBlbmNvZGVkX29mX3BhdGggfnNjaGVtZTooUGN0LnVuY2FzdF9kZWNvZGVkIHMpIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aClcbmxldCB3aXRoX3BhdGggdXJpIHBhdGggPVxuICBsZXQgcGF0aCA9IHBhdGhfb2ZfZW5jb2RlZCBwYXRoIGluXG4gIG1hdGNoIGhvc3QgdXJpLCBwYXRoIHdpdGhcbiAgfCBOb25lLCBfIHwgU29tZSBfLCBcIi9cIjo6XyB8IFNvbWUgXywgW10gLT4geyB1cmkgd2l0aCBwYXRoPXBhdGggfVxuICB8IFNvbWUgXywgXyAgLT4geyB1cmkgd2l0aCBwYXRoPVwiL1wiOjpwYXRoIH1cblxubGV0IGZyYWdtZW50IHVyaSA9IGdldF9kZWNvZGVkX29wdCB1cmkuZnJhZ21lbnRcbmxldCB3aXRoX2ZyYWdtZW50IHVyaSA9XG4gIGZ1bmN0aW9uXG4gIHxOb25lIC0+IHsgdXJpIHdpdGggZnJhZ21lbnQ9Tm9uZSB9XG4gIHxTb21lIGZyYWcgLT4geyB1cmkgd2l0aCBmcmFnbWVudD1Tb21lIChQY3QuY2FzdF9kZWNvZGVkIGZyYWcpIH1cblxubGV0IHF1ZXJ5IHVyaSA9IFF1ZXJ5Lmt2IHVyaS5xdWVyeVxubGV0IHZlcmJhdGltX3F1ZXJ5ID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9IFF1ZXJ5LihtYXRjaCB1cmkucXVlcnkgd2l0aFxuICB8IFJhdyAocXMsXykgLT4gcXNcbiAgfCBLViBbXSAtPiBOb25lXG4gIHwgS1Yga3YgLT4gU29tZSAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lOihzY2hlbWUgdXJpKSB+cGN0X2VuY29kZXIga3YpXG4pXG5sZXQgZ2V0X3F1ZXJ5X3BhcmFtJyB1cmkgayA9IFF1ZXJ5LihmaW5kIChrdiB1cmkucXVlcnkpIGspXG5sZXQgZ2V0X3F1ZXJ5X3BhcmFtIHVyaSBrID1cbiAgbWF0Y2ggZ2V0X3F1ZXJ5X3BhcmFtJyB1cmkgayB3aXRoXG4gIHxOb25lIC0+IE5vbmVcbiAgfFNvbWUgdiAtPiBTb21lIChTdHJpbmcuY29uY2F0IFwiLFwiIHYpXG5cbmxldCB3aXRoX3F1ZXJ5IHVyaSBxdWVyeSA9IHsgdXJpIHdpdGggcXVlcnk9UXVlcnkuS1YgcXVlcnkgfVxubGV0IHFfcyBxID0gTGlzdC5tYXAgKGZ1biAoayx2KSAtPiBrLFt2XSkgcVxubGV0IHdpdGhfcXVlcnknIHVyaSBxdWVyeSA9IHdpdGhfcXVlcnkgdXJpIChxX3MgcXVlcnkpXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtIHVyaSBwID0gUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKHA6OihrdiB1cmkucXVlcnkpKSB9KVxubGV0IGFkZF9xdWVyeV9wYXJhbScgdXJpIChrLHYpID1cbiAgUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKChrLFt2XSk6OihrdiB1cmkucXVlcnkpKSB9KVxubGV0IGFkZF9xdWVyeV9wYXJhbXMgdXJpIHBzID0gUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKHBzQChrdiB1cmkucXVlcnkpKSB9KVxubGV0IGFkZF9xdWVyeV9wYXJhbXMnIHVyaSBwcyA9XG4gIFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWICgocV9zIHBzKUAoa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCByZW1vdmVfcXVlcnlfcGFyYW0gdXJpIGsgPSBRdWVyeS4oXG4gIHsgdXJpIHdpdGggcXVlcnk9S1YgKExpc3QuZmlsdGVyIChmdW4gKGsnLF8pIC0+IGs8PmsnKSAoa3YgdXJpLnF1ZXJ5KSkgfVxuKVxuXG4oKiBDb25zdHJ1Y3QgZW5jb2RlZCBwYXRoIGFuZCBxdWVyeSBjb21wb25lbnRzICopXG5sZXQgcGF0aF9hbmRfcXVlcnkgdXJpID1cbiAgbWF0Y2ggKHBhdGggdXJpKSwgKHF1ZXJ5IHVyaSkgd2l0aFxuICB8XCJcIiwgW10gLT4gXCIvXCIgKCogVE9ETzogV2hhdCBhYm91dCBzYW1lIGRvY3VtZW50PyAoLykgKilcbiAgfFwiXCIsIHEgLT4gKCogVE9ETzogV2hhdCBhYm91dCBzYW1lIGRvY3VtZW50PyAoLykgKilcbiAgICBsZXQgc2NoZW1lID0gdW5jYXN0X29wdCB1cmkuc2NoZW1lIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIvPyVzXCIgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSBxKVxuICB8cCwgW10gLT4gcFxuICB8cCwgcSAtPlxuICAgIGxldCBzY2hlbWUgPSB1bmNhc3Rfb3B0IHVyaS5zY2hlbWUgaW5cbiAgICBQcmludGYuc3ByaW50ZiBcIiVzPyVzXCIgcCAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lIHEpXG5cbigqIFRPRE86IGZ1bmN0aW9ucyB0byBhZGQgYW5kIHJlbW92ZSBmcm9tIGEgVVJJICopXG5cbigqIFJlc29sdmUgYSBVUkkgd3J0IGEgYmFzZSBVUkkgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjI+ICopXG5sZXQgcmVzb2x2ZSBzY2hlbSBiYXNlIHVyaSA9XG4gIGxldCBzY2hlbSA9IFNvbWUgKFBjdC5jYXN0X2RlY29kZWQgKG1hdGNoIHNjaGVtZSBiYXNlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAgc2NoZW1cbiAgICAgIHwgU29tZSBzY2hlbWUgLT4gc2NoZW1lXG4gICAgKSkgaW5cbiAgbm9ybWFsaXplIHNjaGVtXG4gICAgUGF0aC4obWF0Y2ggc2NoZW1lIHVyaSwgdXNlcmluZm8gdXJpLCBob3N0IHVyaSB3aXRoXG4gICAgfCBTb21lIF8sIF8sIF8gLT5cbiAgICAgIHt1cmkgd2l0aCBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgdXJpLnBhdGh9XG4gICAgfCBOb25lLCBTb21lIF8sIF9cbiAgICB8IE5vbmUsIF8sIFNvbWUgXyAtPlxuICAgICAge3VyaSB3aXRoIHNjaGVtZT1iYXNlLnNjaGVtZTsgcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIHVyaS5wYXRofVxuICAgIHwgTm9uZSwgTm9uZSwgTm9uZSAtPlxuICAgICAgbGV0IHVyaSA9IHt1cmkgd2l0aCBzY2hlbWU9YmFzZS5zY2hlbWU7IHVzZXJpbmZvPWJhc2UudXNlcmluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q9YmFzZS5ob3N0OyBwb3J0PWJhc2UucG9ydH0gaW5cbiAgICAgIGxldCBwYXRoX3N0ciA9IHBhdGggdXJpIGluXG4gICAgICBpZiBwYXRoX3N0cj1cIlwiXG4gICAgICB0aGVuIHsgdXJpIHdpdGhcbiAgICAgICAgICAgICBwYXRoPWJhc2UucGF0aDtcbiAgICAgICAgICAgICBxdWVyeT1tYXRjaCB1cmkucXVlcnkgd2l0aFxuICAgICAgICAgICAgICAgfCBRdWVyeS5SYXcgKE5vbmUsXykgfCBRdWVyeS5LViBbXSAtPiBiYXNlLnF1ZXJ5XG4gICAgICAgICAgICAgICB8IF8gLT4gdXJpLnF1ZXJ5XG4gICAgICAgICAgIH1cbiAgICAgIGVsc2UgaWYgcGF0aF9zdHIuWzBdPScvJ1xuICAgICAgdGhlbiB7dXJpIHdpdGggcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIHVyaS5wYXRofVxuICAgICAgZWxzZSB7dXJpIHdpdGhcbiAgICAgICAgcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIChtZXJnZSBiYXNlLmhvc3QgYmFzZS5wYXRoIHVyaS5wYXRoKTtcbiAgICAgIH1cbiAgICApXG5cbmxldCBjYW5vbmljYWxpemUgdXJpID1cbiAgbGV0IHVyaSA9IHJlc29sdmUgXCJcIiBlbXB0eSB1cmkgaW5cbiAgbGV0IG1vZHVsZSBTY2hlbWUgPVxuICAgICh2YWwgKG1vZHVsZV9vZl9zY2hlbWUgKHVuY2FzdF9vcHQgdXJpLnNjaGVtZSkpIDogU2NoZW1lKSBpblxuICB7IHVyaSB3aXRoXG4gICAgcG9ydD1TY2hlbWUuY2Fub25pY2FsaXplX3BvcnQgdXJpLnBvcnQ7XG4gICAgcGF0aD1TY2hlbWUuY2Fub25pY2FsaXplX3BhdGggdXJpLnBhdGg7XG4gIH1cblxubGV0IHBwIHBwZiB1cmkgPSBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nIHVyaSlcbmxldCBwcF9odW0gcHBmIHVyaSA9IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmcgdXJpKVxuXG5tb2R1bGUgUGFyc2VyID0gc3RydWN0XG4gIG9wZW4gQW5nc3Ryb21cblxuICBsZXQgc3RyaW5nX29mX2NoYXIgPSBTdHJpbmcubWFrZSAxXG5cbiAgbGV0IHN0cmluZ19vZl9jaGFyX2xpc3QgY2hhcnMgPVxuICAgIFN0cmluZy5jb25jYXQgXCJcIiAoTGlzdC5tYXAgc3RyaW5nX29mX2NoYXIgY2hhcnMpXG5cbiAgbGV0IHNjaGVtZSA9XG4gICAgbGlmdFxuICAgICAgKGZ1biBzIC0+IFNvbWUgKFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcykpKVxuICAgICAgKHRha2Vfd2hpbGUgKGZ1biBjIC0+IGMgPD4gJzonICYmIGMgPD4gJy8nICYmIGMgPD4gJz8nICYmIGMgPD4gJyMnKVxuICAgICAgPCogY2hhciAnOicpXG4gICAgPHw+IHJldHVybiBOb25lXG5cbiAgbGV0IGlzX2RpZ2l0ID0gZnVuY3Rpb24gJzAnIC4uICc5JyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gIGxldCBoZXhfZGlnaXQgPVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgaGV4YWRlY2ltYWwgPSBsaWZ0IHN0cmluZ19vZl9jaGFyX2xpc3QgKG1hbnkgaGV4X2RpZ2l0KVxuXG4gIGxldCBjX2RvdCA9IGNoYXIgJy4nXG5cbiAgbGV0IGNfYXQgPSBjaGFyICdAJ1xuXG4gIGxldCBjX2NvbG9uID0gY2hhciAnOidcblxuICBsZXQgZGVjX29jdGV0ID1cbiAgICB0YWtlX3doaWxlMSAoZnVuY3Rpb24gJzAnIC4uICc5JyAtPiB0cnVlIHwgXyAtPiBmYWxzZSkgPj49IGZ1biBudW0gLT5cbiAgICBpZiBpbnRfb2Zfc3RyaW5nIG51bSA8IDI1NiB0aGVuXG4gICAgICByZXR1cm4gbnVtXG4gICAgZWxzZVxuICAgICAgZmFpbCBcImludmFsaWQgb2N0ZWN0XCJcblxuICBsZXQgaXB2NF9hZGRyZXNzID1cbiAgICBsaWZ0MlxuICAgICAgKGZ1biB0aHJlZSBvbmUgLT4gU3RyaW5nLmNvbmNhdCBcIi5cIiB0aHJlZSBeIFwiLlwiIF4gb25lKVxuICAgICAgKGNvdW50IDMgKGRlY19vY3RldCA8KiBjX2RvdCkpXG4gICAgICBkZWNfb2N0ZXRcblxuICAoKiAtLSBhZnRlciBkb3VibGUgY29sb24sIElQdjQgZG90dGVkIG5vdGF0aW9uIGNvdWxkIGFwcGVhciBhbnl3aGVyZSAqKVxuICBsZXQgYWZ0ZXJfZG91YmxlX2NvbG9uID1cbiAgICBmaXggKGZ1biBmIC0+XG4gICAgICAgIGxpc3QgWyBpcHY0X2FkZHJlc3MgXVxuICAgICAgICA8fD4gbGlmdDIgKGZ1biB4IHkgLT4geCA6OiB5KSBoZXhhZGVjaW1hbCAoY19jb2xvbiAqPiBmIDx8PiByZXR1cm4gW10pKVxuXG4gIGxldCBkb3VibGVfY29sb24gY291bnQgPVxuICAgIGFmdGVyX2RvdWJsZV9jb2xvbiA+Pj0gKGZ1biByZXN0IC0+XG4gICAgbGV0IGZpbGxlcl9sZW5ndGggPSA4IC0gY291bnQgLSBMaXN0Lmxlbmd0aCByZXN0IGluXG4gICAgaWYgZmlsbGVyX2xlbmd0aCA8PSAwIHRoZW5cbiAgICAgIGZhaWwgXCJ0b28gbWFueSBwYXJ0cyBpbiBJUHY2IGFkZHJlc3NcIlxuICAgIGVsc2VcbiAgICAgIHJldHVybiAoXCJcIiA6OiByZXN0KSlcbiAgICA8fD4gcmV0dXJuIFtcIlwiXVxuXG4gIGxldCByZWMgcGFydCA9IGZ1bmN0aW9uXG4gICAgfCA3IC0+XG4gICAgICAoKiBtYXggOCBwYXJ0cyBpbiBhbiBJUHY2IGFkZHJlc3MgKilcbiAgICAgIGxpZnQgKGZ1biB4IC0+IFsgeCBdKSBoZXhhZGVjaW1hbFxuICAgIHwgNiAtPlxuICAgICAgKCogYWZ0ZXIgNiBwYXJ0cyBpdCBjb3VsZCBlbmQgaW4gSVB2NCBkb3R0ZWQgbm90YXRpb24gKilcbiAgICAgIGxpc3QgWyBpcHY0X2FkZHJlc3MgXSA8fD4gaGV4X3BhcnQgNlxuICAgIHwgbiAtPlxuICAgICAgaGV4X3BhcnQgblxuXG4gIGFuZCBoZXhfcGFydCBuID1cbiAgICBsaWZ0MlxuICAgICAgKGZ1biB4IHkgLT4geCA6OiB5KVxuICAgICAgaGV4YWRlY2ltYWxcbiAgICAgIChjX2NvbG9uICo+IChjX2NvbG9uICo+IGRvdWJsZV9jb2xvbiAobiArIDEpIDx8PiBwYXJ0IChuICsgMSkpKVxuXG4gIGxldCByZWMgc3BsaXRfd2l0aCBmIHhzID1cbiAgICBtYXRjaCB4cyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgW10sIFtdXG4gICAgfCB5IDo6IHlzIC0+XG4gICAgICBpZiBmIHkgdGhlblxuICAgICAgICBsZXQgenMsIHRzID0gc3BsaXRfd2l0aCBmIHlzIGluXG4gICAgICAgIHkgOjogenMsIHRzXG4gICAgICBlbHNlXG4gICAgICAgIFtdLCB4c1xuXG4gIGxldCBpcHY2ID1cbiAgICBsZXQgZm9ybWF0X2FkZHIgc2VnbWVudHMgPVxuICAgICAgbGV0IGJlZm9yZV9kb3VibGVfY29sb24sIGFmdGVyX2RvdWJsZV9jb2xvbiA9XG4gICAgICAgIHNwbGl0X3dpdGggKGZ1biBzZWdtZW50IC0+IHNlZ21lbnQgPD4gXCJcIikgc2VnbWVudHNcbiAgICAgIGluXG4gICAgICBsZXQgYmVmb3JlID0gU3RyaW5nLmNvbmNhdCBcIjpcIiBiZWZvcmVfZG91YmxlX2NvbG9uIGluXG4gICAgICBsZXQgcmVzID1cbiAgICAgICAgbWF0Y2ggYWZ0ZXJfZG91YmxlX2NvbG9uIHdpdGhcbiAgICAgICAgfCBcIlwiIDo6IHhzIC0+XG4gICAgICAgICAgYmVmb3JlIF4gXCI6OlwiIF4gU3RyaW5nLmNvbmNhdCBcIjpcIiB4c1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBiZWZvcmVcbiAgICAgIGluXG4gICAgICByZXNcbiAgICBpblxuICAgIGxpZnQgZm9ybWF0X2FkZHIgKGNfY29sb24gKj4gY19jb2xvbiAqPiBkb3VibGVfY29sb24gMCA8fD4gcGFydCAwKVxuXG4gIGxldCBpcHY2X2FkZHJlc3MgPVxuICAgIChjaGFyICdbJykgKj4gaXB2NiA8KiAoY2hhciAnXScpXG5cbiAgbGV0IHBjdF9lbmNvZGVkID1cbiAgICBsaWZ0MlxuICAgICAgKGZ1biBwY3QgZGlnaXRzIC0+IHN0cmluZ19vZl9jaGFyX2xpc3QgKHBjdCA6OiBkaWdpdHMpKVxuICAgICAgKGNoYXIgJyUnKVxuICAgICAgKGNvdW50IDIgaGV4X2RpZ2l0KVxuXG4gIGxldCBzdWJfZGVsaW1zID1cbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICchJyB8ICckJyB8ICcmJyB8ICdcXCcnIHwgJygnIHwgJyknIHwgJyonIHwgJysnIHwgJywnIHwgJzsnIHwgJz0nIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgdW5yZXNlcnZlZCA9XG4gICAgKCogXCJbQS1aYS16MC05LS5ffl1cIiAqKVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uXG4gICAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgfCAnMCcgLi4gJzknIHwgJy0nIHwgJy4nIHwgJ18nIHwgJ34nIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgcmVnX25hbWUgPVxuICAgIGxpZnRcbiAgICAgIChTdHJpbmcuY29uY2F0IFwiXCIpXG4gICAgICAobWFueVxuICAgICAgICAgKGNob2ljZVxuICAgICAgICAgICAgWyBzdHJpbmdfb2ZfY2hhciA8JD4gdW5yZXNlcnZlZFxuICAgICAgICAgICAgOyBwY3RfZW5jb2RlZFxuICAgICAgICAgICAgOyBzdHJpbmdfb2ZfY2hhciA8JD4gc3ViX2RlbGltc1xuICAgICAgICAgICAgXSkpXG5cbiAgbGV0IGhvc3QgPVxuICAgIGNob2ljZVxuICAgICAgWyBpcHY0X2FkZHJlc3MgPj58IChmdW4gaCAtPiBgSXB2NF9saXRlcmFsIGgpXG4gICAgICA7IGlwdjZfYWRkcmVzcyA+PnwgKGZ1biBoIC0+IGBJcHY2X2xpdGVyYWwgaClcbiAgICAgIDsgcmVnX25hbWUgPj58IChmdW4gcyAtPiBgSG9zdCAoUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBzKSkpXG4gICAgICAoKiBUT0RPKGRpbm9zYXVyZSk6IEFjY29yZGluZyB0byBSRkMzOTg2OlxuXG4gICAgICAgICBob3N0ICAgICAgICA9IElQLWxpdGVyYWwgLyBJUHY0YWRkcmVzcyAvIHJlZy1uYW1lXG4gICAgICAgICBJUC1saXRlcmFsICA9IFwiW1wiICggSVB2NmFkZHJlc3MgLyBJUHZGdXR1cmUgICkgXCJdXCJcbiAgICAgICAgIElQdkZ1dHVyZSAgID0gXCJ2XCIgMSpIRVhESUcgXCIuXCIgMSooIHVucmVzZXJ2ZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuXG4gICAgICAgICBJUHZGdXR1cmUgaXMgbm90IGltcGxlbWVudGVkLiBXZSBzaG91bGQgaGFuZGxlIGl0OlxuXG4gICAgICAgICBJUHZGdXR1cmUgICA9IFwidlwiIDEqSEVYRElHIFwiLlwiIDEqKCB1bnJlc2VydmVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIClcbiAgICAgICAqKVxuICAgICAgXVxuXG4gIGxldCB1c2VyaW5mbyA9XG4gICAgbGlmdFxuICAgICAgKGZ1biB4IC0+XG4gICAgICAgIGxldCBzID0gU3RyaW5nLmNvbmNhdCBcIlwiIHggaW5cbiAgICAgICAgU29tZSAoVXNlcmluZm8udXNlcmluZm9fb2ZfZW5jb2RlZCBzKSlcbiAgICAgIChtYW55XG4gICAgICAgICAoY2hvaWNlXG4gICAgICAgICAgICBbIHN0cmluZ19vZl9jaGFyIDwkPiB1bnJlc2VydmVkXG4gICAgICAgICAgICA7IHBjdF9lbmNvZGVkXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBzdWJfZGVsaW1zXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBjX2NvbG9uXG4gICAgICAgICAgICBdKVxuICAgICAgPCogY19hdClcbiAgICA8fD4gcmV0dXJuIE5vbmVcblxuICBsZXQgcG9ydCA9XG4gICAgcGVla19jaGFyID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSAnOicgLT5cbiAgICAgIGNfY29sb24gKj4gdGFrZV93aGlsZSBpc19kaWdpdCA+PnwgZnVuIHBvcnQgLT5cbiAgICAgIGxldCBkZWNvZGVkID0gUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBwb3J0KSBpblxuICAgICAgKHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIChQY3QudW5jYXN0X2RlY29kZWQgZGVjb2RlZCkpIHdpdGggXyAtPiBOb25lKVxuICAgIHwgU29tZSBfIHwgTm9uZSAtPlxuICAgICAgcmV0dXJuIE5vbmVcblxuICBsZXQgYXV0aG9yaXR5ID1cbiAgICBzdHJpbmcgXCIvL1wiXG4gICAgKj4gbGlmdDNcbiAgICAgICAgIChmdW4gdXNlcmluZm8gaG9zdCBwb3J0IC0+XG4gICAgICAgICAgIHVzZXJpbmZvLCBTb21lIGhvc3QsIHBvcnQpXG4gICAgICAgICB1c2VyaW5mb1xuICAgICAgICAgaG9zdFxuICAgICAgICAgcG9ydFxuICAgIDx8PiByZXR1cm4gKE5vbmUsIE5vbmUsIE5vbmUpXG5cbiAgbGV0IHBhdGggPVxuICAgIGxpZnRcbiAgICAgIFBhdGgucGF0aF9vZl9lbmNvZGVkXG4gICAgICAodGFrZV93aGlsZSAoZnVuY3Rpb24gJz8nIHwgJyMnIC0+IGZhbHNlIHwgXyAtPiB0cnVlKSlcblxuICBsZXQgcXVlcnkgPVxuICAgIGxpZnRcbiAgICAgIFF1ZXJ5Lm9mX3Jhd1xuICAgICAgKGNoYXIgJz8nICo+IHRha2VfdGlsbCAoZnVuY3Rpb24gJyMnIC0+IHRydWUgfCBfIC0+IGZhbHNlKSlcbiAgICA8fD4gcmV0dXJuIChRdWVyeS5SYXcgKE5vbmUsIExhenkuZnJvbV92YWwgW10pKVxuXG4gIGxldCBmcmFnbWVudCA9XG4gICAgbGlmdFxuICAgICAgKGZ1biBzIC0+IFNvbWUgKFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcykpKVxuICAgICAgKGNoYXIgJyMnICo+IHRha2Vfd2hpbGUgKGZ1biBfIC0+IHRydWUpKVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBfdXJpX3JlZmVyZW5jZSA9XG4gICAgbGlmdDRcbiAgICAgIChmdW4gc2NoZW1lICh1c2VyaW5mbywgaG9zdCwgcG9ydCkgcGF0aCBxdWVyeSBmcmFnbWVudCAtPlxuICAgICAgICBub3JtYWxpemUgc2NoZW1lIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH0pXG4gICAgICBzY2hlbWVcbiAgICAgIGF1dGhvcml0eVxuICAgICAgcGF0aFxuICAgICAgcXVlcnlcbiAgICA8Kj4gZnJhZ21lbnRcblxuICAoKiBYWFgoYW5tb250ZWlybyk6IEZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnMgd2l0aCB0aGUgb2xkIHJlZ2V4IHBhcnNlciwgd2VcbiAgICogb25seSBwYXJzZSB1bnRpbCB0aGUgZmlyc3QgbmV3bGluZSBjaGFyYWN0ZXIgYW5kIGRyb3AgZXZlcnl0aGluZyBlbHNlXG4gICAqIGFmdGVyIHRoYXQgKilcbiAgbGV0IHVyaV9yZWZlcmVuY2UgPVxuICAgIHRha2Vfd2hpbGUgKGZ1bmN0aW9uIHwgJ1xcbicgLT4gZmFsc2UgfCBfIC0+IHRydWUpID4+fCBmdW4gcyAtPlxuICAgICAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBfdXJpX3JlZmVyZW5jZSBzIHdpdGhcbiAgICAgIHwgT2sgdCAtPiB0XG4gICAgICB8IEVycm9yIF8gLT5cbiAgICAgICAgKCogU2hvdWxkbid0IHJlYWxseSBoYXBwZW4gaWYgdGhlIHBhcnNlciBpcyBmb3JnaXZpbmcuICopXG4gICAgICAgIGVtcHR5XG5lbmRcblxubGV0IGRlY29kZV9ob3N0IGhvc3QgPVxuICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6QWxsIFBhcnNlci5ob3N0IGhvc3Qgd2l0aFxuICB8IE9rIHBhcnNlZCAtPiBwYXJzZWRcbiAgfCBFcnJvciBfIC0+XG4gICAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBQYXJzZXIuaXB2NiBob3N0IHdpdGhcbiAgICB8IE9rIHBhcnNlZCAtPiAoYElwdjZfbGl0ZXJhbCBwYXJzZWQpXG4gICAgfCBFcnJvciBfIC0+IChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBob3N0KSlcblxuKCogTWFrZSBhIFVSSSByZWNvcmQuIFRoaXMgaXMgYSBiaXQgbW9yZSBpbmVmZmljaWVudCB0aGFuIGl0IG5lZWRzIHRvIGJlIGR1ZSB0byB0aGVcbiAqIGNhc3RpbmcvdW5jYXN0aW5nICh3aGljaCBpc24ndCBmdWxseSBpZGVudGl0eSBkdWUgdG8gdGhlIG9wdGlvbiBib3gpLCBidXQgaXQgaXNcbiAqIG5vIGJpZyBkZWFsIGZvciBub3cuXG4qKVxubGV0IG1ha2UgP3NjaGVtZSA/dXNlcmluZm8gP2hvc3QgP3BvcnQgP3BhdGggP3F1ZXJ5ID9mcmFnbWVudCAoKSA9XG4gIGxldCBkZWNvZGUgPSBmdW5jdGlvblxuICAgIHxTb21lIHggLT4gU29tZSAoUGN0LmNhc3RfZGVjb2RlZCB4KSB8Tm9uZSAtPiBOb25lIGluXG4gIGxldCBob3N0ID0gbWF0Y2ggdXNlcmluZm8sIGhvc3QsIHBvcnQgd2l0aFxuICAgIHwgXywgU29tZSBfLCBfIHwgTm9uZSwgTm9uZSwgTm9uZSAtPiBob3N0XG4gICAgfCBTb21lIF8sIE5vbmUsIF8gfCBfLCBOb25lLCBTb21lIF8gLT4gU29tZSBcIlwiXG4gIGluXG4gIGxldCB1c2VyaW5mbyA9IG1hdGNoIHVzZXJpbmZvIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZSB8IFNvbWUgdSAtPiBTb21lICh1c2VyaW5mb19vZl9lbmNvZGVkIHUpIGluXG4gIGxldCBwYXRoID0gbWF0Y2ggcGF0aCB3aXRoXG4gICAgfE5vbmUgLT4gW10gfCBTb21lIHAgLT5cbiAgICAgIGxldCBwYXRoID0gcGF0aF9vZl9lbmNvZGVkIHAgaW5cbiAgICAgIG1hdGNoIGhvc3QsIHBhdGggd2l0aFxuICAgICAgfCBOb25lLCBfIHwgU29tZSBfLCBcIi9cIjo6XyB8IFNvbWUgXywgW10gLT4gcGF0aFxuICAgICAgfCBTb21lIF8sIF8gIC0+IFwiL1wiOjpwYXRoXG4gIGluXG4gIGxldCBxdWVyeSA9IG1hdGNoIHF1ZXJ5IHdpdGhcbiAgICB8IE5vbmUgLT4gUXVlcnkuS1YgW11cbiAgICB8IFNvbWUgcCAtPiBRdWVyeS5LViBwXG4gIGluXG4gIGxldCBzY2hlbWUgPSBkZWNvZGUgc2NoZW1lIGluXG4gIG5vcm1hbGl6ZSBzY2hlbWVcbiAgICB7IHNjaGVtZTsgdXNlcmluZm87XG4gICAgICBob3N0ID1cbiAgICAgICAgKG1hdGNoIGhvc3Qgd2l0aFxuICAgICAgICB8IFNvbWUgaG9zdCAtPiBTb21lIChkZWNvZGVfaG9zdCBob3N0KVxuICAgICAgICB8IE5vbmUgLT4gTm9uZSk7XG4gICAgICBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQ9ZGVjb2RlIGZyYWdtZW50IH1cblxubGV0IHdpdGhfaG9zdCB1cmkgaG9zdCA9XG4gIHsgdXJpIHdpdGhcbiAgICBob3N0ID0gKG1hdGNoIGhvc3Qgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGhvc3QgLT4gU29tZSAoZGVjb2RlX2hvc3QgaG9zdClcbiAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICB9XG5cbmxldCB3aXRoX3VyaSA/c2NoZW1lID91c2VyaW5mbyA/aG9zdCA/cG9ydCA/cGF0aCA/cXVlcnkgP2ZyYWdtZW50IHVyaSA9XG4gIGxldCB3aXRoX3BhdGhfb3B0IHUgbyA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHdpdGhfcGF0aCB1IFwiXCJcbiAgICB8IFNvbWUgcCAtPiB3aXRoX3BhdGggdSBwXG4gIGluXG4gIGxldCB3aXRoX3F1ZXJ5X29wdCB1IG8gPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiB3aXRoX3F1ZXJ5IHUgW11cbiAgICB8IFNvbWUgcSAtPiB3aXRoX3F1ZXJ5IHUgcVxuICBpblxuICBsZXQgd2l0aF8gZiBvIHUgPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiB1XG4gICAgfCBTb21lIHggLT4gZiB1IHhcbiAgaW5cbiAgd2l0aF8gd2l0aF9zY2hlbWUgc2NoZW1lIHVyaVxuICB8PiB3aXRoXyB3aXRoX3VzZXJpbmZvIHVzZXJpbmZvXG4gIHw+IHdpdGhfIHdpdGhfaG9zdCBob3N0XG4gIHw+IHdpdGhfIHdpdGhfcG9ydCBwb3J0XG4gIHw+IHdpdGhfIHdpdGhfcGF0aF9vcHQgcGF0aFxuICB8PiB3aXRoXyB3aXRoX3F1ZXJ5X29wdCBxdWVyeVxuICB8PiB3aXRoXyB3aXRoX2ZyYWdtZW50IGZyYWdtZW50XG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gICgqIFRvIHByZXNlcnZlIHRoZSBvbGQgcmVnZXggcGFyc2VyJ3MgYmVoYXZpb3IsIHdlIG9ubHkgcGFyc2UgYSBwcmVmaXgsIGFuZFxuICAgKiBzdG9wIHdoZW5ldmVyIHdlIGNhbid0IHBhcnNlIG1vcmUuICopXG4gIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpQcmVmaXggUGFyc2VyLnVyaV9yZWZlcmVuY2UgcyB3aXRoXG4gIHwgT2sgdCAtPiB0XG4gIHwgRXJyb3IgXyAtPlxuICAgICgqIFNob3VsZG4ndCByZWFsbHkgaGFwcGVuIGlmIHRoZSBwYXJzZXIgaXMgZm9yZ2l2aW5nLiAqKVxuICAgIGVtcHR5XG5cbm1vZHVsZSBBYnNvbHV0ZV9odHRwID0gc3RydWN0XG4gIHR5cGUgdXJpID0gdFxuICB0eXBlIHQgPVxuICAgIHsgc2NoZW1lIDogWyBgSHR0cCB8IGBIdHRwcyBdO1xuICAgICAgdXNlcmluZm86IFVzZXJpbmZvLnQgb3B0aW9uO1xuICAgICAgaG9zdDogWyBgSXB2NF9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICAgICAgfCBgSXB2Nl9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICAgICAgfCBgSG9zdCBvZiBQY3QuZGVjb2RlZF07XG4gICAgICBwb3J0IDogaW50IG9wdGlvbjtcbiAgICAgIHBhdGggOiBQYXRoLnQ7XG4gICAgICBxdWVyeSA6IFF1ZXJ5LnQ7XG4gICAgICBmcmFnbWVudCA6IFBjdC5kZWNvZGVkIG9wdGlvblxuICAgIH1cblxuICBsZXQgKCBsZXQqICkgPSBSZXN1bHQuYmluZFxuXG4gIGxldCB0b191cmkgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfSA9XG4gICAgbGV0IHNjaGVtZSA9XG4gICAgICBtYXRjaCBzY2hlbWUgd2l0aFxuICAgICAgfCBgSHR0cCAtPiBQY3QuY2FzdF9kZWNvZGVkIFwiaHR0cFwiXG4gICAgICB8IGBIdHRwcyAtPiBQY3QuY2FzdF9kZWNvZGVkIFwiaHR0cHNcIlxuICAgIGluXG4gICAgKHsgc2NoZW1lID0gU29tZSBzY2hlbWU7XG4gICAgICAgdXNlcmluZm87XG4gICAgICAgaG9zdCA9IFNvbWUgaG9zdDtcbiAgICAgICBwb3J0O1xuICAgICAgIHBhdGg7XG4gICAgICAgcXVlcnk7XG4gICAgICAgZnJhZ21lbnQgfSA6IHVyaSlcbiAgOztcblxuICBsZXQgb2ZfdXJpICh7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9OiB1cmkpID1cbiAgICBsZXQqIHNjaGVtZSA9XG4gICAgICBtYXRjaCBzY2hlbWUgd2l0aFxuICAgICAgfCBOb25lIC0+IEVycm9yIChgTXNnIFwiTm8gc2NoZW1lIHByZXNlbnQgaW4gVVJJXCIpXG4gICAgICB8IFNvbWUgc2NoZW1lIC0+XG4gICAgICAgIChtYXRjaCBQY3QudW5jYXN0X2RlY29kZWQgc2NoZW1lIHdpdGhcbiAgICAgICAgIHwgXCJodHRwXCIgLT4gT2sgYEh0dHBcbiAgICAgICAgIHwgXCJodHRwc1wiIC0+IE9rIGBIdHRwc1xuICAgICAgICAgfCB1bnN1cHBvcnRlZF9zY2hlbWUgLT5cbiAgICAgICAgICAgRXJyb3JcbiAgICAgICAgICAgICAoYE1zZ1xuICAgICAgICAgICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgIFwiT25seSBodHRwIGFuZCBodHRwcyBVUklzIGFyZSBzdXBwb3J0ZWQuICVzIGlzIGludmFsaWQuXCJcbiAgICAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZF9zY2hlbWUpKSlcbiAgICBpblxuICAgIGxldCogaG9zdCA9IE9wdGlvbi50b19yZXN1bHQgfm5vbmU6KGBNc2cgXCJob3N0IGlzIHJlcXVpcmVkIGZvciBIVFRQKFMpIHVyaXNcIikgaG9zdCBpblxuICAgIE9rIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH1cbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nIHMgPSBtYXRjaCBvZl9zdHJpbmcgcyB8PiBvZl91cmkgd2l0aFxuICAgIHwgT2sgdCAtPiB0XG4gICAgfCBFcnJvciAoYE1zZyBlcnJvcikgLT4gZmFpbHdpdGggZXJyb3JcblxuICBsZXQgdG9fc3RyaW5nID9wY3RfZW5jb2RlciB0ID0gdG9fdXJpIHQgfD4gdG9fc3RyaW5nID9wY3RfZW5jb2RlclxuXG4gIGxldCBub3JtYWxpemUgdCA9XG4gICAgeyB0IHdpdGhcbiAgICAgIGhvc3QgPSBtYXRjaCB0Lmhvc3Qgd2l0aFxuICAgICAgIHwgKGBJcHY0X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIChgSXB2NF9saXRlcmFsIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhvc3QpKVxuICAgICAgIHwgKGBJcHY2X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIChgSXB2Nl9saXRlcmFsIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhvc3QpKVxuICAgICAgIHwgKGBIb3N0IGhvc3QpIC0+XG4gICAgICAgICAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgKFBjdC51bmNhc3RfZGVjb2RlZCBob3N0KSkpKVxuICAgIH1cblxuICBsZXQgbWFrZSB+c2NoZW1lIH5ob3N0ID91c2VyaW5mbyA/cG9ydCA/cGF0aCA/cXVlcnkgP2ZyYWdtZW50ICgpID1cbiAgICBsZXQgZGVjb2RlID0gZnVuY3Rpb25cbiAgICAgIHxTb21lIHggLT4gU29tZSAoUGN0LmNhc3RfZGVjb2RlZCB4KSB8Tm9uZSAtPiBOb25lIGluXG4gICAgbGV0IHVzZXJpbmZvID0gbWF0Y2ggdXNlcmluZm8gd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmUgfCBTb21lIHUgLT4gU29tZSAodXNlcmluZm9fb2ZfZW5jb2RlZCB1KSBpblxuICAgIGxldCBwYXRoID0gbWF0Y2ggcGF0aCB3aXRoXG4gICAgICB8Tm9uZSAtPiBbXSB8IFNvbWUgcCAtPlxuICAgICAgICBsZXQgcGF0aCA9IHBhdGhfb2ZfZW5jb2RlZCBwIGluXG4gICAgICAgIG1hdGNoIHBhdGggd2l0aFxuICAgICAgICB8ICBcIi9cIjo6XyB8ICBbXSAtPiBwYXRoXG4gICAgICAgIHwgXyAgLT4gXCIvXCI6OnBhdGhcbiAgICBpblxuICAgIGxldCBxdWVyeSA9IG1hdGNoIHF1ZXJ5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBRdWVyeS5LViBbXVxuICAgICAgfCBTb21lIHAgLT4gUXVlcnkuS1YgcFxuICAgIGluXG4gICAgbm9ybWFsaXplXG4gICAgICB7IHNjaGVtZTtcbiAgICAgICAgdXNlcmluZm87XG4gICAgICAgIGhvc3Q9IGRlY29kZV9ob3N0IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudD1kZWNvZGUgZnJhZ21lbnQgfVxuXG4gIGxldCBob3N0IHQgPVxuICAgIG1hdGNoIHQuaG9zdCB3aXRoXG4gICAgfCAoYElwdjRfbGl0ZXJhbCBoIHwgYElwdjZfbGl0ZXJhbCBoKSAtPiBoXG4gICAgfCAoYEhvc3QgaCkgLT4gKFBjdC51bmNhc3RfZGVjb2RlZCBoKVxuXG4gIGxldCBzY2hlbWUgdCA9IHQuc2NoZW1lXG5lbmRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fV19
