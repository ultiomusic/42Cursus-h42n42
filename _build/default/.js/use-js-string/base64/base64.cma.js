// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Base64__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64 = [0];
   runtime.caml_register_global(0, Base64, "Base64__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64__Unsafe
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64_Unsafe = [0];
   runtime.caml_register_global(0, Base64_Unsafe, "Base64__Unsafe");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Invalid_bounds = "Invalid bounds",
    cst_Malformed_input = "Malformed input",
    cst_Too_much_input = "Too much input",
    cst_Wrong_padding = "Wrong padding",
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get16 = runtime.caml_string_get16,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys,
    cst_Length_of_alphabet_must_be = "Length of alphabet must be 64",
    cst_Alphabet_can_not_contain_p =
      "Alphabet can not contain padding character";
   function symbol(x, y){
    if(y < 1) throw caml_maybe_attach_backtrace(Stdlib[13], 1);
    return 0 < x ? 1 + runtime.caml_div(x - 1 | 0, y) | 0 : 0;
   }
   function unsafe_set_uint8(t, off, v){
    runtime.caml_bytes_unsafe_set(t, off, caml_call1(Stdlib_Char[1], v));
   }
   function make_alphabet(alphabet){
    if(64 !== caml_ml_string_length(alphabet))
     caml_call1(Stdlib[1], cst_Length_of_alphabet_must_be);
    if(caml_call2(Stdlib_String[15], alphabet, 61))
     caml_call1(Stdlib[1], cst_Alphabet_can_not_contain_p);
    var
     emap =
       caml_call2
        (Stdlib_Array[1],
         caml_ml_string_length(alphabet),
         function(i){return runtime.caml_string_get(alphabet, i);}),
     dmap = runtime.caml_make_vect(256, -1);
    caml_call2
     (Stdlib_String[31],
      function(idx, chr){
       caml_check_bound(dmap, chr)[1 + chr] = idx;
       return 0;
      },
      alphabet);
    return [0, emap, dmap];
   }
   function length_alphabet(param){
    var emap = param[1];
    return emap.length - 1;
   }
   function alphabet(param){
    var emap = param[1];
    return caml_call2
            (Stdlib_String[2],
             emap.length - 1,
             function(i){
              var _y_ = caml_check_bound(emap, i)[1 + i];
              return caml_call1(Stdlib_Char[1], _y_);
             });
   }
   var
    default_alphabet =
      make_alphabet
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),
    uri_safe_alphabet =
      make_alphabet
       ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),
    _e_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    _f_ = [0, [11, cst_Wrong_padding, 0], cst_Wrong_padding],
    _g_ = [0, [11, cst_Malformed_input, 0], cst_Malformed_input],
    _h_ = [0, [11, cst_Too_much_input, 0], cst_Too_much_input],
    _c_ = [0, "src/base64.ml", 157, 15],
    _b_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    cst_Base64_Out_of_bounds = "Base64.Out_of_bounds",
    cst_Base64_Too_much_input = "Base64.Too_much_input",
    unsafe_set_be_uint16 =
      Stdlib_Sys[11]
       ? function(t, off, v){caml_bytes_set16(t, off, v);}
       : function
        (t, off, v){
         caml_bytes_set16(t, off, runtime.caml_bswap16(v));
        },
    Out_of_bounds = [248, cst_Base64_Out_of_bounds, caml_fresh_oo_id(0)],
    Too_much_input = [248, cst_Base64_Too_much_input, caml_fresh_oo_id(0)];
   function get_uint8(t, off){
    var
     _w_ = off < 0 ? 1 : 0,
     _x_ = _w_ || (caml_ml_string_length(t) <= off ? 1 : 0);
    if(_x_) throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
    return caml_string_unsafe_get(t, off);
   }
   var padding = 61;
   function error_msgf(fmt){
    return caml_call2
            (Stdlib_Format[149],
             function(err){return [1, [0, 3854881, err]];},
             fmt);
   }
   function _a_(pad, param, opt, len, input){
    var emap = param[1], off = opt ? opt[1] : 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_ml_string_length(input) - off | 0;
    if
     (0 <= len$1
      && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
     var
      n = symbol(len$1, 3) * 4 | 0,
      res = caml_create_bytes(n),
      emit =
        function(b1, b2, b3, i){
         var i$0 = (b1 << 4 | b2 >>> 4 | 0) & 63, i$1 = (b1 >>> 2 | 0) & 63;
         unsafe_set_be_uint16(res, i, emap[1 + i$1] << 8 | emap[1 + i$0]);
         var i$2 = b3 & 63, i$3 = (b2 << 2 | b3 >>> 6 | 0) & 63;
         return unsafe_set_be_uint16
                 (res, i + 2 | 0, emap[1 + i$3] << 8 | emap[1 + i$2]);
        };
     a:
     b:
     {
      c:
      {
       var j = 0, i = 0;
       for(;;){
        if(i === len$1) break b;
        if(i === (len$1 - 1 | 0)) break c;
        if(i === (len$1 - 2 | 0)) break;
        var
         off$3 = (off + i | 0) + 2 | 0,
         off$4 = (off + i | 0) + 1 | 0,
         off$5 = off + i | 0;
        emit
         (caml_string_unsafe_get(input, off$5),
          caml_string_unsafe_get(input, off$4),
          caml_string_unsafe_get(input, off$3),
          j);
        var i$0 = i + 3 | 0, j$0 = j + 4 | 0;
        j = j$0;
        i = i$0;
       }
       var off$1 = (off + i | 0) + 1 | 0, off$2 = off + i | 0;
       emit
        (caml_string_unsafe_get(input, off$2),
         caml_string_unsafe_get(input, off$1),
         0,
         j);
       break a;
      }
      var off$0 = off + i | 0;
      emit(caml_string_unsafe_get(input, off$0), 0, 0, j);
      break a;
     }
     var pad_to_write = (3 - (len$1 % 3 | 0) | 0) % 3 | 0;
     if(! pad)
      return [0,
              [0, caml_call1(Stdlib_Bytes[44], res), 0, n - pad_to_write | 0]];
     var i$1 = pad_to_write;
     for(;;){
      if(0 === i$1) return [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n]];
      unsafe_set_uint8(res, n - i$1 | 0, padding);
      var i$2 = i$1 - 1 | 0;
      i$1 = i$2;
     }
    }
    return error_msgf(_b_);
   }
   function encode(_v_, opt, off, len, input){
    var
     pad = _v_ ? _v_[1] : 1,
     alphabet = opt ? opt[1] : default_alphabet,
     err = _a_(pad, alphabet, off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[16], res, off$0, len$0)];
   }
   function encode_string(pad, alphabet, input){
    var match = encode(pad, alphabet, 0, 0, input);
    if(0 !== match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var res = match[1];
    return res;
   }
   function encode_sub(_u_, opt, off, len, input){
    var pad = _u_ ? _u_[1] : 1, alphabet = opt ? opt[1] : default_alphabet;
    return _a_(pad, alphabet, off, len, input);
   }
   function encode_exn(pad, alphabet, off, len, input){
    var match = encode(pad, alphabet, off, len, input);
    if(0 === match[0]){var v = match[1]; return v;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   function _d_(_i_, param, opt, len, input){
    var
     invalid_pad_overflow = _i_ ? _i_[1] : 1,
     dmap = param[2],
     off = opt ? opt[1] : 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_ml_string_length(input) - off | 0;
    if
     (0 <= len$1
      && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
     var
      n = symbol(len$1, 4) * 4 | 0,
      n$0 = symbol(n, 4) * 3 | 0,
      res = caml_create_bytes(n$0),
      get_uint8_or_padding =
        invalid_pad_overflow
         ? function
          (t, i){
           if(len$1 <= i) throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
           return get_uint8(t, off + i | 0);
          }
         : function
          (t, i){
           try{
            var _s_ = i < len$1 ? get_uint8(t, off + i | 0) : padding;
            return _s_;
           }
           catch(_t_){
            var _r_ = caml_wrap_exception(_t_);
            if(_r_ === Out_of_bounds) return padding;
            throw caml_maybe_attach_backtrace(_r_, 0);
           }
          },
      dmap$0 =
        function(i){
         var x = dmap[1 + i];
         if(x === -1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
         return x;
        },
      only_padding =
        function(pad, idx){
         var pad$0 = [0, pad + 3 | 0], idx$0 = [0, idx];
         for(;;){
          if((idx$0[1] + 4 | 0) >= len$1) break;
          var
           _p_ =
             15677 !== caml_string_get16(input, off + idx$0[1] | 0) ? 1 : 0,
           _q_ =
             _p_
             ||
              (15677
                !== caml_string_get16(input, (off + idx$0[1] | 0) + 2 | 0)
                ? 1
                : 0);
          if(_q_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          idx$0[1] = idx$0[1] + 4 | 0;
          pad$0[1] = pad$0[1] + 3 | 0;
         }
         for(;;){
          if(idx$0[1] >= len$1) return pad$0[1];
          var off$0 = off + idx$0[1] | 0;
          if(caml_string_unsafe_get(input, off$0) !== 61)
           throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          idx$0[1]++;
         }
        };
     try{
      a:
      {
       b:
       {
        var off$1 = 0, i = 0;
        for(;;){
         if(i === n){var pad$4 = 0; break a;}
         var x$0 = get_uint8_or_padding(input, i + 3 | 0);
         c:
         try{var pad$3 = 0, _m_ = dmap$0(x$0), pad = pad$3, d = _m_;}
         catch(exn$0){
          var exn = caml_wrap_exception(exn$0);
          if(exn === Stdlib[8] && x$0 === 61){var pad = 1, d = 0; break c;}
          throw caml_maybe_attach_backtrace(exn, 0);
         }
         var x$1 = get_uint8_or_padding(input, i + 2 | 0);
         c:
         try{var _l_ = dmap$0(x$1), pad$0 = pad, c = _l_;}
         catch(exn){
          var exn$0 = caml_wrap_exception(exn);
          if(exn$0 === Stdlib[8] && x$1 === 61 && 1 === pad){var pad$0 = 2, c = 0; break c;}
          throw caml_maybe_attach_backtrace(exn$0, 0);
         }
         var x$2 = get_uint8_or_padding(input, i + 1 | 0);
         c:
         try{var _k_ = dmap$0(x$2), pad$1 = pad$0, b = _k_;}
         catch(exn){
          var exn$1 = caml_wrap_exception(exn);
          if(exn$1 === Stdlib[8] && x$2 === 61 && 2 === pad$0){var pad$1 = 3, b = 0; break c;}
          throw caml_maybe_attach_backtrace(exn$1, 0);
         }
         var x$3 = get_uint8_or_padding(input, i);
         c:
         try{var _j_ = dmap$0(x$3), pad$2 = pad$1, a = _j_;}
         catch(exn){
          var exn$2 = caml_wrap_exception(exn);
          if(exn$2 === Stdlib[8] && x$3 === 61 && 3 === pad$1){var pad$2 = 4, a = 0; break c;}
          throw caml_maybe_attach_backtrace(exn$2, 0);
         }
         var x = a << 18 | b << 12 | c << 6 | d, v = x >>> 8 | 0;
         c:
         if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 1 | 0)){
          if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 2 | 0)){unsafe_set_be_uint16(res, off$1, v); break c;}
          unsafe_set_uint8(res, off$1, v >>> 8 | 0);
          break c;
         }
         var v$0 = x & 255, off$0 = off$1 + 2 | 0;
         c:
         if(0 <= off$0 && caml_ml_bytes_length(res) > off$0){unsafe_set_uint8(res, off$0, v$0); break c;}
         if((i + 4 | 0) === n) break b;
         if(0 !== pad$2) break;
         var i$0 = i + 4 | 0, j = off$1 + 3 | 0;
         off$1 = j;
         i = i$0;
        }
        if(4 === pad$2){var pad$4 = only_padding(3, i + 4 | 0); break a;}
        if(1 === invalid_pad_overflow)
         throw caml_maybe_attach_backtrace(Too_much_input, 1);
        var pad$4 = only_padding(pad$2, i + 4 | 0);
        break a;
       }
       var pad$4 = 0 === pad$2 ? 0 : 4 === pad$2 ? 3 : pad$2;
      }
     }
     catch(_o_){
      var _n_ = caml_wrap_exception(_o_);
      if(_n_ === Out_of_bounds) return error_msgf(_f_);
      if(_n_ === Stdlib[8]) return error_msgf(_g_);
      if(_n_ === Too_much_input) return error_msgf(_h_);
      throw caml_maybe_attach_backtrace(_n_, 0);
     }
     return 0 === pad$4
             ? [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n$0]]
             : [0, [0, caml_call1(Stdlib_Bytes[44], res), 0, n$0 - pad$4 | 0]];
    }
    return error_msgf(_e_);
   }
   function decode(pad, opt, off, len, input){
    var
     alphabet = opt ? opt[1] : default_alphabet,
     err = _d_(pad, alphabet, off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[16], res, off$0, len$0)];
   }
   function decode_sub(pad, opt, off, len, input){
    var alphabet = opt ? opt[1] : default_alphabet;
    return _d_(pad, alphabet, off, len, input);
   }
   function decode_exn(pad, alphabet, off, len, input){
    var match = decode(pad, alphabet, off, len, input);
    if(0 === match[0]){var res = match[1]; return res;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   var
    Base64 =
      [0,
       default_alphabet,
       uri_safe_alphabet,
       make_alphabet,
       length_alphabet,
       alphabet,
       decode_exn,
       decode_sub,
       decode,
       encode,
       encode_string,
       encode_sub,
       encode_exn];
   runtime.caml_register_global(20, Base64, "Base64");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZTY0LmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlNjQuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsIkJhc2U2NCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsU0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6ImJhc2U2NC5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiQmFzZTY0X1Vuc2FmZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsZ0JBQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJiYXNlNjQuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9JbnZhbGlkX2JvdW5kcyIsImNzdF9NYWxmb3JtZWRfaW5wdXQiLCJjc3RfVG9vX211Y2hfaW5wdXQiLCJjc3RfV3JvbmdfcGFkZGluZyIsImNhbWxfYnl0ZXNfc2V0MTYiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9ieXRlc19sZW5ndGgiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliX0J5dGVzIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX0NoYXIiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfU3lzIiwiY3N0X0xlbmd0aF9vZl9hbHBoYWJldF9tdXN0X2JlIiwiY3N0X0FscGhhYmV0X2Nhbl9ub3RfY29udGFpbl9wIiwic3ltYm9sIiwieCIsInkiLCJ1bnNhZmVfc2V0X3VpbnQ4IiwidCIsIm9mZiIsInYiLCJtYWtlX2FscGhhYmV0IiwiYWxwaGFiZXQiLCJlbWFwIiwiaSIsImRtYXAiLCJpZHgiLCJjaHIiLCJsZW5ndGhfYWxwaGFiZXQiLCJwYXJhbSIsImRlZmF1bHRfYWxwaGFiZXQiLCJ1cmlfc2FmZV9hbHBoYWJldCIsImNzdF9CYXNlNjRfT3V0X29mX2JvdW5kcyIsImNzdF9CYXNlNjRfVG9vX211Y2hfaW5wdXQiLCJ1bnNhZmVfc2V0X2JlX3VpbnQxNiIsIk91dF9vZl9ib3VuZHMiLCJUb29fbXVjaF9pbnB1dCIsImdldF91aW50OCIsInBhZGRpbmciLCJlcnJvcl9tc2dmIiwiZm10IiwiZXJyIiwicGFkIiwib3B0IiwibGVuIiwiaW5wdXQiLCJuIiwicmVzIiwiZW1pdCIsImIxIiwiYjIiLCJiMyIsImoiLCJwYWRfdG9fd3JpdGUiLCJlbmNvZGUiLCJtYXRjaCIsImVuY29kZV9zdHJpbmciLCJlbmNvZGVfc3ViIiwiZW5jb2RlX2V4biIsImludmFsaWRfcGFkX292ZXJmbG93IiwiZ2V0X3VpbnQ4X29yX3BhZGRpbmciLCJvbmx5X3BhZGRpbmciLCJkIiwiZXhuIiwiYyIsImIiLCJhIiwiZGVjb2RlIiwiZGVjb2RlX3N1YiIsImRlY29kZV9leG4iLCJCYXNlNjQiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9iYXNlNjQvYmFzZTY0Lm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHVCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxpQ0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQSxZQUFBQyxPQUFBQyxHQUFBQztBQUFBQSxJQzBCRSxVQUFjO0FBQUEsSUFDZCxtQkFBYyxzQ0FBd0I7QUFBQTtBQUFBLFlBQUFDLGlCQUFBQyxHQUFBQyxLQUFBQztBQUFBQSxJQUswQixzQ0FBWjtBQUFBLEdBQVk7QUFBQSxZQUFBQyxjQUFBQztBQUFBQSxJQWVoRTtBQUFBLEtBQ0s7QUFBQSxJQUNGO0FBQUEsS0FDRTtBQUFBO0FBQUEs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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURwRXRFIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgQ2l0cml4IFN5c3RlbXMgSW5jLlxuICogQ29weXJpZ2h0IChjKSAyMDEwIFRob21hcyBHYXphZ25haXJlIDx0aG9tYXNAZ2F6YWduYWlyZS5jb20+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBBbmlsIE1hZGhhdmFwZWRkeSA8YW5pbEByZWNvaWwub3JnPlxuICogQ29weXJpZ2h0IChjKSAyMDE2IERhdmlkIEthbG9wZXIgTWVyxaFpbmpha1xuICogQ29weXJpZ2h0IChjKSAyMDE4IFJvbWFpbiBDYWxhc2NpYmV0dGEgPHJvbWFpbi5jYWxhc2NpYmV0dGFAZ21haWwuY29tPlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuICogV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1JcbiAqIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbiAqIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuICogQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0ZcbiAqIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKlxuICopXG5cbnR5cGUgYWxwaGFiZXQgPSB7IGVtYXAgOiBpbnQgYXJyYXk7IGRtYXAgOiBpbnQgYXJyYXkgfVxuXG50eXBlIHN1YiA9IHN0cmluZyAqIGludCAqIGludFxuXG5sZXQgKCAvLyApIHggeSA9XG4gIGlmIHkgPCAxIHRoZW4gcmFpc2UgRGl2aXNpb25fYnlfemVybyA7XG4gIGlmIHggPiAwIHRoZW4gMSArICgoeCAtIDEpIC8geSkgZWxzZSAwXG4gIFtAQGlubGluZV1cblxubGV0IHVuc2FmZV9nZXRfdWludDggdCBvZmYgPSBDaGFyLmNvZGUgKFN0cmluZy51bnNhZmVfZ2V0IHQgb2ZmKVxuXG5sZXQgdW5zYWZlX3NldF91aW50OCB0IG9mZiB2ID0gQnl0ZXMudW5zYWZlX3NldCB0IG9mZiAoQ2hhci5jaHIgdilcblxubGV0IHVuc2FmZV9zZXRfdWludDE2ID0gVW5zYWZlLnVuc2FmZV9zZXRfdWludDE2XG5cbmV4dGVybmFsIHVuc2FmZV9nZXRfdWludDE2IDogc3RyaW5nIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX3N0cmluZ19nZXQxNnVcIlxuICBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiIFtAQG5vYWxsb2NdXG5cbmxldCBub25lID0gLTFcblxuKCogV2UgbW9zdGx5IHdhbnQgdG8gaGF2ZSBhbiBvcHRpb25hbCBhcnJheSBmb3IgW2RtYXBdIChlLmcuIFtpbnQgb3B0aW9uXG4gICBhcnJheV0pLiBTbyB3ZSBjb25zaWRlciB0aGUgW25vbmVdIHZhbHVlIGFzIFstMV0uICopXG5cbmxldCBtYWtlX2FscGhhYmV0IGFscGhhYmV0ID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBhbHBoYWJldCA8PiA2NFxuICB0aGVuIGludmFsaWRfYXJnIFwiTGVuZ3RoIG9mIGFscGhhYmV0IG11c3QgYmUgNjRcIiA7XG4gIGlmIFN0cmluZy5jb250YWlucyBhbHBoYWJldCAnPSdcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFscGhhYmV0IGNhbiBub3QgY29udGFpbiBwYWRkaW5nIGNoYXJhY3RlclwiIDtcbiAgbGV0IGVtYXAgPVxuICAgIEFycmF5LmluaXQgKFN0cmluZy5sZW5ndGggYWxwaGFiZXQpIChmdW4gaSAtPiBDaGFyLmNvZGUgYWxwaGFiZXQuW2ldKSBpblxuICBsZXQgZG1hcCA9IEFycmF5Lm1ha2UgMjU2IG5vbmUgaW5cbiAgU3RyaW5nLml0ZXJpIChmdW4gaWR4IGNociAtPiBkbWFwLihDaGFyLmNvZGUgY2hyKSA8LSBpZHgpIGFscGhhYmV0IDtcbiAgeyBlbWFwOyBkbWFwIH1cblxubGV0IGxlbmd0aF9hbHBoYWJldCB7IGVtYXA7IF8gfSA9IEFycmF5Lmxlbmd0aCBlbWFwXG5cbmxldCBhbHBoYWJldCB7IGVtYXA7IF8gfSA9XG4gIFN0cmluZy5pbml0IChBcnJheS5sZW5ndGggZW1hcCkgKGZ1biBpIC0+IENoYXIuY2hyIGVtYXAuKGkpKVxuXG5sZXQgZGVmYXVsdF9hbHBoYWJldCA9XG4gIG1ha2VfYWxwaGFiZXRcbiAgICBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIlxuXG5sZXQgdXJpX3NhZmVfYWxwaGFiZXQgPVxuICBtYWtlX2FscGhhYmV0XG4gICAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fXCJcblxubGV0IHVuc2FmZV9zZXRfYmVfdWludDE2ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW5cbiAgdGhlbiBmdW4gdCBvZmYgdiAtPiB1bnNhZmVfc2V0X3VpbnQxNiB0IG9mZiB2XG4gIGVsc2UgZnVuIHQgb2ZmIHYgLT4gdW5zYWZlX3NldF91aW50MTYgdCBvZmYgKHN3YXAxNiB2KVxuXG4oKiBXZSBtYWtlIHRoaXMgZXhjZXB0aW9uIHRvIGVuc3VyZSB0byBrZWVwIGEgY29udHJvbCBhYm91dCB3aGljaCBleGNlcHRpb24gd2VcbiAgIGNhbiByYWlzZSBhbmQgYXZvaWQgYXBwZWFyYW5jZSBvZiB1bmtub3duIGV4Y2VwdGlvbnMgbGlrZSBhbiBleC1uaWhpbG9cbiAgIG1hZ2ljIHJhYmJpdCAob3IgbWFnaWMgbW9uZXk/KS4gKilcbmV4Y2VwdGlvbiBPdXRfb2ZfYm91bmRzXG5cbmV4Y2VwdGlvbiBUb29fbXVjaF9pbnB1dFxuXG5sZXQgZ2V0X3VpbnQ4IHQgb2ZmID1cbiAgaWYgb2ZmIDwgMCB8fCBvZmYgPj0gU3RyaW5nLmxlbmd0aCB0IHRoZW4gcmFpc2UgT3V0X29mX2JvdW5kcyA7XG4gIHVuc2FmZV9nZXRfdWludDggdCBvZmZcblxubGV0IHBhZGRpbmcgPSBpbnRfb2ZfY2hhciAnPSdcblxubGV0IGVycm9yX21zZ2YgZm10ID0gRm9ybWF0LmtzcHJpbnRmIChmdW4gZXJyIC0+IEVycm9yIChgTXNnIGVycikpIGZtdFxuXG5sZXQgZW5jb2RlX3N1YiBwYWQgeyBlbWFwOyBfIH0gPyhvZmYgPSAwKSA/bGVuIGlucHV0ID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIGlucHV0IC0gb2ZmIGluXG5cbiAgaWYgbGVuIDwgMCB8fCBvZmYgPCAwIHx8IG9mZiA+IFN0cmluZy5sZW5ndGggaW5wdXQgLSBsZW5cbiAgdGhlbiBlcnJvcl9tc2dmIFwiSW52YWxpZCBib3VuZHNcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBsZW4gaW5cbiAgICBsZXQgbicgPSBuIC8vIDMgKiA0IGluXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBuJyBpblxuXG4gICAgbGV0IGVtYXAgaSA9IEFycmF5LnVuc2FmZV9nZXQgZW1hcCBpIGluXG5cbiAgICBsZXQgZW1pdCBiMSBiMiBiMyBpID1cbiAgICAgIHVuc2FmZV9zZXRfYmVfdWludDE2IHJlcyBpXG4gICAgICAgICgoZW1hcCAoKGIxIGxzciAyKSBsYW5kIDB4M2YpIGxzbCA4KVxuICAgICAgICBsb3IgZW1hcCAoKGIxIGxzbCA0KSBsb3IgKGIyIGxzciA0KSBsYW5kIDB4M2YpKSA7XG4gICAgICB1bnNhZmVfc2V0X2JlX3VpbnQxNiByZXMgKGkgKyAyKVxuICAgICAgICAoKGVtYXAgKChiMiBsc2wgMikgbG9yIChiMyBsc3IgNikgbGFuZCAweDNmKSBsc2wgOClcbiAgICAgICAgbG9yIGVtYXAgKGIzIGxhbmQgMHgzZikpIGluXG5cbiAgICBsZXQgcmVjIGVuYyBqIGkgPVxuICAgICAgaWYgaSA9IG5cbiAgICAgIHRoZW4gKClcbiAgICAgIGVsc2UgaWYgaSA9IG4gLSAxXG4gICAgICB0aGVuIGVtaXQgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkpKSAwIDAgalxuICAgICAgZWxzZSBpZiBpID0gbiAtIDJcbiAgICAgIHRoZW5cbiAgICAgICAgZW1pdFxuICAgICAgICAgICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpKSlcbiAgICAgICAgICAodW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgaSArIDEpKVxuICAgICAgICAgIDAgalxuICAgICAgZWxzZSAoXG4gICAgICAgIGVtaXRcbiAgICAgICAgICAodW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgaSkpXG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkgKyAxKSlcbiAgICAgICAgICAodW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgaSArIDIpKVxuICAgICAgICAgIGogO1xuICAgICAgICBlbmMgKGogKyA0KSAoaSArIDMpKSBpblxuXG4gICAgbGV0IHJlYyB1bnNhZmVfZml4ID0gZnVuY3Rpb25cbiAgICAgIHwgMCAtPiAoKVxuICAgICAgfCBpIC0+XG4gICAgICAgICAgdW5zYWZlX3NldF91aW50OCByZXMgKG4nIC0gaSkgcGFkZGluZyA7XG4gICAgICAgICAgdW5zYWZlX2ZpeCAoaSAtIDEpIGluXG5cbiAgICBlbmMgMCAwIDtcblxuICAgIGxldCBwYWRfdG9fd3JpdGUgPSAoMyAtIChuIG1vZCAzKSkgbW9kIDMgaW5cblxuICAgIGlmIHBhZFxuICAgIHRoZW4gKFxuICAgICAgdW5zYWZlX2ZpeCBwYWRfdG9fd3JpdGUgO1xuICAgICAgT2sgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzLCAwLCBuJykpXG4gICAgZWxzZSBPayAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXMsIDAsIG4nIC0gcGFkX3RvX3dyaXRlKVxuXG4oKiBbcGFkID0gZmFsc2VdLCB3ZSBkb24ndCB3YW50IHRvIHdyaXRlIHRoZW0uICopXG5cbmxldCBlbmNvZGUgPyhwYWQgPSB0cnVlKSA/KGFscGhhYmV0ID0gZGVmYXVsdF9hbHBoYWJldCkgP29mZiA/bGVuIGlucHV0ID1cbiAgbWF0Y2ggZW5jb2RlX3N1YiBwYWQgYWxwaGFiZXQgP29mZiA/bGVuIGlucHV0IHdpdGhcbiAgfCBPayAocmVzLCBvZmYsIGxlbikgLT4gT2sgKFN0cmluZy5zdWIgcmVzIG9mZiBsZW4pXG4gIHwgRXJyb3IgXyBhcyBlcnIgLT4gZXJyXG5cbmxldCBlbmNvZGVfc3RyaW5nID9wYWQgP2FscGhhYmV0IGlucHV0ID1cbiAgbWF0Y2ggZW5jb2RlID9wYWQgP2FscGhhYmV0IGlucHV0IHdpdGhcbiAgfCBPayByZXMgLT4gcmVzXG4gIHwgRXJyb3IgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGVuY29kZV9zdWIgPyhwYWQgPSB0cnVlKSA/KGFscGhhYmV0ID0gZGVmYXVsdF9hbHBoYWJldCkgP29mZiA/bGVuIGlucHV0ID1cbiAgZW5jb2RlX3N1YiBwYWQgYWxwaGFiZXQgP29mZiA/bGVuIGlucHV0XG5cbmxldCBlbmNvZGVfZXhuID9wYWQgP2FscGhhYmV0ID9vZmYgP2xlbiBpbnB1dCA9XG4gIG1hdGNoIGVuY29kZSA/cGFkID9hbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgd2l0aFxuICB8IE9rIHYgLT4gdlxuICB8IEVycm9yIChgTXNnIGVycikgLT4gaW52YWxpZF9hcmcgZXJyXG5cbmxldCBkZWNvZGVfc3ViID8ocGFkID0gdHJ1ZSkgeyBkbWFwOyBfIH0gPyhvZmYgPSAwKSA/bGVuIGlucHV0ID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGggU29tZSBsZW4gLT4gbGVuIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIGlucHV0IC0gb2ZmIGluXG5cbiAgaWYgbGVuIDwgMCB8fCBvZmYgPCAwIHx8IG9mZiA+IFN0cmluZy5sZW5ndGggaW5wdXQgLSBsZW5cbiAgdGhlbiBlcnJvcl9tc2dmIFwiSW52YWxpZCBib3VuZHNcIlxuICBlbHNlXG4gICAgbGV0IG4gPSBsZW4gLy8gNCAqIDQgaW5cbiAgICBsZXQgbicgPSBuIC8vIDQgKiAzIGluXG4gICAgbGV0IHJlcyA9IEJ5dGVzLmNyZWF0ZSBuJyBpblxuICAgIGxldCBpbnZhbGlkX3BhZF9vdmVyZmxvdyA9IHBhZCBpblxuXG4gICAgbGV0IGdldF91aW50OF9vcl9wYWRkaW5nID1cbiAgICAgIGlmIHBhZFxuICAgICAgdGhlbiAoZnVuIHQgaSAtPlxuICAgICAgICBpZiBpID49IGxlbiB0aGVuIHJhaXNlIE91dF9vZl9ib3VuZHMgO1xuICAgICAgICBnZXRfdWludDggdCAob2ZmICsgaSkpXG4gICAgICBlbHNlXG4gICAgICAgIGZ1biB0IGkgLT5cbiAgICAgICAgdHJ5IGlmIGkgPCBsZW4gdGhlbiBnZXRfdWludDggdCAob2ZmICsgaSkgZWxzZSBwYWRkaW5nXG4gICAgICAgIHdpdGggT3V0X29mX2JvdW5kcyAtPiBwYWRkaW5nIGluXG5cbiAgICBsZXQgc2V0X2JlX3VpbnQxNiB0IG9mZiB2ID1cbiAgICAgICgqIGNhbiBub3Qgd3JpdGUgMiBieXRlcy4gKilcbiAgICAgIGlmIG9mZiA8IDAgfHwgb2ZmICsgMSA+IEJ5dGVzLmxlbmd0aCB0XG4gICAgICB0aGVuICgpICgqIGNhbiBub3Qgd3JpdGUgMSBieXRlIGJ1dCBjYW4gd3JpdGUgMSBieXRlICopXG4gICAgICBlbHNlIGlmIG9mZiA8IDAgfHwgb2ZmICsgMiA+IEJ5dGVzLmxlbmd0aCB0XG4gICAgICB0aGVuIHVuc2FmZV9zZXRfdWludDggdCBvZmYgKHYgbHNyIDgpICgqIGNhbiB3cml0ZSAyIGJ5dGVzLiAqKVxuICAgICAgZWxzZSB1bnNhZmVfc2V0X2JlX3VpbnQxNiB0IG9mZiB2IGluXG5cbiAgICBsZXQgc2V0X3VpbnQ4IHQgb2ZmIHYgPVxuICAgICAgaWYgb2ZmIDwgMCB8fCBvZmYgPj0gQnl0ZXMubGVuZ3RoIHQgdGhlbiAoKSBlbHNlIHVuc2FmZV9zZXRfdWludDggdCBvZmYgdlxuICAgIGluXG5cbiAgICBsZXQgZW1pdCBhIGIgYyBkIGogPVxuICAgICAgbGV0IHggPSAoYSBsc2wgMTgpIGxvciAoYiBsc2wgMTIpIGxvciAoYyBsc2wgNikgbG9yIGQgaW5cbiAgICAgIHNldF9iZV91aW50MTYgcmVzIGogKHggbHNyIDgpIDtcbiAgICAgIHNldF91aW50OCByZXMgKGogKyAyKSAoeCBsYW5kIDB4ZmYpIGluXG5cbiAgICBsZXQgZG1hcCBpID1cbiAgICAgIGxldCB4ID0gQXJyYXkudW5zYWZlX2dldCBkbWFwIGkgaW5cbiAgICAgIGlmIHggPSBub25lIHRoZW4gcmFpc2UgTm90X2ZvdW5kIDtcbiAgICAgIHggaW5cblxuICAgIGxldCBvbmx5X3BhZGRpbmcgcGFkIGlkeCA9XG4gICAgICAoKiBiZWNhdXNlIHdlIHJvdW5kIGxlbmd0aCBvZiBbcmVzXSB0byB0aGUgdXBwZXIgYm91bmQgb2YgaG93IG1hbnlcbiAgICAgICAgIGNoYXJhY3RlcnMgd2Ugc2hvdWxkIGhhdmUgZnJvbSBbaW5wdXRdLCB3ZSBnb3QgYXQgdGhpcyBzdGFnZSBvbmx5IHBhZGRpbmdcbiAgICAgICAgIGNoYXJhY3RlcnMgYW5kIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0sIHNvIGZvciBlYWNoIFs9PT09XSwgd2UgZGVsZXRlIDNcbiAgICAgICAgIGJ5dGVzLiAqKVxuICAgICAgbGV0IHBhZCA9IHJlZiAocGFkICsgMykgaW5cbiAgICAgIGxldCBpZHggPSByZWYgaWR4IGluXG5cbiAgICAgIHdoaWxlICFpZHggKyA0IDwgbGVuIGRvXG4gICAgICAgICgqIHVzZSBbdW5zYWZlX2dldF91aW50MTZdIGluc3RlYWQgW3Vuc2FmZV9nZXRfdWludDMyXSB0byBhdm9pZCBhbGxvY2F0aW9uXG4gICAgICAgICAgIG9mIFtpbnQzMl0uIE9mIGNvdXJzZSwgWzNkM2QzZDNkXSBpcyBbPT09PV0uICopXG4gICAgICAgIGlmIHVuc2FmZV9nZXRfdWludDE2IGlucHV0IChvZmYgKyAhaWR4KSA8PiAweDNkM2RcbiAgICAgICAgICAgfHwgdW5zYWZlX2dldF91aW50MTYgaW5wdXQgKG9mZiArICFpZHggKyAyKSA8PiAweDNkM2RcbiAgICAgICAgdGhlbiByYWlzZSBOb3RfZm91bmQgO1xuXG4gICAgICAgICgqIFdlIGdvdCBzb21ldGhpbmcgYmFkLCBzaG91bGQgYmUgYSB2YWxpZCBjaGFyYWN0ZXIgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgIFthbHBoYWJldF0gYnV0IG91dHNpZGUgdGhlIHNjb3BlLiAqKVxuICAgICAgICBpZHggOj0gIWlkeCArIDQgO1xuICAgICAgICBwYWQgOj0gIXBhZCArIDNcbiAgICAgIGRvbmUgO1xuICAgICAgd2hpbGUgIWlkeCA8IGxlbiBkb1xuICAgICAgICBpZiB1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyAhaWR4KSA8PiBwYWRkaW5nIHRoZW4gcmFpc2UgTm90X2ZvdW5kIDtcblxuICAgICAgICBpbmNyIGlkeFxuICAgICAgZG9uZSA7XG4gICAgICAhcGFkIGluXG5cbiAgICBsZXQgcmVjIGRlYyBqIGkgPVxuICAgICAgaWYgaSA9IG5cbiAgICAgIHRoZW4gMFxuICAgICAgZWxzZVxuICAgICAgICBsZXQgZCwgcGFkID1cbiAgICAgICAgICBsZXQgeCA9IGdldF91aW50OF9vcl9wYWRkaW5nIGlucHV0IChpICsgMykgaW5cbiAgICAgICAgICB0cnkgKGRtYXAgeCwgMCkgd2l0aCBOb3RfZm91bmQgd2hlbiB4ID0gcGFkZGluZyAtPiAoMCwgMSkgaW5cbiAgICAgICAgKCogW05vdF9mb3VuZF0gaWZmIFt4IOKIiSBhbHBoYWJldCBhbmQgeCA8PiAnPSddIGNhbiBsZWFrLiAqKVxuICAgICAgICBsZXQgYywgcGFkID1cbiAgICAgICAgICBsZXQgeCA9IGdldF91aW50OF9vcl9wYWRkaW5nIGlucHV0IChpICsgMikgaW5cbiAgICAgICAgICB0cnkgKGRtYXAgeCwgcGFkKVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIHdoZW4geCA9IHBhZGRpbmcgJiYgcGFkID0gMSAtPiAoMCwgMikgaW5cbiAgICAgICAgKCogW05vdF9mb3VuZF0gaWZmIFt4IOKIiSBhbHBoYWJldCBhbmQgeCA8PiAnPSddIGNhbiBsZWFrLiAqKVxuICAgICAgICBsZXQgYiwgcGFkID1cbiAgICAgICAgICBsZXQgeCA9IGdldF91aW50OF9vcl9wYWRkaW5nIGlucHV0IChpICsgMSkgaW5cbiAgICAgICAgICB0cnkgKGRtYXAgeCwgcGFkKVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIHdoZW4geCA9IHBhZGRpbmcgJiYgcGFkID0gMiAtPiAoMCwgMykgaW5cbiAgICAgICAgKCogW05vdF9mb3VuZF0gaWZmIFt4IOKIiSBhbHBoYWJldCBhbmQgeCA8PiAnPSddIGNhbiBsZWFrLiAqKVxuICAgICAgICBsZXQgYSwgcGFkID1cbiAgICAgICAgICBsZXQgeCA9IGdldF91aW50OF9vcl9wYWRkaW5nIGlucHV0IGkgaW5cbiAgICAgICAgICB0cnkgKGRtYXAgeCwgcGFkKVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIHdoZW4geCA9IHBhZGRpbmcgJiYgcGFkID0gMyAtPiAoMCwgNCkgaW5cblxuICAgICAgICAoKiBbTm90X2ZvdW5kXSBpZmYgW3gg4oiJIGFscGhhYmV0IGFuZCB4IDw+ICc9J10gY2FuIGxlYWsuICopXG4gICAgICAgIGVtaXQgYSBiIGMgZCBqIDtcblxuICAgICAgICBpZiBpICsgNCA9IG4gKCogZW5kIG9mIGlucHV0IGluIGFueXdheSAqKVxuICAgICAgICB0aGVuXG4gICAgICAgICAgbWF0Y2ggcGFkIHdpdGhcbiAgICAgICAgICB8IDAgLT4gMFxuICAgICAgICAgIHwgNCAtPlxuICAgICAgICAgICAgICAoKiBhc3NlcnQgKGludmFsaWRfcGFkX292ZXJmbG93ID0gZmFsc2UpIDsgKilcbiAgICAgICAgICAgICAgM1xuICAgICAgICAgICgqIFtnZXRfdWludDhdIGxpZXMgYW5kIGlmIHdlIGdldCBbNF0sIHRoYXQgbWVhbiB3ZSBnb3Qgb25lIG9yIG1vcmUgKGF0XG4gICAgICAgICAgICAgbW9zdCA0KSBwYWRkaW5nIGNoYXJhY3Rlci4gSW4gdGhpcyBzaXR1YXRpb24sIGJlY2F1c2Ugd2Ugcm91bmQgbGVuZ3RoXG4gICAgICAgICAgICAgb2YgW3Jlc10gKHNlZSBbbiAvLyA0XSksIHdlIG5lZWQgdG8gZGVsZXRlIDMgYnl0ZXMuICopXG4gICAgICAgICAgfCBwYWQgLT4gcGFkXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgICAgIHwgMCAtPiBkZWMgKGogKyAzKSAoaSArIDQpXG4gICAgICAgICAgfCA0IC0+XG4gICAgICAgICAgICAgICgqIGFzc2VydCAoaW52YWxpZF9wYWRfb3ZlcmZsb3cgPSBmYWxzZSkgOyAqKVxuICAgICAgICAgICAgICBvbmx5X3BhZGRpbmcgMyAoaSArIDQpXG4gICAgICAgICAgKCogU2FtZSBzaXR1YXRpb24gdGhhbiBhYm92ZSBidXQgd2Ugc2hvdWxkIGdldCBvbmx5IG1vcmUgcGFkZGluZ1xuICAgICAgICAgICAgIGNoYXJhY3RlcnMgdGhlbi4gKilcbiAgICAgICAgICB8IHBhZCAtPlxuICAgICAgICAgICAgICBpZiBpbnZhbGlkX3BhZF9vdmVyZmxvdyA9IHRydWUgdGhlbiByYWlzZSBUb29fbXVjaF9pbnB1dCA7XG4gICAgICAgICAgICAgIG9ubHlfcGFkZGluZyBwYWQgKGkgKyA0KSBpblxuXG4gICAgbWF0Y2ggZGVjIDAgMCB3aXRoXG4gICAgfCAwIC0+IE9rIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlcywgMCwgbicpXG4gICAgfCBwYWQgLT4gT2sgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzLCAwLCBuJyAtIHBhZClcbiAgICB8IGV4Y2VwdGlvbiBPdXRfb2ZfYm91bmRzIC0+XG4gICAgICAgIGVycm9yX21zZ2YgXCJXcm9uZyBwYWRkaW5nXCJcbiAgICAgICAgKCogYXBwZWFyIG9ubHkgd2hlbiBbcGFkID0gdHJ1ZV0gYW5kIHdoZW4gbGVuZ3RoIG9mIGlucHV0IGlzIG5vdCBhIG11bHRpcGxlIG9mIDQuICopXG4gICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgICAgICgqIGFwcGVhciB3aGVuIG9uZSBjaGFyYWN0ZXIgb2YgW2lucHV0XSDiiIkgW2FscGhhYmV0XSBhbmQgdGhpcyBjaGFyYWN0ZXIgPD4gJz0nICopXG4gICAgICAgIGVycm9yX21zZ2YgXCJNYWxmb3JtZWQgaW5wdXRcIlxuICAgIHwgZXhjZXB0aW9uIFRvb19tdWNoX2lucHV0IC0+IGVycm9yX21zZ2YgXCJUb28gbXVjaCBpbnB1dFwiXG5cbmxldCBkZWNvZGUgP3BhZCA/KGFscGhhYmV0ID0gZGVmYXVsdF9hbHBoYWJldCkgP29mZiA/bGVuIGlucHV0ID1cbiAgbWF0Y2ggZGVjb2RlX3N1YiA/cGFkIGFscGhhYmV0ID9vZmYgP2xlbiBpbnB1dCB3aXRoXG4gIHwgT2sgKHJlcywgb2ZmLCBsZW4pIC0+IE9rIChTdHJpbmcuc3ViIHJlcyBvZmYgbGVuKVxuICB8IEVycm9yIF8gYXMgZXJyIC0+IGVyclxuXG5sZXQgZGVjb2RlX3N1YiA/cGFkID8oYWxwaGFiZXQgPSBkZWZhdWx0X2FscGhhYmV0KSA/b2ZmID9sZW4gaW5wdXQgPVxuICBkZWNvZGVfc3ViID9wYWQgYWxwaGFiZXQgP29mZiA/bGVuIGlucHV0XG5cbmxldCBkZWNvZGVfZXhuID9wYWQgP2FscGhhYmV0ID9vZmYgP2xlbiBpbnB1dCA9XG4gIG1hdGNoIGRlY29kZSA/cGFkID9hbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgd2l0aFxuICB8IE9rIHJlcyAtPiByZXNcbiAgfCBFcnJvciAoYE1zZyBlcnIpIC0+IGludmFsaWRfYXJnIGVyclxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
