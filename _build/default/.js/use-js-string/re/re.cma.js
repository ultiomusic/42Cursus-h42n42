// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Re__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Re = [0];
   runtime.caml_register_global(0, Re, "Re__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Bit_vector
//# unitInfo: Requires: Stdlib, Stdlib__Bytes, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib = global_data.Stdlib,
    Stdlib_Char = global_data.Stdlib__Char,
    cst_Bit_vector_set = "Bit_vector.set",
    cst_Bit_vector_get = "Bit_vector.get";
   function length(t){return t[1];}
   function set(v, n, b){
    var _f_ = n < 0 ? 1 : 0, _g_ = _f_ || (v[1] <= n ? 1 : 0);
    if(_g_) caml_call1(Stdlib[1], cst_Bit_vector_set);
    var
     i = n >>> 3 | 0,
     s = v[2],
     c = caml_bytes_unsafe_get(s, i),
     mask = 1 << (n & 7),
     x = b ? c | mask : c & caml_call1(Stdlib[21], mask),
     s$0 = v[2];
    runtime.caml_bytes_unsafe_set(s$0, i, caml_call1(Stdlib_Char[1], x));
    return 0;
   }
   function get(v, n){
    var _d_ = n < 0 ? 1 : 0, _e_ = _d_ || (v[1] <= n ? 1 : 0);
    if(_e_) caml_call1(Stdlib[1], cst_Bit_vector_get);
    var i = n >>> 3 | 0, s = v[2];
    return 0 < (caml_bytes_unsafe_get(s, i) & 1 << (n & 7)) ? 1 : 0;
   }
   function reset_zero(t){
    var _b_ = runtime.caml_ml_bytes_length(t[2]) - 1 | 0, _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      runtime.caml_bytes_set(t[2], i, 0);
      var _c_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _c_;
     }
    }
    return 0;
   }
   function create_zero(len){
    var
     r = len & 7,
     q = len >>> 3 | 0,
     len$0 = 0 === r ? q : q + 1 | 0,
     bits = caml_call2(Stdlib_Bytes[1], len$0, 0);
    return [0, len, bits];
   }
   var Re_Bit_vector = [0, length, set, create_zero, get, reset_zero];
   runtime.caml_register_global(5, Re_Bit_vector, "Re__Bit_vector");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Category
//# unitInfo: Requires: Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function to_int(x){return x;}
   var pp = Stdlib_Format[19];
   function intersect(x, y){return 0 !== (x & y) ? 1 : 0;}
   function symbol(x, y){return x | y;}
   var letter = 2, not_letter = 4;
   function from_char(param){
    a:
    {
     if(170 <= param)
      if(187 <= param){
       var _a_ = param - 192 | 0;
       if(54 < _a_ >>> 0){if(56 <= _a_) break a;} else if(23 !== _a_) break a;
      }
      else{
       var _b_ = param - 171 | 0;
       if(14 < _b_ >>> 0 || 10 === _b_) break a;
      }
     else if(65 <= param){
      var _c_ = param - 91 | 0;
      if(5 < _c_ >>> 0){if(32 > _c_) break a;} else if(4 === _c_) break a;
     }
     else
      if(48 <= param){
       if(58 > param) break a;
      }
      else if(10 === param) return 12;
     return not_letter;
    }
    return letter;
   }
   var
    Re_Category =
      [0,
       symbol,
       from_char,
       -1,
       1,
       letter,
       not_letter,
       8,
       16,
       32,
       to_int,
       equal,
       compare,
       intersect,
       pp];
   runtime.caml_register_global(1, Re_Category, "Re__Category");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Fmt
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_3 = "<3>", cst = "@ ";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Format = global_data.Stdlib__Format,
    pp_print_string = Stdlib_Format[13],
    pp_print_int = Stdlib_Format[19],
    pp_print_space = Stdlib_Format[28],
    pp_print_list = Stdlib_Format[132],
    fprintf = Stdlib_Format[139],
    _a_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12, 40, [2, 0, [17, [0, cst, 1, 0], [15, [12, 41, [17, 0, 0]]]]]]],
       "@[<3>(%s@ %a)@]"],
    _b_ = [0, [17, [0, cst, 1, 0], [4, 0, 0, 0, 0]], "@ %d"],
    _c_ = [0, [12, 34, [2, 0, [12, 34, 0]]], '"%s"'],
    _d_ = [0, [12, 59, [17, [0, cst, 1, 0], 0]], ";@ "],
    _e_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12,
         91,
         [17,
          [0, cst, 1, 0],
          [15, [17, [0, cst, 1, 0], [12, 93, [17, 0, 0]]]]]]],
       "@[<3>[@ %a@ ]@]"];
   function sexp(fmt, s, pp, x){
    return caml_call5(fprintf, fmt, _a_, s, pp, x);
   }
   function pair(pp1, pp2, fmt, param){
    var v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp2, fmt, v2);
   }
   function triple(pp1, pp2, pp3, fmt, param){
    var v3 = param[3], v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    caml_call2(pp2, fmt, v2);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp3, fmt, v3);
   }
   function optint(fmt, param){
    if(! param) return 0;
    var i = param[1];
    return caml_call3(fprintf, fmt, _b_, i);
   }
   function pp_elem(fmt, s){
    return caml_call3(Stdlib_Format[139], fmt, _c_, s);
   }
   function pp_str_list(fmt){
    var
     _f_ =
       caml_call2
        (pp_print_list,
         [0, function(fmt, param){return caml_call2(fprintf, fmt, _d_);}],
         pp_elem);
    return caml_call3(Stdlib_Format[139], fmt, _e_, _f_);
   }
   function to_to_string(pp, x){
    var
     b = caml_call1(Stdlib_Buffer[1], 16),
     fmt = caml_call1(Stdlib_Format[116], b);
    caml_call2(pp, fmt, x);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   var
    Re_Fmt =
      [0,
       pp_str_list,
       sexp,
       pp_print_string,
       optint,
       pp_print_int,
       pair,
       triple,
       pp_print_list,
       to_to_string];
   runtime.caml_register_global(7, Re_Fmt, "Re__Fmt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Import
//# unitInfo: Requires: Stdlib__Int
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Int = global_data.Stdlib__Int,
    equal = runtime.caml_equal,
    Poly = [0, equal],
    symbol = Stdlib_Int[8],
    Re_Import = [0, Poly, symbol];
   runtime.caml_register_global(1, Re_Import, "Re__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Cset
//# unitInfo: Requires: Re__Fmt, Stdlib, Stdlib__Char, Stdlib__Format, Stdlib__Int, Stdlib__ListLabels, Stdlib__Map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cany = [0, [0, 0, 255], 0],
    cst = "\t ",
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Char = global_data.Stdlib__Char,
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Map = global_data.Stdlib__Map;
   function to_int(x){return x;}
   function of_int(x){return x;}
   function to_char(t){return caml_call1(Stdlib_Char[1], t);}
   function of_char(c){return c;}
   var
    equal =
      caml_call1
       (Stdlib_ListLabels[16],
        function(_N_, param){
         var
          y = param[2],
          x = param[1],
          y$0 = _N_[2],
          x$0 = _N_[1],
          _O_ = caml_call2(Stdlib_Int[8], x$0, x);
         return _O_ ? caml_call2(Stdlib_Int[8], y$0, y) : _O_;
        });
   function union(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return l$1;
     var
      r = l$1[2],
      _M_ = l$1[1],
      c2 = _M_[2],
      c1 = _M_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if((c2$0 + 1 | 0) < c1) return [0, [0, c1$0, c2$0], union(r$0, l$1)];
     if((c2 + 1 | 0) < c1$0) return [0, [0, c1, c2], union(l$2, r)];
     if(c2$0 < c2){
      var l$3 = [0, [0, caml_call2(Stdlib[16], c1$0, c1), c2], r];
      l$2 = r$0;
      l$1 = l$3;
     }
     else{
      var l$4 = [0, [0, caml_call2(Stdlib[16], c1$0, c1), c2$0], r$0];
      l$2 = l$4;
      l$1 = r;
     }
    }
   }
   function inter(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return 0;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _J_ = l$1[1],
      c2 = _J_[2],
      c1 = _J_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(caml_lessthan(c2$0, c1))
      l$2 = r$0;
     else{
      if(! caml_lessthan(c2, c1$0)){
       if(caml_lessthan(c2$0, c2)){
        var _K_ = inter(r$0, l$1);
        return [0, [0, caml_call2(Stdlib[17], c1$0, c1), c2$0], _K_];
       }
       var _L_ = inter(l$2, r);
       return [0, [0, caml_call2(Stdlib[17], c1$0, c1), c2], _L_];
      }
      l$1 = r;
     }
    }
   }
   function diff(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _I_ = l$1[1],
      c2 = _I_[2],
      c1 = _I_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(c2$0 < c1) return [0, [0, c1$0, c2$0], diff(r$0, l$1)];
     if(c2 < c1$0)
      l$1 = r;
     else{
      var r$1 = c2 < c2$0 ? [0, [0, c2 + 1 | 0, c2$0], r$0] : r$0;
      if(c1$0 < c1) return [0, [0, c1$0, c1 - 1 | 0], diff(r$1, r)];
      l$2 = r$1;
      l$1 = r;
     }
    }
   }
   function single(c){return [0, [0, c, c], 0];}
   function add(c, l){return union(single(c), l);}
   function seq(c$0, c){
    return runtime.caml_lessequal(c$0, c)
            ? [0, [0, c$0, c], 0]
            : [0, [0, c, c$0], 0];
   }
   function offset(o, l){
    if(! l) return 0;
    var r = l[2], match = l[1], c2 = match[2], c1 = match[1];
    return [0, [0, c1 + o | 0, c2 + o | 0], offset(o, r)];
   }
   var
    empty = 0,
    union_all = caml_call2(Stdlib_ListLabels[26], union, empty),
    intersect_all = caml_call2(Stdlib_ListLabels[26], inter, cany),
    _a_ = [0, [4, 0, 0, 0, 0], "%d"],
    _b_ = [0, [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]], "%d-%d"];
   function mem(c, s){
    var s$0 = s;
    for(;;){
     if(! s$0) return 0;
     var rem = s$0[2], match = s$0[1], c2 = match[2], c1 = match[1];
     if(c <= c2) return c1 <= c ? 1 : 0;
     s$0 = rem;
    }
   }
   function hash_rec(param){
    if(! param) return 0;
    var r = param[2], match = param[1], j = match[2], i = match[1];
    return (i + (13 * j | 0) | 0) + (257 * hash_rec(r) | 0) | 0;
   }
   function hash(l){return hash_rec(l) & 1073741823;}
   function print_one(ch, param){
    var c2 = param[2], c1 = param[1];
    return caml_call2(Stdlib_Int[8], c1, c2)
            ? caml_call3(Stdlib_Format[139], ch, _a_, c1)
            : caml_call4(Stdlib_Format[139], ch, _b_, c1, c2);
   }
   var pp = caml_call2(Re_Fmt[8], 0, print_one);
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var xs = t$0[2], match = t$0[1], y = match[2], x = match[1];
     caml_call2(f, x, y);
     t$0 = xs;
    }
   }
   function one_char(param){
    if(param && ! param[2]){
     var match = param[1], j = match[2], i = match[1];
     if(caml_call2(Stdlib_Int[8], i, j)) return [0, i];
    }
    return 0;
   }
   function compare(_H_, param){
    var
     v = param[2],
     j = param[1],
     u = _H_[2],
     i = _H_[1],
     c = caml_compare(i, j);
    return 0 === c ? caml_compare(u, v) : c;
   }
   var
    CSetMap = caml_call1(Stdlib_Map[1], [0, compare]),
    _c_ = [0, "lib/cset.ml", 163, 9],
    cst_Re_cset_pick = "Re_cset.pick";
   function fold_right(t, init, f){
    return caml_call3(Stdlib_ListLabels[27], f, t, init);
   }
   function csingle(c){return single(c);}
   function is_empty(param){return param ? 0 : 1;}
   function prepend(s, x, l){
    var s$0 = s;
    for(;;){
     if(! s$0) return l;
     if(! l) return 0;
     var _C_ = l[1], _D_ = _C_[1];
     if(_D_ && ! _D_[2]){
      var
       x$0 = _C_[2],
       _E_ = _D_[1],
       d = _E_[2],
       d$0 = _E_[1],
       r = s$0[2],
       match = s$0[1],
       c = match[2],
       c$0 = match[1];
      if(c < d$0){s$0 = r; continue;}
      var r$0 = l[2];
      if(c$0 > d$0)
       return d < c$0
               ? [0, [0, [0, [0, d$0, d], 0], x$0], prepend(s$0, x, r$0)]
               : [0,
                 [0, [0, [0, d$0, c$0 - 1 | 0], 0], x$0],
                 prepend(s$0, x, [0, [0, [0, [0, c$0, d], 0], x$0], r$0])];
      if(c < d){
       var _F_ = prepend(r, x, [0, [0, [0, [0, c + 1 | 0, d], 0], x$0], r$0]);
       return [0,
               [0, [0, [0, d$0, c], 0], caml_call2(Stdlib[37], x, x$0)],
               _F_];
      }
      var _G_ = prepend(s$0, x, r$0);
      return [0,
              [0, [0, [0, d$0, d], 0], caml_call2(Stdlib[37], x, x$0)],
              _G_];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
   }
   function pick(param){
    if(! param) return caml_call1(Stdlib[1], cst_Re_cset_pick);
    var x = param[1][1];
    return x;
   }
   function cseq(c$0, c){return seq(c$0, c);}
   var
    _d_ = [0, seq(216, 222), 0],
    _e_ = [0, seq(192, 214), _d_],
    upper = caml_call1(union_all, [0, seq(65, 90), _e_]),
    clower = offset(32, upper),
    cdigit = seq(48, 57),
    ascii = seq(0, 127);
   function cadd(c, s){return add(c, s);}
   var
    space = add(32, seq(9, 13)),
    _f_ = [0, seq(65, 70), 0],
    xdigit = caml_call1(union_all, [0, cdigit, [0, seq(97, 102), _f_]]),
    _g_ = union(clower, upper),
    calpha =
      caml_call3
       (Stdlib_ListLabels[27],
        cadd,
        [0, 170, [0, 181, [0, 186, [0, 223, [0, 255, 0]]]]],
        _g_),
    calnum = union(calpha, cdigit);
   function case_insens(s){
    var _B_ = [0, offset(-32, inter(s, clower)), 0];
    return caml_call1
            (union_all, [0, s, [0, offset(32, inter(s, upper)), _B_]]);
   }
   var
    cword = add(95, calnum),
    notnl = diff(cany, single(10)),
    nl = single(10);
   function set(str){
    var
     s = [0, empty],
     _y_ = runtime.caml_ml_string_length(str) - 1 | 0,
     _x_ = 0;
    if(_y_ >= 0){
     var i = _x_;
     for(;;){
      var _z_ = s[1], c = runtime.caml_string_get(str, i);
      s[1] = union(single(c), _z_);
      var _A_ = i + 1 | 0;
      if(_y_ === i) break;
      i = _A_;
     }
    }
    return s[1];
   }
   var
    blank = set(cst),
    _h_ = [0, seq(248, 255), 0],
    _i_ = [0, seq(223, 246), _h_],
    _j_ = [0, single(181), _i_],
    lower = caml_call1(union_all, [0, seq(97, 122), _j_]),
    _k_ = [0, single(186), 0],
    alpha =
      caml_call1(union_all, [0, lower, [0, upper, [0, single(170), _k_]]]),
    alnum = caml_call1(union_all, [0, alpha, [0, cdigit, 0]]),
    wordc = caml_call1(union_all, [0, alnum, [0, single(95), 0]]),
    _l_ = [0, seq(127, 159), 0],
    cntrl = caml_call1(union_all, [0, seq(0, 31), _l_]),
    _m_ = [0, seq(160, 255), 0],
    graph = caml_call1(union_all, [0, seq(33, 126), _m_]),
    _n_ = [0, seq(160, 255), 0],
    print = caml_call1(union_all, [0, seq(32, 126), _n_]),
    _o_ = [0, single(247), 0],
    _p_ = [0, single(215), _o_],
    _q_ = [0, seq(187, 191), _p_],
    _r_ = [0, seq(182, 185), _q_],
    _s_ = [0, seq(171, 180), _r_],
    _t_ = [0, seq(160, 169), _s_],
    _u_ = [0, seq(123, 126), _t_],
    _v_ = [0, seq(91, 96), _u_],
    _w_ = [0, seq(58, 64), _v_],
    punct = caml_call1(union_all, [0, seq(33, 47), _w_]),
    Re_Cset =
      [0,
       to_int,
       of_int,
       to_char,
       of_char,
       equal,
       iter,
       union,
       union_all,
       intersect_all,
       inter,
       diff,
       offset,
       empty,
       single,
       seq,
       add,
       mem,
       case_insens,
       cdigit,
       calpha,
       cword,
       notnl,
       ascii,
       nl,
       cseq,
       set,
       blank,
       space,
       xdigit,
       lower,
       upper,
       alpha,
       alnum,
       wordc,
       cntrl,
       graph,
       print,
       punct,
       hash,
       pp,
       one_char,
       fold_right,
       hash_rec,
       CSetMap,
       cany,
       csingle,
       is_empty,
       prepend,
       pick];
   runtime.caml_register_global(15, Re_Cset, "Re__Cset");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Mark_infos
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function make(marks){
    var
     len =
       1
       +
        caml_call3
         (Stdlib_List[26],
          function(ma, param){
           var i = param[1];
           return caml_call2(Stdlib[17], ma, i);
          },
          -1,
          marks)
       | 0,
     t = runtime.caml_make_vect(len, -1);
    caml_call2
     (Stdlib_List[18],
      function(param){
       var v = param[2], i = param[1];
       caml_check_bound(t, i)[1 + i] = v;
       return 0;
      },
      marks);
    return t;
   }
   function test(t, i){
    if(t.length - 1 <= (2 * i | 0)) return 0;
    var _e_ = 2 * i | 0;
    return -1 !== caml_check_bound(t, _e_)[1 + _e_] ? 1 : 0;
   }
   function offset(t, i){
    var start_i = 2 * i | 0, stop_i = start_i + 1 | 0;
    if(t.length - 1 <= stop_i) return 0;
    var start = caml_check_bound(t, start_i)[1 + start_i];
    if(-1 === start) return 0;
    var stop = caml_check_bound(t, stop_i)[1 + stop_i];
    return [0, [0, start, stop]];
   }
   function iteri(t, f){
    var _b_ = ((t.length - 1) / 2 | 0) - 1 | 0, _a_ = 0;
    if(_b_ >= 0){
     var i = _a_;
     for(;;){
      var idx = 2 * i | 0, start = caml_check_bound(t, idx)[1 + idx];
      if(-1 !== start){
       var _c_ = idx + 1 | 0, stop = caml_check_bound(t, _c_)[1 + _c_];
       caml_call3(f, i, start, stop);
      }
      var _d_ = i + 1 | 0;
      if(_b_ === i) break;
      i = _d_;
     }
    }
    return 0;
   }
   var Re_Mark_infos = [0, make, offset, test, iteri];
   runtime.caml_register_global(2, Re_Mark_infos, "Re__Mark_infos");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pmark
//# unitInfo: Requires: Stdlib__Format, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Set = global_data.Stdlib__Set;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare, r = [0, 0];
   function gen(param){r[1]++; return r[1];}
   var
    pp = Stdlib_Format[19],
    Set = caml_call1(Stdlib_Set[1], [0, compare]),
    Re_Pmark = [0, equal, compare, gen, pp, Set];
   runtime.caml_register_global(2, Re_Pmark, "Re__Pmark");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Automata
//# unitInfo: Requires: Re__Bit_vector, Re__Category, Re__Cset, Re__Fmt, Re__Import, Re__Mark_infos, Re__Pmark, Stdlib__Format, Stdlib__Hashtbl, Stdlib__Int, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    _a_ = [1, 0],
    eps_expr = [0, 0, 0],
    Re_Fmt = global_data.Re__Fmt,
    Re_Cset = global_data.Re__Cset,
    Re_Category = global_data.Re__Category,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Bit_vector = global_data.Re__Bit_vector,
    Re_Import = global_data.Re__Import,
    Re_Mark_infos = global_data.Re__Mark_infos,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Format = global_data.Stdlib__Format,
    Re_Pmark = global_data.Re__Pmark,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Int = global_data.Stdlib__Int;
   function create(param){return [0, 0];}
   var
    equal = Re_Import[1][1],
    cst_long = "long",
    cst_first = "first",
    cst_short = "short",
    cst_Non_greedy = "Non_greedy",
    cst_Greedy = "Greedy";
   function pp(ch, k){
    var
     _an_ =
       -730718166 === k ? cst_long : 332064784 <= k ? cst_first : cst_short;
    return caml_call2(Stdlib_Format[13], ch, _an_);
   }
   function pp$0(fmt, param){
    return 620821490 <= param
            ? caml_call2(Stdlib_Format[13], fmt, cst_Non_greedy)
            : caml_call2(Stdlib_Format[13], fmt, cst_Greedy);
   }
   var Rep_kind = [0, pp$0];
   function prev(x){return x - 1 | 0;}
   function next(x){return x + 1 | 0;}
   function next2(x){return x + 2 | 0;}
   function group_count(x){return x / 2 | 0;}
   var Mark = [0, 0, prev, next, next2, group_count];
   function hash_combine(h, accu){return (accu * 65599 | 0) + h | 0;}
   function equal$0(param, t){
    var
     pmarks = param[2],
     marks = param[1],
     _ak_ =
       caml_call3
        (Stdlib_ListLabels[16],
         function(_al_, param){
          var
           y = param[2],
           x = param[1],
           y$0 = _al_[2],
           x$0 = _al_[1],
           _am_ = caml_call2(Stdlib_Int[8], x$0, x);
          return _am_ ? caml_call2(Stdlib_Int[8], y$0, y) : _am_;
         },
         marks,
         t[1]);
    return _ak_ ? caml_call2(Re_Pmark[5][32], pmarks, t[2]) : _ak_;
   }
   var
    empty = [0, 0, Re_Pmark[5][1]],
    cst_eps = "eps",
    cst_cst = "cst",
    cst_alt = "alt",
    cst_seq = "seq",
    cst_rep = "rep",
    cst_mark = "mark",
    cst_erase = "erase",
    cst_before = "before",
    cst_after = "after",
    cst_pmark = "pmark";
   function merge_marks_offset(old, param){
    if(! param) return old;
    var
     rem = param[2],
     match = param[1],
     v = match[2],
     i = match[1],
     nw = merge_marks_offset(caml_call2(Stdlib_ListLabels[56], i, old), rem);
    return caml_call2(Re_Import[2], v, -2) ? nw : [0, [0, i, v], nw];
   }
   function merge(old, nw){
    var _aj_ = caml_call2(Re_Pmark[5][5], old[2], nw[2]);
    return [0, merge_marks_offset(old[1], nw[1]), _aj_];
   }
   function hash(m, accu$1){
    var
     accu$2 = hash_combine(caml_call1(Stdlib_Hashtbl[28], m[2]), accu$1),
     l$0 = m[1],
     l = l$0,
     accu = accu$2;
    for(;;){
     if(! l) return accu;
     var
      r = l[2],
      match = l[1],
      i = match[2],
      a = match[1],
      accu$0 = hash_combine(a, hash_combine(i, accu));
     l = r;
     accu = accu$0;
    }
   }
   function marks_set_idx(idx, marks){
    if(marks){
     var _ai_ = marks[1];
     if(-1 === _ai_[2]){
      var rem = marks[2], a = _ai_[1];
      return [0, [0, a, idx], marks_set_idx(idx, rem)];
     }
    }
    return marks;
   }
   function marks_set_idx$0(marks, idx){
    var _ah_ = marks[2];
    return [0, marks_set_idx(idx, marks[1]), _ah_];
   }
   function filter(t, b, e){
    var _ae_ = t[2];
    return [0,
            caml_call2
             (Stdlib_ListLabels[44],
              function(param){
               var
                i = param[1],
                _af_ = i < b ? 1 : 0,
                _ag_ = _af_ || (e < i ? 1 : 0);
               return _ag_;
              },
              t[1]),
            _ae_];
   }
   function set_mark(t, i){
    var _ad_ = t[2];
    return [0,
            [0, [0, i, -1], caml_call2(Stdlib_ListLabels[56], i, t[1])],
            _ad_];
   }
   function pp$1(ch, e){
    var match = e[2];
    if(typeof match === "number") return caml_call2(Re_Fmt[3], ch, cst_eps);
    switch(match[0]){
      case 0:
       var l = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_cst, Re_Cset[40], l);
      case 1:
       var l$0 = match[1], _$_ = caml_call2(Re_Fmt[8], 0, pp$1);
       return caml_call4(Re_Fmt[2], ch, cst_alt, _$_, l$0);
      case 2:
       var
        e$0 = match[3],
        e$1 = match[2],
        k = match[1],
        _aa_ = caml_call3(Re_Fmt[7], pp, pp$1, pp$1);
       return caml_call4(Re_Fmt[2], ch, cst_seq, _aa_, [0, k, e$1, e$0]);
      case 3:
       var
        e$2 = match[3],
        k$0 = match[2],
        _ab_ = caml_call2(Re_Fmt[6], pp, pp$1);
       return caml_call4(Re_Fmt[2], ch, cst_rep, _ab_, [0, k$0, e$2]);
      case 4:
       var i = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_mark, Re_Fmt[5], i);
      case 5:
       var
        e$3 = match[2],
        b = match[1],
        _ac_ = caml_call2(Re_Fmt[6], Re_Fmt[5], Re_Fmt[5]);
       return caml_call4(Re_Fmt[2], ch, cst_erase, _ac_, [0, b, e$3]);
      case 6:
       var c = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_before, Re_Category[14], c);
      case 7:
       var c$0 = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_after, Re_Category[14], c$0);
      default:
       var i$0 = match[1];
       return caml_call4(Re_Fmt[2], ch, cst_pmark, Re_Fmt[5], i$0);
    }
   }
   function mk_expr(ids, def){ids[1]++; return [0, ids[1], def];}
   function empty$0(ids){return mk_expr(ids, _a_);}
   function cst(ids, s){
    return caml_call1(Re_Cset[47], s)
            ? mk_expr(ids, _a_)
            : mk_expr(ids, [0, s]);
   }
   function alt(ids, l){
    if(! l) return mk_expr(ids, _a_);
    if(l[2]) return mk_expr(ids, [1, l]);
    var c = l[1];
    return c;
   }
   function seq(ids, kind, x, y){
    var _Z_ = x[2], ___ = y[2];
    if(typeof _Z_ !== "number" && 1 === _Z_[0] && ! _Z_[1]) return x;
    if(typeof ___ !== "number" && 1 === ___[0] && ! ___[1]) return y;
    if(typeof _Z_ === "number") return y;
    if(typeof ___ === "number" && caml_call2(equal, kind, 332064784))
     return x;
    return mk_expr(ids, [2, kind, x, y]);
   }
   function is_eps(expr){return typeof expr[2] === "number" ? 1 : 0;}
   function eps(ids){return mk_expr(ids, 0);}
   function rep(ids, kind, sem, x){return mk_expr(ids, [3, kind, sem, x]);}
   function mark(ids, m){return mk_expr(ids, [4, m]);}
   function pmark(ids, i){return mk_expr(ids, [8, i]);}
   function erase(ids, m$0, m){return mk_expr(ids, [5, m$0, m]);}
   function before(ids, c){return mk_expr(ids, [6, c]);}
   function after(ids, c){return mk_expr(ids, [7, c]);}
   function rename(ids, x){
    var match = x[2];
    if(typeof match !== "number")
     switch(match[0]){
       case 1:
        var l = match[1];
        return mk_expr
                (ids,
                 [1,
                  caml_call2
                   (Stdlib_ListLabels[20],
                    function(_Y_){return rename(ids, _Y_);},
                    l)]);
       case 2:
        var z = match[3], y = match[2], k = match[1], _X_ = rename(ids, z);
        return mk_expr(ids, [2, k, rename(ids, y), _X_]);
       case 3:
        var y$0 = match[3], k$0 = match[2], g = match[1];
        return mk_expr(ids, [3, g, k$0, rename(ids, y$0)]);
     }
    return mk_expr(ids, x[2]);
   }
   function is_tmatch(param){return 2 === param[0] ? 1 : 0;}
   function equal$1(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      var _P_ = l1$0[1];
      switch(_P_[0]){
        case 0:
         if(l2$0){
          var match = l2$0[1], r1 = l1$0[2], e1 = _P_[2], l1$1 = _P_[1];
          if(0 === match[0]){
           var
            r2 = l2$0[2],
            e2 = match[2],
            l2$1 = match[1],
            _Q_ = caml_call2(Re_Import[2], e1[1], e2[1]);
           if(_Q_){
            var _R_ = equal$1(l1$1, l2$1);
            if(_R_){l1$0 = r1; l2$0 = r2; continue;}
            var _S_ = _R_;
           }
           else
            var _S_ = _Q_;
           return _S_;
          }
         }
         break;
        case 1:
         if(l2$0){
          var
           match$0 = l2$0[1],
           r1$0 = l1$0[2],
           e1$0 = _P_[2],
           marks1 = _P_[1];
          if(1 === match$0[0]){
           var
            r2$0 = l2$0[2],
            e2$0 = match$0[2],
            marks2 = match$0[1],
            _T_ = caml_call2(Re_Import[2], e1$0[1], e2$0[1]);
           if(_T_){
            var _U_ = equal$0(marks1, marks2);
            if(_U_){l1$0 = r1$0; l2$0 = r2$0; continue;}
            var _V_ = _U_;
           }
           else
            var _V_ = _T_;
           return _V_;
          }
         }
         break;
        default:
         if(l2$0){
          var match$1 = l2$0[1], r1$1 = l1$0[2], marks1$0 = _P_[1];
          if(2 === match$1[0]){
           var
            r2$1 = l2$0[2],
            marks2$0 = match$1[1],
            _W_ = equal$0(marks1$0, marks2$0);
           if(! _W_) return _W_;
           l1$0 = r1$1;
           l2$0 = r2$1;
           continue;
          }
         }
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function hash$0(l, accu){
    var l$0 = l, accu$0 = accu;
    for(;;){
     if(! l$0) return accu$0;
     var match = l$0[1];
     switch(match[0]){
       case 0:
        var
         r = l$0[2],
         e = match[2],
         l$1 = match[1],
         _N_ = hash$0(l$1, accu$0),
         accu$1 = hash_combine(388635598, hash_combine(e[1], _N_));
        l$0 = r;
        accu$0 = accu$1;
        break;
       case 1:
        var
         r$0 = l$0[2],
         e$0 = match[2],
         marks = match[1],
         _O_ = hash(marks, accu$0),
         accu$2 = hash_combine(726404471, hash_combine(e$0[1], _O_));
        l$0 = r$0;
        accu$0 = accu$2;
        break;
       default:
        var
         r$1 = l$0[2],
         marks$0 = match[1],
         accu$3 = hash_combine(471882453, hash(marks$0, accu$0));
        l$0 = r$1;
        accu$0 = accu$3;
     }
    }
   }
   function tseq(kind, x, y, rem){
    if(! x) return rem;
    var _M_ = x[1];
    if(1 === _M_[0] && typeof _M_[2][2] === "number" && ! x[2]){var marks = _M_[1]; return [0, [1, marks, y], rem];}
    return [0, [0, x, y, kind], rem];
   }
   function first_match(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var match = param$0[1];
     if(2 === match[0]){var marks = match[1]; return [0, marks];}
     var r = param$0[2];
     param$0 = r;
    }
   }
   var
    remove_matches =
      caml_call1
       (Stdlib_ListLabels[44],
        function(param){return 2 === param[0] ? 0 : 1;}),
    _b_ = [0, "lib/automata.ml", 317, 14];
   function split_at_match(l$1){
    var l = 0, param = l$1;
    for(;;){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var x = param[1];
     if(2 === x[0]){
      var r$0 = param[2], _L_ = caml_call1(remove_matches, r$0);
      return [0, caml_call1(Stdlib_ListLabels[10], l), _L_];
     }
     var r = param[2], l$0 = [0, x, l];
     l = l$0;
     param = r;
    }
   }
   var exists_tmatch = caml_call1(Stdlib_ListLabels[34], is_tmatch);
   function set_idx(idx, param){
    if(! param) return 0;
    var match = param[1];
    switch(match[0]){
      case 0:
       var
        r = param[2],
        kind = match[3],
        x = match[2],
        l = match[1],
        _I_ = set_idx(idx, r);
       return [0, [0, set_idx(idx, l), x, kind], _I_];
      case 1:
       var
        r$0 = param[2],
        x$0 = match[2],
        marks = match[1],
        _J_ = set_idx(idx, r$0);
       return [0, [1, marks_set_idx$0(marks, idx), x$0], _J_];
      default:
       var r$1 = param[2], marks$0 = match[1], _K_ = set_idx(idx, r$1);
       return [0, [2, marks_set_idx$0(marks$0, idx)], _K_];
    }
   }
   function idx(t){return t[1];}
   var dummy = [0, -1, Re_Category[3], 0, 0, -1];
   function mk(idx, cat, desc){
    return [0,
            idx,
            cat,
            desc,
            0,
            hash$0
             (desc,
              hash_combine
               (idx, hash_combine(caml_call1(Re_Category[10], cat), 0)))
            & 1073741823];
   }
   function create$0(cat, e){return mk(0, cat, [0, [1, empty, e], 0]);}
   function equal$2(x, y){
    var _E_ = caml_call2(Re_Import[2], x[5], y[5]);
    if(_E_){
     var _F_ = caml_call2(Re_Import[2], x[1], y[1]);
     if(_F_){
      var _G_ = caml_call2(Re_Category[11], x[2], y[2]);
      if(_G_) return equal$1(x[3], y[3]);
      var _H_ = _G_;
     }
     else
      var _H_ = _F_;
    }
    else
     var _H_ = _E_;
    return _H_;
   }
   function status(s){
    var match = s[4];
    if(match){var st = match[1]; return st;}
    var _C_ = s[3];
    if(_C_){
     var match$0 = _C_[1];
     if(2 === match$0[0])
      var
       m = match$0[1],
       _D_ = m[2],
       st$0 = [0, caml_call1(Re_Mark_infos[1], m[1]), _D_];
     else
      var st$0 = 1;
    }
    else
     var st$0 = 0;
    s[4] = [0, st$0];
    return st$0;
   }
   function hash$1(t){return t[5];}
   var Table = caml_call1(Stdlib_Hashtbl[26], [0, equal$2, hash$1]);
   function create$1(param){return [0, caml_call1(Re_Bit_vector[3], 1)];}
   function index_count(w){return caml_call1(Re_Bit_vector[1], w[1]);}
   function mark_used_indices(tbl){
    return caml_call1
            (Stdlib_ListLabels[18],
             function(param){
              if(0 === param[0]){
               var l = param[1];
               return caml_call1(mark_used_indices(tbl), l);
              }
              var marks = param[1];
              return caml_call2
                      (Stdlib_ListLabels[18],
                       function(param){
                        var i = param[2], _B_ = 0 <= i ? 1 : 0;
                        return _B_ ? caml_call3(Re_Bit_vector[2], tbl, i, 1) : _B_;
                       },
                       marks[1]);
             });
   }
   function free_index(tbl_ref, l){
    var tbl = tbl_ref[1];
    caml_call1(Re_Bit_vector[5], tbl);
    caml_call1(mark_used_indices(tbl), l);
    var len = caml_call1(Re_Bit_vector[1], tbl), idx = 0;
    for(;;){
     if
      (!
       caml_call2(Re_Import[2], idx, len)
       && caml_call2(Re_Bit_vector[4], tbl, idx)){
      var idx$0 = idx + 1 | 0;
      idx = idx$0;
      continue;
     }
     if(caml_call2(Re_Import[2], idx, len))
      tbl_ref[1] = caml_call1(Re_Bit_vector[3], 2 * len | 0);
     return idx;
    }
   }
   function remove_duplicates(prev, l, y){
    var l$0 = l;
    for(;;){
     if(! l$0) return [0, 0, prev];
     var x = l$0[1];
     switch(x[0]){
       case 0:
        var
         r = l$0[2],
         kind = x[3],
         x$0 = x[2],
         l$1 = x[1],
         match = remove_duplicates(prev, l$1, x$0),
         prev$0 = match[2],
         l$2 = match[1],
         match$0 = remove_duplicates(prev$0, r, y),
         prev$1 = match$0[2],
         r$0 = match$0[1];
        return [0, tseq(kind, l$2, x$0, r$0), prev$1];
       case 1:
        if(typeof x[2][2] === "number"){
         var r$1 = l$0[2];
         if(! caml_call2(Stdlib_ListLabels[38], y[1], prev)){
          var
           match$1 = remove_duplicates([0, y[1], prev], r$1, y),
           prev$2 = match$1[2],
           r$2 = match$1[1];
          return [0, [0, x, r$2], prev$2];
         }
         l$0 = r$1;
        }
        else{
         var r$3 = l$0[2], x$1 = x[2];
         if(! caml_call2(Stdlib_ListLabels[38], x$1[1], prev)){
          var
           match$2 = remove_duplicates([0, x$1[1], prev], r$3, y),
           prev$3 = match$2[2],
           r$4 = match$2[1];
          return [0, [0, x, r$4], prev$3];
         }
         l$0 = r$3;
        }
        break;
       default: return [0, [0, x, 0], prev];
     }
    }
   }
   function delta_1$0(counter, ctx, x, rem){
    var marks$0 = ctx[4], c = ctx[1], match = x[2];
    if(typeof match === "number") return [0, [2, marks$0], rem];
    switch(match[0]){
      case 0:
       var s = match[1];
       return caml_call2(Re_Cset[17], c, s)
               ? [0, [1, marks$0, eps_expr], rem]
               : rem;
      case 1:
       var l = match[1];
       if(counter >= 50)
        return caml_trampoline_return(delta_alt$0, [0, ctx, l, rem]);
       var counter$1 = counter + 1 | 0;
       return delta_alt$0(counter$1, ctx, l, rem);
      case 2:
       var
        z = match[3],
        y = match[2],
        kind = match[1],
        y$0 = delta_1(ctx, y, 0);
       if(counter >= 50)
        return caml_trampoline_return
                (delta_seq$0, [0, ctx, kind, y$0, z, rem]);
       var counter$0 = counter + 1 | 0;
       return delta_seq$0(counter$0, ctx, kind, y$0, z, rem);
      case 3:
       var
        y$1 = match[3],
        kind$0 = match[2],
        rep_kind = match[1],
        y$2 = delta_1(ctx, y$1, 0),
        match$0 = first_match(y$2);
       if(match$0)
        var
         marks$1 = match$0[1],
         marks$2 = marks$1,
         y$3 = caml_call1(remove_matches, y$2);
       else
        var marks$2 = marks$0, y$3 = y$2;
       return 620821490 <= rep_kind
               ? [0, [2, marks$0], tseq(kind$0, y$3, x, rem)]
               : tseq(kind$0, y$3, x, [0, [2, marks$2], rem]);
      case 4:
       var i = match[1], marks$3 = set_mark(marks$0, i);
       return [0, [2, marks$3], rem];
      case 5:
       var e = match[2], b = match[1];
       return [0, [2, filter(marks$0, b, e)], rem];
      case 6:
       var cat = match[1];
       return caml_call2(Re_Category[13], ctx[3], cat)
               ? [0, [2, marks$0], rem]
               : rem;
      case 7:
       var cat$0 = match[1];
       return caml_call2(Re_Category[13], ctx[2], cat$0)
               ? [0, [2, marks$0], rem]
               : rem;
      default:
       var
        i$0 = match[1],
        _A_ = caml_call2(Re_Pmark[5][2], i$0, marks$0[2]),
        marks = [0, marks$0[1], _A_];
       return [0, [2, marks], rem];
    }
   }
   function delta_1(ctx, x, rem){
    return caml_trampoline(delta_1$0(0, ctx, x, rem));
   }
   function delta_alt$0(counter, ctx, l, rem){
    if(! l) return rem;
    var r = l[2], y = l[1], _z_ = delta_alt(ctx, r, rem);
    if(counter >= 50)
     return caml_trampoline_return(delta_1$0, [0, ctx, y, _z_]);
    var counter$0 = counter + 1 | 0;
    return delta_1$0(counter$0, ctx, y, _z_);
   }
   function delta_alt(ctx, l, rem){
    return caml_trampoline(delta_alt$0(0, ctx, l, rem));
   }
   function delta_seq$0(counter, ctx, kind, y, z, rem){
    var match = first_match(y);
    if(! match) return tseq(kind, y, z, rem);
    var marks = match[1], ctx$0 = [0, ctx[1], ctx[2], ctx[3], marks];
    if(-730718166 === kind){
     var _x_ = delta_1(ctx$0, z, rem);
     return tseq(kind, caml_call1(remove_matches, y), z, _x_);
    }
    if(332064784 <= kind){
     var match$0 = split_at_match(y), y$0 = match$0[2], y$1 = match$0[1];
     return tseq(kind, y$1, z, delta_1(ctx$0, z, tseq(kind, y$0, z, rem)));
    }
    var _y_ = tseq(kind, caml_call1(remove_matches, y), z, rem);
    if(counter >= 50)
     return caml_trampoline_return(delta_1$0, [0, ctx$0, z, _y_]);
    var counter$0 = counter + 1 | 0;
    return delta_1$0(counter$0, ctx$0, z, _y_);
   }
   function delta_seq(ctx, kind, y, z, rem){
    return caml_trampoline(delta_seq$0(0, ctx, kind, y, z, rem));
   }
   function delta_4(ctx, l, rem){
    if(! l) return rem;
    var r = l[2], y$1 = l[1], rem$0 = delta_4(ctx, r, rem);
    switch(y$1[0]){
      case 0:
       var kind = y$1[3], z = y$1[2], y = y$1[1], y$0 = delta_4(ctx, y, 0);
       return delta_seq(ctx, kind, y$0, z, rem$0);
      case 1:
       var e = y$1[2], marks = y$1[1];
       return delta_1([0, ctx[1], ctx[2], ctx[3], marks], e, rem$0);
      default: return [0, y$1, rem$0];
    }
   }
   function delta(tbl_ref, next_cat, char$0, st){
    var
     prev_cat = st[2],
     ctx = [0, char$0, prev_cat, next_cat, empty],
     expr = remove_duplicates(0, delta_4(ctx, st[3], 0), eps_expr)[1],
     idx = free_index(tbl_ref, expr),
     expr$0 = set_idx(idx, expr);
    return mk(idx, next_cat, expr$0);
   }
   function red_tr(l){
    var l$0 = l;
    for(;;){
     if(l$0){
      var match = l$0[2];
      if(match){
       var
        rem = match[2],
        tr2 = match[1],
        st2 = tr2[2],
        s2 = tr2[1],
        tr1 = l$0[1],
        st1 = tr1[2],
        s1 = tr1[1];
       if(! equal$2(st1, st2)) return [0, tr1, red_tr([0, tr2, rem])];
       var l$1 = [0, [0, caml_call2(Re_Cset[7], s1, s2), st1], rem];
       l$0 = l$1;
       continue;
      }
     }
     return l$0;
    }
   }
   function prepend_deriv(init){
    var
     _v_ =
       caml_call1
        (Stdlib_ListLabels[27],
         function(param, l){
          var x = param[2], s = param[1];
          return caml_call3(Re_Cset[48], s, x, l);
         });
    return function(_w_){return caml_call2(_v_, _w_, init);};
   }
   function restrict(s, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      rem = param$0[2],
      match = param$0[1],
      x = match[2],
      s$0 = match[1],
      s$1 = caml_call2(Re_Cset[10], s, s$0);
     if(! caml_call1(Re_Cset[47], s$1))
      return [0, [0, s$1, x], restrict(s, rem)];
     param$0 = rem;
    }
   }
   function prepend_marks_expr_lst(m, l){
    return caml_call2
            (Stdlib_ListLabels[20],
             function(param){
              switch(param[0]){
                case 0:
                 var s = param[3], e = param[2], l = param[1];
                 return [0, prepend_marks_expr_lst(m, l), e, s];
                case 1:
                 var e$0 = param[2], m$0 = param[1];
                 return [1, merge(m, m$0), e$0];
                default: var m$1 = param[1]; return [2, merge(m, m$1)];
              }
             },
             l);
   }
   function deriv_1$0(counter, all_chars, categories, marks, cat, x, rem$2){
    var match = x[2];
    if(typeof match === "number")
     return caml_call3(Re_Cset[48], all_chars, [0, [2, marks], 0], rem$2);
    switch(match[0]){
      case 0:
       var s = match[1];
       return caml_call3(Re_Cset[48], s, [0, [1, marks, eps_expr], 0], rem$2);
      case 1:
       var l = match[1];
       if(counter >= 50)
        return caml_trampoline_return
                (deriv_2$0, [0, all_chars, categories, marks, cat, l, rem$2]);
       var counter$0 = counter + 1 | 0;
       return deriv_2$0
               (counter$0, all_chars, categories, marks, cat, l, rem$2);
      case 2:
       var
        z = match[3],
        y = match[2],
        kind = match[1],
        y$0 =
          deriv_1
           (all_chars, categories, marks, cat, y, [0, [0, all_chars, 0], 0]);
       return deriv_seq(all_chars, categories, cat, kind, y$0, z, rem$2);
      case 3:
       var
        y$1 = match[3],
        kind$0 = match[2],
        rep_kind = match[1],
        y$2 =
          deriv_1
           (all_chars, categories, marks, cat, y$1, [0, [0, all_chars, 0], 0]);
       return caml_call3
               (Stdlib_ListLabels[27],
                function(param, rem){
                 var z = param[2], s = param[1], match = first_match(z);
                 if(match)
                  var
                   marks$0 = match[1],
                   marks$1 = marks$0,
                   z$0 = caml_call1(remove_matches, z);
                 else
                  var marks$1 = marks, z$0 = z;
                 var
                  _u_ =
                    620821490 <= rep_kind
                     ? [0, [2, marks], tseq(kind$0, z$0, x, 0)]
                     : tseq(kind$0, z$0, x, [0, [2, marks$1], 0]);
                 return caml_call3(Re_Cset[48], s, _u_, rem);
                },
                y$2,
                rem$2);
      case 4:
       var i = match[1], _r_ = [0, [2, set_mark(marks, i)], 0];
       return caml_call3(Re_Cset[48], all_chars, _r_, rem$2);
      case 5:
       var
        e$1 = match[2],
        b = match[1],
        _q_ = marks[2],
        rem$1 = filter(marks, b, e$1)[1],
        e = e$1,
        rem = rem$1,
        _s_ = 0;
       for(;;){
        if(e < b)
         return caml_call3
                 (Re_Cset[48], all_chars, [0, [2, [0, rem, _q_]], _s_], rem$2);
        var rem$0 = [0, [0, e, -2], rem], e$0 = e - 1 | 0;
        e = e$0;
        rem = rem$0;
       }
       break;
      case 6:
       var
        cat$0 = match[1],
        _t_ = caml_call2(Stdlib_ListLabels[51], cat$0, categories);
       return caml_call3(Re_Cset[48], _t_, [0, [2, marks], 0], rem$2);
      case 7:
       var cat$1 = match[1];
       return caml_call2(Re_Category[13], cat, cat$1)
               ? caml_call3(Re_Cset[48], all_chars, [0, [2, marks], 0], rem$2)
               : rem$2;
      default:
       return caml_call3(Re_Cset[48], all_chars, [0, [2, marks], 0], rem$2);
    }
   }
   function deriv_1(all_chars, categories, marks, cat, x, rem){
    return caml_trampoline
            (deriv_1$0(0, all_chars, categories, marks, cat, x, rem));
   }
   function deriv_2$0(counter, all_chars, categories, marks, cat, l, rem){
    if(! l) return rem;
    var
     r = l[2],
     y = l[1],
     _p_ = deriv_2(all_chars, categories, marks, cat, r, rem);
    if(counter >= 50)
     return caml_trampoline_return
             (deriv_1$0, [0, all_chars, categories, marks, cat, y, _p_]);
    var counter$0 = counter + 1 | 0;
    return deriv_1$0(counter$0, all_chars, categories, marks, cat, y, _p_);
   }
   function deriv_2(all_chars, categories, marks, cat, l, rem){
    return caml_trampoline
            (deriv_2$0(0, all_chars, categories, marks, cat, l, rem));
   }
   function deriv_seq(all_chars, categories, cat, kind, y, z, rem){
    if
     (!
      caml_call2
       (Stdlib_ListLabels[34],
        function(param){
         var xl = param[2];
         return caml_call1(exists_tmatch, xl);
        },
        y))
     return caml_call3
             (Stdlib_ListLabels[27],
              function(param, rem){
               var xl = param[2], s = param[1], _o_ = tseq(kind, xl, z, 0);
               return caml_call3(Re_Cset[48], s, _o_, rem);
              },
              y,
              rem);
    var
     z$0 =
       deriv_1
        (all_chars, categories, empty, cat, z, [0, [0, all_chars, 0], 0]);
    return caml_call3
            (Stdlib_ListLabels[27],
             function(param, rem){
              var y = param[2], s = param[1], match = first_match(y);
              if(! match){
               var _n_ = tseq(kind, y, z, 0);
               return caml_call3(Re_Cset[48], s, _n_, rem);
              }
              var
               marks = match[1],
               z$1 =
                 restrict
                  (s,
                   caml_call1
                    (caml_call1
                      (Stdlib_ListLabels[20],
                       function(param){
                        var x = param[2], s = param[1];
                        return [0, s, prepend_marks_expr_lst(marks, x)];
                       }),
                     z$0));
              if(-730718166 === kind){
               var
                _f_ = prepend_deriv(z$1)(rem),
                _g_ = tseq(kind, caml_call1(remove_matches, y), z, 0);
               return caml_call3(Re_Cset[48], s, _g_, _f_);
              }
              if(332064784 <= kind){
               var
                match$0 = split_at_match(y),
                y$0 = match$0[2],
                y$1 = match$0[1],
                _h_ = tseq(kind, y$0, z, 0),
                _i_ = caml_call3(Re_Cset[48], s, _h_, rem),
                _j_ = prepend_deriv(z$1)(_i_),
                _k_ = tseq(kind, y$1, z, 0);
               return caml_call3(Re_Cset[48], s, _k_, _j_);
              }
              var
               _l_ = tseq(kind, caml_call1(remove_matches, y), z, 0),
               _m_ = caml_call3(Re_Cset[48], s, _l_, rem);
              return prepend_deriv(z$1)(_m_);
             },
             y,
             rem);
   }
   function deriv_4(all_chars, categories, cat, l, rem){
    if(! l) return rem;
    var
     r = l[2],
     y$1 = l[1],
     rem$0 = deriv_4(all_chars, categories, cat, r, rem);
    switch(y$1[0]){
      case 0:
       var
        kind = y$1[3],
        z = y$1[2],
        y = y$1[1],
        y$0 =
          deriv_4(all_chars, categories, cat, y, [0, [0, all_chars, 0], 0]);
       return deriv_seq(all_chars, categories, cat, kind, y$0, z, rem$0);
      case 1:
       var e = y$1[2], marks = y$1[1];
       return deriv_1(all_chars, categories, marks, cat, e, rem$0);
      default: return caml_call3(Re_Cset[48], all_chars, [0, y$1, 0], rem$0);
    }
   }
   function deriv(tbl_ref, all_chars, categories, st){
    var
     der =
       deriv_4(all_chars, categories, st[2], st[3], [0, [0, all_chars, 0], 0]),
     l =
       caml_call3
        (Stdlib_ListLabels[27],
         function(param, rem){
          var
           expr = param[2],
           s = param[1],
           expr$0 = remove_duplicates(0, expr, eps_expr)[1],
           idx = free_index(tbl_ref, expr$0),
           expr$1 = set_idx(idx, expr$0);
          return caml_call3
                  (Stdlib_ListLabels[27],
                   function(param, rem){
                    var
                     s$0 = param[2],
                     cat = param[1],
                     s$1 = caml_call2(Re_Cset[10], s, s$0);
                    return caml_call1(Re_Cset[47], s$1)
                            ? rem
                            : [0, [0, s$1, mk(idx, cat, expr$1)], rem];
                   },
                   categories,
                   rem);
         },
         der,
         0),
     _c_ =
       red_tr
        (caml_call2
          (Stdlib_ListLabels[59],
           function(_e_, param){
            var
             st2 = param[2],
             st1 = _e_[2],
             c = runtime.caml_int_compare(st1[5], st2[5]);
            if(0 !== c) return c;
            var c$0 = caml_call2(Re_Category[12], st1[2], st2[2]);
            return 0 === c$0 ? caml_compare(st1[3], st2[3]) : c$0;
           },
           l));
    return caml_call2
            (Stdlib_ListLabels[59],
             function(_d_, param){
              var s2 = param[1], s1 = _d_[1];
              return caml_compare(s1, s2);
             },
             _c_);
   }
   var
    Re_Automata =
      [0,
       Mark,
       [0, pp],
       Rep_kind,
       is_eps,
       pp$1,
       [0, create],
       cst,
       empty$0,
       alt,
       seq,
       eps,
       rep,
       mark,
       pmark,
       erase,
       before,
       after,
       rename,
       [0, dummy, create$0, idx, status, Table],
       [0, create$1, index_count],
       delta,
       deriv];
   runtime.caml_register_global(40, Re_Automata, "Re__Automata");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Color_map
//# unitInfo: Requires: Re__Cset, Stdlib__Bytes, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Cset = global_data.Re__Cset,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function repr(t, color){
    return caml_string_get(t, caml_call1(Re_Cset[1], color));
   }
   var length = runtime.caml_ml_string_length, Repr = [0, repr, length];
   function get_char(t, c){
    return caml_string_get(t, caml_call1(Re_Cset[1], c));
   }
   function get(t, c){
    var _e_ = caml_string_get(t, c);
    return caml_call1(Re_Cset[2], _e_);
   }
   function translate_colors(cm, cset){
    return caml_call3
            (Re_Cset[42],
             cset,
             Re_Cset[13],
             function(param, l){
              var
               j = param[2],
               i = param[1],
               start = get_char(cm, i),
               stop = get_char(cm, j),
               _d_ = caml_call2(Re_Cset[25], start, stop);
              return caml_call2(Re_Cset[7], _d_, l);
             });
   }
   var Table = [0, get_char, get, translate_colors];
   function make(param){return caml_call2(Stdlib_Bytes[1], 257, 0);}
   function flatten(cm){
    var
     c = caml_create_bytes(256),
     color_repr = caml_create_bytes(256),
     v = [0, 0];
    caml_bytes_set(c, 0, 0);
    caml_bytes_set(color_repr, 0, 0);
    var i = 1;
    for(;;){
     if(0 !== runtime.caml_bytes_get(cm, i)) v[1]++;
     caml_bytes_set(c, i, caml_call1(Stdlib_Char[1], v[1]));
     var _b_ = caml_call1(Stdlib_Char[1], i);
     caml_bytes_set(color_repr, v[1], _b_);
     var _c_ = i + 1 | 0;
     if(255 === i){
      var _a_ = caml_call3(Stdlib_Bytes[8], color_repr, 0, v[1] + 1 | 0);
      return [0, caml_call1(Stdlib_Bytes[44], c), _a_];
     }
     i = _c_;
    }
   }
   function split(t, set){
    return caml_call2
            (Re_Cset[6],
             set,
             function(i, j){
              caml_bytes_set(t, caml_call1(Re_Cset[1], i), 1);
              return caml_bytes_set(t, caml_call1(Re_Cset[1], j) + 1 | 0, 1);
             });
   }
   var Re_Color_map = [0, Repr, Table, make, flatten, split];
   runtime.caml_register_global(3, Re_Color_map, "Re__Color_map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Ast
//# unitInfo: Requires: Re__Automata, Re__Color_map, Re__Cset, Re__Fmt, Re__Import, Re__Pmark, Stdlib, Stdlib__Buffer, Stdlib__Format, Stdlib__Int, Stdlib__ListLabels, Stdlib__Option, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Re_repn$1 = "Re.repn",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    s = "Sequence",
    cst = cst$1,
    cst$0 = cst$1,
    empty_alternative = [0, 0],
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Format = global_data.Stdlib__Format,
    Re_Pmark = global_data.Re__Pmark,
    Re_Automata = global_data.Re__Automata,
    Re_Cset = global_data.Re__Cset,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Option = global_data.Stdlib__Option,
    Re_Import = global_data.Re__Import,
    Stdlib = global_data.Stdlib,
    Re_Color_map = global_data.Re__Color_map,
    Stdlib_String = global_data.Stdlib__String,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    cst_Alternative = "Alternative",
    cst_No_case = "No_case",
    cst_Case = "Case",
    cst_Beg_of_line = "Beg_of_line",
    cst_End_of_line = "End_of_line",
    cst_Beg_of_word = "Beg_of_word",
    cst_End_of_word = "End_of_word",
    cst_Not_bound = "Not_bound",
    cst_Beg_of_str = "Beg_of_str",
    cst_End_of_str = "End_of_str",
    cst_Last_end_of_line = "Last_end_of_line",
    cst_Start = "Start",
    cst_Stop = "Stop",
    _a_ = [0, [15, [17, [0, "@ ", 1, 0], [4, 0, 0, 0, [15, 0]]]], "%a@ %d%a"],
    cst_Repeat = "Repeat",
    cst_Named_group = "Named_group",
    cst_Group = "Group",
    cst_No_group = "No_group",
    cst_Nest = "Nest",
    cst_Pmark = "Pmark",
    cst_Sem = "Sem",
    cst_Sem_greedy = "Sem_greedy",
    cst_Set = "Set",
    cst_Intersection = "Intersection",
    cst_Complement = "Complement",
    cst_Difference = "Difference";
   function pp_ast(f, fmt, ast){
    function var$0(s, re){return caml_call4(Re_Fmt[2], fmt, s, f, re);}
    switch(ast[0]){
      case 0:
       var alt = ast[1], _ai_ = caml_call2(Re_Fmt[8], 0, f);
       return caml_call4(Re_Fmt[2], fmt, cst_Alternative, _ai_, alt);
      case 1:
       var c = ast[1]; return var$0(cst_No_case, c);
      default: var c$0 = ast[1]; return var$0(cst_Case, c$0);
    }
   }
   function pp_gen(pp_cset, fmt, t){
    function pp(_ag_, _ah_){return pp_gen(pp_cset, _ag_, _ah_);}
    function var$0(s, re){return caml_call4(Re_Fmt[2], fmt, s, pp, re);}
    if(typeof t === "number")
     switch(t){
       case 0:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_line);
       case 1:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_line);
       case 2:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_word);
       case 3:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_word);
       case 4:
        return caml_call2(Re_Fmt[3], fmt, cst_Not_bound);
       case 5:
        return caml_call2(Re_Fmt[3], fmt, cst_Beg_of_str);
       case 6:
        return caml_call2(Re_Fmt[3], fmt, cst_End_of_str);
       case 7:
        return caml_call2(Re_Fmt[3], fmt, cst_Last_end_of_line);
       case 8:
        return caml_call2(Re_Fmt[3], fmt, cst_Start);
       default: return caml_call2(Re_Fmt[3], fmt, cst_Stop);
     }
    switch(t[0]){
      case 0:
       var cset = t[1]; return caml_call2(pp_cset, fmt, cset);
      case 1:
       var a = t[1]; return pp_ast(pp, fmt, a);
      case 2:
       var rel = t[1], _ab_ = caml_call2(Re_Fmt[8], 0, pp);
       return caml_call4(Re_Fmt[2], fmt, s, _ab_, rel);
      case 3:
       var
        stop = t[3],
        start = t[2],
        re = t[1],
        pp$0 =
          function(fmt, param){
           return caml_call7
                   (Stdlib_Format[139],
                    fmt,
                    _a_,
                    pp,
                    re,
                    start,
                    Re_Fmt[4],
                    stop);
          };
       return caml_call4(Re_Fmt[2], fmt, cst_Repeat, pp$0, 0);
      case 4:
       var match = t[1];
       if(match){
        var
         c = t[2],
         n = match[1],
         _ac_ = caml_call2(Re_Fmt[6], Re_Fmt[3], pp);
        return caml_call4(Re_Fmt[2], fmt, cst_Named_group, _ac_, [0, n, c]);
       }
       var c$0 = t[2];
       return var$0(cst_Group, c$0);
      case 5:
       var c$1 = t[1]; return var$0(cst_No_group, c$1);
      case 6:
       var c$2 = t[1]; return var$0(cst_Nest, c$2);
      case 7:
       var r = t[2], m = t[1], _ad_ = caml_call2(Re_Fmt[6], Re_Pmark[4], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Pmark, _ad_, [0, m, r]);
      case 8:
       var
        a$0 = t[2],
        sem = t[1],
        _ae_ = caml_call2(Re_Fmt[6], Re_Automata[2][1], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Sem, _ae_, [0, sem, a$0]);
      default:
       var
        re$0 = t[2],
        k = t[1],
        _af_ = caml_call2(Re_Fmt[6], Re_Automata[3][1], pp);
       return caml_call4(Re_Fmt[2], fmt, cst_Sem_greedy, _af_, [0, k, re$0]);
    }
   }
   function pp_cset(fmt, cset){
    function seq(s, rel){
     var _aa_ = caml_call2(Re_Fmt[8], 0, pp_cset);
     return caml_call4(Re_Fmt[2], fmt, s, _aa_, rel);
    }
    switch(cset[0]){
      case 0:
       var s = cset[1];
       return caml_call4(Re_Fmt[2], fmt, cst_Set, Re_Cset[40], s);
      case 1:
       var c = cset[1]; return seq(cst_Intersection, c);
      case 2:
       var c$0 = cset[1]; return seq(cst_Complement, c$0);
      case 3:
       var
        b = cset[2],
        a = cset[1],
        _$_ = caml_call2(Re_Fmt[6], pp_cset, pp_cset);
       return caml_call4(Re_Fmt[2], fmt, cst_Difference, _$_, [0, a, b]);
      default: var s$0 = cset[1]; return pp_ast(pp_cset, fmt, s$0);
    }
   }
   function equal(cset, x1, x2){
    var x1$0 = x1, x2$0 = x2;
    for(;;){
     a:
     {
      if(typeof x1$0 === "number"){
       switch(x1$0){
         case 0:
          if(typeof x2$0 !== "number" || x2$0) break a; break;
         case 1:
          if(typeof x2$0 !== "number" || 1 !== x2$0) break a; break;
         case 2:
          if(typeof x2$0 !== "number" || 2 !== x2$0) break a; break;
         case 3:
          if(typeof x2$0 !== "number" || 3 !== x2$0) break a; break;
         case 4:
          if(typeof x2$0 !== "number" || 4 !== x2$0) break a; break;
         case 5:
          if(typeof x2$0 !== "number" || 5 !== x2$0) break a; break;
         case 6:
          if(typeof x2$0 !== "number" || 6 !== x2$0) break a; break;
         case 7:
          if(typeof x2$0 !== "number" || 7 !== x2$0) break a; break;
         case 8:
          if(typeof x2$0 !== "number" || 8 !== x2$0) break a; break;
         default: if(typeof x2$0 !== "number" || 9 > x2$0) break a;
       }
       return 1;
      }
      switch(x1$0[0]){
        case 0:
         if(typeof x2$0 !== "number" && 0 === x2$0[0]){
          var s2 = x2$0[1], s1 = x1$0[1];
          return caml_call2(cset, s1, s2);
         }
         break;
        case 1:
         if(typeof x2$0 !== "number" && 1 === x2$0[0]){
          var
           y = x2$0[1],
           x = x1$0[1],
           eq = function(_Z_, ___){return equal(cset, _Z_, ___);},
           b = y[1],
           a = x[1];
          return caml_call3(Stdlib_ListLabels[16], eq, a, b);
         }
         break;
        case 2:
         if(typeof x2$0 !== "number" && 2 === x2$0[0]){
          var l2 = x2$0[1], l1 = x1$0[1];
          return caml_call3
                  (Stdlib_ListLabels[16],
                   function(_X_, _Y_){return equal(cset, _X_, _Y_);},
                   l1,
                   l2);
         }
         break;
        case 3:
         if(typeof x2$0 !== "number" && 3 === x2$0[0]){
          var
           j2 = x2$0[3],
           i2 = x2$0[2],
           x2$1 = x2$0[1],
           j1 = x1$0[3],
           i1 = x1$0[2],
           x1$1 = x1$0[1],
           _R_ = caml_call2(Stdlib_Int[8], i1, i2);
          if(_R_){
           var _S_ = caml_call3(Stdlib_Option[12], Stdlib_Int[8], j1, j2);
           if(_S_){x1$0 = x1$1; x2$0 = x2$1; continue;}
           var _T_ = _S_;
          }
          else
           var _T_ = _R_;
          return _T_;
         }
         break;
        case 4:
         if(typeof x2$0 !== "number" && 4 === x2$0[0]) return 0; break;
        case 6:
         if(typeof x2$0 !== "number" && 6 === x2$0[0]){
          var x2$2 = x2$0[1], x1$2 = x1$0[1];
          x1$0 = x1$2;
          x2$0 = x2$2;
          continue;
         }
         break;
        case 7:
         if(typeof x2$0 !== "number" && 7 === x2$0[0]){
          var
           r2 = x2$0[2],
           m2 = x2$0[1],
           r1 = x1$0[2],
           m1 = x1$0[1],
           _U_ = caml_call2(Re_Pmark[1], m1, m2);
          if(! _U_) return _U_;
          x1$0 = r1;
          x2$0 = r2;
          continue;
         }
         break;
        case 8:
         if(typeof x2$0 !== "number" && 8 === x2$0[0]){
          var
           x2$3 = x2$0[2],
           sem = x2$0[1],
           x1$3 = x1$0[2],
           sem$0 = x1$0[1],
           _V_ = caml_call2(Re_Import[1][1], sem$0, sem);
          if(! _V_) return _V_;
          x1$0 = x1$3;
          x2$0 = x2$3;
          continue;
         }
         break;
        case 9:
         if(typeof x2$0 !== "number" && 9 === x2$0[0]){
          var
           x2$4 = x2$0[2],
           rep = x2$0[1],
           x1$4 = x1$0[2],
           rep$0 = x1$0[1],
           _W_ = caml_call2(Re_Import[1][1], rep$0, rep);
          if(! _W_) return _W_;
          x1$0 = x1$4;
          x2$0 = x2$4;
          continue;
         }
         break;
      }
     }
     return 0;
    }
   }
   function pp(_P_, _Q_){return pp_gen(pp_cset, _P_, _Q_);}
   function cset(cset){return [0, [0, cset]];}
   function handle_case_cset(ign_case, param){
    var ign_case$0 = ign_case, param$0 = param;
    for(;;)
     switch(param$0[0]){
       case 0:
        var s = param$0[1];
        return ign_case$0 ? caml_call1(Re_Cset[18], s) : s;
       case 1:
        var
         l = param$0[1],
         _F_ =
           caml_call2
            (Stdlib_ListLabels[20],
             function(_O_){return handle_case_cset(ign_case$0, _O_);},
             l);
        return caml_call1(Re_Cset[9], _F_);
       case 2:
        var
         l$0 = param$0[1],
         _G_ =
           caml_call2
            (Stdlib_ListLabels[20],
             function(_N_){return handle_case_cset(ign_case$0, _N_);},
             l$0),
         _H_ = caml_call1(Re_Cset[8], _G_);
        return caml_call1(caml_call1(Re_Cset[11], Re_Cset[45]), _H_);
       case 3:
        var
         r = param$0[2],
         r$0 = param$0[1],
         _I_ = handle_case_cset(ign_case$0, r),
         _J_ = caml_call2(Re_Cset[11], Re_Cset[45], _I_),
         _K_ = handle_case_cset(ign_case$0, r$0);
        return caml_call2(Re_Cset[10], _K_, _J_);
       default:
        var match = param$0[1];
        switch(match[0]){
          case 0:
           var
            l$1 = match[1],
            _L_ =
              caml_call2
               (Stdlib_ListLabels[20],
                function(_M_){return handle_case_cset(ign_case$0, _M_);},
                l$1);
           return caml_call1(Re_Cset[8], _L_);
          case 1:
           var a = match[1]; ign_case$0 = 1; param$0 = a; break;
          default: var a$0 = match[1]; ign_case$0 = 0; param$0 = a$0;
        }
     }
   }
   function handle_case(ign_case, r){
    var ign_case$0 = ign_case, r$0 = r;
    for(;;){
     if(typeof r$0 === "number") return r$0;
     switch(r$0[0]){
       case 0:
        var s = r$0[1]; return [0, handle_case_cset(ign_case$0, s)];
       case 1:
        var match = r$0[1];
        switch(match[0]){
          case 0:
           var
            l = match[1],
            l$0 =
              caml_call2
               (Stdlib_ListLabels[20],
                function(_E_){return handle_case(ign_case$0, _E_);},
                l);
           return [1, [0, l$0]];
          case 1:
           var r$1 = match[1]; ign_case$0 = 1; r$0 = r$1; break;
          default: var r$2 = match[1]; ign_case$0 = 0; r$0 = r$2;
        }
        break;
       case 2:
        var l$1 = r$0[1];
        return [2,
                caml_call2
                 (Stdlib_ListLabels[20],
                  function(_D_){return handle_case(ign_case$0, _D_);},
                  l$1)];
       case 3:
        var j = r$0[3], i = r$0[2], r$3 = r$0[1];
        return [3, handle_case(ign_case$0, r$3), i, j];
       case 4:
        var r$4 = r$0[2], n = r$0[1];
        return [4, n, handle_case(ign_case$0, r$4)];
       case 5:
        var r$5 = r$0[1]; return [5, handle_case(ign_case$0, r$5)];
       case 6:
        var r$6 = r$0[1]; return [6, handle_case(ign_case$0, r$6)];
       case 7:
        var r$7 = r$0[2], i$0 = r$0[1];
        return [7, i$0, handle_case(ign_case$0, r$7)];
       case 8:
        var r$8 = r$0[2], k = r$0[1];
        return [8, k, handle_case(ign_case$0, r$8)];
       default:
        var r$9 = r$0[2], k$0 = r$0[1];
        return [9, k$0, handle_case(ign_case$0, r$9)];
     }
    }
   }
   function seq(l){if(l && ! l[2]){var r = l[1]; return r;} return [2, l];}
   function str(s){
    var l = [0, 0], _z_ = caml_ml_string_length(s) - 1 | 0;
    if(_z_ >= 0){
     var i = _z_;
     for(;;){
      var _A_ = l[1], _B_ = runtime.caml_string_get(s, i);
      l[1] = [0, [0, [0, caml_call1(Re_Cset[46], _B_)]], _A_];
      var _C_ = i - 1 | 0;
      if(0 === i) break;
      i = _C_;
     }
    }
    return seq(l[1]);
   }
   function as_set_elems(elems){
    try{
     var
      e =
        caml_call2
         (Stdlib_ListLabels[20],
          function(param){
           if(typeof param !== "number" && 0 === param[0]){var e = param[1]; return e;}
           throw Stdlib[3];
          },
          elems);
    }
    catch(_y_){
     var _x_ = caml_wrap_exception(_y_);
     if(_x_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_x_, 0);
    }
    return [0, e];
   }
   var empty = [1, empty_alternative];
   function alt(elems){
    if(! elems) return empty;
    if(! elems[2]){var x = elems[1]; return x;}
    var match = as_set_elems(elems);
    if(! match) return [1, [0, elems]];
    var elems$0 = match[1];
    return [0, [4, [0, elems$0]]];
   }
   var
    epsilon = seq(0),
    cst_Re_repn = cst_Re_repn$1,
    cst_Re_repn$0 = cst_Re_repn$1,
    _b_ = [0, 1];
   function repn(r, i, j){
    if(i < 0) caml_call1(Stdlib[1], cst_Re_repn);
    if(j){
     var j$0 = j[1];
     if(j$0 < i) return caml_call1(Stdlib[1], cst_Re_repn$0);
     if(0 === j$0){
      if(0 === i) return epsilon;
     }
     else if(1 === j$0 && 1 === i) return r;
    }
    return [3, r, i, j];
   }
   function rep(r){return repn(r, 0, 0);}
   function rep1(r){return repn(r, 1, 0);}
   function opt(r){return repn(r, 0, _b_);}
   var bow = 2, eow = 3;
   function word(r){return seq([0, bow, [0, r, [0, eow, 0]]]);}
   var bos = 5, eos = 6;
   function whole_string(r){return seq([0, bos, [0, r, [0, eos, 0]]]);}
   var
    cst_Re_inter = "Re.inter",
    cst_Re_compl = "Re.compl",
    cst_Re_diff = "Re.diff";
   function make_set(f, t){
    if(typeof t !== "number" && 0 === t[0]){
     var x = t[1];
     return [0, [4, caml_call1(f[1], x)]];
    }
    return [1, caml_call1(f[1], t)];
   }
   function preserve_set(f, t){
    if(typeof t !== "number" && 0 === t[0]) return t;
    return caml_call1(f, t);
   }
   function _c_(t){return [8, -730718166, t];}
   function longest(_w_){return preserve_set(_c_, _w_);}
   function _d_(t){return [8, -1034406550, t];}
   function shortest(_v_){return preserve_set(_d_, _v_);}
   function _e_(t){return [8, 332064784, t];}
   function first(_u_){return preserve_set(_e_, _u_);}
   function _f_(t){return [9, -904640576, t];}
   function greedy(_t_){return preserve_set(_f_, _t_);}
   function _g_(t){return [9, 620821490, t];}
   function non_greedy(_s_){return preserve_set(_g_, _s_);}
   function group(name, r){return [4, name, r];}
   function _h_(t){return [5, t];}
   function no_group(_r_){return preserve_set(_h_, _r_);}
   function nest(r){return [6, r];}
   function set(str){return cset(caml_call1(Re_Cset[26], str));}
   function mark(r){
    var i = caml_call1(Re_Pmark[3], 0);
    return [0, i, [7, i, r]];
   }
   function as_set_or_error(name, elems){
    var match = as_set_elems(elems);
    if(! match) return caml_call1(Stdlib[1], name);
    var s = match[1];
    return s;
   }
   function inter(elems){
    return [0, [1, as_set_or_error(cst_Re_inter, elems)]];
   }
   function compl(elems){
    return [0, [2, as_set_or_error(cst_Re_compl, elems)]];
   }
   function diff(r$0, r){
    if
     (typeof r$0 !== "number"
      && 0 === r$0[0] && typeof r !== "number" && 0 === r[0]){
     var r$1 = r[1], r$2 = r$0[1];
     return [0, [3, r$2, r$1]];
    }
    return caml_call1(Stdlib[1], cst_Re_diff);
   }
   var f = [0, function(r){return [2, r];}];
   function case$0(t){return make_set(f, t);}
   var
    f$0 = [0, function(r){return [1, r];}],
    _i_ = [0, "lib/ast.ml", 298, 32];
   function no_case(t){return make_set(f$0, t);}
   function witness(t){
    function witness(t){
     var t$0 = t;
     for(;;){
      if(typeof t$0 === "number") return cst;
      switch(t$0[0]){
        case 0:
         var
          c = t$0[1],
          _m_ = caml_call1(Re_Cset[49], c),
          _n_ = caml_call1(Re_Cset[3], _m_);
         return caml_call2(Stdlib_String[1], 1, _n_);
        case 1:
         var match = t$0[1][1];
         if(! match)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
         var x = match[1];
         t$0 = x;
         continue;
        case 2:
         var
          xs = t$0[1],
          _o_ = caml_call2(Stdlib_ListLabels[20], witness, xs);
         return caml_call2(Stdlib_String[7], cst$0, _o_);
        case 3:
         var
          from = t$0[2],
          r = t$0[1],
          w = witness(r),
          b =
            caml_call1
             (Stdlib_Buffer[1],
              runtime.caml_mul(caml_ml_string_length(w), from)),
          _p_ = 1;
         if(from >= 1){
          var i = _p_;
          for(;;){
           caml_call2(Stdlib_Buffer[16], b, w);
           var _q_ = i + 1 | 0;
           if(from === i) break;
           i = _q_;
          }
         }
         return caml_call1(Stdlib_Buffer[2], b);
        case 5:
         var r$1 = t$0[1]; t$0 = r$1; continue;
        case 6:
         var r$0 = t$0[1]; break;
        default: var r$0 = t$0[2];
      }
      t$0 = r$0;
     }
    }
    return witness(handle_case(0, t));
   }
   function merge_sequences(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var x = param$0[1];
     if(typeof x !== "number")
      switch(x[0]){
        case 1:
         var match = x[1];
         if(0 === match[0]){
          var r$0 = param$0[2], l = match[1];
          param$0 = caml_call2(Stdlib[37], l, r$0);
          continue;
         }
         break;
        case 2:
         var match$0 = x[1];
         if(match$0){
          var
           r$1 = param$0[2],
           y = match$0[2],
           x$0 = match$0[1],
           r$2 = merge_sequences(r$1);
          a:
          if(r$2){
           var _k_ = r$2[1];
           if(typeof _k_ !== "number" && 2 === _k_[0]){
            var match$1 = _k_[1];
            if(! match$1) break a;
            var r$3 = r$2[2], y$0 = match$1[2], x$1 = match$1[1];
            if(! equal(Re_Cset[5], x$0, x$1)) break a;
            var _l_ = [0, seq(y$0), 0];
            return [0, [2, [0, x$0, [0, [1, [0, [0, seq(y), _l_]]], 0]]], r$3];
           }
          }
          return [0, [2, [0, x$0, y]], r$2];
         }
         break;
      }
     var r = param$0[2];
     return [0, x, merge_sequences(r)];
    }
   }
   function colorize(color_map, regexp){
    var lnl = [0, 0];
    function colorize(regexp){
     var regexp$0 = regexp;
     for(;;){
      if(typeof regexp$0 === "number")
       switch(regexp$0){
         case 7:
          lnl[1] = 1; return 0;
         case 0:
         case 1:
          return caml_call2(Re_Color_map[5], color_map, Re_Cset[24]);
         case 2:
         case 3:
         case 4:
          return caml_call2(Re_Color_map[5], color_map, Re_Cset[21]);
         default: return 0;
       }
      switch(regexp$0[0]){
        case 0:
         var s = regexp$0[1];
         return caml_call2(Re_Color_map[5], color_map, s);
        case 1:
         var l = regexp$0[1][1];
         return caml_call2(Stdlib_ListLabels[18], colorize, l);
        case 2:
         var l$0 = regexp$0[1];
         return caml_call2(Stdlib_ListLabels[18], colorize, l$0);
        case 3:
         var regexp$1 = regexp$0[1]; regexp$0 = regexp$1; continue;
        case 4:
        case 7:
         var regexp$2 = regexp$0[2]; break;
        case 5:
        case 6:
         var regexp$2 = regexp$0[1]; break;
        default: var regexp$3 = regexp$0[2]; regexp$0 = regexp$3; continue;
      }
      regexp$0 = regexp$2;
     }
    }
    colorize(regexp);
    return lnl[1];
   }
   function anchored(param){
    var param$0 = param;
    for(;;){
     a:
     {
      if(typeof param$0 !== "number"){
       switch(param$0[0]){
         case 1:
          var a = param$0[1];
          if(0 === a[0]){
           var als = a[1];
           return caml_call2(Stdlib_ListLabels[33], anchored, als);
          }
          var r = a[1];
          param$0 = r;
          continue;
         case 2:
          var l = param$0[1];
          return caml_call2(Stdlib_ListLabels[34], anchored, l);
         case 3:
          var i = param$0[2], r$0 = param$0[1], _j_ = 0 < i ? 1 : 0;
          if(! _j_) return _j_;
          param$0 = r$0;
          continue;
         case 0:
          break a;
         case 5:
         case 6:
          var r$1 = param$0[1]; break;
         default: var r$1 = param$0[2];
       }
       param$0 = r$1;
       continue;
      }
      switch(param$0){case 5:case 8: return 1;
      }
     }
     return 0;
    }
   }
   function t_of_cset(x){return [0, x];}
   var
    Re_Ast =
      [0,
       pp,
       merge_sequences,
       handle_case,
       anchored,
       colorize,
       [0,
        empty,
        epsilon,
        str,
        no_case,
        case$0,
        diff,
        compl,
        repn,
        inter,
        set,
        mark,
        nest,
        no_group,
        whole_string,
        7,
        longest,
        greedy,
        non_greedy,
        9,
        4,
        group,
        word,
        first,
        bos,
        bow,
        eow,
        eos,
        0,
        8,
        1,
        opt,
        rep,
        rep1,
        alt,
        shortest,
        seq,
        pp,
        witness],
       cset,
       t_of_cset];
   runtime.caml_register_global(51, Re_Ast, "Re__Ast");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__View
//# unitInfo: Requires: Re__Ast, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Ast = global_data.Re__Ast,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function view_ast(f, t){
    switch(t[0]){
      case 0:
       var a = t[1]; return [2, caml_call2(Stdlib_ListLabels[20], f, a)];
      case 1:
       var a$0 = t[1]; return [10, caml_call1(f, a$0)];
      default: var a$1 = t[1]; return [9, caml_call1(f, a$1)];
    }
   }
   function view(param){
    if(typeof param === "number")
     switch(param){
       case 0:
        return 0;
       case 1:
        return 1;
       case 2:
        return 2;
       case 3:
        return 3;
       case 4:
        return 4;
       case 5:
        return 5;
       case 6:
        return 6;
       case 7:
        return 7;
       case 8:
        return 8;
       default: return 9;
     }
    switch(param[0]){
      case 0:
       var cset = param[1];
       switch(cset[0]){
         case 0:
          var set = cset[1]; return [0, set];
         case 1:
          var sets = cset[1];
          return [11, caml_call2(Stdlib_ListLabels[20], Re_Ast[8], sets)];
         case 2:
          var sets$0 = cset[1];
          return [12, caml_call2(Stdlib_ListLabels[20], Re_Ast[8], sets$0)];
         case 3:
          var y = cset[2], x = cset[1], _a_ = caml_call1(Re_Ast[8], y);
          return [13, caml_call1(Re_Ast[8], x), _a_];
         default: var ast = cset[1]; return view_ast(Re_Ast[8], ast);
       }
      case 1:
       var s = param[1]; return view_ast(function(x){return x;}, s);
      case 2:
       var s$0 = param[1]; return [1, s$0];
      case 3:
       var y$0 = param[3], x$0 = param[2], t = param[1];
       return [3, t, x$0, y$0];
      case 4:
       var t$0 = param[2], name = param[1]; return [6, name, t$0];
      case 5:
       var a = param[1]; return [7, a];
      case 6:
       var t$1 = param[1]; return [8, t$1];
      case 7:
       var t$2 = param[2], pmark = param[1]; return [14, pmark, t$2];
      case 8:
       var a$0 = param[2], sem = param[1]; return [4, sem, a$0];
      default: var a$1 = param[2], sem$0 = param[1]; return [5, sem$0, a$1];
    }
   }
   var Re_View = [0, view];
   runtime.caml_register_global(2, Re_View, "Re__View");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Group
//# unitInfo: Requires: Re__Fmt, Re__Mark_infos, Stdlib, Stdlib__Array, Stdlib__Format, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_offset = [0, -1, -1],
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Array = global_data.Stdlib__Array,
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_String = global_data.Stdlib__String,
    Re_Mark_infos = global_data.Re__Mark_infos,
    Stdlib = global_data.Stdlib,
    _a_ =
      [0,
       [18,
        [1, [0, 0, cst]],
        [12,
         40,
         [2,
          0,
          [11,
           " (",
           [4, 0, 0, 0, [12, 32, [4, 0, 0, 0, [11, "))", [17, 0, 0]]]]]]]]],
       "@[(%s (%d %d))@]"],
    cst_Group = "Group";
   function offset(t, i){
    var match = caml_call2(Re_Mark_infos[2], t[2], i);
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var
     match$0 = match[1],
     stop = match$0[2],
     start = match$0[1],
     _f_ = caml_check_bound(t[4], stop)[1 + stop];
    return [0, caml_check_bound(t[4], start)[1 + start], _f_];
   }
   function get(t, i){
    var match = offset(t, i), p2 = match[2], p1 = match[1];
    return caml_call3(Stdlib_String[16], t[1], p1, p2 - p1 | 0);
   }
   function start(subs, i){return offset(subs, i)[1];}
   function stop(subs, i){return offset(subs, i)[2];}
   function test(t, i){return caml_call2(Re_Mark_infos[3], t[2], i);}
   function get_opt(t, i){return test(t, i) ? [0, get(t, i)] : 0;}
   function all_offset(t){
    var res = caml_make_vect(t[5], dummy_offset);
    caml_call2
     (Re_Mark_infos[4],
      t[2],
      function(i, start, stop){
       var
        p1 = caml_check_bound(t[4], start)[1 + start],
        p2 = caml_check_bound(t[4], stop)[1 + stop];
       caml_check_bound(res, i)[1 + i] = [0, p1, p2];
       return 0;
      });
    return res;
   }
   function all(t){
    var res = caml_make_vect(t[5], cst);
    caml_call2
     (Re_Mark_infos[4],
      t[2],
      function(i, start, stop){
       var
        p1 = caml_check_bound(t[4], start)[1 + start],
        p2 = caml_check_bound(t[4], stop)[1 + stop],
        _e_ = caml_call3(Stdlib_String[16], t[1], p1, p2 - p1 | 0);
       caml_check_bound(res, i)[1 + i] = _e_;
       return 0;
      });
    return res;
   }
   function pp(fmt, t){
    var
     offsets = all_offset(t),
     strs = all(t),
     _b_ =
       caml_call2
        (Stdlib_Array[1],
         strs.length - 1,
         function(i){
          var _d_ = caml_check_bound(offsets, i)[1 + i];
          return [0, caml_check_bound(strs, i)[1 + i], _d_];
         }),
     matches = caml_call1(Stdlib_Array[10], _b_);
    function pp_match(fmt, param){
     var match = param[2], stop = match[2], start = match[1], str = param[1];
     return caml_call5(Stdlib_Format[139], fmt, _a_, str, start, stop);
    }
    var _c_ = caml_call2(Re_Fmt[8], 0, pp_match);
    return caml_call4(Re_Fmt[2], fmt, cst_Group, _c_, matches);
   }
   function nb_groups(t){return t[5];}
   var
    Re_Group =
      [0,
       get,
       get_opt,
       offset,
       start,
       stop,
       all,
       all_offset,
       test,
       nb_groups,
       pp];
   runtime.caml_register_global(10, Re_Group, "Re__Group");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Compile
//# unitInfo: Requires: Re__Ast, Re__Automata, Re__Category, Re__Color_map, Re__Cset, Re__Import, Stdlib, Stdlib__Array, Stdlib__Char, Stdlib__Int, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Int = global_data.Stdlib__Int,
    Re_Import = global_data.Re__Import,
    Re_Cset = global_data.Re__Cset,
    Re_Color_map = global_data.Re__Color_map,
    Stdlib_Char = global_data.Stdlib__Char,
    Re_Automata = global_data.Re__Automata,
    Re_Category = global_data.Re__Category,
    Re_Ast = global_data.Re__Ast,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array;
   function iter(n, f, v){
    var n$0 = n, v$0 = v;
    for(;;){
     if(caml_call2(Stdlib_Int[8], n$0, 0)) return v$0;
     var v$1 = caml_call1(f, v$0), n$1 = n$0 - 1 | 0;
     n$0 = n$1;
     v$0 = v$1;
    }
   }
   var break$0 = -3, dummy = 0;
   function get_info(param){return param[1];}
   function follow_transition(param, color){
    return param[1 + (1 + caml_call1(Re_Cset[1], color) | 0)];
   }
   function set_transition(param, color, st){
    var _ax_ = 1 + caml_call1(Re_Cset[1], color) | 0;
    caml_check_bound(param, _ax_)[1 + _ax_] = st;
   }
   var
    info = [0, -2, 0, 0, Re_Automata[19][1]],
    unknown_state = [0, info],
    _a_ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
   function pp_re(ch, re){return caml_call2(Re_Automata[5], ch, re[1]);}
   function group_count(re){return re[10];}
   function group_names(re){return re[9];}
   function category(re, color){
    var _ar_ = caml_call1(Re_Cset[1], color);
    if(caml_call2(Re_Import[2], _ar_, -1)) return Re_Category[4];
    var _as_ = re[6], _at_ = caml_call1(Re_Cset[1], color);
    if(caml_call2(Re_Import[2], _at_, _as_)){
     var
      _au_ = Re_Category[6],
      _av_ = caml_call2(Re_Category[1], Re_Category[8], Re_Category[7]);
     return caml_call2(Re_Category[1], _av_, _au_);
    }
    var _aw_ = caml_call2(Re_Color_map[1][1], re[4], color);
    return caml_call1(Re_Category[2], _aw_);
   }
   function find_state(re, desc){
    try{
     var _ap_ = caml_call2(Re_Automata[19][5][7], re[8], desc);
     return _ap_;
    }
    catch(_aq_){
     var _ao_ = caml_wrap_exception(_aq_);
     if(_ao_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ao_, 0);
     var ncol$0 = re[5], match = caml_call1(Re_Automata[19][4], desc);
     a:
     {
      if(typeof match === "number" && match){var break_state = 0; break a;}
      var break_state = 1;
     }
     var
      real_idx = caml_call1(Re_Automata[19][3], desc),
      _an_ = 0,
      break$1 = break_state ? break$0 : real_idx,
      state = [0, break$1, real_idx, _an_, desc],
      ncol = break_state ? 0 : ncol$0,
      st = caml_make_vect(ncol + 1 | 0, unknown_state);
     caml_check_bound(st, 0)[1] = state;
     caml_call3(Re_Automata[19][5][5], re[8], desc, st);
     return st;
    }
   }
   function delta(info, cat, color, st){
    var
     desc = caml_call4(Re_Automata[21], info[1][7], cat, color, st[4]),
     len = info[2].length - 1,
     _ak_ = caml_call1(Re_Automata[19][3], desc),
     _al_ = caml_call2(Re_Import[2], _ak_, len),
     _am_ = _al_ ? 0 < len ? 1 : 0 : _al_;
    if(_am_){
     var pos = info[2];
     info[2] = caml_make_vect(2 * len | 0, 0);
     caml_call5(Stdlib_Array[9], pos, 0, info[2], 0, len);
    }
    return desc;
   }
   function validate(info, s, pos, st){
    var
     _aj_ = caml_string_get(s, pos),
     color = caml_call2(Re_Color_map[2][2], info[1][3], _aj_),
     cat = category(info[1], color),
     desc = delta(info, cat, color, get_info(st)),
     st$0 = find_state(info[1], desc);
    return set_transition(st, color, st$0);
   }
   function next(colors, st, s, pos){
    return follow_transition
            (st,
             caml_call2
              (Re_Color_map[2][2],
               colors,
               runtime.caml_string_unsafe_get(s, pos)));
   }
   function get_color(re, s, pos){
    if(0 > pos) return caml_call1(Re_Cset[2], -1);
    var slen = caml_ml_string_length(s);
    if(slen <= pos) return caml_call1(Re_Cset[2], -1);
    if(caml_call2(Re_Import[2], pos, slen - 1 | 0) && -1 !== re[6]){
     var _ai_ = caml_string_get(s, pos);
     if(caml_call2(Stdlib_Char[6], _ai_, 10))
      return caml_call1(Re_Cset[2], re[6]);
    }
    var _ah_ = caml_string_get(s, pos);
    return caml_call2(Re_Color_map[2][2], re[3], _ah_);
   }
   function scan_str(info$0, s, initial_state, groups){
    var pos$3 = info$0[3], last = info$0[4];
    if
     (caml_call2(Re_Import[2], last, caml_ml_string_length(s))
      && -1 !== info$0[1][6] && pos$3 < last){
     var _af_ = caml_string_get(s, last - 1 | 0);
     if(caml_call2(Stdlib_Char[6], _af_, 10)){
      var
       info$1 = [0, info$0[1], info$0[2], info$0[3], last - 1 | 0],
       st$3 = scan_str(info$1, s, initial_state, groups),
       _ag_ = get_info(st$3)[1];
      if(caml_call2(Re_Import[2], _ag_, break$0)) return st$3;
      var pos$4 = last - 1 | 0;
      for(;;){
       var
        st$1 = follow_transition(st$3, caml_call1(Re_Cset[2], info$1[1][6])),
        info = get_info(st$1);
       if(0 <= info[1]){
        if(groups){
         var _ad_ = info[1];
         caml_check_bound(info$1[2], _ad_)[1 + _ad_] = pos$4;
        }
        return st$1;
       }
       if(caml_call2(Re_Import[2], info[1], break$0)){
        if(groups){
         var _ae_ = info[2];
         caml_check_bound(info$1[2], _ae_)[1 + _ae_] = pos$4;
        }
        return st$1;
       }
       var
        color = caml_call1(Re_Cset[2], info$1[1][6]),
        cat = category(info$1[1], color),
        real_c = caml_call2(Re_Color_map[2][2], info$1[1][3], 10),
        desc = delta(info$1, cat, real_c, get_info(st$3)),
        st$2 = find_state(info$1[1], desc);
       set_transition(st$3, color, st$2);
      }
     }
    }
    if(groups){
     var
      positions$1 = info$0[2],
      colors = info$0[1][3],
      positions = positions$1,
      pos = pos$3,
      st0 = initial_state,
      st = initial_state;
     for(;;){
      if(pos >= last) return st;
      var
       st0$0 = next(colors, st, s, pos),
       state_info = get_info(st0$0),
       idx = state_info[1];
      if(0 <= idx){
       positions[1 + idx] = pos;
       var pos$0 = pos + 1 | 0;
       pos = pos$0;
       st0 = st0$0;
       st = st0$0;
      }
      else{
       if(caml_call2(Re_Import[2], idx, break$0)){
        positions[1 + state_info[2]] = pos;
        return st0$0;
       }
       validate(info$0, s, pos, st0);
       var positions$0 = info$0[2];
       positions = positions$0;
       st = st0;
      }
     }
    }
    else{
     var
      colors$0 = info$0[1][3],
      pos$1 = pos$3,
      st0$1 = initial_state,
      st$0 = initial_state;
     for(;;){
      if(pos$1 >= last) return st$0;
      var
       st0$2 = next(colors$0, st$0, s, pos$1),
       state_info$0 = get_info(st0$2),
       idx$0 = state_info$0[1];
      if(0 <= idx$0){
       var pos$2 = pos$1 + 1 | 0;
       pos$1 = pos$2;
       st0$1 = st0$2;
       st$0 = st0$2;
      }
      else{
       if(caml_call2(Re_Import[2], idx$0, break$0)) return st0$2;
       validate(info$0, s, pos$1, st0$1);
       st$0 = st0$1;
      }
     }
    }
   }
   function final_boundary_check(last, slen, re, s, info, st$0, groups){
    var
     _ab_ =
       caml_call2(Re_Import[2], last, slen)
        ? Re_Category[4]
        : category(re, get_color(re, s, last)),
     final_cat = caml_call2(Re_Category[1], Re_Category[9], _ab_),
     st$1 = get_info(st$0);
    try{
     var
      _aa_ = caml_call2(Stdlib_ListLabels[51], final_cat, st$1[3]),
      match = _aa_;
    }
    catch(_ac_){
     var ___ = caml_wrap_exception(_ac_);
     if(___ !== Stdlib[8]) throw caml_maybe_attach_backtrace(___, 0);
     var
      st = delta(info, final_cat, caml_call1(Re_Cset[2], -1), st$1),
      _$_ = caml_call1(Re_Automata[19][4], st),
      res = [0, caml_call1(Re_Automata[19][3], st), _$_];
     st$1[3] = [0, [0, final_cat, res], st$1[3]];
     var match = res;
    }
    var res$0 = match[2], idx = match[1];
    a:
    if(groups && typeof res$0 !== "number"){
     caml_check_bound(info[2], idx)[1 + idx] = last;
     break a;
    }
    return res$0;
   }
   function match_str(groups, partial, re, s, pos, len){
    var
     slen = caml_ml_string_length(s),
     last = caml_call2(Re_Import[2], len, -1) ? slen : pos + len | 0;
    if(groups)
     var
      n = caml_call1(Re_Automata[20][2], re[7]) + 1 | 0,
      _U_ = 10 < n ? caml_make_vect(n, 0) : _a_.slice(),
      _V_ = _U_;
    else
     var _V_ = [0];
    var
     info = [0, re, _V_, pos, last],
     _W_ =
       caml_call2(Re_Import[2], pos, 0)
        ? Re_Category[4]
        : category(re, get_color(re, s, pos - 1 | 0)),
     initial_cat = caml_call2(Re_Category[1], Re_Category[9], _W_);
    try{
     var
      _T_ = caml_call2(Stdlib_ListLabels[51], initial_cat, re[2]),
      initial_state = _T_;
    }
    catch(_Z_){
     var _S_ = caml_wrap_exception(_Z_);
     if(_S_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_S_, 0);
     var
      st = find_state(re, caml_call2(Re_Automata[19][2], initial_cat, re[1]));
     re[2] = [0, [0, initial_cat, st], re[2]];
     var initial_state = st;
    }
    var
     st$0 = scan_str(info, s, initial_state, groups),
     state_info = get_info(st$0);
    a:
    {
     b:
     if(! caml_call2(Re_Import[2], state_info[1], break$0)){
      if(partial && ! groups) break b;
      if(partial && groups){
       var status = caml_call1(Re_Automata[19][4], state_info[4]);
       c:
       {
        if(typeof status === "number" && status){
         var
          status$0 =
            final_boundary_check(last, slen, re, s, info, st$0, groups),
          _X_ = typeof status$0 === "number" ? 1 : status$0,
          _Y_ = _X_;
         break c;
        }
        var _Y_ = status;
       }
       var match = _Y_;
       break a;
      }
      var match = final_boundary_check(last, slen, re, s, info, st$0, groups);
      break a;
     }
     var match = caml_call1(Re_Automata[19][4], state_info[4]);
    }
    if(typeof match !== "number"){
     var pmarks = match[2], marks = match[1];
     return [0, [0, s, marks, pmarks, info[2], re[10]]];
    }
    if(! match) return 0;
    var no_match_starts_before = groups ? caml_check_bound(info[2], 0)[1] : 0;
    return [1, no_match_starts_before];
   }
   function enforce_kind(ids, kind$0, kind, cr){
    if(typeof kind$0 === "number" && 332064784 === kind$0){
     if(typeof kind === "number" && 332064784 === kind) return cr;
     var _R_ = caml_call1(Re_Automata[11], ids);
     return caml_call4(Re_Automata[10], ids, kind, cr, _R_);
    }
    return cr;
   }
   function translate(ctx, ast){
    var ctx$0 = ctx, ast$0 = ast;
    for(;;){
     var
      colors = ctx$0[8],
      cache = ctx$0[7],
      names = ctx$0[6],
      pos = ctx$0[5],
      greedy = ctx$0[4],
      ign_group = ctx$0[3],
      kind = ctx$0[2],
      ids = ctx$0[1];
     if(typeof ast$0 === "number")
      switch(ast$0){
        case 0:
         var _l_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[17], ids, _l_), kind];
        case 1:
         var _m_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[16], ids, _m_), kind];
        case 2:
         var
          _n_ = caml_call2(Re_Automata[16], ids, Re_Category[5]),
          _o_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _p_ = caml_call2(Re_Automata[17], ids, _o_);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _p_, _n_),
                 kind];
        case 3:
         var
          _q_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _r_ = caml_call2(Re_Automata[16], ids, _q_),
          _s_ = caml_call2(Re_Automata[17], ids, Re_Category[5]);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _s_, _r_),
                 kind];
        case 4:
         var
          cat = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _t_ = caml_call2(Re_Automata[16], ids, cat),
          _u_ = caml_call2(Re_Automata[17], ids, cat),
          _v_ = [0, caml_call4(Re_Automata[10], ids, 332064784, _u_, _t_), 0],
          _w_ = caml_call2(Re_Automata[16], ids, Re_Category[5]),
          _x_ = caml_call2(Re_Automata[17], ids, Re_Category[5]),
          _y_ =
            [0, caml_call4(Re_Automata[10], ids, 332064784, _x_, _w_), _v_];
         return [0, caml_call2(Re_Automata[9], ids, _y_), kind];
        case 5:
         return [0, caml_call2(Re_Automata[17], ids, Re_Category[4]), kind];
        case 6:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[4]), kind];
        case 7:
         var _z_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[8]);
         return [0, caml_call2(Re_Automata[16], ids, _z_), kind];
        case 8:
         return [0, caml_call2(Re_Automata[17], ids, Re_Category[9]), kind];
        default:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[9]), kind];
      }
     switch(ast$0[0]){
       case 0:
        var s = ast$0[1], match = caml_call1(Re_Cset[41], s);
        if(match)
         var
          i = match[1],
          _i_ = caml_call2(Re_Color_map[2][1], colors, i),
          _A_ = caml_call1(Re_Cset[46], _i_);
        else{
         var v = [0, caml_call1(Re_Cset[43], s), s];
         try{var _k_ = caml_call2(Re_Cset[44][17], v, cache[1]), _A_ = _k_;}
         catch(_Q_){
          var _j_ = caml_wrap_exception(_Q_);
          if(_j_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_j_, 0);
          var l = caml_call2(Re_Color_map[2][3], colors, s);
          cache[1] = caml_call3(Re_Cset[44][2], v, l, cache[1]);
          var _A_ = l;
         }
        }
        return [0, caml_call2(Re_Automata[7], ids, _A_), kind];
       case 1:
        var l$0 = ast$0[1][1], merged_sequences = caml_call1(Re_Ast[2], l$0);
        if(merged_sequences && ! merged_sequences[2]){
         var
          r = merged_sequences[1],
          match$0 = translate(ctx$0, r),
          kind$0 = match$0[2],
          cr = match$0[1];
         return [0, enforce_kind(ids, kind, kind$0, cr), kind];
        }
        var
         _B_ =
           caml_call2
            (Stdlib_ListLabels[20],
             function(r){
              var
               match = translate(ctx$0, r),
               kind$0 = match[2],
               cr = match[1];
              return enforce_kind(ids, kind, kind$0, cr);
             },
             merged_sequences);
        return [0, caml_call2(Re_Automata[9], ids, _B_), kind];
       case 2:
        var l$1 = ast$0[1]; return [0, trans_seq(ctx$0, l$1), kind];
       case 3:
        var
         j = ast$0[3],
         i$0 = ast$0[2],
         r$0 = ast$0[1],
         match$1 = translate(ctx$0, r$0),
         kind$1 = match$1[2],
         cr$0 = match$1[1];
        if(j)
         var
          j$0 = j[1],
          f =
            620821490 <= greedy
             ? function
              (rem){
               var
                _K_ = caml_call2(Re_Automata[18], ids, cr$0),
                _L_ =
                  [0, caml_call4(Re_Automata[10], ids, kind$1, _K_, rem), 0],
                _M_ = [0, caml_call1(Re_Automata[11], ids), _L_];
               return caml_call2(Re_Automata[9], ids, _M_);
              }
             : function
              (rem){
               var
                _N_ = [0, caml_call1(Re_Automata[11], ids), 0],
                _O_ = caml_call2(Re_Automata[18], ids, cr$0),
                _P_ =
                  [0, caml_call4(Re_Automata[10], ids, kind$1, _O_, rem), _N_];
               return caml_call2(Re_Automata[9], ids, _P_);
              },
          rem = iter(j$0 - i$0 | 0, f, caml_call1(Re_Automata[11], ids));
        else
         var rem = caml_call4(Re_Automata[12], ids, greedy, kind$1, cr$0);
        return [0,
                iter
                 (i$0,
                  function(rem){
                   var _J_ = caml_call2(Re_Automata[18], ids, cr$0);
                   return caml_call4(Re_Automata[10], ids, kind$1, _J_, rem);
                  },
                  rem),
                kind];
       case 4:
        var ast$1 = ast$0[2], n = ast$0[1];
        if(! ign_group){
         var p = pos[1];
         if(n){
          var name = n[1], _C_ = names[1];
          names[1] = [0, [0, name, caml_call1(Re_Automata[1][5], p)], _C_];
         }
         pos[1] = caml_call1(Re_Automata[1][4], pos[1]);
         var
          match$2 = translate(ctx$0, ast$1),
          kind$2 = match$2[2],
          cr$1 = match$2[1],
          _D_ = caml_call1(Re_Automata[1][3], p),
          _E_ = caml_call2(Re_Automata[13], ids, _D_),
          _F_ = caml_call4(Re_Automata[10], ids, 332064784, cr$1, _E_),
          _G_ = caml_call2(Re_Automata[13], ids, p);
         return [0,
                 caml_call4(Re_Automata[10], ids, 332064784, _G_, _F_),
                 kind$2];
        }
        ast$0 = ast$1;
        break;
       case 5:
        var
         ast$2 = ast$0[1],
         ctx$1 =
           [0,
            ctx$0[1],
            ctx$0[2],
            1,
            ctx$0[4],
            ctx$0[5],
            ctx$0[6],
            ctx$0[7],
            ctx$0[8]];
        ctx$0 = ctx$1;
        ast$0 = ast$2;
        break;
       case 6:
        var
         r$1 = ast$0[1],
         b = pos[1],
         match$3 = translate(ctx$0, r$1),
         kind$3 = match$3[2],
         cr$2 = match$3[1],
         e = caml_call1(Re_Automata[1][2], pos[1]);
        if(e < b) return [0, cr$2, kind$3];
        var _H_ = caml_call3(Re_Automata[15], ids, b, e);
        return [0,
                caml_call4(Re_Automata[10], ids, 332064784, _H_, cr$2),
                kind$3];
       case 7:
        var
         r$2 = ast$0[2],
         i$1 = ast$0[1],
         match$4 = translate(ctx$0, r$2),
         kind$4 = match$4[2],
         cr$3 = match$4[1],
         _I_ = caml_call2(Re_Automata[14], ids, i$1);
        return [0,
                caml_call4(Re_Automata[10], ids, 332064784, _I_, cr$3),
                kind$4];
       case 8:
        var
         r$3 = ast$0[2],
         kind$5 = ast$0[1],
         match$5 =
           translate
            ([0,
              ctx$0[1],
              kind$5,
              ctx$0[3],
              ctx$0[4],
              ctx$0[5],
              ctx$0[6],
              ctx$0[7],
              ctx$0[8]],
             r$3),
         kind$6 = match$5[2],
         cr$4 = match$5[1];
        return [0, enforce_kind(ids, kind$5, kind$6, cr$4), kind$5];
       default:
        var
         ast$3 = ast$0[2],
         greedy$0 = ast$0[1],
         ctx$2 =
           [0,
            ctx$0[1],
            ctx$0[2],
            ctx$0[3],
            greedy$0,
            ctx$0[5],
            ctx$0[6],
            ctx$0[7],
            ctx$0[8]];
        ctx$0 = ctx$2;
        ast$0 = ast$3;
     }
    }
   }
   function trans_seq(ctx, param){
    var kind = ctx[2], ids = ctx[1];
    if(! param) return caml_call1(Re_Automata[11], ids);
    var r = param[1];
    if(param[2]){
     var
      rem = param[2],
      match = translate(ctx, r),
      kind$0 = match[2],
      cr = match[1],
      cr$0 = trans_seq(ctx, rem);
     return caml_call1(Re_Automata[4], cr$0)
             ? cr
             : caml_call1
                (Re_Automata[4], cr)
               ? cr$0
               : caml_call4(Re_Automata[10], ids, kind$0, cr, cr$0);
    }
    var match$0 = translate(ctx, r), kind$1 = match$0[2], cr$1 = match$0[1];
    return enforce_kind(ids, kind, kind$1, cr$1);
   }
   function compile(r$0){
    if(caml_call1(Re_Ast[4], r$0))
     var regexp$0 = caml_call2(Re_Ast[6][21], 0, r$0);
    else
     var
      _e_ = [0, caml_call2(Re_Ast[6][21], 0, r$0), 0],
      _f_ = caml_call1(Re_Ast[7], Re_Cset[45]),
      _g_ = caml_call1(Re_Ast[6][32], _f_),
      _h_ = [0, caml_call1(Re_Ast[6][35], _g_), _e_],
      regexp$0 = caml_call1(Re_Ast[6][36], _h_);
    var
     regexp = caml_call2(Re_Ast[3], 0, regexp$0),
     color_map = caml_call1(Re_Color_map[3], 0),
     need_lnl = caml_call2(Re_Ast[5], color_map, regexp),
     match = caml_call1(Re_Color_map[4], color_map),
     color_repr = match[2],
     colors = match[1],
     ncolor = caml_call1(Re_Color_map[1][2], color_repr),
     lnl = need_lnl ? ncolor : -1,
     ncolor$0 = need_lnl ? ncolor + 1 | 0 : ncolor,
     _c_ = [0, Re_Cset[44][1]],
     _d_ = [0, Re_Automata[1][1]],
     ctx =
       [0,
        caml_call1(Re_Automata[6][1], 0),
        332064784,
        0,
        -904640576,
        _d_,
        [0, 0],
        _c_,
        colors],
     match$0 = translate(ctx, regexp),
     kind = match$0[2],
     r = match$0[1],
     initial = enforce_kind(ctx[1], 332064784, kind, r),
     group_count = caml_call1(Re_Automata[1][5], ctx[5][1]),
     group_names = caml_call1(Stdlib_ListLabels[10], ctx[6][1]),
     _b_ = caml_call1(Re_Automata[19][5][1], 97);
    return [0,
            initial,
            0,
            colors,
            color_repr,
            ncolor$0,
            lnl,
            caml_call1(Re_Automata[20][1], 0),
            _b_,
            group_names,
            group_count];
   }
   var
    Re_Compile =
      [0, match_str, compile, group_count, group_names, pp_re, pp_re];
   runtime.caml_register_global(12, Re_Compile, "Re__Compile");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Search
//# unitInfo: Requires: Re__Compile, Re__Group, Stdlib, Stdlib__Seq, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Re_all$1 = "Re.all",
    cst_Re_split$1 = "Re.split",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Assert_failure = global_data.Assert_failure,
    Re_Compile = global_data.Re__Compile,
    Stdlib_String = global_data.Stdlib__String,
    Re_Group = global_data.Re__Group,
    Stdlib = global_data.Stdlib,
    Stdlib_Seq = global_data.Stdlib__Seq,
    cst_Re_all = cst_Re_all$1,
    cst_Re_all$0 = cst_Re_all$1,
    cst_Re_split = cst_Re_split$1,
    cst_Re_split$0 = cst_Re_split$1,
    _a_ = [0, "lib/search.ml", 55, 6];
   function all(opt, len, re, s){
    var pos = opt ? opt[1] : 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_all);
    if(len){
     var
      l = len[1],
      _r_ = l < 0 ? 1 : 0,
      _s_ = _r_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_s_) caml_call1(Stdlib[1], cst_Re_all$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(pos, on_match, param){
     var pos$0 = pos, on_match$0 = on_match;
     for(;;){
      if(limit < pos$0) return 0;
      var
       match =
         caml_call6(Re_Compile[1], 1, 0, re, s, pos$0, limit - pos$0 | 0);
      if(typeof match !== "number" && 0 === match[0]){
       var
        substr = match[1],
        match$0 = caml_call2(Re_Group[3], substr, 0),
        p2 = match$0[2],
        p1 = match$0[1];
       if(on_match$0 && p1 === pos$0 && p1 === p2){
        var pos$1 = pos$0 + 1 | 0;
        pos$0 = pos$1;
        on_match$0 = 0;
        continue;
       }
       var pos$2 = p1 === p2 ? p2 + 1 | 0 : p2, _v_ = p1 !== p2 ? 1 : 0;
       return [0, substr, function(_w_){return aux(pos$2, _v_, _w_);}];
      }
      return 0;
     }
    }
    var _t_ = 0;
    return function(_u_){return aux(pos, _t_, _u_);};
   }
   function matches(pos, len, re, s){
    var _q_ = all(pos, len, re, s);
    return caml_call1
            (caml_call1
              (Stdlib_Seq[29],
               function(sub){return caml_call2(Re_Group[1], sub, 0);}),
             _q_);
   }
   function split_full(opt, len, re, s){
    var pos = opt ? opt[1] : 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_split);
    if(len){
     var
      l = len[1],
      _h_ = l < 0 ? 1 : 0,
      _i_ = _h_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_i_) caml_call1(Stdlib[1], cst_Re_split$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(state, i, pos$0, param){
     var old_i = i, pos$1 = pos$0;
     for(;;){
      if(typeof state !== "number"){
       var x = state[2], _l_ = 814535476;
       return [0, x, function(_p_){return aux(_l_, old_i, pos$1, _p_);}];
      }
      if(limit < pos$1){
       if(old_i === limit) return 0;
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      }
      var
       match =
         caml_call6(Re_Compile[1], 1, 0, re, s, pos$1, limit - pos$1 | 0);
      if(typeof match === "number"){
       if(old_i >= limit) return 0;
       var text = caml_call3(Stdlib_String[16], s, old_i, limit - old_i | 0);
       return [0,
               [0, 936573133, text],
               function(_o_){return aux(state, limit, pos$1, _o_);}];
      }
      if(0 !== match[0]) return 0;
      var
       substr = match[1],
       match$0 = caml_call2(Re_Group[3], substr, 0),
       p2 = match$0[2],
       p1 = match$0[1],
       pos$2 = p1 === p2 ? p2 + 1 | 0 : p2;
      if(old_i === p1 && p1 === p2 && pos < p1){old_i = p2; pos$1 = pos$2; continue;}
      if(pos >= p1)
       return [0,
               [0, -363573681, substr],
               function(_n_){return aux(state, p2, pos$2, _n_);}];
      var
       text$0 = caml_call3(Stdlib_String[16], s, old_i, p1 - old_i | 0),
       state$0 = [0, 73271853, [0, -363573681, substr]];
      return [0,
              [0, 936573133, text$0],
              function(_m_){return aux(state$0, p2, pos$2, _m_);}];
     }
    }
    var _j_ = 814535476;
    return function(_k_){return aux(_j_, pos, pos, _k_);};
   }
   function split(pos, len, re, s){
    var seq = split_full(pos, len, re, s);
    function filter(seq, param){
     var seq$0 = seq;
     for(;;){
      var match = caml_call1(seq$0, 0);
      if(! match) return 0;
      var match$0 = match[1];
      if(936573133 <= match$0[1]){
       var tl = match[2], s = match$0[2];
       return [0, s, function(_g_){return filter(tl, _g_);}];
      }
      var seq$1 = match[2];
      seq$0 = seq$1;
     }
    }
    return function(_f_){return filter(seq, _f_);};
   }
   function split_delim(pos, len, re, s){
    var seq = split_full(pos, len, re, s);
    function filter(delim, seq, param){
     var delim$0 = delim, seq$0 = seq;
     for(;;){
      var match = caml_call1(seq$0, 0);
      if(! match) return delim$0 ? [0, cst$0, function(param){return 0;}] : 0;
      var match$0 = match[1];
      if(936573133 <= match$0[1]){
       var tl = match[2], s = match$0[2], _d_ = 0;
       return [0, s, function(_e_){return filter(_d_, tl, _e_);}];
      }
      var seq$1 = match[2];
      if(delim$0)
       return [0, cst, function(param){return filter(1, seq$1, 0);}];
      delim$0 = 1;
      seq$0 = seq$1;
     }
    }
    var _b_ = 1;
    return function(_c_){return filter(_b_, seq, _c_);};
   }
   var Re_Search = [0, all, matches, split_full, split, split_delim];
   runtime.caml_register_global(13, Re_Search, "Re__Search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Core
//# unitInfo: Requires: Re__Ast, Re__Compile, Re__Cset, Re__Group, Re__Pmark, Re__Search, Stdlib, Stdlib__ListLabels, Stdlib__Seq
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Search = global_data.Re__Search,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Re_Pmark = global_data.Re__Pmark,
    Stdlib = global_data.Stdlib,
    Re_Compile = global_data.Re__Compile,
    Re_Cset = global_data.Re__Cset,
    Re_Ast = global_data.Re__Ast,
    Re_Group = global_data.Re__Group,
    cset = Re_Ast[7];
   function char$0(c){return caml_call1(cset, caml_call1(Re_Cset[46], c));}
   function rg(c$0, c){
    return caml_call1(cset, caml_call2(Re_Cset[25], c$0, c));
   }
   var
    any = caml_call1(cset, Re_Cset[45]),
    notnl = caml_call1(cset, Re_Cset[22]),
    lower = caml_call1(cset, Re_Cset[30]),
    upper = caml_call1(cset, Re_Cset[31]),
    alpha = caml_call1(cset, Re_Cset[32]),
    digit = caml_call1(cset, Re_Cset[19]),
    alnum = caml_call1(cset, Re_Cset[33]),
    wordc = caml_call1(cset, Re_Cset[34]),
    ascii = caml_call1(cset, Re_Cset[23]),
    blank = caml_call1(cset, Re_Cset[27]),
    cntrl = caml_call1(cset, Re_Cset[35]),
    graph = caml_call1(cset, Re_Cset[36]),
    print = caml_call1(cset, Re_Cset[37]),
    punct = caml_call1(cset, Re_Cset[38]),
    space = caml_call1(cset, Re_Cset[28]),
    xdigit = caml_call1(cset, Re_Cset[29]),
    include = Re_Ast[6],
    empty = include[1],
    epsilon = include[2],
    str = include[3],
    no_case = include[4],
    case$0 = include[5],
    diff = include[6],
    compl = include[7],
    repn = include[8],
    inter = include[9],
    set = include[10],
    mark = include[11],
    nest = include[12],
    no_group = include[13],
    whole_string = include[14],
    leol = include[15],
    longest = include[16],
    greedy = include[17],
    non_greedy = include[18],
    stop = include[19],
    not_boundary = include[20],
    group = include[21],
    word = include[22],
    first = include[23],
    bos = include[24],
    bow = include[25],
    eow = include[26],
    eos = include[27],
    bol = include[28],
    start = include[29],
    eol = include[30],
    opt = include[31],
    rep = include[32],
    rep1 = include[33],
    alt = include[34],
    shortest = include[35],
    seq = include[36],
    pp = include[37],
    witness = include[38];
   function exec_internal(_b_, opt, partial, groups, re, s){
    var pos = _b_ ? _b_[1] : 0, len = opt ? opt[1] : -1;
    return caml_call6(Re_Compile[1], groups, partial, re, s, pos, len);
   }
   function exec(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return substr;}
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function exec_opt(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return [0, substr];}
    return 0;
   }
   function execp(pos, len, re, s){
    var match = exec_internal(pos, len, 0, 0, re, s);
    if(typeof match !== "number" && 0 === match[0]) return 1;
    return 0;
   }
   function exec_partial(pos, len, re, s){
    var match = exec_internal(pos, len, 1, 0, re, s);
    return typeof match === "number"
            ? -1062743954
            : 0 === match[0] ? 782112175 : 939392865;
   }
   function exec_partial_detailed(pos, len, re, s){
    var match = exec_internal(pos, len, 1, 1, re, s);
    if(typeof match === "number") return -1062743954;
    if(0 === match[0]){var group = match[1]; return [0, 782112175, group];}
    var no_match_starts_before = match[1];
    return [0, 939392865, no_match_starts_before];
   }
   function marked(g, p){return caml_call2(Re_Pmark[5][31], p, g[3]);}
   function mark_set(g){return g[3];}
   var equal = Re_Pmark[1], compare = Re_Pmark[2];
   function gen_of_seq(s){
    var r = [0, s];
    return function(param){
     var match = caml_call1(r[1], 0);
     if(! match) return 0;
     var tl = match[2], x = match[1];
     r[1] = tl;
     return [0, x];};
   }
   function split_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[4], pos, len, re, s));
   }
   function split_full_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[3], pos, len, re, s));
   }
   function all_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[1], pos, len, re, s));
   }
   function matches_gen(pos, len, re, s){
    return gen_of_seq(caml_call4(Re_Search[2], pos, len, re, s));
   }
   var
    split_full_seq = Re_Search[3],
    split_seq = Re_Search[4],
    matches_seq = Re_Search[2],
    all_seq = Re_Search[1],
    get = Re_Group[1],
    get_ofs = Re_Group[3],
    get_all = Re_Group[6],
    get_all_ofs = Re_Group[7],
    test = Re_Group[8];
   function list_of_seq(s){
    var
     _a_ = caml_call3(Stdlib_Seq[5], function(l, x){return [0, x, l];}, 0, s);
    return caml_call1(Stdlib_ListLabels[10], _a_);
   }
   function all(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[1], pos, len, re, s));
   }
   function matches(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[2], pos, len, re, s));
   }
   function split_full(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[3], pos, len, re, s));
   }
   function split(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[4], pos, len, re, s));
   }
   function split_delim(pos, len, re, s){
    return list_of_seq(caml_call4(Re_Search[5], pos, len, re, s));
   }
   var
    compile = Re_Compile[2],
    pp_re = Re_Compile[6],
    print_re = Re_Compile[5],
    group_names = Re_Compile[4],
    group_count = Re_Compile[3],
    Re_Core =
      [0,
       Re_Group,
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       [0, marked, Re_Pmark[5], mark_set, equal, compare],
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_delim,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       [0,
        Re_Search[1],
        Re_Search[2],
        Re_Search[4],
        Re_Search[5],
        Re_Search[3]],
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       pp_re,
       print_re,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set];
   runtime.caml_register_global(9, Re_Core, "Re__Core");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Parse_buffer
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Parse_error =
      [248, "Re__Parse_buffer.Parse_error", runtime.caml_fresh_oo_id(0)];
   function create(str){return [0, str, 0];}
   function unget(t){t[2] = t[2] - 1 | 0; return 0;}
   function junk(t){t[2] = t[2] + 1 | 0; return 0;}
   function eos(t){return t[2] === caml_ml_string_length(t[1]) ? 1 : 0;}
   function test(t, c){
    var
     _l_ = 1 - eos(t),
     _m_ = _l_ ? caml_string_get(t[1], t[2]) === c ? 1 : 0 : _l_;
    return _m_;
   }
   function test2(t, c$0, c){
    var _i_ = (t[2] + 1 | 0) < caml_ml_string_length(t[1]) ? 1 : 0;
    if(_i_)
     var
      _j_ = caml_string_get(t[1], t[2]) === c$0 ? 1 : 0,
      _k_ = _j_ ? caml_string_get(t[1], t[2] + 1 | 0) === c ? 1 : 0 : _j_;
    else
     var _k_ = _i_;
    return _k_;
   }
   function accept(t, c){
    var r = test(t, c);
    if(r) t[2] = t[2] + 1 | 0;
    return r;
   }
   function accept2(t, c$0, c){
    var r = test2(t, c$0, c);
    if(r) t[2] = t[2] + 2 | 0;
    return r;
   }
   function get(t){
    var r = caml_string_get(t[1], t[2]);
    t[2] = t[2] + 1 | 0;
    return r;
   }
   function accept_s(t, s){
    var len = caml_ml_string_length(s);
    try{
     var _c_ = len - 1 | 0, _b_ = 0;
     if(_c_ >= 0){
      var j = _b_;
      for(;;){
       try{
        var _e_ = caml_string_get(t[1], t[2] + j | 0);
        if(caml_string_get(s, j) !== _e_) throw Stdlib[3];
       }
       catch(_h_){throw Stdlib[3];}
       var _f_ = j + 1 | 0;
       if(_c_ === j) break;
       j = _f_;
      }
     }
     t[2] = t[2] + len | 0;
     var _d_ = 1;
     return _d_;
    }
    catch(_g_){
     var _a_ = caml_wrap_exception(_g_);
     if(_a_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   function integer(t){
    if(eos(t)) return 0;
    var d$0 = get(t);
    if(9 < d$0 - 48 >>> 0){unget(t); return 0;}
    var i$1 = d$0 - 48 | 0, i = i$1;
    for(;;){
     if(eos(t)) return [0, i];
     var d = get(t);
     if(9 < d - 48 >>> 0){unget(t); return [0, i];}
     var i$0 = (10 * i | 0) + (d - 48 | 0) | 0;
     if(i$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
     i = i$0;
    }
   }
   var
    Re_Parse_buffer =
      [0,
       Parse_error,
       create,
       junk,
       unget,
       eos,
       test,
       test2,
       get,
       accept,
       accept2,
       accept_s,
       integer];
   runtime.caml_register_global(2, Re_Parse_buffer, "Re__Parse_buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Emacs
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Parse_error = [248, "Re__Emacs.Parse_error", caml_fresh_oo_id(0)],
    Not_supported = [248, "Re__Emacs.Not_supported", caml_fresh_oo_id(0)];
   function re(opt, s){
    var
     case$0 = opt ? opt[1] : 1,
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf),
     accept2 = caml_call1(Re_Parse_buffer[10], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    var test2 = caml_call1(Re_Parse_buffer[7], buf);
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call2(accept2, 92, 124)) return left$0;
      var
       _h_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _h_);
      left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if
       (!
        eos(0)
        && ! caml_call2(test2, 92, 124) && ! caml_call2(test2, 92, 41)){
       a:
       if(caml_call1(accept, 46))
        var r = Re_Core[62];
       else if(caml_call1(accept, 94))
        var r = Re_Core[35];
       else if(caml_call1(accept, 36))
        var r = Re_Core[36];
       else if(caml_call1(accept, 91))
        if(caml_call1(accept, 94))
         var _d_ = bracket(0), r = caml_call1(Re_Core[60], _d_);
        else
         var _e_ = bracket(0), r = caml_call1(Re_Core[27], _e_);
       else{
        if(! caml_call1(accept, 92)){
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c$0 = get(0);
         b:
         {
          if(44 <= c$0){if(63 === c$0) break b;} else if(42 <= c$0) break b;
          var r = caml_call1(Re_Core[26], c$0);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(caml_call1(accept, 40)){
         var r$0 = regexp(0);
         if(1 - caml_call2(accept2, 92, 41))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         var r = caml_call2(Re_Core[52], 0, r$0);
        }
        else if(caml_call1(accept, 96))
         var r = Re_Core[39];
        else if(caml_call1(accept, 39))
         var r = Re_Core[40];
        else if(caml_call1(accept, 61))
         var r = Re_Core[42];
        else if(caml_call1(accept, 98))
         var
          r = caml_call1(Re_Core[27], [0, Re_Core[37], [0, Re_Core[38], 0]]);
        else if(caml_call1(accept, 66))
         var r = Re_Core[45];
        else if(caml_call1(accept, 60))
         var r = Re_Core[37];
        else if(caml_call1(accept, 62))
         var r = Re_Core[38];
        else if(caml_call1(accept, 119))
         var
          _f_ = [0, caml_call1(Re_Core[26], 95), 0],
          r = caml_call1(Re_Core[27], [0, Re_Core[63], _f_]);
        else if(caml_call1(accept, 87))
         var
          _g_ = [0, caml_call1(Re_Core[26], 95), 0],
          r = caml_call1(Re_Core[60], [0, Re_Core[63], _g_]);
        else{
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(63 <= c){
           if(91 <= c){if(95 > c) break b;} else if(64 > c) break b;
          }
          else
           if(48 <= c){
            if(58 > c) throw caml_maybe_attach_backtrace(Not_supported, 1);
           }
           else if(36 <= c)
            switch(c - 36 | 0){case 0:case 6:case 7:case 10: break b;}
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var r = caml_call1(Re_Core[26], c);
        }
       }
       var
        _c_ =
          caml_call1(accept, 42)
           ? caml_call1(Re_Core[31], r)
           : caml_call1
              (accept, 43)
             ? caml_call1(Re_Core[32], r)
             : caml_call1(accept, 63) ? caml_call1(Re_Core[34], r) : r,
        left$0 = [0, _c_, left];
       left = left$0;
       continue;
      }
      var _b_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _b_);
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var c = char$0(0);
      if(caml_call1(accept, 45)){
       if(caml_call1(accept, 93)){
        var _a_ = [0, caml_call1(Re_Core[26], 45), s$0];
        return [0, caml_call1(Re_Core[26], c), _a_];
       }
       var c$0 = char$0(0), s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
       s$0 = s$1;
      }
      else{var s$2 = [0, caml_call1(Re_Core[26], c), s$0]; s$0 = s$2;}
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     return get(0);
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    return case$0 ? res : caml_call1(Re_Core[78], res);
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    var case$0 = opt ? opt[1] : 1;
    return caml_call1(compile, re([0, case$0], s));
   }
   var Re_Emacs = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(5, Re_Emacs, "Re__Emacs");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Str
//# unitInfo: Requires: CamlinternalLazy, Re__Core, Re__Emacs, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Re_Core = global_data.Re__Core,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Re_Emacs = global_data.Re__Emacs;
   function compile_regexp(s, c){
    var re = caml_call2(Re_Emacs[3], [0, 1 - c], s);
    return [0,
            re,
            [246,
             function(param){
              var
               _ai_ = caml_call1(Re_Core[28], [0, Re_Core[42], [0, re, 0]]);
              return caml_call1(Re_Core[2], _ai_);
             }],
            [246, function(_ah_){return caml_call1(Re_Core[2], re);}]];
   }
   var
    state = [0, 0],
    cst_Str_replace_illegal_backsl = "Str.replace: illegal backslash sequence",
    cst_Str_group_beginning = "Str.group_beginning",
    cst_Str_group_end = "Str.group_end";
   function string_match(re, s, p){
    try{
     var _ac_ = re[2], _ad_ = caml_obj_tag(_ac_);
     a:
     if(250 === _ad_)
      var _ae_ = _ac_[1];
     else{
      if(246 !== _ad_ && 244 !== _ad_){var _ae_ = _ac_; break a;}
      var _ae_ = caml_call1(CamlinternalLazy[2], _ac_);
     }
     state[1] = [0, caml_call4(Re_Core[5], [0, p], 0, _ae_, s)];
     var _af_ = 1;
     return _af_;
    }
    catch(_ag_){
     var _ab_ = caml_wrap_exception(_ag_);
     if(_ab_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ab_, 0);
     state[1] = 0;
     return 0;
    }
   }
   function string_partial_match(re, s, p){
    var ___ = re[2], _$_ = caml_obj_tag(___);
    a:
    if(250 === _$_)
     var _aa_ = ___[1];
    else{
     if(246 !== _$_ && 244 !== _$_){var _aa_ = ___; break a;}
     var _aa_ = caml_call1(CamlinternalLazy[2], ___);
    }
    var match = caml_call4(Re_Core[8], [0, p], 0, _aa_, s);
    return 782112175 === match
            ? string_match(re, s, p)
            : 939392865 <= match ? 1 : 0;
   }
   function search_forward(re, s, p){
    try{
     var _V_ = re[3], _W_ = caml_obj_tag(_V_);
     a:
     if(250 === _W_)
      var _X_ = _V_[1];
     else{
      if(246 !== _W_ && 244 !== _W_){var _X_ = _V_; break a;}
      var _X_ = caml_call1(CamlinternalLazy[2], _V_);
     }
     var res = caml_call4(Re_Core[5], [0, p], 0, _X_, s);
     state[1] = [0, res];
     var _Y_ = caml_call2(Re_Core[1][3], res, 0)[1];
     return _Y_;
    }
    catch(_Z_){
     var _U_ = caml_wrap_exception(_Z_);
     if(_U_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_U_, 0);
     state[1] = 0;
     throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    }
   }
   function search_backward(re, s, p){
    var p$0 = p;
    for(;;)
     try{
      var _Q_ = re[2], _R_ = caml_obj_tag(_Q_);
      a:
      if(250 === _R_)
       var _S_ = _Q_[1];
      else{
       if(246 !== _R_ && 244 !== _R_){var _S_ = _Q_; break a;}
       var _S_ = caml_call1(CamlinternalLazy[2], _Q_);
      }
      var res = caml_call4(Re_Core[5], [0, p$0], 0, _S_, s);
      state[1] = [0, res];
      return p$0;
     }
     catch(_T_){
      var _P_ = caml_wrap_exception(_T_);
      if(_P_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_P_, 0);
      state[1] = 0;
      if(0 === p$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var p$1 = p$0 - 1 | 0;
      p$0 = p$1;
     }
   }
   function valid_group(n){
    var _M_ = 0 <= n ? 1 : 0;
    if(_M_){
     var _N_ = n < 10 ? 1 : 0;
     if(_N_){
      var match = state[1];
      if(match){
       var m = match[1];
       return n < caml_call1(Re_Core[1][9], m) ? 1 : 0;
      }
      var _O_ = 0;
     }
     else
      var _O_ = _N_;
    }
    else
     var _O_ = _M_;
    return _O_;
   }
   function offset_group(i){
    var match = state[1];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var m = match[1];
    return caml_call2(Re_Core[1][3], m, i);
   }
   function replacement_text(repl, orig){
    var len = caml_ml_string_length(repl), p = 0, q = 0;
    for(;;){
     if(p >= len) break;
     if(92 === caml_string_get(repl, p)){
      var p$0 = p + 1 | 0;
      if(p$0 === len) caml_call1(Stdlib[2], cst_Str_replace_illegal_backsl);
      var c = caml_string_get(repl, p$0);
      a:
      {
       if(58 <= c){
        if(92 === c){var q$0 = q + 1 | 0; break a;}
       }
       else if(48 <= c){
        var i = c - 48 | 0;
        try{
         var
          match = offset_group(i),
          e = match[2],
          b = match[1],
          _H_ = e - b | 0,
          _I_ = _H_;
        }
        catch(_L_){
         var _G_ = caml_wrap_exception(_L_);
         if(_G_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_G_, 0);
         var _I_ = 0;
        }
        var q$0 = q + _I_ | 0;
        break a;
       }
       var q$0 = q + 2 | 0;
      }
      var p$1 = p$0 + 1 | 0;
      p = p$1;
      q = q$0;
     }
     else{var q$1 = q + 1 | 0, p$2 = p + 1 | 0; p = p$2; q = q$1;}
    }
    var
     res = runtime.caml_create_bytes(q),
     len$0 = caml_ml_string_length(repl),
     p$3 = 0,
     q$2 = 0;
    for(;;){
     if(p$3 >= len$0) return caml_call1(Stdlib_Bytes[44], res);
     var c$0 = caml_string_get(repl, p$3);
     if(92 === c$0){
      var c$1 = caml_string_get(repl, p$3 + 1 | 0);
      if(58 <= c$1){
       if(92 === c$1){
        caml_bytes_set(res, q$2, 92);
        var q$3 = q$2 + 1 | 0, p$4 = p$3 + 2 | 0;
        p$3 = p$4;
        q$2 = q$3;
        continue;
       }
      }
      else if(48 <= c$1){
       try{
        var
         match$0 = offset_group(c$1 - 48 | 0),
         e$0 = match$0[2],
         b$0 = match$0[1],
         d$0 = e$0 - b$0 | 0;
        if(0 < d$0) caml_call5(Stdlib_String[6], orig, b$0, res, q$2, d$0);
        var d = d$0;
       }
       catch(_K_){
        var _J_ = caml_wrap_exception(_K_);
        if(_J_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_J_, 0);
        var d = 0;
       }
       var q$5 = q$2 + d | 0, p$6 = p$3 + 2 | 0;
       p$3 = p$6;
       q$2 = q$5;
       continue;
      }
      caml_bytes_set(res, q$2, 92);
      caml_bytes_set(res, q$2 + 1 | 0, c$1);
      var q$4 = q$2 + 2 | 0, p$5 = p$3 + 2 | 0;
      p$3 = p$5;
      q$2 = q$4;
     }
     else{
      caml_bytes_set(res, q$2, c$0);
      var q$6 = q$2 + 1 | 0, p$7 = p$3 + 1 | 0;
      p$3 = p$7;
      q$2 = q$6;
     }
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_call1(Stdlib_Buffer[1], 2 * len | 0),
     _C_ = len - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var c = caml_string_get(s, i), _D_ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < _D_ >>> 0){
         var _E_ = _D_ + 27 | 0;
         if(10 < _E_ >>> 0) break b;
         switch(_E_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= _D_ - 1 >>> 0) break b;
        caml_call2(Stdlib_Buffer[12], buf, 92);
        caml_call2(Stdlib_Buffer[12], buf, c);
        break a;
       }
       caml_call2(Stdlib_Buffer[12], buf, c);
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      i = _F_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function string_before(s, n){
    return caml_call3(Stdlib_String[16], s, 0, n);
   }
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[16], s, n, caml_ml_string_length(s) - n | 0);
   }
   function first_chars(s, n){return caml_call3(Stdlib_String[16], s, 0, n);}
   function last_chars(s, n){
    return caml_call3
            (Stdlib_String[16], s, caml_ml_string_length(s) - n | 0, n);
   }
   function regexp(e){return compile_regexp(e, 0);}
   function regexp_case_fold(e){return compile_regexp(e, 1);}
   function regexp_string(s){return compile_regexp(quote(s), 0);}
   function regexp_string_case_fold(s){return compile_regexp(quote(s), 1);}
   function group_beginning(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_beginning);
    var pos = offset_group(n)[1];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function group_end(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_end);
    var pos = offset_group(n)[2];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function matched_group(n, txt){
    var match = offset_group(n), e = match[2], b = match[1];
    return caml_call3(Stdlib_String[16], txt, b, e - b | 0);
   }
   function replace_matched(repl, matched){
    return replacement_text(repl, matched);
   }
   function match_beginning(param){return group_beginning(0);}
   function match_end(param){return group_end(0);}
   function matched_string(txt){return matched_group(0, txt);}
   function substitute_first(expr, repl_fun, text){
    try{
     var
      pos = search_forward(expr, text, 0),
      _w_ = [0, string_after(text, match_end(0)), 0],
      _x_ = [0, caml_call1(repl_fun, text), _w_],
      _y_ = [0, string_before(text, pos), _x_],
      _z_ = caml_call2(Stdlib_String[7], cst, _y_);
     return _z_;
    }
    catch(_A_){
     var _v_ = caml_wrap_exception(_A_);
     if(_v_ === Stdlib[8]) return text;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
   }
   function global_substitute(expr, repl_fun, text){
    var accu = 0, start = 0, last_was_empty = 0;
    for(;;){
     var startpos = last_was_empty ? start + 1 | 0 : start;
     a:
     {
      if(caml_ml_string_length(text) >= startpos){
       try{var pos = search_forward(expr, text, startpos);}
       catch(_u_){
        var _r_ = caml_wrap_exception(_u_);
        if(_r_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_r_, 0);
        var _s_ = [0, string_after(text, start), accu];
        break a;
       }
       var
        end_pos = match_end(0),
        repl_text = caml_call1(repl_fun, text),
        last_was_empty$0 = end_pos === pos ? 1 : 0,
        accu$0 =
          [0,
           repl_text,
           [0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu]];
       accu = accu$0;
       start = end_pos;
       last_was_empty = last_was_empty$0;
       continue;
      }
      var _s_ = [0, string_after(text, start), accu];
     }
     var _t_ = caml_call1(Stdlib_List[10], _s_);
     return caml_call2(Stdlib_String[7], cst$0, _t_);
    }
   }
   function global_replace(expr, repl, text){
    return global_substitute
            (expr, function(_q_){return replacement_text(repl, _q_);}, text);
   }
   function replace_first(expr, repl, text){
    return substitute_first
            (expr, function(_p_){return replacement_text(repl, _p_);}, text);
   }
   function search_forward_progress(re, s, p){
    var pos = search_forward(re, s, p);
    if(p < match_end(0)) return pos;
    if(p < caml_ml_string_length(s)) return search_forward(re, s, p + 1 | 0);
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function bounded_split(expr, text, num){
    var start = string_match(expr, text, 0) ? match_end(0) : 0;
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _m_ = match_end(0),
       _n_ =
         split
          ([0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu],
           _m_,
           n - 1 | 0);
      return _n_;
     }
     catch(_o_){
      var _l_ = caml_wrap_exception(_o_);
      if(_l_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_l_, 0);
     }
    }
    var _k_ = split(0, start, num);
    return caml_call1(Stdlib_List[10], _k_);
   }
   function split(expr, text){return bounded_split(expr, text, 0);}
   function bounded_split_delim(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) < start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _h_ = match_end(0),
       _i_ =
         split
          ([0,
            caml_call3(Stdlib_String[16], text, start, pos - start | 0),
            accu],
           _h_,
           n - 1 | 0);
      return _i_;
     }
     catch(_j_){
      var _g_ = caml_wrap_exception(_j_);
      if(_g_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_g_, 0);
     }
    }
    if(text === cst$1) return 0;
    var _f_ = split(0, 0, num);
    return caml_call1(Stdlib_List[10], _f_);
   }
   function split_delim(expr, text){
    return bounded_split_delim(expr, text, 0);
   }
   function bounded_full_split(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, [0, string_after(text, start)], accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       s = matched_string(text);
      if(start < pos)
       var
        _c_ = match_end(0),
        _d_ =
          split
           ([0,
             [1, s],
             [0,
              [0, caml_call3(Stdlib_String[16], text, start, pos - start | 0)],
              accu]],
            _c_,
            n - 1 | 0);
      else
       var _d_ = split([0, [1, s], accu], match_end(0), n - 1 | 0);
      return _d_;
     }
     catch(_e_){
      var _b_ = caml_wrap_exception(_e_);
      if(_b_ === Stdlib[8]) return [0, [0, string_after(text, start)], accu];
      throw caml_maybe_attach_backtrace(_b_, 0);
     }
    }
    var _a_ = split(0, 0, num);
    return caml_call1(Stdlib_List[10], _a_);
   }
   function full_split(expr, text){return bounded_full_split(expr, text, 0);}
   var
    Re_Str =
      [0,
       regexp,
       regexp_case_fold,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_backward,
       string_partial_match,
       matched_string,
       match_beginning,
       match_end,
       matched_group,
       group_beginning,
       group_end,
       global_replace,
       replace_first,
       global_substitute,
       substitute_first,
       replace_matched,
       split,
       bounded_split,
       split_delim,
       bounded_split_delim,
       full_split,
       bounded_full_split,
       string_before,
       string_after,
       first_chars,
       last_chars];
   runtime.caml_register_global(14, Re_Str, "Re__Str");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Replace
//# unitInfo: Requires: Re__Compile, Re__Group, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Re_replace$1 = "Re.replace",
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) === 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Compile = global_data.Re__Compile,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Re_Group = global_data.Re__Group,
    Stdlib = global_data.Stdlib,
    cst_Re_replace = cst_Re_replace$1,
    cst_Re_replace$0 = cst_Re_replace$1;
   function replace(_a_, len, opt, re, f, s){
    var pos = _a_ ? _a_[1] : 0, all = opt ? opt[1] : 1;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_replace);
    if(len){
     var
      l = len[1],
      _b_ = l < 0 ? 1 : 0,
      _c_ = _b_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_c_) caml_call1(Stdlib[1], cst_Re_replace$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    var
     buf = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(s)),
     pos$0 = pos,
     on_match = 0;
    for(;;){
     if(pos$0 <= limit){
      var
       match =
         caml_call6(Re_Compile[1], 1, 0, re, s, pos$0, limit - pos$0 | 0);
      if(typeof match === "number")
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, limit - pos$0 | 0);
      else if(0 === match[0]){
       var
        substr = match[1],
        match$0 = caml_call2(Re_Group[3], substr, 0),
        p2 = match$0[2],
        p1 = match$0[1];
       if(pos$0 === p1 && p1 === p2 && on_match){
        if(p2 < limit){
         var _d_ = caml_string_get(s, p2);
         caml_call2(Stdlib_Buffer[12], buf, _d_);
        }
        var pos$1 = p2 + 1 | 0;
        pos$0 = pos$1;
        on_match = 0;
        continue;
       }
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, p1 - pos$0 | 0);
       var replacing = caml_call1(f, substr);
       caml_call2(Stdlib_Buffer[16], buf, replacing);
       if(all){
        var on_match$0 = p1 !== p2 ? 1 : 0;
        if(p1 === p2){
         if(p2 < limit){
          var _e_ = caml_string_get(s, p2);
          caml_call2(Stdlib_Buffer[12], buf, _e_);
         }
         var pos$2 = p2 + 1 | 0;
        }
        else
         var pos$2 = p2;
        pos$0 = pos$2;
        on_match = on_match$0;
        continue;
       }
       caml_call4(Stdlib_Buffer[18], buf, s, p2, limit - p2 | 0);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function replace_string(pos, len, all, re, by, s){
    return replace(pos, len, all, re, function(param){return by;}, s);
   }
   var Re_Replace = [0, replace, replace_string];
   runtime.caml_register_global(6, Re_Replace, "Re__Replace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Glob
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$0 = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    beg = [0, cst$0, 0],
    cst = "/**",
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Parse_error = [248, "Re__Glob.Parse_error", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, 45],
    _b_ = [0, 47],
    _c_ = [0, cst$0, 0],
    _d_ = [0, cst$0, 0],
    _e_ = [0, 47, [0, 92, 0]],
    _f_ = [0, 47, 0],
    _g_ = [0, 1],
    _h_ = [0, 1];
   function mul(l$0, l){
    var
     _ac_ =
       caml_call2
        (Stdlib_List[20],
         function(s){
          return caml_call2
                  (Stdlib_List[20],
                   function(s$0){return caml_call2(Stdlib[28], s, s$0);},
                   l);
         },
         l$0);
    return caml_call1(Stdlib_List[15], _ac_);
   }
   function explicit_period(t){
    var ___ = t[7];
    if(___){
     var _$_ = t[3];
     if(_$_) var _aa_ = _$_; else var _ab_ = t[4], _aa_ = _ab_ ? t[5] : _ab_;
    }
    else
     var _aa_ = ___;
    return _aa_;
   }
   function slashes(t){return t[6] ? _e_ : _f_;}
   function append(opt, t, piece){
    var am_at_start_of_component = opt ? opt[1] : 0;
    return [0,
            [0, piece, t[1]],
            t[2],
            0,
            am_at_start_of_component,
            t[5],
            t[6],
            t[7]];
   }
   function next(t){
    var match = t[2];
    if(! match) return 0;
    var remaining = match[2], piece = match[1];
    return [0, [0, piece, [0, t[1], remaining, t[3], t[4], t[5], t[6], t[7]]]];
   }
   function one(explicit_slash, slashes, explicit_period){
    var
     _V_ = 0,
     _W_ = explicit_period ? [0, caml_call1(Re_Core[26], 46), 0] : 0,
     _X_ = [0, _W_, _V_],
     _Y_ =
       explicit_slash ? caml_call2(Stdlib_List[20], Re_Core[26], slashes) : 0,
     _Z_ = caml_call1(Stdlib_List[14], [0, _Y_, _X_]);
    return caml_call1(Re_Core[60], _Z_);
   }
   function enclosed(enclosed){
    if(0 === enclosed[0]){
     var c = enclosed[1];
     return caml_call1(Re_Core[26], c);
    }
    var high = enclosed[2], low = enclosed[1];
    return caml_call2(Re_Core[57], low, high);
   }
   function enclosed_set(explicit_slash, slashes, explicit_period, kind, set){
    var
     set$0 = caml_call2(Stdlib_List[20], enclosed, set),
     enclosure =
       596216810 <= kind
        ? caml_call1(Re_Core[27], set$0)
        : caml_call1(Re_Core[60], set$0),
     _U_ =
       [0, enclosure, [0, one(explicit_slash, slashes, explicit_period), 0]];
    return caml_call1(Re_Core[58], _U_);
   }
   function exactly(state, c){
    var
     slashes$0 = slashes(state),
     am_at_start_of_component = caml_call2(Stdlib_List[37], c, slashes$0),
     chars = am_at_start_of_component ? slashes$0 : [0, c, 0],
     _T_ = caml_call2(Stdlib_List[20], Re_Core[26], chars);
    return append
            ([0, am_at_start_of_component],
             state,
             caml_call1(Re_Core[27], _T_));
   }
   function many_many(state){
    var
     _H_ = state[7],
     explicit_period$0 = _H_ ? state[5] : _H_,
     first_explicit_period = explicit_period(state),
     slashes$0 = slashes(state);
    function match_component(explicit_period){
     var
      _Q_ = one(1, slashes$0, 0),
      _R_ = [0, caml_call1(Re_Core[31], _Q_), 0],
      _S_ = [0, one(1, slashes$0, explicit_period), _R_];
     return caml_call1(Re_Core[28], _S_);
    }
    var
     _I_ = match_component(explicit_period$0),
     _J_ = [0, caml_call1(Re_Core[34], _I_), 0],
     _K_ = caml_call2(Stdlib_List[20], Re_Core[26], slashes$0),
     _L_ = [0, caml_call1(Re_Core[27], _K_), _J_],
     _M_ = caml_call1(Re_Core[28], _L_),
     _N_ = [0, caml_call1(Re_Core[31], _M_), 0],
     _O_ = match_component(first_explicit_period),
     _P_ = [0, caml_call1(Re_Core[34], _O_), _N_];
    return append(0, state, caml_call1(Re_Core[28], _P_));
   }
   function glob(_o_, _n_, _m_, _l_, _k_, opt, str){
    var
     anchored = _o_ ? _o_[1] : 0,
     pathname = _n_ ? _n_[1] : 1,
     match_backslashes = _m_ ? _m_[1] : 0,
     period = _l_ ? _l_[1] : 1,
     expand_braces = _k_ ? _k_[1] : 0,
     double_asterisk = opt ? opt[1] : 1;
    function to_re(s){
     var buf = caml_call1(Re_Parse_buffer[2], s);
     function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
     function read(c){return caml_call2(Re_Parse_buffer[9], buf, c);}
     function char$0(param){
      read(92);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      return caml_call1(Re_Parse_buffer[8], buf);
     }
     function enclosed(param){
      var s = 0;
      for(;;){
       if(0 !== s && read(93)) return s;
       var c = char$0(0);
       if(read(45)){
        if(read(93)) return [0, [0, c], [0, _a_, s]];
        var c$0 = char$0(0), s$0 = [0, [1, c, c$0], s];
        s = s$0;
       }
       else{var s$1 = [0, [0, c], s]; s = s$1;}
      }
     }
     var pieces = 0;
     for(;;){
      if(eos(0)) break;
      a:
      {
       if(double_asterisk && caml_call2(Re_Parse_buffer[11], buf, cst)){
        var _s_ = eos(0) ? [0, _b_, pieces] : pieces, pieces$0 = [0, 2, _s_];
        break a;
       }
       if(read(42)){
        b:
        {if(double_asterisk && read(42)){var _t_ = 2; break b;} var _t_ = 1;}
        var pieces$0 = [0, _t_, pieces];
       }
       else if(read(63))
        var pieces$0 = [0, 0, pieces];
       else if(read(91)){
        if(! read(94) && ! read(33)){
         var pieces$0 = [0, [1, enclosed(0)], pieces];
         break a;
        }
        var pieces$0 = [0, [2, enclosed(0)], pieces];
       }
       else
        var pieces$0 = [0, [0, char$0(0)], pieces];
      }
      pieces = pieces$0;
     }
     var
      remaining = caml_call1(Stdlib_List[10], pieces),
      state = [0, 0, remaining, 1, 1, pathname, match_backslashes, period],
      state$8 = state;
     for(;;){
      var match$1 = next(state$8);
      if(! match$1){
       var
        _u_ = caml_call1(Stdlib_List[10], state$8[1]),
        re = caml_call1(Re_Core[28], _u_);
       return anchored ? caml_call1(Re_Core[46], re) : re;
      }
      var
       match$2 = match$1[1],
       state$9 = match$2[2],
       piece = match$2[1],
       explicit_slash = state$9[5],
       explicit_period$1 = explicit_period(state$9),
       slashes$1 = slashes(state$9);
      if(typeof piece === "number")
       a:
       switch(piece){
         case 0:
          var
           state$10 =
             append
              (0, state$9, one(explicit_slash, slashes$1, explicit_period$1));
          break;
         case 1:
          var
           explicit_slash$0 = state$9[5],
           explicit_period$0 = explicit_period(state$9),
           slashes$0 = slashes(state$9);
          if(explicit_period$0)
           if(explicit_slash$0){
            var
             _v_ = one(1, slashes$0, 0),
             _w_ = [0, caml_call1(Re_Core[31], _v_), 0],
             _x_ = [0, one(1, slashes$0, 1), _w_],
             not_empty = caml_call1(Re_Core[28], _x_),
             maybe_empty = caml_call1(Re_Core[34], not_empty);
            let slashes = slashes$0, not_empty$1 = not_empty;
            var
             enclosed_set$0 =
               function(state, kind, set){
                var
                 _E_ =
                   [0,
                    not_empty$1,
                    [0, enclosed_set(1, slashes, 0, kind, set), 0]],
                 _F_ = [0, caml_call1(Re_Core[28], _E_), 0],
                 _G_ = [0, enclosed_set(1, slashes, 1, kind, set), _F_];
                return append(0, state, caml_call1(Re_Core[27], _G_));
               };
            b:
            {
             c:
             {
              d:
              {
               var state$0 = state$9;
               for(;;){
                var match = next(state$0);
                if(! match) break;
                var _y_ = match[1], match$0 = _y_[1];
                if(typeof match$0 !== "number") break d;
                switch(match$0){
                  case 0:
                   break b;
                  case 1:
                   var state$2 = _y_[2]; state$0 = state$2; break;
                  default: break c;
                }
               }
               var state$10 = append(0, state$0, maybe_empty);
               break;
              }
              switch(match$0[0]){
                case 0:
                 var
                  state$4 = _y_[2],
                  c = match$0[1],
                  not_empty$0 = 46 === c ? not_empty : maybe_empty,
                  state$5 = append(0, state$4, not_empty$0),
                  state$10 = exactly(state$5, c);
                 break a;
                case 1:
                 var
                  state$6 = _y_[2],
                  enclosed$0 = match$0[1],
                  state$10 = enclosed_set$0(state$6, 596216810, enclosed$0);
                 break a;
                default:
                 var
                  state$7 = _y_[2],
                  enclosed$1 = match$0[1],
                  state$10 = enclosed_set$0(state$7, -188280562, enclosed$1);
                 break a;
              }
             }
             var state$3 = _y_[2], state$10 = many_many(state$3);
             break;
            }
            var state$1 = _y_[2], state$10 = append(0, state$1, not_empty);
           }
           else
            var
             _z_ = one(0, slashes$0, 0),
             _A_ = [0, caml_call1(Re_Core[31], _z_), 0],
             _B_ = [0, one(0, slashes$0, explicit_period$0), _A_],
             _C_ = caml_call1(Re_Core[28], _B_),
             state$10 = append(0, state$9, caml_call1(Re_Core[34], _C_));
          else
           var
            _D_ = one(explicit_slash$0, slashes$0, explicit_period$0),
            state$10 = append(0, state$9, caml_call1(Re_Core[31], _D_));
          break;
         default: var state$10 = many_many(state$9);
       }
      else
       switch(piece[0]){
         case 0:
          var c$0 = piece[1], state$10 = exactly(state$9, c$0); break;
         case 1:
          var
           enclosed$2 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash,
                 slashes$1,
                 explicit_period$1,
                 596216810,
                 enclosed$2));
          break;
         default:
          var
           enclosed$3 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash,
                 slashes$1,
                 explicit_period$1,
                 -188280562,
                 enclosed$3));
       }
      state$8 = state$10;
     }
    }
    if(! expand_braces) return to_re(str);
    var l = runtime.caml_ml_string_length(str);
    function expl(inner, s, i, acc, beg$0){
     var s$0 = s, i$0 = i, acc$0 = acc, beg$1 = beg$0;
     for(;;){
      if(l <= i$0){
       if(inner) throw caml_maybe_attach_backtrace(Parse_error, 1);
       return [0,
               mul
                (beg$1,
                 [0,
                  caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                  0]),
               i$0];
      }
      var match = runtime.caml_string_get(str, i$0);
      if(44 === match){
       if(inner){
        var
         _q_ =
           mul
            (beg$1,
             [0, caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0), 0]),
         acc$1 = caml_call2(Stdlib[37], _q_, acc$0),
         i$1 = i$0 + 1 | 0,
         s$1 = i$0 + 1 | 0;
        s$0 = s$1;
        i$0 = i$1;
        acc$0 = acc$1;
        beg$1 = beg;
        continue;
       }
      }
      else
       if(123 <= match){
        if(126 > match)
         switch(match - 123 | 0){
           case 0:
            var
             match$0 = expl(1, i$0 + 1 | 0, i$0 + 1 | 0, 0, _c_),
             i$3 = match$0[2],
             t = match$0[1],
             beg$2 =
               mul
                (beg$1,
                 mul
                  ([0,
                    caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                    0],
                   t));
            s$0 = i$3;
            i$0 = i$3;
            beg$1 = beg$2;
            continue;
           case 1: break;
           default:
            if(inner){
             var
              _r_ =
                mul
                 (beg$1,
                  [0,
                   caml_call3(Stdlib_String[16], str, s$0, i$0 - s$0 | 0),
                   0]);
             return [0, caml_call2(Stdlib[37], _r_, acc$0), i$0 + 1 | 0];
            }
         }
       }
       else if(92 === match){var i$4 = i$0 + 2 | 0; i$0 = i$4; continue;}
      var i$2 = i$0 + 1 | 0;
      i$0 = i$2;
     }
    }
    var
     _i_ = expl(0, 0, 0, 0, _d_)[1],
     _j_ = caml_call1(Stdlib_List[10], _i_),
     _p_ = caml_call2(Stdlib_List[20], to_re, _j_);
    return caml_call1(Re_Core[27], _p_);
   }
   function glob$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], 0, 0, s);
   }
   function globx(anchored, s){return glob(anchored, 0, 0, 0, _g_, 0, s);}
   function globx$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], _h_, 0, s);
   }
   var Re_Glob = [0, Parse_error, glob, glob$0, globx, globx$0];
   runtime.caml_register_global(16, Re_Glob, "Re__Glob");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Posix_class
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_alnum = "alnum",
    cst_alpha = "alpha",
    cst_ascii = "ascii",
    cst_blank = "blank",
    cst_cntrl = "cntrl",
    cst_digit = "digit",
    cst_graph = "graph",
    cst_lower = "lower",
    cst_print = "print",
    cst_punct = "punct",
    cst_space = "space",
    cst_upper = "upper",
    cst_word = "word",
    cst_xdigit = "xdigit",
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = ":]",
    names =
      caml_list_of_js_array
       ([cst_alpha,
         cst_alnum,
         cst_ascii,
         cst_blank,
         cst_cntrl,
         cst_digit,
         cst_lower,
         cst_print,
         cst_space,
         cst_upper,
         cst_word,
         cst_punct,
         cst_graph,
         cst_xdigit]),
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Re_Core = global_data.Re__Core,
    cst_Invalid_pcre_class = "Invalid pcre class: ";
   function of_name(class$0){
    var switch$0 = runtime.caml_string_compare(class$0, cst_lower);
    if(0 <= switch$0){
     if(0 >= switch$0) return Re_Core[71];
     if(class$0 === cst_print) return Re_Core[72];
     if(class$0 === cst_punct) return Re_Core[73];
     if(class$0 === cst_space) return Re_Core[74];
     if(class$0 === cst_upper) return Re_Core[75];
     if(class$0 === cst_word) return Re_Core[64];
     if(class$0 === cst_xdigit) return Re_Core[76];
    }
    else{
     if(class$0 === cst_alnum) return Re_Core[63];
     if(class$0 === cst_alpha) return Re_Core[65];
     if(class$0 === cst_ascii) return Re_Core[66];
     if(class$0 === cst_blank) return Re_Core[67];
     if(class$0 === cst_cntrl) return Re_Core[68];
     if(class$0 === cst_digit) return Re_Core[69];
     if(class$0 === cst_graph) return Re_Core[70];
    }
    var _d_ = caml_call2(Stdlib[28], cst_Invalid_pcre_class, class$0);
    return caml_call1(Stdlib[1], _d_);
   }
   function parse(buf){
    var
     accept = caml_call1(Re_Parse_buffer[9], buf),
     accept_s = caml_call1(Re_Parse_buffer[11], buf);
    if(! caml_call1(accept, 58)) return 0;
    var compl = caml_call1(accept, 94);
    try{var cls = caml_call2(Stdlib_List[39], accept_s, names);}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8])
      throw caml_maybe_attach_backtrace(Re_Parse_buffer[1], 1);
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
    if(1 - caml_call1(accept_s, cst))
     throw caml_maybe_attach_backtrace(Re_Parse_buffer[1], 1);
    var
     posix_class = of_name(cls),
     _b_ = compl ? caml_call1(Re_Core[60], [0, posix_class, 0]) : posix_class;
    return [0, _b_];
   }
   var Re_Posix_class = [0, names, of_name, parse];
   runtime.caml_register_global(21, Re_Posix_class, "Re__Posix_class");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Perl
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Re__Posix_class, Stdlib, Stdlib__Buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    Re_Core = global_data.Re__Core,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Re_Posix_class = global_data.Re__Posix_class,
    Parse_error = Re_Parse_buffer[1],
    Not_supported =
      [248, "Re__Perl.Not_supported", runtime.caml_fresh_oo_id(0)],
    _a_ = [0, 748194550, 8],
    _b_ = [0, 748194550, 10],
    _c_ = [0, 748194550, 13],
    _d_ = [0, 748194550, 9];
   function re(opt, s){
    var
     opts = opt ? opt[1] : 0,
     ungreedy = caml_call2(Stdlib_List[38], -243745063, opts),
     dotall = caml_call2(Stdlib_List[38], -424303016, opts),
     dollar_endonly = caml_call2(Stdlib_List[38], -712595228, opts),
     multiline = caml_call2(Stdlib_List[38], 1071952589, opts),
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    function test(c){return caml_call2(Re_Parse_buffer[6], buf, c);}
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function greedy_mod(r){
     var gr = caml_call1(accept, 63), gr$0 = ungreedy ? 1 - gr : gr;
     return gr$0 ? caml_call1(Re_Core[51], r) : caml_call1(Re_Core[50], r);
    }
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call1(accept, 124)) return left$0;
      var
       _r_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _r_);
      left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       var r = atom(0);
       if(caml_call1(accept, 42))
        var _q_ = greedy_mod(caml_call1(Re_Core[31], r));
       else if(caml_call1(accept, 43))
        var _q_ = greedy_mod(caml_call1(Re_Core[32], r));
       else if(caml_call1(accept, 63))
        var _q_ = greedy_mod(caml_call1(Re_Core[34], r));
       else if(caml_call1(accept, 123)){
        var match = caml_call1(Re_Parse_buffer[12], buf);
        if(match){
         var
          i = match[1],
          j =
            caml_call1(accept, 44)
             ? caml_call1(Re_Parse_buffer[12], buf)
             : [0, i];
         if(1 - caml_call1(accept, 125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var _q_ = greedy_mod(caml_call3(Re_Core[33], r, i, j));
        }
        else{caml_call1(Re_Parse_buffer[4], buf); var _q_ = r;}
       }
       else
        var _q_ = r;
       var left$0 = [0, _q_, left];
       left = left$0;
       continue;
      }
      var _p_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _p_);
     }
    }
    function atom(param){
     if(caml_call1(accept, 46)) return dotall ? Re_Core[61] : Re_Core[62];
     if(! caml_call1(accept, 40)){
      if(caml_call1(accept, 94)) return multiline ? Re_Core[35] : Re_Core[39];
      if(caml_call1(accept, 36))
       return multiline
               ? Re_Core[36]
               : dollar_endonly ? Re_Core[41] : Re_Core[40];
      if(caml_call1(accept, 91)){
       if(caml_call1(accept, 94)){
        var _i_ = bracket(0);
        return caml_call1(Re_Core[60], _i_);
       }
       var _j_ = bracket(0);
       return caml_call1(Re_Core[27], _j_);
      }
      if(caml_call1(accept, 92)){
       if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
       var c = get(0), switcher = c - 48 | 0;
       if(74 >= switcher >>> 0)
        switch(switcher){
          case 17:
           return Re_Core[39];
          case 18:
           return Re_Core[45];
          case 20:
           return caml_call1(Re_Core[60], [0, Re_Core[69], 0]);
          case 23:
           return Re_Core[42];
          case 35:
           return caml_call1(Re_Core[60], [0, Re_Core[74], 0]);
          case 39:
           var _k_ = [0, caml_call1(Re_Core[26], 95), 0];
           return caml_call1(Re_Core[60], [0, Re_Core[63], _k_]);
          case 42:
           return Re_Core[41];
          case 50:
           return caml_call1
                   (Re_Core[27], [0, Re_Core[37], [0, Re_Core[38], 0]]);
          case 52:
           return Re_Core[69];
          case 53:
           return caml_call1(Re_Core[26], 27);
          case 54:
           return caml_call1(Re_Core[26], 12);
          case 62:
           return caml_call1(Re_Core[26], 10);
          case 66:
           return caml_call1(Re_Core[26], 13);
          case 67:
           return Re_Core[74];
          case 68:
           return caml_call1(Re_Core[26], 9);
          case 71:
           var _l_ = [0, caml_call1(Re_Core[26], 95), 0];
           return caml_call1(Re_Core[27], [0, Re_Core[63], _l_]);
          case 72:
           var
            c1 = hexdigit(0),
            c2 = hexdigit(0),
            code = (c1 * 16 | 0) + c2 | 0,
            _m_ = caml_call1(Stdlib[29], code);
           return caml_call1(Re_Core[26], _m_);
          case 74:
           return Re_Core[40];
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
           throw caml_maybe_attach_backtrace(Not_supported, 1);
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48: break;
          default: throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
       return caml_call1(Re_Core[26], c);
      }
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$0 = get(0);
      a:
      {
       if(64 <= c$0){
        if(92 === c$0 || 123 === c$0) break a;
       }
       else
        if(44 <= c$0){if(63 <= c$0) break a;} else if(42 <= c$0) break a;
       return caml_call1(Re_Core[26], c$0);
      }
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     }
     if(! caml_call1(accept, 63)){
      var r$1 = regexp(0);
      if(1 - caml_call1(accept, 41))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return caml_call2(Re_Core[52], 0, r$1);
     }
     if(caml_call1(accept, 58)){
      var r = regexp(0);
      if(1 - caml_call1(accept, 41))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return r;
     }
     if(! caml_call1(accept, 35)){
      if(! caml_call1(accept, 60))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$1 = get(0), _n_ = c$1 - 91 | 0;
      a:
      {
       if(5 < _n_ >>> 0){
        if(57 < _n_ + 26 >>> 0) break a;
       }
       else if(4 !== _n_) break a;
       var b = caml_call1(Stdlib_Buffer[1], 32);
       caml_call2(Stdlib_Buffer[12], b, c$1);
       for(;;){
        if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
        var c$2 = get(0);
        b:
        {
         if(65 <= c$2){
          var _o_ = c$2 - 91 | 0;
          if(5 < _o_ >>> 0){
           if(32 <= _o_) break b;
          }
          else if(4 !== _o_) break b;
         }
         else{
          if(58 <= c$2){
           if(62 !== c$2) break b;
           var name = caml_call1(Stdlib_Buffer[2], b), r$0 = regexp(0);
           if(1 - caml_call1(accept, 41))
            throw caml_maybe_attach_backtrace(Parse_error, 1);
           return caml_call2(Re_Core[52], [0, name], r$0);
          }
          if(48 > c$2) break b;
         }
         caml_call2(Stdlib_Buffer[12], b, c$2);
         continue;
        }
        throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
      }
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     }
     for(;;){
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(caml_call1(accept, 41)) return Re_Core[30];
      caml_call1(Re_Parse_buffer[3], buf);
     }
    }
    function hexdigit(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var d = get(0);
     if(65 <= d){
      if(97 <= d){
       if(103 > d) return (d - 97 | 0) + 10 | 0;
      }
      else if(71 > d) return (d - 65 | 0) + 10 | 0;
     }
     else if(9 >= d - 48 >>> 0) return d - 48 | 0;
     throw caml_maybe_attach_backtrace(Parse_error, 1);
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var match = char$0(0);
      if(748194550 <= match[1]){
       var c = match[2];
       if(caml_call1(accept, 45)){
        if(caml_call1(accept, 93)){
         var _g_ = [0, caml_call1(Re_Core[26], 45), s$0];
         return [0, caml_call1(Re_Core[26], c), _g_];
        }
        var match$0 = char$0(0);
        if(748194550 <= match$0[1])
         var
          c$0 = match$0[2],
          s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
        else
         var
          st = match$0[2],
          _h_ = [0, caml_call1(Re_Core[26], 45), [0, st, s$0]],
          s$1 = [0, caml_call1(Re_Core[26], c), _h_];
        s$0 = s$1;
       }
       else{var s$2 = [0, caml_call1(Re_Core[26], c), s$0]; s$0 = s$2;}
      }
      else{var st$0 = match[2], s$3 = [0, st$0, s$0]; s$0 = s$3;}
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 === c){
      if(caml_call1(accept, 61))
       throw caml_maybe_attach_backtrace(Not_supported, 1);
      var match = caml_call1(Re_Posix_class[3], buf);
      if(match){var set = match[1]; return [0, 4150146, set];}
      if(! caml_call1(accept, 46)) return [0, 748194550, c];
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$0 = get(0);
      if(1 - caml_call1(accept, 46))
       throw caml_maybe_attach_backtrace(Not_supported, 1);
      if(1 - caml_call1(accept, 93))
       throw caml_maybe_attach_backtrace(Parse_error, 1);
      return [0, 748194550, c$0];
     }
     if(92 !== c) return [0, 748194550, c];
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c$1 = get(0);
     if(58 <= c$1){
      if(123 > c$1)
       switch(c$1 - 58 | 0){
         case 10:
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[69], 0])];
         case 25:
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[74], 0])];
         case 29:
          var _e_ = [0, caml_call1(Re_Core[26], 95), 0];
          return [0, 4150146, caml_call1(Re_Core[60], [0, Re_Core[63], _e_])];
         case 40:
          return _a_;
         case 42:
          return [0, 4150146, Re_Core[69]];
         case 52:
          return _b_;
         case 56:
          return _c_;
         case 57:
          return [0, 4150146, Re_Core[74]];
         case 58:
          return _d_;
         case 61:
          var _f_ = [0, caml_call1(Re_Core[26], 95), 0];
          return [0, 4150146, caml_call1(Re_Core[27], [0, Re_Core[63], _f_])];
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 33:
         case 34:
         case 35:
         case 36:
         case 37:
         case 38: break;
         default: throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
     }
     else if(48 <= c$1) throw caml_maybe_attach_backtrace(Not_supported, 1);
     return [0, 748194550, c$1];
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[38], 616470068, opts)
        ? caml_call1(Re_Core[28], [0, Re_Core[42], [0, res, 0]])
        : res,
     r$0 =
       caml_call2(Stdlib_List[38], 604571177, opts)
        ? caml_call1(Re_Core[78], r)
        : r;
    return r$0;
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    var opts = opt ? opt[1] : 0;
    return caml_call1(compile, re([0, opts], s));
   }
   var Re_Perl = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(11, Re_Perl, "Re__Perl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pcre
//# unitInfo: Requires: Re__Core, Re__Perl, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Re_Perl = global_data.Re__Perl,
    Parse_error = Re_Perl[1],
    Not_supported = Re_Perl[2],
    _a_ = [0, -1, -1];
   function re(opt, pat){
    var
     flags = opt ? opt[1] : 0,
     opts =
       caml_call2
        (Stdlib_List[20],
         function(param){
          return 601676297 <= param
                  ? 613575188 <= param ? 616470068 : 604571177
                  : 426394317 <= param ? 1071952589 : -424303016;
         },
         flags);
    return caml_call2(Re_Perl[3], [0, opts], pat);
   }
   function regexp(flags, pat){
    var _u_ = re(flags, pat);
    return caml_call1(Re_Core[2], _u_);
   }
   function extract(rex, s){
    var _t_ = caml_call4(Re_Core[5], 0, 0, rex, s);
    return caml_call1(Re_Core[1][6], _t_);
   }
   function exec(rex, pos, s){return caml_call4(Re_Core[5], pos, 0, rex, s);}
   function get_substring(s, i){return caml_call2(Re_Core[1][1], s, i);}
   function names(rex){
    var
     _q_ = caml_call1(Re_Core[4], rex),
     _r_ =
       caml_call1
        (caml_call1(Stdlib_List[20], function(_s_){return _s_[1];}), _q_);
    return caml_call1(Stdlib_Array[11], _r_);
   }
   function get_named_substring(rex, name, s){
    var param = caml_call1(Re_Core[4], rex);
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var match = param[1], rem = param[2], i = match[2], n = match[1];
     if(n === name)
      try{var _o_ = get_substring(s, i); return _o_;}
      catch(_p_){
       var _n_ = caml_wrap_exception(_p_);
       if(_n_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_n_, 0);
       param = rem;
      }
     else{var rem$0 = param[2]; param = rem$0;}
    }
   }
   function get_substring_ofs(s, i){return caml_call2(Re_Core[1][3], s, i);}
   function pmatch(rex, s){return caml_call4(Re_Core[7], 0, 0, rex, s);}
   function substitute(rex, subst, str){
    var b = caml_call1(Stdlib_Buffer[1], 1024), pos = 0, on_match = 0;
    for(;;){
     a:
     if(caml_call4(Re_Core[7], [0, pos], 0, rex, str)){
      var
       ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
       match = caml_call2(Re_Core[1][3], ss, 0),
       fin = match[2],
       start = match[1];
      if(on_match && start === pos && start === fin){
       if(pos >= caml_ml_string_length(str)) break a;
       var _k_ = caml_string_get(str, pos);
       caml_call2(Stdlib_Buffer[12], b, _k_);
       var pos$0 = pos + 1 | 0;
       pos = pos$0;
       on_match = 0;
       continue;
      }
      var pat = caml_call2(Re_Core[1][1], ss, 0);
      caml_call4(Stdlib_Buffer[18], b, str, pos, start - pos | 0);
      var _l_ = caml_call1(subst, pat);
      caml_call2(Stdlib_Buffer[16], b, _l_);
      if(start !== fin){pos = fin; on_match = 1; continue;}
      if(fin < caml_ml_string_length(str)){
       var _m_ = caml_string_get(str, fin);
       caml_call2(Stdlib_Buffer[12], b, _m_);
       var pos$1 = fin + 1 | 0;
       pos = pos$1;
       on_match = 0;
       continue;
      }
     }
     else
      caml_call4
       (Stdlib_Buffer[18], b, str, pos, caml_ml_string_length(str) - pos | 0);
     return caml_call1(Stdlib_Buffer[2], b);
    }
   }
   function split(rex, str){
    function finish(str, last, accu){
     var
      accu$0 =
        [0,
         caml_call3
          (Stdlib_String[16],
           str,
           last,
           caml_ml_string_length(str) - last | 0),
         accu];
     return caml_call1(Stdlib_List[10], accu$0);
    }
    var accu = 0, last = 0, pos = 0, on_match = 0;
    for(;;){
     if(! caml_call4(Re_Core[7], [0, pos], 0, rex, str))
      return finish(str, last, accu);
     var
      ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
      match = caml_call2(Re_Core[1][3], ss, 0),
      last$0 = match[2],
      start = match[1];
     if(on_match && start === pos && start === last$0){
      if(pos === caml_ml_string_length(str)) return finish(str, last, accu);
      var pos$0 = pos + 1 | 0;
      pos = pos$0;
      on_match = 0;
      continue;
     }
     var
      accu$0 =
        [0, caml_call3(Stdlib_String[16], str, last, start - last | 0), accu];
     if(start === last$0){
      if(last$0 === caml_ml_string_length(str))
       return finish(str, last$0, accu$0);
      var pos$1 = last$0 + 1 | 0;
      accu = accu$0;
      last = last$0;
      pos = pos$1;
      on_match = 0;
     }
     else{accu = accu$0; last = last$0; pos = last$0; on_match = 1;}
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_create_bytes(len << 1),
     pos = [0, 0],
     _h_ = len - 1 | 0,
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var c = runtime.caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        if(91 <= c){
         var _i_ = c - 93 | 0;
         if(29 < _i_ >>> 0){
          if(32 <= _i_) break b;
         }
         else if(1 !== _i_) break b;
        }
        else
         if(47 <= c){
          if(63 !== c) break b;
         }
         else{
          if(36 > c) break b;
          switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
          }
         }
        caml_bytes_unsafe_set(buf, pos[1], 92);
        pos[1]++;
        caml_bytes_unsafe_set(buf, pos[1], c);
        pos[1]++;
        break a;
       }
       caml_bytes_unsafe_set(buf, pos[1], c);
       pos[1]++;
      }
      var _j_ = i + 1 | 0;
      if(_h_ === i) break;
      i = _j_;
     }
    }
    var len$0 = pos[1], r = caml_create_bytes(len$0);
    runtime.caml_blit_bytes(buf, 0, r, 0, len$0);
    return caml_call1(Stdlib_Bytes[44], r);
   }
   function full_split(opt, rex, s){
    var max = opt ? opt[1] : 0;
    if(0 === caml_ml_string_length(s)) return 0;
    if(1 === max) return [0, [0, s], 0];
    var
     results = caml_call4(Re_Core[21], 0, 0, rex, s),
     matches =
       caml_call2
        (Stdlib_List[20],
         function(param){
          if(936573133 <= param[1]){var s = param[2]; return [0, [0, s], 0];}
          var
           d = param[2],
           matches = caml_call1(Re_Core[1][7], d),
           delim = caml_call2(Re_Core[1][1], d, 0),
           l = [0, 0],
           _c_ = matches.length - 2 | 0,
           _b_ = 1;
          if(_c_ >= 1){
           var i = _b_;
           for(;;){
            var
             _d_ = l[1],
             _e_ =
               runtime.caml_equal
                 (runtime.caml_check_bound(matches, i)[1 + i], _a_)
                ? 0
                : [2, i, caml_call2(Re_Core[1][1], d, i)];
            l[1] = [0, _e_, _d_];
            var _f_ = i + 1 | 0;
            if(_c_ === i) break;
            i = _f_;
           }
          }
          return [0, [1, delim], caml_call1(Stdlib_List[10], l[1])];
         },
         results);
    return caml_call1(Stdlib_List[14], matches);
   }
   var
    Re_Pcre =
      [0,
       Parse_error,
       Not_supported,
       re,
       regexp,
       extract,
       exec,
       get_substring,
       names,
       get_named_substring,
       get_substring_ofs,
       pmatch,
       substitute,
       full_split,
       split,
       quote];
   runtime.caml_register_global(9, Re_Pcre, "Re__Pcre");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Posix
//# unitInfo: Requires: Re__Core, Re__Parse_buffer, Re__Posix_class, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Re_Parse_buffer = global_data.Re__Parse_buffer,
    Re_Posix_class = global_data.Re__Posix_class,
    Parse_error = Re_Parse_buffer[1],
    Not_supported =
      [248, "Re__Posix.Not_supported", runtime.caml_fresh_oo_id(0)];
   function re(opt, s){
    var
     opts = opt ? opt[1] : 0,
     newline = caml_call2(Stdlib_List[38], -638074828, opts),
     buf = caml_call1(Re_Parse_buffer[2], s),
     accept = caml_call1(Re_Parse_buffer[9], buf);
    function eos(param){return caml_call1(Re_Parse_buffer[5], buf);}
    function test(c){return caml_call2(Re_Parse_buffer[6], buf, c);}
    function get(param){return caml_call1(Re_Parse_buffer[8], buf);}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! caml_call1(accept, 124)) return left$0;
      var
       _n_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[27], _n_);
      left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       a:
       if(caml_call1(accept, 46))
        var r = newline ? Re_Core[62] : Re_Core[61];
       else if(caml_call1(accept, 40)){
        var r$0 = regexp(0);
        if(1 - caml_call1(accept, 41))
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        var r = caml_call2(Re_Core[52], 0, r$0);
       }
       else if(caml_call1(accept, 94))
        var r = newline ? Re_Core[35] : Re_Core[39];
       else if(caml_call1(accept, 36))
        var r = newline ? Re_Core[36] : Re_Core[40];
       else{
        if(! caml_call1(accept, 91)){
         if(! caml_call1(accept, 92)){
          if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
          var c$0 = get(0);
          b:
          {
           if(64 <= c$0){
            if(92 === c$0 || 123 === c$0) break b;
           }
           else
            if(44 <= c$0){if(63 <= c$0) break b;} else if(42 <= c$0) break b;
           var r = caml_call1(Re_Core[26], c$0);
           break a;
          }
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(91 <= c){
           var _m_ = c - 93 | 0;
           if(29 < _m_ >>> 0){
            if(32 <= _m_) break b;
           }
           else if(1 !== _m_) break b;
          }
          else
           if(47 <= c){
            if(63 !== c) break b;
           }
           else{
            if(36 > c) break b;
            switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
            }
           }
          var r = caml_call1(Re_Core[26], c);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(caml_call1(accept, 94))
         var
          _i_ = caml_call1(Re_Core[26], 10),
          _j_ = bracket(0),
          _k_ = caml_call1(Re_Core[60], _j_),
          r = caml_call2(Re_Core[59], _k_, _i_);
        else
         var _l_ = bracket(0), r = caml_call1(Re_Core[27], _l_);
       }
       if(caml_call1(accept, 42))
        var
         _f_ = caml_call1(Re_Core[54], r),
         _e_ = caml_call1(Re_Core[31], _f_);
       else if(caml_call1(accept, 43))
        var
         _g_ = caml_call1(Re_Core[54], r),
         _e_ = caml_call1(Re_Core[32], _g_);
       else if(caml_call1(accept, 63))
        var _e_ = caml_call1(Re_Core[34], r);
       else if(caml_call1(accept, 123)){
        var match = caml_call1(Re_Parse_buffer[12], buf);
        if(match){
         var
          i = match[1],
          j =
            caml_call1(accept, 44)
             ? caml_call1(Re_Parse_buffer[12], buf)
             : [0, i];
         if(1 - caml_call1(accept, 125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var
          _h_ = caml_call1(Re_Core[54], r),
          _e_ = caml_call3(Re_Core[33], _h_, i, j);
        }
        else{caml_call1(Re_Parse_buffer[4], buf); var _e_ = r;}
       }
       else
        var _e_ = r;
       var left$0 = [0, _e_, left];
       left = left$0;
       continue;
      }
      var _d_ = caml_call1(Stdlib_List[10], left);
      return caml_call1(Re_Core[28], _d_);
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && caml_call1(accept, 93)) return s$0;
      var match = char$0(0);
      if(748194550 <= match[1]){
       var c = match[2];
       if(caml_call1(accept, 45)){
        if(caml_call1(accept, 93)){
         var _b_ = [0, caml_call1(Re_Core[26], 45), s$0];
         return [0, caml_call1(Re_Core[26], c), _b_];
        }
        var match$0 = char$0(0);
        if(748194550 <= match$0[1])
         var
          c$0 = match$0[2],
          s$1 = [0, caml_call2(Re_Core[57], c, c$0), s$0];
        else
         var
          st = match$0[2],
          _c_ = [0, caml_call1(Re_Core[26], 45), [0, st, s$0]],
          s$1 = [0, caml_call1(Re_Core[26], c), _c_];
        s$0 = s$1;
       }
       else{var s$2 = [0, caml_call1(Re_Core[26], c), s$0]; s$0 = s$2;}
      }
      else{var st$0 = match[2], s$3 = [0, st$0, s$0]; s$0 = s$3;}
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 !== c) return [0, 748194550, c];
     var match = caml_call1(Re_Posix_class[3], buf);
     if(match){var set = match[1]; return [0, 4150146, set];}
     if(! caml_call1(accept, 46)) return [0, 748194550, c];
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c$0 = get(0);
     if(1 - caml_call1(accept, 46))
      throw caml_maybe_attach_backtrace(Not_supported, 1);
     if(1 - caml_call1(accept, 93))
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     return [0, 748194550, c$0];
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[38], 886285209, opts)
        ? caml_call1(Re_Core[78], res)
        : res,
     r$0 =
       caml_call2(Stdlib_List[38], 853495711, opts)
        ? caml_call1(Re_Core[53], r)
        : r;
    return r$0;
   }
   function compile(re){
    var _a_ = caml_call1(Re_Core[47], re);
    return caml_call1(Re_Core[2], _a_);
   }
   function compile_pat(opt, s){
    var opts = opt ? opt[1] : 0;
    return compile(re([0, opts], s));
   }
   var Re_Posix = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(5, Re_Posix, "Re__Posix");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re
//# unitInfo: Requires: Re__Core, Re__Replace
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Re_Replace = global_data.Re__Replace,
    Group = Re_Core[1],
    compile = Re_Core[2],
    group_count = Re_Core[3],
    group_names = Re_Core[4],
    exec = Re_Core[5],
    exec_opt = Re_Core[6],
    execp = Re_Core[7],
    exec_partial = Re_Core[8],
    exec_partial_detailed = Re_Core[9],
    Mark = Re_Core[10],
    all = Re_Core[11],
    all_gen = Re_Core[12],
    all_seq = Re_Core[13],
    matches = Re_Core[14],
    matches_gen = Re_Core[15],
    matches_seq = Re_Core[16],
    split = Re_Core[17],
    split_delim = Re_Core[18],
    split_gen = Re_Core[19],
    split_seq = Re_Core[20],
    split_full = Re_Core[21],
    split_full_gen = Re_Core[22],
    split_full_seq = Re_Core[23],
    Seq = Re_Core[24],
    str = Re_Core[25],
    char$0 = Re_Core[26],
    alt = Re_Core[27],
    seq = Re_Core[28],
    empty = Re_Core[29],
    epsilon = Re_Core[30],
    rep = Re_Core[31],
    rep1 = Re_Core[32],
    repn = Re_Core[33],
    opt = Re_Core[34],
    bol = Re_Core[35],
    eol = Re_Core[36],
    bow = Re_Core[37],
    eow = Re_Core[38],
    bos = Re_Core[39],
    eos = Re_Core[40],
    leol = Re_Core[41],
    start = Re_Core[42],
    stop = Re_Core[43],
    word = Re_Core[44],
    not_boundary = Re_Core[45],
    whole_string = Re_Core[46],
    longest = Re_Core[47],
    shortest = Re_Core[48],
    first = Re_Core[49],
    greedy = Re_Core[50],
    non_greedy = Re_Core[51],
    group = Re_Core[52],
    no_group = Re_Core[53],
    nest = Re_Core[54],
    mark = Re_Core[55],
    set = Re_Core[56],
    rg = Re_Core[57],
    inter = Re_Core[58],
    diff = Re_Core[59],
    compl = Re_Core[60],
    any = Re_Core[61],
    notnl = Re_Core[62],
    alnum = Re_Core[63],
    wordc = Re_Core[64],
    alpha = Re_Core[65],
    ascii = Re_Core[66],
    blank = Re_Core[67],
    cntrl = Re_Core[68],
    digit = Re_Core[69],
    graph = Re_Core[70],
    lower = Re_Core[71],
    print = Re_Core[72],
    punct = Re_Core[73],
    space = Re_Core[74],
    upper = Re_Core[75],
    xdigit = Re_Core[76],
    case$0 = Re_Core[77],
    no_case = Re_Core[78],
    pp = Re_Core[79],
    pp_re = Re_Core[80],
    print_re = Re_Core[81],
    witness = Re_Core[82],
    get = Re_Core[83],
    get_ofs = Re_Core[84],
    get_all = Re_Core[85],
    get_all_ofs = Re_Core[86],
    test = Re_Core[87],
    marked = Re_Core[88],
    mark_set = Re_Core[89],
    replace = Re_Replace[1],
    replace_string = Re_Replace[2],
    Re =
      [0,
       Group,
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       Mark,
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_delim,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       Seq,
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       pp_re,
       print_re,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set,
       replace,
       replace_string];
   runtime.caml_register_global(2, Re, "Re");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJSZSJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsS0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2J5dGVzX3Vuc2FmZV9nZXQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfQnl0ZXMiLCJTdGRsaWIiLCJTdGRsaWJfQ2hhciIsImNzdF9CaXRfdmVjdG9yX3NldCIsImNzdF9CaXRfdmVjdG9yX2dldCIsImxlbmd0aCIsInQiLCJzZXQiLCJ2IiwibiIsImIiLCJpIiwicyIsImMiLCJtYXNrIiwieCIsImdldCIsInJlc2V0X3plcm8iLCJjcmVhdGVfemVybyIsImxlbiIsInIiLCJxIiwiYml0cyIsIlJlX0JpdF92ZWN0b3IiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9iaXRfdmVjdG9yLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxxQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsWUFBQUMsT0FBQUMsR0NPZSxZQUFLO0FBQUEsWUFBQUMsSUFBQUMsR0FBQUMsR0FBQUM7QUFBQUEsUUFBQSxNQVVsQjtBQUFBLFlBQTRCO0FBQUE7QUFBQSxLQUFBQyxJQVA1QjtBQUFBLEtBQUFDLElBQ0E7QUFBQSxLQUFBQyxJQU5hO0FBQUEsS0FBQUMsT0FPYjtBQUFBLEtBQUFDLElBQ0EsbUJBQW9EO0FBQUEsS0FBQUgsTUFBcEQ7QUFBQSxJQVBvRCxzQ0FBWjtBQUFBLElBQVk7QUFBQSxHQVlwQztBQUFBLFlBQUFJLElBQUFSLEdBQUFDO0FBQUFBLFFBQUEsTUFTaEI7QUFBQSxZQUE0QjtBQUFBLFFBQUFFLElBTDVCLGFBQUFDLElBQ0E7QUFBQSxJQWxCYSwrREFrQkE7QUFBQSxHQUtDO0FBQUEsWUFBQUssV0FBQVg7QUFBQUEsUUFBQSxNQUlkO0FBQUE7QUFBQSxTQUFBSyxJQUFBO0FBQUE7QUFBQSxNQUNFO0FBQUEsZ0JBQXlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUQzQjtBQUFBLEdBRUk7QUFBQSxZQUFBTyxZQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxJQUlKO0FBQUEsS0FBQUMsSUFFRTtBQUFBLEtBQUFGLFFBQ0E7QUFBQSxLQUFBRyxPQUNBO0FBQUEsSUFFRjtBQUFBLEdBQWE7QUFBQSxPQUFBQyxnQkQ1Q2YiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsInR5cGUgdCA9XG4gIHsgbGVuIDogaW50XG4gIDsgYml0cyA6IEJ5dGVzLnRcbiAgfVxuXG5sZXQgYnl0ZSBzIGkgPSBDaGFyLmNvZGUgKEJ5dGVzLnVuc2FmZV9nZXQgcyBpKVxubGV0IHNldF9ieXRlIHMgaSB4ID0gQnl0ZXMudW5zYWZlX3NldCBzIGkgKENoYXIuY2hyIHgpXG5sZXQgbGVuZ3RoIHQgPSB0LmxlblxuXG5sZXQgdW5zYWZlX3NldCB2IG4gYiA9XG4gIGxldCBpID0gbiBsc3IgMyBpblxuICBsZXQgYyA9IGJ5dGUgdi5iaXRzIGkgaW5cbiAgbGV0IG1hc2sgPSAxIGxzbCAobiBsYW5kIDcpIGluXG4gIHNldF9ieXRlIHYuYml0cyBpIChpZiBiIHRoZW4gYyBsb3IgbWFzayBlbHNlIGMgbGFuZCBsbm90IG1hc2spXG47O1xuXG5sZXQgc2V0IHYgbiBiID1cbiAgaWYgbiA8IDAgfHwgbiA+PSB2LmxlbiB0aGVuIGludmFsaWRfYXJnIFwiQml0X3ZlY3Rvci5zZXRcIjtcbiAgdW5zYWZlX3NldCB2IG4gYlxuOztcblxubGV0IHVuc2FmZV9nZXQgdiBuID1cbiAgbGV0IGkgPSBuIGxzciAzIGluXG4gIGJ5dGUgdi5iaXRzIGkgbGFuZCAoMSBsc2wgKG4gbGFuZCA3KSkgPiAwXG47O1xuXG5sZXQgZ2V0IHYgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPj0gdi5sZW4gdGhlbiBpbnZhbGlkX2FyZyBcIkJpdF92ZWN0b3IuZ2V0XCI7XG4gIHVuc2FmZV9nZXQgdiBuXG47O1xuXG5sZXQgcmVzZXRfemVybyB0ID1cbiAgZm9yIGkgPSAwIHRvIEJ5dGVzLmxlbmd0aCB0LmJpdHMgLSAxIGRvXG4gICAgQnl0ZXMuc2V0IHQuYml0cyBpICdcXDAwMCdcbiAgZG9uZVxuOztcblxubGV0IGNyZWF0ZV96ZXJvIGxlbiA9XG4gIGxldCBiaXRzID1cbiAgICBsZXQgciA9IGxlbiBsYW5kIDcgaW5cbiAgICBsZXQgcSA9IGxlbiBsc3IgMyBpblxuICAgIGxldCBsZW4gPSBpZiByID0gMCB0aGVuIHEgZWxzZSBxICsgMSBpblxuICAgIEJ5dGVzLm1ha2UgbGVuICdcXDAwMCdcbiAgaW5cbiAgeyBsZW47IGJpdHMgfVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo5MSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRm9ybWF0IiwiZXF1YWwiLCJ4IiwieSIsImNvbXBhcmUiLCJ0b19pbnQiLCJwcCIsImludGVyc2VjdCIsInN5bWJvbCIsImxldHRlciIsIm5vdF9sZXR0ZXIiLCJmcm9tX2NoYXIiLCJwYXJhbSIsIlJlX0NhdGVnb3J5Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvcmUvY2F0ZWdvcnkubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsWUFBQUMsTUFBQUMsR0FBQUMsR0NFZ0MsdUJBQUs7QUFBQSxPQUFBQyxVREZyQztBQUFBLFlBQUFDLE9BQUFILEdDSWUsU0FBQztBQUFBLE9BQUFJLEtESmhCO0FBQUEsWUFBQUMsVUFBQUwsR0FBQUMsR0NNb0IsNkJBQWE7QUFBQSxZQUFBSyxPQUFBTixHQUFBQyxHQUNoQixhQUFPO0FBQUEsT0FBQU0sU0RQeEIsR0FBQUMsYUFBQTtBQUFBLFlBQUFDLFVBQUFDO0FBQUFBO0FBQUFBO0FBQUFBLEtDZ0JnQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNEJBVEM7QUFBQSxLQW1CUjtBQUFBO0FBQUEsSUFGZTtBQUFBLEdBRUw7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EMUJuQiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwidHlwZSB0ID0gaW50XG5cbmxldCBlcXVhbCAoeCA6IGludCkgKHkgOiBpbnQpID0geCA9IHlcbmxldCBjb21wYXJlICh4IDogaW50KSAoeSA6IGludCkgPSBjb21wYXJlIHggeVxubGV0IHRvX2ludCB4ID0geFxubGV0IHBwID0gRm9ybWF0LnBwX3ByaW50X2ludFxubGV0IGludGVyc2VjdCB4IHkgPSB4IGxhbmQgeSA8PiAwXG5sZXQgKCArKyApIHggeSA9IHggbG9yIHlcbmxldCBkdW1teSA9IC0xXG5sZXQgaW5leGlzdGFudCA9IDFcbmxldCBsZXR0ZXIgPSAyXG5sZXQgbm90X2xldHRlciA9IDRcbmxldCBuZXdsaW5lID0gOFxubGV0IGxhc3RuZXdsaW5lID0gMTZcbmxldCBzZWFyY2hfYm91bmRhcnkgPSAzMlxuXG5sZXQgZnJvbV9jaGFyID0gZnVuY3Rpb25cbiAgKCogU2hvdWxkIG1hdGNoIFtjd29yZF0gZGVmaW5pdGlvbiAqKVxuICB8ICdhJyAuLiAneidcbiAgfCAnQScgLi4gJ1onXG4gIHwgJzAnIC4uICc5J1xuICB8ICdfJyB8ICdcXDE3MCcgfCAnXFwxODEnIHwgJ1xcMTg2J1xuICB8ICdcXDE5MicgLi4gJ1xcMjE0J1xuICB8ICdcXDIxNicgLi4gJ1xcMjQ2J1xuICB8ICdcXDI0OCcgLi4gJ1xcMjU1JyAtPiBsZXR0ZXJcbiAgfCAnXFxuJyAtPiBub3RfbGV0dGVyICsrIG5ld2xpbmVcbiAgfCBfIC0+IG5vdF9sZXR0ZXJcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTUzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfMyIsImNzdCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw1IiwiYTMiLCJhNCIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9Gb3JtYXQiLCJwcF9wcmludF9zdHJpbmciLCJwcF9wcmludF9pbnQiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2xpc3QiLCJmcHJpbnRmIiwic2V4cCIsImZtdCIsInMiLCJwcCIsIngiLCJwYWlyIiwicHAxIiwicHAyIiwicGFyYW0iLCJ2MiIsInYxIiwidHJpcGxlIiwicHAzIiwidjMiLCJvcHRpbnQiLCJpIiwicHBfZWxlbSIsInBwX3N0cl9saXN0IiwidG9fdG9fc3RyaW5nIiwiYiIsIlJlX0ZtdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlL2ZtdC5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUEseUJBQUFDLFFBQUEsT0FBQUMsTUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQTtBQUFBLE1Dd0NnQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxLQUFBQyxLQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQWhDViw4Q0FBb0M7QUFBQTtBQUFBLFlBQUFDLEtBQUFDLEtBQUFDLEtBQUFOLEtBQUFPO0FBQUFBLFFBQUFDLEtBRWpELFVBQUFDLEtBQUE7QUFBQSxJQUNQO0FBQUEsSUFDQTtBQUFBLElBQXFCLCtCQUNYO0FBQUE7QUFBQSxZQUFBQyxPQUFBTCxLQUFBQyxLQUFBSyxLQUFBWCxLQUFBTztBQUFBQSxRQUFBSyxLQUdELFVBQUFKLEtBQUEsVUFBQUMsS0FBQTtBQUFBLElBQ1Q7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUFxQiwrQkFDWDtBQUFBO0FBQUEsWUFBQUksT0FBQWIsS0FBQU87QUFBQUEsSUFLRCxZQUNDO0FBQUEsUUFBQU8sSUFERDtBQUFBLElBRUcsdUNBQW9CO0FBQUE7QUFBQSxZQUFBQyxRQUFBZixLQUFBQztBQUFBQSxJQUdoQixrREFBNkI7QUFBQTtBQUFBLFlBQUFlLFlBQUFoQjtBQUFBQTtBQUFBQSxLQUFBO0FBQUEsT0FNM0M7QUFBQTtBQUFBLHNCQUFBQSxLQUFBTyxPQUFzQyxvQ0FBaUI7QUFBQTtBQUFBLElBQVU7QUFBQTtBQUFBLFlBQUFVLGFBQUFmLElBQUFDO0FBQUFBO0FBQUFBLEtBQUFlLElBTTNEO0FBQUEsS0FBQWxCLE1BQ0U7QUFBQSxJQUNWO0FBQUEsSUFBUSxzQ0FDUztBQUFBO0FBQUE7QUFBQSxJQUFBbUI7QUFBQUEsTUFOYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRHhDaEMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKiBWZXJ5IHNtYWxsIHRvb2xpbmcgZm9yIGZvcm1hdCBwcmludGVycy4gKilcblxuaW5jbHVkZSBGb3JtYXRcblxudHlwZSAnYSB0ID0gRm9ybWF0LmZvcm1hdHRlciAtPiAnYSAtPiB1bml0XG5cbmxldCBsaXN0ID0gcHBfcHJpbnRfbGlzdFxubGV0IHN0ciA9IHBwX3ByaW50X3N0cmluZ1xubGV0IHNleHAgZm10IHMgcHAgeCA9IGZwcmludGYgZm10IFwiQFs8Mz4oJXNAICVhKUBdXCIgcyBwcCB4XG5cbmxldCBwYWlyIHBwMSBwcDIgZm10ICh2MSwgdjIpID1cbiAgcHAxIGZtdCB2MTtcbiAgcHBfcHJpbnRfc3BhY2UgZm10ICgpO1xuICBwcDIgZm10IHYyXG47O1xuXG5sZXQgdHJpcGxlIHBwMSBwcDIgcHAzIGZtdCAodjEsIHYyLCB2MykgPVxuICBwcDEgZm10IHYxO1xuICBwcF9wcmludF9zcGFjZSBmbXQgKCk7XG4gIHBwMiBmbXQgdjI7XG4gIHBwX3ByaW50X3NwYWNlIGZtdCAoKTtcbiAgcHAzIGZtdCB2M1xuOztcblxubGV0IGludCA9IHBwX3ByaW50X2ludFxuXG5sZXQgb3B0aW50IGZtdCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgaSAtPiBmcHJpbnRmIGZtdCBcIkAgJWRcIiBpXG47O1xuXG5sZXQgcXVvdGUgZm10IHMgPSBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXFwiJXNcXFwiXCIgc1xuXG5sZXQgcHBfb2xpc3QgcHBfZWxlbSBmbXQgPVxuICBGb3JtYXQuZnByaW50ZlxuICAgIGZtdFxuICAgIFwiQFs8Mz5bQCAlYUAgXUBdXCJcbiAgICAocHBfcHJpbnRfbGlzdCB+cHBfc2VwOihmdW4gZm10ICgpIC0+IGZwcmludGYgZm10IFwiO0AgXCIpIHBwX2VsZW0pXG47O1xuXG5sZXQgcHBfc3RyX2xpc3QgPSBwcF9vbGlzdCBxdW90ZVxuXG5sZXQgdG9fdG9fc3RyaW5nIHBwIHggPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IGZtdCA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgcHAgZm10IHg7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI2NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfSW50IiwiZXF1YWwiLCJQb2x5Iiwic3ltYm9sIiwiUmVfSW1wb3J0Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxZQUFBIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6Mjg0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImdsb2JhbF9kYXRhIiwiY2FueSIsImNzdCIsIlN0ZGxpYiIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0xpc3RMYWJlbHMiLCJTdGRsaWJfSW50IiwiU3RkbGliX0Zvcm1hdCIsIlN0ZGxpYl9DaGFyIiwiUmVfRm10IiwiU3RkbGliX01hcCIsInRvX2ludCIsIngiLCJvZl9pbnQiLCJ0b19jaGFyIiwidCIsIm9mX2NoYXIiLCJjIiwiZXF1YWwiLCJwYXJhbSIsInkiLCJ1bmlvbiIsImwiLCJyIiwiYzIiLCJjMSIsIm1hdGNoIiwiaW50ZXIiLCJkaWZmIiwic2luZ2xlIiwiYWRkIiwic2VxIiwib2Zmc2V0IiwibyIsImVtcHR5IiwidW5pb25fYWxsIiwiaW50ZXJzZWN0X2FsbCIsIm1lbSIsInMiLCJyZW0iLCJoYXNoX3JlYyIsImoiLCJpIiwiaGFzaCIsInByaW50X29uZSIsImNoIiwicHAiLCJpdGVyIiwieHMiLCJvbmVfY2hhciIsImNvbXBhcmUiLCJ2IiwidSIsIkNTZXRNYXAiLCJjc3RfUmVfY3NldF9waWNrIiwiZm9sZF9yaWdodCIsImluaXQiLCJjc2luZ2xlIiwiaXNfZW1wdHkiLCJwcmVwZW5kIiwiZCIsInBpY2siLCJjc2VxIiwidXBwZXIiLCJjbG93ZXIiLCJjZGlnaXQiLCJhc2NpaSIsImNhZGQiLCJzcGFjZSIsInhkaWdpdCIsImNhbHBoYSIsImNhbG51bSIsImNhc2VfaW5zZW5zIiwiY3dvcmQiLCJub3RubCIsIm5sIiwic2V0Iiwic3RyIiwiYmxhbmsiLCJsb3dlciIsImFscGhhIiwiYWxudW0iLCJ3b3JkYyIsImNudHJsIiwiZ3JhcGgiLCJwcmludCIsInB1bmN0IiwiUmVfQ3NldCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlL2NzZXQubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLFlBQUFDLE9BQUFDLEdDMkJlLFNBQUM7QUFBQSxZQUFBQyxPQUFBRCxHQUNELFNBQUM7QUFBQSxZQUFBRSxRQUFBQyxHQUNBLG9DQUFVO0FBQUEsWUFBQUMsUUFBQUMsR0FDVixTQUFXO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUlmO0FBQUE7QUFBQSxzQkFBQUM7QUFBQUE7QUFBQUEsVUFBQUMsSUFBZTtBQUFB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bUI7QUFBQSxVQTdCZjtBQUFBLElBQUFDO0FBQUFBLE1BcUVKLGdEQXJFSTtBQUFBLElBQUFDLFFBc0VKO0FBQUEsSUFBQUMsUUFDQSxxQ0F2RUk7QUFBQSxVQTZCZTtBQUFBLElBQUFDLFFBMkNuQiwwQkEzQ21CO0FBQUE7QUFBQSxJQUFBQyxRQTRDbkIsMEJBNUNtQjtBQUFBO0FBQUEsSUFBQUMsUUE2Q25CLDBCQTdDbUI7QUFBQSxVQTdCZjtBQUFBO0FBQUEsVUE2QmU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxRQWdEN0IsMEJBaEQ2QjtBQUFBLElBQUFDO0FBQUFBLE1BMkQxQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEck9MIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgTGlzdCA9IHN0cnVjdCBlbmRcbm9wZW4gSW1wb3J0XG5cbigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbnR5cGUgYyA9IGludFxuXG5sZXQgdG9faW50IHggPSB4XG5sZXQgb2ZfaW50IHggPSB4XG5sZXQgdG9fY2hhciB0ID0gQ2hhci5jaHIgdFxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5cbnR5cGUgdCA9IChjICogYykgbGlzdFxuXG5sZXQgZXF1YWwgPSBMaXN0LmVxdWFsIH5lcTooZnVuICh4LCB5KSAoeCcsIHknKSAtPiBJbnQuZXF1YWwgeCB4JyAmJiBJbnQuZXF1YWwgeSB5JylcblxubGV0IHJlYyB1bmlvbiBsIGwnID1cbiAgbWF0Y2ggbCwgbCcgd2l0aFxuICB8IF8sIFtdIC0+IGxcbiAgfCBbXSwgXyAtPiBsJ1xuICB8IChjMSwgYzIpIDo6IHIsIChjMScsIGMyJykgOjogcicgLT5cbiAgICBpZiBjMiArIDEgPCBjMSdcbiAgICB0aGVuIChjMSwgYzIpIDo6IHVuaW9uIHIgbCdcbiAgICBlbHNlIGlmIGMyJyArIDEgPCBjMVxuICAgIHRoZW4gKGMxJywgYzInKSA6OiB1bmlvbiBsIHInXG4gICAgZWxzZSBpZiBjMiA8IGMyJ1xuICAgIHRoZW4gdW5pb24gciAoKG1pbiBjMSBjMScsIGMyJykgOjogcicpXG4gICAgZWxzZSB1bmlvbiAoKG1pbiBjMSBjMScsIGMyKSA6OiByKSByJ1xuOztcblxubGV0IHJlYyBpbnRlciBsIGwnID1cbiAgbWF0Y2ggbCwgbCcgd2l0aFxuICB8IF8sIFtdIC0+IFtdXG4gIHwgW10sIF8gLT4gW11cbiAgfCAoYzEsIGMyKSA6OiByLCAoYzEnLCBjMicpIDo6IHInIC0+XG4gICAgaWYgYzIgPCBjMSdcbiAgICB0aGVuIGludGVyIHIgbCdcbiAgICBlbHNlIGlmIGMyJyA8IGMxXG4gICAgdGhlbiBpbnRlciBsIHInXG4gICAgZWxzZSBpZiBjMiA8IGMyJ1xuICAgIHRoZW4gKG1heCBjMSBjMScsIGMyKSA6OiBpbnRlciByIGwnXG4gICAgZWxzZSAobWF4IGMxIGMxJywgYzInKSA6OiBpbnRlciBsIHInXG47O1xuXG5sZXQgcmVjIGRpZmYgbCBsJyA9XG4gIG1hdGNoIGwsIGwnIHdpdGhcbiAgfCBfLCBbXSAtPiBsXG4gIHwgW10sIF8gLT4gW11cbiAgfCAoYzEsIGMyKSA6OiByLCAoYzEnLCBjMicpIDo6IHInIC0+XG4gICAgaWYgYzIgPCBjMSdcbiAgICB0aGVuIChjMSwgYzIpIDo6IGRpZmYgciBsJ1xuICAgIGVsc2UgaWYgYzInIDwgYzFcbiAgICB0aGVuIGRpZmYgbCByJ1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHInJyA9IGlmIGMyJyA8IGMyIHRoZW4gKGMyJyArIDEsIGMyKSA6OiByIGVsc2UgciBpblxuICAgICAgaWYgYzEgPCBjMScgdGhlbiAoYzEsIGMxJyAtIDEpIDo6IGRpZmYgcicnIHInIGVsc2UgZGlmZiByJycgcicpXG47O1xuXG5sZXQgc2luZ2xlIGMgPSBbIGMsIGMgXVxubGV0IGFkZCBjIGwgPSB1bmlvbiAoc2luZ2xlIGMpIGxcbmxldCBzZXEgYyBjJyA9IGlmIGMgPD0gYycgdGhlbiBbIGMsIGMnIF0gZWxzZSBbIGMnLCBjIF1cblxubGV0IHJlYyBvZmZzZXQgbyBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCAoYzEsIGMyKSA6OiByIC0+IChjMSArIG8sIGMyICsgbykgOjogb2Zmc2V0IG8gclxuOztcblxubGV0IGVtcHR5ID0gW11cbmxldCBjYW55ID0gWyAwLCAyNTUgXVxubGV0IHVuaW9uX2FsbCA6IHQgbGlzdCAtPiB0ID0gTGlzdC5mb2xkX2xlZnQgfmluaXQ6ZW1wdHkgfmY6dW5pb25cbmxldCBpbnRlcnNlY3RfYWxsIDogdCBsaXN0IC0+IHQgPSBMaXN0LmZvbGRfbGVmdCB+aW5pdDpjYW55IH5mOmludGVyXG5cbmxldCByZWMgbWVtIChjIDogaW50KSBzID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYzEsIGMyKSA6OiByZW0gLT4gaWYgYyA8PSBjMiB0aGVuIGMgPj0gYzEgZWxzZSBtZW0gYyByZW1cbjs7XG5cbigqKioqKVxuXG50eXBlIGhhc2ggPSBpbnRcblxubGV0IHJlYyBoYXNoX3JlYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gMFxuICB8IChpLCBqKSA6OiByIC0+IGkgKyAoMTMgKiBqKSArICgyNTcgKiBoYXNoX3JlYyByKVxuOztcblxubGV0IGhhc2ggbCA9IGhhc2hfcmVjIGwgbGFuZCAweDNGRkZGRkZGXG5cbigqKioqKVxuXG5sZXQgcHJpbnRfb25lIGNoIChjMSwgYzIpID1cbiAgaWYgSW50LmVxdWFsIGMxIGMyIHRoZW4gRm9ybWF0LmZwcmludGYgY2ggXCIlZFwiIGMxIGVsc2UgRm9ybWF0LmZwcmludGYgY2ggXCIlZC0lZFwiIGMxIGMyXG47O1xuXG5sZXQgcHAgPSBGbXQubGlzdCBwcmludF9vbmVcblxubGV0IHJlYyBpdGVyIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiAoKVxuICB8ICh4LCB5KSA6OiB4cyAtPlxuICAgIGYgeCB5O1xuICAgIGl0ZXIgeHMgfmZcbjs7XG5cbmxldCBvbmVfY2hhciA9IGZ1bmN0aW9uXG4gIHwgWyAoaSwgaikgXSB3aGVuIEludC5lcXVhbCBpIGogLT4gU29tZSBpXG4gIHwgXyAtPiBOb25lXG47O1xuXG5tb2R1bGUgQ1NldE1hcCA9IE1hcC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQgKiAoaW50ICogaW50KSBsaXN0XG5cbiAgICBsZXQgY29tcGFyZSAoaSwgdSkgKGosIHYpID1cbiAgICAgIGxldCBjID0gY29tcGFyZSBpIGogaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBjb21wYXJlIHUgdlxuICAgIDs7XG4gIGVuZClcblxubGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IExpc3QuZm9sZF9yaWdodCB+ZiB0IH5pbml0XG5sZXQgY3NpbmdsZSBjID0gc2luZ2xlIChDaGFyLmNvZGUgYylcblxubGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHJlYyBwcmVwZW5kIHMgeCBsID1cbiAgbWF0Y2ggcywgbCB3aXRoXG4gIHwgW10sIF8gLT4gbFxuICB8IF9yLCBbXSAtPiBbXVxuICB8IChfYywgYycpIDo6IHIsIChbIChkLCBfZCcpIF0sIF94JykgOjogX3InIHdoZW4gYycgPCBkIC0+IHByZXBlbmQgciB4IGxcbiAgfCAoYywgYycpIDo6IHIsIChbIChkLCBkJykgXSwgeCcpIDo6IHInIC0+XG4gICAgaWYgYyA8PSBkXG4gICAgdGhlblxuICAgICAgaWYgYycgPCBkJ1xuICAgICAgdGhlbiAoWyBkLCBjJyBdLCB4IEAgeCcpIDo6IHByZXBlbmQgciB4ICgoWyBjJyArIDEsIGQnIF0sIHgnKSA6OiByJylcbiAgICAgIGVsc2UgKFsgZCwgZCcgXSwgeCBAIHgnKSA6OiBwcmVwZW5kIHMgeCByJ1xuICAgIGVsc2UgaWYgYyA+IGQnXG4gICAgdGhlbiAoWyBkLCBkJyBdLCB4JykgOjogcHJlcGVuZCBzIHggcidcbiAgICBlbHNlIChbIGQsIGMgLSAxIF0sIHgnKSA6OiBwcmVwZW5kIHMgeCAoKFsgYywgZCcgXSwgeCcpIDo6IHInKVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgcGljayA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gaW52YWxpZF9hcmcgXCJSZV9jc2V0LnBpY2tcIlxuICB8ICh4LCBfKSA6OiBfIC0+IHhcbjs7XG5cbmxldCBjc2VxIGMgYycgPSBzZXEgKG9mX2NoYXIgYykgKG9mX2NoYXIgYycpXG5sZXQgcmcgPSBjc2VxXG5sZXQgY2hhciA9IGNzaW5nbGVcbmxldCB1cHBlciA9IHVuaW9uX2FsbCBbIGNzZXEgJ0EnICdaJzsgY3NlcSAnXFwxOTInICdcXDIxNCc7IGNzZXEgJ1xcMjE2JyAnXFwyMjInIF1cbmxldCBjbG93ZXIgPSBvZmZzZXQgMzIgdXBwZXJcbmxldCBjZGlnaXQgPSBjc2VxICcwJyAnOSdcbmxldCBhc2NpaSA9IGNzZXEgJ1xcMDAwJyAnXFwxMjcnXG5sZXQgY2FkZCBjIHMgPSBhZGQgKG9mX2NoYXIgYykgc1xubGV0IHNwYWNlID0gYWRkIChvZl9jaGFyICcgJykgKGNzZXEgJ1xcMDA5JyAnXFwwMTMnKVxubGV0IHhkaWdpdCA9IHVuaW9uX2FsbCBbIGNkaWdpdDsgY3NlcSAnYScgJ2YnOyBjc2VxICdBJyAnRicgXVxuXG5sZXQgY2FscGhhID1cbiAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgfmY6Y2FkZFxuICAgIFsgJ1xcMTcwJzsgJ1xcMTgxJzsgJ1xcMTg2JzsgJ1xcMjIzJzsgJ1xcMjU1JyBdXG4gICAgfmluaXQ6KHVuaW9uIGNsb3dlciB1cHBlcilcbjs7XG5cbmxldCBjYWxudW0gPSB1bmlvbiBjYWxwaGEgY2RpZ2l0XG5cbmxldCBjYXNlX2luc2VucyBzID1cbiAgdW5pb25fYWxsIFsgczsgb2Zmc2V0IDMyIChpbnRlciBzIHVwcGVyKTsgb2Zmc2V0ICgtMzIpIChpbnRlciBzIGNsb3dlcikgXVxuOztcblxubGV0IGN3b3JkID0gY2FkZCAnXycgY2FsbnVtXG5sZXQgbm90bmwgPSBkaWZmIGNhbnkgKGNzaW5nbGUgJ1xcbicpXG5sZXQgbmwgPSBjc2luZ2xlICdcXG4nXG5cbmxldCBzZXQgc3RyID1cbiAgbGV0IHMgPSByZWYgZW1wdHkgaW5cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIHMgOj0gdW5pb24gKGNzaW5nbGUgc3RyLltpXSkgIXNcbiAgZG9uZTtcbiAgIXNcbjs7XG5cbmxldCBibGFuayA9IHNldCBcIlxcdCBcIlxuXG4oKiBDUiByZ3JpbmJlcmc6IHRoaXMgW2xvd2VyXSBkb2Vzbid0IG1hdGNoIFtjbG93ZXJdICopXG5sZXQgbG93ZXIgPSB1bmlvbl9hbGwgWyByZyAnYScgJ3onOyBjaGFyICdcXDE4MSc7IHJnICdcXDIyMycgJ1xcMjQ2JzsgcmcgJ1xcMjQ4JyAnXFwyNTUnIF1cbmxldCBhbHBoYSA9IHVuaW9uX2FsbCBbIGxvd2VyOyB1cHBlcjsgY2hhciAnXFwxNzAnOyBjaGFyICdcXDE4NicgXVxubGV0IGFsbnVtID0gdW5pb25fYWxsIFsgYWxwaGE7IGNkaWdpdCBdXG5sZXQgd29yZGMgPSB1bmlvbl9hbGwgWyBhbG51bTsgY2hhciAnXycgXVxubGV0IGNudHJsID0gdW5pb25fYWxsIFsgcmcgJ1xcMDAwJyAnXFwwMzEnOyByZyAnXFwxMjcnICdcXDE1OScgXVxubGV0IGdyYXBoID0gdW5pb25fYWxsIFsgcmcgJ1xcMDMzJyAnXFwxMjYnOyByZyAnXFwxNjAnICdcXDI1NScgXVxubGV0IHByaW50ID0gdW5pb25fYWxsIFsgcmcgJ1xcMDMyJyAnXFwxMjYnOyByZyAnXFwxNjAnICdcXDI1NScgXVxuXG5sZXQgcHVuY3QgPVxuICB1bmlvbl9hbGxcbiAgICBbIHJnICdcXDAzMycgJ1xcMDQ3J1xuICAgIDsgcmcgJ1xcMDU4JyAnXFwwNjQnXG4gICAgOyByZyAnXFwwOTEnICdcXDA5NidcbiAgICA7IHJnICdcXDEyMycgJ1xcMTI2J1xuICAgIDsgcmcgJ1xcMTYwJyAnXFwxNjknXG4gICAgOyByZyAnXFwxNzEnICdcXDE4MCdcbiAgICA7IHJnICdcXDE4MicgJ1xcMTg1J1xuICAgIDsgcmcgJ1xcMTg3JyAnXFwxOTEnXG4gICAgOyBjaGFyICdcXDIxNSdcbiAgICA7IGNoYXIgJ1xcMjQ3J1xuICAgIF1cbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjcyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jYWxsMiIsImYiLCJhMCIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWIiLCJTdGRsaWJfTGlzdCIsIm1ha2UiLCJtYXJrcyIsImxlbiIsIm1hIiwicGFyYW0iLCJpIiwidCIsInYiLCJ0ZXN0Iiwib2Zmc2V0Iiwic3RhcnRfaSIsInN0b3BfaSIsInN0YXJ0Iiwic3RvcCIsIml0ZXJpIiwiaWR4IiwiUmVfTWFya19pbmZvcyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlL21hcmtfaW5mb3MubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUgsR0FBQUMsSUFBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsWUFBQUMsS0FBQUM7QUFBQUE7QUFBQUEsS0FBQUM7QUFBQUEsT0NHZ0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFBQUMsSUFBQUM7QUFBQUEsZUFBQUMsSUFBZTtBQUFBLFdBQWtCLG9DQUFTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBQyxJQUNoRDtBQUFBLElBQ1I7QUFBQTtBQUFBLGVBQUFGO0FBQUFBLFdBQUFHLElBQVUsVUFBQUYsSUFBQTtBQUFBLE9BQWU7QUFBQSxPQUFVO0FBQUEsTUFBQztBQUFBO0FBQUEsSUFBTTtBQUFBLEdBQ3pDO0FBQUEsWUFBQUcsS0FBQUYsR0FBQUQ7QUFBQUEsSUFHWSxnQ0FBZ0M7QUFBQSxjQUFXO0FBQUEsMkRBQVM7QUFBQSxHQUFNO0FBQUEsWUFBQUksT0FBQUgsR0FBQUQ7QUFBQUEsUUFBQUssVUFHdkUsV0FBQUMsU0FDQTtBQUFBLElBQ0EsMkJBQ0s7QUFBQSxRQUFBQyxRQUVTO0FBQUEsSUFDWixpQkFDSztBQUFBLFFBQUFDLE9BRVE7QUFBQSxJQUNYO0FBQUEsR0FBb0I7QUFBQSxZQUFBQyxNQUFBUixHQUFBZDtBQUFBQSxRQUFBLE1BSXhCO0FBQUE7QUFBQSxTQUFBYSxJQUFBO0FBQUE7QUFBQSxVQUFBVSxNQUNFLFdBQUFILFFBQ1k7QUFBQSxNQUNaO0FBQUEsaUJBQ0ssYUFBQUMsT0FDUTtBQUFBLE9BQ1g7QUFBQTtBQUFBLGdCQUhGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUhGO0FBQUEsR0FPSTtBQUFBLE9BQUFHLGdCRGpDTiIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwidHlwZSB0ID0gaW50IGFycmF5XG5cbmxldCBtYWtlIG1hcmtzID1cbiAgbGV0IGxlbiA9IDEgKyBMaXN0LmZvbGRfbGVmdCAoZnVuIG1hIChpLCBfKSAtPiBtYXggbWEgaSkgKC0xKSBtYXJrcyBpblxuICBsZXQgdCA9IEFycmF5Lm1ha2UgbGVuICgtMSkgaW5cbiAgTGlzdC5pdGVyIChmdW4gKGksIHYpIC0+IHQuKGkpIDwtIHYpIG1hcmtzO1xuICB0XG47O1xuXG5sZXQgdGVzdCB0IGkgPSBpZiAyICogaSA+PSBBcnJheS5sZW5ndGggdCB0aGVuIGZhbHNlIGVsc2UgdC4oMiAqIGkpIDw+IC0xXG5cbmxldCBvZmZzZXQgdCBpID1cbiAgbGV0IHN0YXJ0X2kgPSAyICogaSBpblxuICBsZXQgc3RvcF9pID0gc3RhcnRfaSArIDEgaW5cbiAgaWYgc3RvcF9pID49IEFycmF5Lmxlbmd0aCB0XG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgc3RhcnQgPSB0LihzdGFydF9pKSBpblxuICAgIGlmIHN0YXJ0ID0gLTFcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIGxldCBzdG9wID0gdC4oc3RvcF9pKSBpblxuICAgICAgU29tZSAoc3RhcnQsIHN0b3ApKSlcbjs7XG5cbmxldCBpdGVyaSB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIChBcnJheS5sZW5ndGggdCAvIDIpIC0gMSBkb1xuICAgIGxldCBpZHggPSAyICogaSBpblxuICAgIGxldCBzdGFydCA9IHQuKGlkeCkgaW5cbiAgICBpZiBzdGFydCA8PiAtMVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHN0b3AgPSB0LihpZHggKyAxKSBpblxuICAgICAgZiBpIHN0YXJ0IHN0b3ApXG4gIGRvbmVcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NzU0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX1NldCIsImVxdWFsIiwieCIsInkiLCJjb21wYXJlIiwiciIsImdlbiIsInBhcmFtIiwicHAiLCJTZXQiLCJSZV9QbWFyayJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlL3BtYXJrLm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxZQUFBQyxNQUFBQyxHQUFBQyxHQ0drQyx1QkFBSztBQUFBLE9BQUFDLFVESHZDLDBCQUFBQyxJQUFBO0FBQUEsWUFBQUMsSUFBQUMsT0NRSSxRQUNBLFlBQUU7QUFBQTtBQUFBLElBQUFDLEtEVE47QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQSIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwibW9kdWxlIFBtYXJrID0gc3RydWN0XG4gIHR5cGUgdCA9IGludFxuXG4gIGxldCBlcXVhbCAoeCA6IGludCkgKHkgOiBpbnQpID0geCA9IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBpbnQpICh5IDogaW50KSA9IGNvbXBhcmUgeCB5XG4gIGxldCByID0gcmVmIDBcblxuICBsZXQgZ2VuICgpID1cbiAgICBpbmNyIHI7XG4gICAgIXJcbiAgOztcblxuICBsZXQgcHAgPSBGb3JtYXQucHBfcHJpbnRfaW50XG5lbmRcblxuaW5jbHVkZSBQbWFya1xubW9kdWxlIFNldCA9IFNldC5NYWtlIChQbWFyaylcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo3ODIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfY29tcGFyZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiZ2xvYmFsX2RhdGEiLCJlcHNfZXhwciIsIlJlX0ZtdCIsIlJlX0NzZXQiLCJSZV9DYXRlZ29yeSIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiUmVfQml0X3ZlY3RvciIsIlJlX0ltcG9ydCIsIlJlX01hcmtfaW5mb3MiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYl9Gb3JtYXQiLCJSZV9QbWFyayIsIlN0ZGxpYl9IYXNodGJsIiwiU3RkbGliX0ludCIsImNyZWF0ZSIsInBhcmFtIiwiZXF1YWwiLCJjc3RfbG9uZyIsImNzdF9maXJzdCIsImNzdF9zaG9ydCIsImNzdF9Ob25fZ3JlZWR5IiwiY3N0X0dyZWVkeSIsInBwIiwiY2giLCJrIiwiZm10IiwiUmVwX2tpbmQiLCJwcmV2IiwieCIsIm5leHQiLCJuZXh0MiIsImdyb3VwX2NvdW50IiwiTWFyayIsImhhc2hfY29tYmluZSIsImgiLCJhY2N1IiwidCIsInBtYXJrcyIsIm1hcmtzIiwieSIsImVtcHR5IiwiY3N0X2VwcyIsImNzdF9jc3QiLCJjc3RfYWx0IiwiY3N0X3NlcSIsImNzdF9yZXAiLCJjc3RfbWFyayIsImNzdF9lcmFzZSIsImNzdF9iZWZvcmUiLCJjc3RfYWZ0ZXIiLCJjc3RfcG1hcmsiLCJtZXJnZV9tYXJrc19vZmZzZXQiLCJvbGQiLCJyZW0iLCJtYXRjaCIsInYiLCJpIiwibnciLCJtZXJnZSIsImhhc2giLCJtIiwibCIsInIiLCJhIiwibWFya3Nfc2V0X2lkeCIsImlkeCIsImZpbHRlciIsImIiLCJlIiwic2V0X21hcmsiLCJjIiwibWtfZXhwciIsImlkcyIsImRlZiIsImNzdCIsInMiLCJhbHQiLCJzZXEiLCJraW5kIiwiaXNfZXBzIiwiZXhwciIsImVwcyIsInJlcCIsInNlbSIsIm1hcmsiLCJwbWFyayIsImVyYXNlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZW5hbWUiLCJ6IiwiZyIsImlzX3RtYXRjaCIsImwxIiwibDIiLCJyMSIsImUxIiwicjIiLCJlMiIsIm1hcmtzMSIsIm1hcmtzMiIsInRzZXEiLCJmaXJzdF9tYXRjaCIsInJlbW92ZV9tYXRjaGVzIiwic3BsaXRfYXRfbWF0Y2giLCJleGlzdHNfdG1hdGNoIiwic2V0X2lkeCIsImR1bW15IiwibWsiLCJjYXQiLCJkZXNjIiwic3RhdHVzIiwic3QiLCJUYWJsZSIsImluZGV4X2NvdW50IiwidyIsIm1hcmtfdXNlZF9pbmRpY2VzIiwidGJsIiwiZnJlZV9pbmRleCIsInRibF9yZWYiLCJsZW4iLCJyZW1vdmVfZHVwbGljYXRlcyIsImRlbHRhXzEiLCJjb3VudGVyIiwiY3R4IiwicmVwX2tpbmQiLCJkZWx0YV9hbHQiLCJkZWx0YV9zZXEiLCJkZWx0YV80IiwiZGVsdGEiLCJuZXh0X2NhdCIsImNoYXIiLCJwcmV2X2NhdCIsInJlZF90ciIsInRyMiIsInN0MiIsInMyIiwidHIxIiwic3QxIiwiczEiLCJwcmVwZW5kX2Rlcml2IiwiaW5pdCIsInJlc3RyaWN0IiwicHJlcGVuZF9tYXJrc19leHByX2xzdCIsImRlcml2XzEiLCJhbGxfY2hhcnMiLCJjYXRlZ29yaWVzIiwiZGVyaXZfMiIsImRlcml2X3NlcSIsInhsIiwiZGVyaXZfNCIsImRlcml2IiwiZGVyIiwiUmVfQXV0b21hdGEiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9hdXRvbWF0YS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHlCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFB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c0M7QUFBQTtBQUFBO0FBQUEsSUFBQWM7QUFBQUEsTUF0R25GO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRURuakJGIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuIEltcG9ydFxuXG4oKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG5tb2R1bGUgSWRzID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCByZWZcblxuICBsZXQgY3JlYXRlICgpID0gcmVmIDBcblxuICBsZXQgbmV4dCB0ID1cbiAgICBpbmNyIHQ7XG4gICAgIXRcbiAgOztcbmVuZFxuXG5tb2R1bGUgU2VtID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgTG9uZ2VzdFxuICAgIHwgYFNob3J0ZXN0XG4gICAgfCBgRmlyc3RcbiAgICBdXG5cbiAgbGV0IGVxdWFsID0gUG9seS5lcXVhbFxuXG4gIGxldCBwcCBjaCBrID1cbiAgICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nXG4gICAgICBjaFxuICAgICAgKG1hdGNoIGsgd2l0aFxuICAgICAgIHwgYFNob3J0ZXN0IC0+IFwic2hvcnRcIlxuICAgICAgIHwgYExvbmdlc3QgLT4gXCJsb25nXCJcbiAgICAgICB8IGBGaXJzdCAtPiBcImZpcnN0XCIpXG4gIDs7XG5lbmRcblxubW9kdWxlIFJlcF9raW5kID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgWyBgR3JlZWR5XG4gICAgfCBgTm9uX2dyZWVkeVxuICAgIF1cblxuICBsZXQgcHAgZm10ID0gZnVuY3Rpb25cbiAgICB8IGBHcmVlZHkgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJHcmVlZHlcIlxuICAgIHwgYE5vbl9ncmVlZHkgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJOb25fZ3JlZWR5XCJcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFyayA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgc3RhcnQgPSAwXG4gIGxldCBwcmV2IHggPSBwcmVkIHhcbiAgbGV0IG5leHQgeCA9IHN1Y2MgeFxuICBsZXQgbmV4dDIgeCA9IHggKyAyXG4gIGxldCBncm91cF9jb3VudCB4ID0geCAvIDJcbmVuZFxuXG50eXBlIGlkeCA9IGludFxuXG50eXBlIGV4cHIgPVxuICB7IGlkIDogaW50XG4gIDsgZGVmIDogZGVmXG4gIH1cblxuYW5kIGRlZiA9XG4gIHwgQ3N0IG9mIENzZXQudFxuICB8IEFsdCBvZiBleHByIGxpc3RcbiAgfCBTZXEgb2YgU2VtLnQgKiBleHByICogZXhwclxuICB8IEVwc1xuICB8IFJlcCBvZiBSZXBfa2luZC50ICogU2VtLnQgKiBleHByXG4gIHwgTWFyayBvZiBpbnRcbiAgfCBFcmFzZSBvZiBpbnQgKiBpbnRcbiAgfCBCZWZvcmUgb2YgQ2F0ZWdvcnkudFxuICB8IEFmdGVyIG9mIENhdGVnb3J5LnRcbiAgfCBQbWFyayBvZiBQbWFyay50XG5cbmxldCBoYXNoX2NvbWJpbmUgaCBhY2N1ID0gKGFjY3UgKiA2NTU5OSkgKyBoXG5cbm1vZHVsZSBNYXJrcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbWFya3MgOiAoaW50ICogaW50KSBsaXN0XG4gICAgOyBwbWFya3MgOiBQbWFyay5TZXQudFxuICAgIH1cblxuICBsZXQgZXF1YWwgeyBtYXJrczsgcG1hcmtzIH0gdCA9XG4gICAgTGlzdC5lcXVhbCB+ZXE6KGZ1biAoeCwgeSkgKHgnLCB5JykgLT4gSW50LmVxdWFsIHggeCcgJiYgSW50LmVxdWFsIHkgeScpIG1hcmtzIHQubWFya3NcbiAgICAmJiBQbWFyay5TZXQuZXF1YWwgcG1hcmtzIHQucG1hcmtzXG4gIDs7XG5cbiAgbGV0IGVtcHR5ID0geyBtYXJrcyA9IFtdOyBwbWFya3MgPSBQbWFyay5TZXQuZW1wdHkgfVxuXG4gIGxldCBtZXJnZSA9XG4gICAgbGV0IHJlYyBtZXJnZV9tYXJrc19vZmZzZXQgb2xkID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gb2xkXG4gICAgICB8IChpLCB2KSA6OiByZW0gLT5cbiAgICAgICAgbGV0IG53JyA9IG1lcmdlX21hcmtzX29mZnNldCAoTGlzdC5yZW1vdmVfYXNzcSBpIG9sZCkgcmVtIGluXG4gICAgICAgIGlmIHYgPSAtMiB0aGVuIG53JyBlbHNlIChpLCB2KSA6OiBudydcbiAgICBpblxuICAgIGZ1biBvbGQgbncgLT5cbiAgICAgIHsgbWFya3MgPSBtZXJnZV9tYXJrc19vZmZzZXQgb2xkLm1hcmtzIG53Lm1hcmtzXG4gICAgICA7IHBtYXJrcyA9IFBtYXJrLlNldC51bmlvbiBvbGQucG1hcmtzIG53LnBtYXJrc1xuICAgICAgfVxuICA7O1xuXG4gIGxldCByZWMgaGFzaF9tYXJrc19vZmZzZXQgbCBhY2N1ID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IChhLCBpKSA6OiByIC0+IGhhc2hfbWFya3Nfb2Zmc2V0IHIgKGhhc2hfY29tYmluZSBhIChoYXNoX2NvbWJpbmUgaSBhY2N1KSlcbiAgOztcblxuICBsZXQgaGFzaCBtIGFjY3UgPSBoYXNoX21hcmtzX29mZnNldCBtLm1hcmtzIChoYXNoX2NvbWJpbmUgKEhhc2h0YmwuaGFzaCBtLnBtYXJrcykgYWNjdSlcblxuICBsZXQgbWFya3Nfc2V0X2lkeCA9XG4gICAgbGV0IHJlYyBtYXJrc19zZXRfaWR4IGlkeCA9IGZ1bmN0aW9uXG4gICAgICB8IChhLCAtMSkgOjogcmVtIC0+IChhLCBpZHgpIDo6IG1hcmtzX3NldF9pZHggaWR4IHJlbVxuICAgICAgfCBtYXJrcyAtPiBtYXJrc1xuICAgIGluXG4gICAgZnVuIG1hcmtzIGlkeCAtPiB7IG1hcmtzIHdpdGggbWFya3MgPSBtYXJrc19zZXRfaWR4IGlkeCBtYXJrcy5tYXJrcyB9XG4gIDs7XG5cbiAgbGV0IHJlYyByZW1vdmVfbWFya3MgYiBlIHJlbSA9XG4gICAgaWYgYiA+IGUgdGhlbiByZW0gZWxzZSByZW1vdmVfbWFya3MgYiAoZSAtIDEpICgoZSwgLTIpIDo6IHJlbSlcbiAgOztcblxuICBsZXQgZmlsdGVyIHQgYiBlID1cbiAgICB7IHQgd2l0aCBtYXJrcyA9IExpc3QuZmlsdGVyIH5mOihmdW4gKGksIF8pIC0+IGkgPCBiIHx8IGkgPiBlKSB0Lm1hcmtzIH1cbiAgOztcblxuICBsZXQgZXJhc2UgdCBiIGUgPSB7IHQgd2l0aCBtYXJrcyA9IHJlbW92ZV9tYXJrcyBiIGUgKGZpbHRlciB0IGIgZSkubWFya3MgfVxuICBsZXQgc2V0X21hcmsgdCBpID0geyB0IHdpdGggbWFya3MgPSAoaSwgLTEpIDo6IExpc3QucmVtb3ZlX2Fzc3EgaSB0Lm1hcmtzIH1cbiAgbGV0IHNldF9wbWFyayB0IGkgPSB7IHQgd2l0aCBwbWFya3MgPSBQbWFyay5TZXQuYWRkIGkgdC5wbWFya3MgfVxuXG4gIGxldCBwcF9tYXJrcyBjaCB0ID1cbiAgICBtYXRjaCB0Lm1hcmtzIHdpdGhcbiAgICB8IFtdIC0+ICgpXG4gICAgfCAoYSwgaSkgOjogciAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCIlZC0lZFwiIGEgaTtcbiAgICAgIExpc3QuaXRlciB+ZjooZnVuIChhLCBpKSAtPiBGb3JtYXQuZnByaW50ZiBjaCBcIiAlZC0lZFwiIGEgaSkgclxuICA7O1xuZW5kXG5cbigqKioqKVxuXG5sZXQgcmVjIHBwIGNoIGUgPVxuICBsZXQgb3BlbiBGbXQgaW5cbiAgbWF0Y2ggZS5kZWYgd2l0aFxuICB8IENzdCBsIC0+IHNleHAgY2ggXCJjc3RcIiBDc2V0LnBwIGxcbiAgfCBBbHQgbCAtPiBzZXhwIGNoIFwiYWx0XCIgKGxpc3QgcHApIGxcbiAgfCBTZXEgKGssIGUsIGUnKSAtPiBzZXhwIGNoIFwic2VxXCIgKHRyaXBsZSBTZW0ucHAgcHAgcHApIChrLCBlLCBlJylcbiAgfCBFcHMgLT4gc3RyIGNoIFwiZXBzXCJcbiAgfCBSZXAgKF9yaywgaywgZSkgLT4gc2V4cCBjaCBcInJlcFwiIChwYWlyIFNlbS5wcCBwcCkgKGssIGUpXG4gIHwgTWFyayBpIC0+IHNleHAgY2ggXCJtYXJrXCIgaW50IGlcbiAgfCBQbWFyayBpIC0+IHNleHAgY2ggXCJwbWFya1wiIGludCAoaSA6PiBpbnQpXG4gIHwgRXJhc2UgKGIsIGUpIC0+IHNleHAgY2ggXCJlcmFzZVwiIChwYWlyIGludCBpbnQpIChiLCBlKVxuICB8IEJlZm9yZSBjIC0+IHNleHAgY2ggXCJiZWZvcmVcIiBDYXRlZ29yeS5wcCBjXG4gIHwgQWZ0ZXIgYyAtPiBzZXhwIGNoIFwiYWZ0ZXJcIiBDYXRlZ29yeS5wcCBjXG47O1xuXG4oKioqKilcbmxldCBlcHNfZXhwciA9IHsgaWQgPSAwOyBkZWYgPSBFcHMgfVxubGV0IG1rX2V4cHIgaWRzIGRlZiA9IHsgaWQgPSBJZHMubmV4dCBpZHM7IGRlZiB9XG5sZXQgZW1wdHkgaWRzID0gbWtfZXhwciBpZHMgKEFsdCBbXSlcbmxldCBjc3QgaWRzIHMgPSBpZiBDc2V0LmlzX2VtcHR5IHMgdGhlbiBlbXB0eSBpZHMgZWxzZSBta19leHByIGlkcyAoQ3N0IHMpXG5cbmxldCBhbHQgaWRzID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBlbXB0eSBpZHNcbiAgfCBbIGMgXSAtPiBjXG4gIHwgbCAtPiBta19leHByIGlkcyAoQWx0IGwpXG47O1xuXG5sZXQgc2VxIGlkcyAoa2luZCA6IFNlbS50KSB4IHkgPVxuICBtYXRjaCB4LmRlZiwgeS5kZWYgd2l0aFxuICB8IEFsdCBbXSwgXyAtPiB4XG4gIHwgXywgQWx0IFtdIC0+IHlcbiAgfCBFcHMsIF8gLT4geVxuICB8IF8sIEVwcyB3aGVuIFNlbS5lcXVhbCBraW5kIGBGaXJzdCAtPiB4XG4gIHwgXyAtPiBta19leHByIGlkcyAoU2VxIChraW5kLCB4LCB5KSlcbjs7XG5cbmxldCBpc19lcHMgZXhwciA9XG4gIG1hdGNoIGV4cHIuZGVmIHdpdGhcbiAgfCBFcHMgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBlcHMgaWRzID0gbWtfZXhwciBpZHMgRXBzXG5sZXQgcmVwIGlkcyBraW5kIHNlbSB4ID0gbWtfZXhwciBpZHMgKFJlcCAoa2luZCwgc2VtLCB4KSlcbmxldCBtYXJrIGlkcyBtID0gbWtfZXhwciBpZHMgKE1hcmsgbSlcbmxldCBwbWFyayBpZHMgaSA9IG1rX2V4cHIgaWRzIChQbWFyayBpKVxubGV0IGVyYXNlIGlkcyBtIG0nID0gbWtfZXhwciBpZHMgKEVyYXNlIChtLCBtJykpXG5sZXQgYmVmb3JlIGlkcyBjID0gbWtfZXhwciBpZHMgKEJlZm9yZSBjKVxubGV0IGFmdGVyIGlkcyBjID0gbWtfZXhwciBpZHMgKEFmdGVyIGMpXG5cbigqKioqKVxuXG5sZXQgcmVjIHJlbmFtZSBpZHMgeCA9XG4gIG1hdGNoIHguZGVmIHdpdGhcbiAgfCBDc3QgXyB8IEVwcyB8IE1hcmsgXyB8IFBtYXJrIF8gfCBFcmFzZSBfIHwgQmVmb3JlIF8gfCBBZnRlciBfIC0+IG1rX2V4cHIgaWRzIHguZGVmXG4gIHwgQWx0IGwgLT4gbWtfZXhwciBpZHMgKEFsdCAoTGlzdC5tYXAgfmY6KHJlbmFtZSBpZHMpIGwpKVxuICB8IFNlcSAoaywgeSwgeikgLT4gbWtfZXhwciBpZHMgKFNlcSAoaywgcmVuYW1lIGlkcyB5LCByZW5hbWUgaWRzIHopKVxuICB8IFJlcCAoZywgaywgeSkgLT4gbWtfZXhwciBpZHMgKFJlcCAoZywgaywgcmVuYW1lIGlkcyB5KSlcbjs7XG5cbigqKioqKVxuXG50eXBlIGhhc2ggPSBpbnRcblxudHlwZSBzdGF0dXMgPVxuICB8IEZhaWxlZFxuICB8IE1hdGNoIG9mIE1hcmtfaW5mb3MudCAqIFBtYXJrLlNldC50XG4gIHwgUnVubmluZ1xuXG5tb2R1bGUgRSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgVFNlcSBvZiB0IGxpc3QgKiBleHByICogU2VtLnRcbiAgICB8IFRFeHAgb2YgTWFya3MudCAqIGV4cHJcbiAgICB8IFRNYXRjaCBvZiBNYXJrcy50XG5cbiAgbGV0IGlzX3RtYXRjaCA9IGZ1bmN0aW9uXG4gICAgfCBUTWF0Y2ggXyAtPiB0cnVlXG4gICAgfCBUU2VxIF8gfCBURXhwIF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgcmVjIGVxdWFsIGwxIGwyID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IFRTZXEgKGwxJywgZTEsIF8pIDo6IHIxLCBUU2VxIChsMicsIGUyLCBfKSA6OiByMiAtPlxuICAgICAgZTEuaWQgPSBlMi5pZCAmJiBlcXVhbCBsMScgbDInICYmIGVxdWFsIHIxIHIyXG4gICAgfCBURXhwIChtYXJrczEsIGUxKSA6OiByMSwgVEV4cCAobWFya3MyLCBlMikgOjogcjIgLT5cbiAgICAgIGUxLmlkID0gZTIuaWQgJiYgTWFya3MuZXF1YWwgbWFya3MxIG1hcmtzMiAmJiBlcXVhbCByMSByMlxuICAgIHwgVE1hdGNoIG1hcmtzMSA6OiByMSwgVE1hdGNoIG1hcmtzMiA6OiByMiAtPiBNYXJrcy5lcXVhbCBtYXJrczEgbWFya3MyICYmIGVxdWFsIHIxIHIyXG4gICAgfCBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IHJlYyBoYXNoIGwgYWNjdSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1XG4gICAgfCBUU2VxIChsJywgZSwgXykgOjogciAtPlxuICAgICAgaGFzaCByIChoYXNoX2NvbWJpbmUgMHgxNzJhMWJjZSAoaGFzaF9jb21iaW5lIGUuaWQgKGhhc2ggbCcgYWNjdSkpKVxuICAgIHwgVEV4cCAobWFya3MsIGUpIDo6IHIgLT5cbiAgICAgIGhhc2ggciAoaGFzaF9jb21iaW5lIDB4MmI0YzBkNzcgKGhhc2hfY29tYmluZSBlLmlkIChNYXJrcy5oYXNoIG1hcmtzIGFjY3UpKSlcbiAgICB8IFRNYXRjaCBtYXJrcyA6OiByIC0+IGhhc2ggciAoaGFzaF9jb21iaW5lIDB4MWMyMDVhZDUgKE1hcmtzLmhhc2ggbWFya3MgYWNjdSkpXG4gIDs7XG5cbiAgbGV0IHRleHAgbWFya3MgeCA9IFRFeHAgKG1hcmtzLCB4KVxuXG4gIGxldCB0c2VxIGtpbmQgeCB5IHJlbSA9XG4gICAgbWF0Y2ggeCB3aXRoXG4gICAgfCBbXSAtPiByZW1cbiAgICB8IFsgVEV4cCAobWFya3MsIHsgZGVmID0gRXBzOyBfIH0pIF0gLT4gVEV4cCAobWFya3MsIHkpIDo6IHJlbVxuICAgIHwgXyAtPiBUU2VxICh4LCB5LCBraW5kKSA6OiByZW1cbiAgOztcblxuICBsZXQgcmVjIHByaW50X3N0YXRlX3JlYyBjaCBlIHkgPVxuICAgIG1hdGNoIGUgd2l0aFxuICAgIHwgVE1hdGNoIG1hcmtzIC0+IEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oTWF0Y2hAICVhKUBdXCIgTWFya3MucHBfbWFya3MgbWFya3NcbiAgICB8IFRTZXEgKGwnLCB4LCBfa2luZCkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oU2VxQCBcIjtcbiAgICAgIHByaW50X3N0YXRlX2xzdCBjaCBsJyB4O1xuICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCJAICVhKUBdXCIgcHAgeFxuICAgIHwgVEV4cCAobWFya3MsIHsgZGVmID0gRXBzOyBfIH0pIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KEV4cEAgJWRAICglYSlAIChlcHMpKUBdXCIgeS5pZCBNYXJrcy5wcF9tYXJrcyBtYXJrc1xuICAgIHwgVEV4cCAobWFya3MsIHgpIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KEV4cEAgJWRAICglYSlAICVhKUBdXCIgeC5pZCBNYXJrcy5wcF9tYXJrcyBtYXJrcyBwcCB4XG5cbiAgYW5kIHByaW50X3N0YXRlX2xzdCBjaCBsIHkgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gRm9ybWF0LmZwcmludGYgY2ggXCIoKVwiXG4gICAgfCBlIDo6IHJlbSAtPlxuICAgICAgcHJpbnRfc3RhdGVfcmVjIGNoIGUgeTtcbiAgICAgIExpc3QuaXRlciByZW0gfmY6KGZ1biBlIC0+XG4gICAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQCB8IFwiO1xuICAgICAgICBwcmludF9zdGF0ZV9yZWMgY2ggZSB5KVxuICA7O1xuXG4gIGxldCBfcHAgY2ggdCA9IHByaW50X3N0YXRlX2xzdCBjaCBbIHQgXSB7IGlkID0gMDsgZGVmID0gRXBzIH1cbmVuZFxuXG5tb2R1bGUgRGVzYyA9IHN0cnVjdFxuICB0eXBlIHQgPSBFLnQgbGlzdFxuXG4gIG9wZW4gRVxuXG4gIGxldCByZWMgZmlyc3RfbWF0Y2ggPSBmdW5jdGlvblxuICAgIHwgW10gLT4gTm9uZVxuICAgIHwgVE1hdGNoIG1hcmtzIDo6IF8gLT4gU29tZSBtYXJrc1xuICAgIHwgXyA6OiByIC0+IGZpcnN0X21hdGNoIHJcbiAgOztcblxuICBsZXQgcmVtb3ZlX21hdGNoZXMgPVxuICAgIExpc3QuZmlsdGVyIH5mOihmdW5jdGlvblxuICAgICAgfCBUTWF0Y2ggXyAtPiBmYWxzZVxuICAgICAgfCBfIC0+IHRydWUpXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2F0X21hdGNoID1cbiAgICBsZXQgcmVjIHNwbGl0X2F0X21hdGNoX3JlYyBsID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IFRNYXRjaCBfIDo6IHIgLT4gTGlzdC5yZXYgbCwgcmVtb3ZlX21hdGNoZXMgclxuICAgICAgfCB4IDo6IHIgLT4gc3BsaXRfYXRfbWF0Y2hfcmVjICh4IDo6IGwpIHJcbiAgICBpblxuICAgIGZ1biBsIC0+IHNwbGl0X2F0X21hdGNoX3JlYyBbXSBsXG4gIDs7XG5cbiAgbGV0IGV4aXN0c190bWF0Y2ggPSBMaXN0LmV4aXN0cyB+Zjppc190bWF0Y2hcblxuICBsZXQgcmVjIHNldF9pZHggaWR4ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCBUTWF0Y2ggbWFya3MgOjogciAtPiBUTWF0Y2ggKE1hcmtzLm1hcmtzX3NldF9pZHggbWFya3MgaWR4KSA6OiBzZXRfaWR4IGlkeCByXG4gICAgfCBUU2VxIChsLCB4LCBraW5kKSA6OiByIC0+IFRTZXEgKHNldF9pZHggaWR4IGwsIHgsIGtpbmQpIDo6IHNldF9pZHggaWR4IHJcbiAgICB8IFRFeHAgKG1hcmtzLCB4KSA6OiByIC0+IFRFeHAgKE1hcmtzLm1hcmtzX3NldF9pZHggbWFya3MgaWR4LCB4KSA6OiBzZXRfaWR4IGlkeCByXG4gIDs7XG5lbmRcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyBpZHggOiBpZHhcbiAgICA7IGNhdGVnb3J5IDogQ2F0ZWdvcnkudFxuICAgIDsgZGVzYyA6IERlc2MudFxuICAgIDsgbXV0YWJsZSBzdGF0dXMgOiBzdGF0dXMgb3B0aW9uXG4gICAgOyBoYXNoIDogaGFzaFxuICAgIH1cblxuICBsZXRbQGlubGluZV0gaWR4IHQgPSB0LmlkeFxuICBsZXQgZHVtbXkgPSB7IGlkeCA9IC0xOyBjYXRlZ29yeSA9IENhdGVnb3J5LmR1bW15OyBkZXNjID0gW107IHN0YXR1cyA9IE5vbmU7IGhhc2ggPSAtMSB9XG5cbiAgbGV0IGhhc2ggaWR4IGNhdCBkZXNjID1cbiAgICBFLmhhc2ggZGVzYyAoaGFzaF9jb21iaW5lIGlkeCAoaGFzaF9jb21iaW5lIChDYXRlZ29yeS50b19pbnQgY2F0KSAwKSkgbGFuZCAweDNGRkZGRkZGXG4gIDs7XG5cbiAgbGV0IG1rIGlkeCBjYXQgZGVzYyA9XG4gICAgeyBpZHg7IGNhdGVnb3J5ID0gY2F0OyBkZXNjOyBzdGF0dXMgPSBOb25lOyBoYXNoID0gaGFzaCBpZHggY2F0IGRlc2MgfVxuICA7O1xuXG4gIGxldCBjcmVhdGUgY2F0IGUgPSBtayAwIGNhdCBbIEUuVEV4cCAoTWFya3MuZW1wdHksIGUpIF1cblxuICBsZXQgZXF1YWwgeCB5ID1cbiAgICAoeC5oYXNoIDogaW50KSA9IHkuaGFzaFxuICAgICYmICh4LmlkeCA6IGludCkgPSB5LmlkeFxuICAgICYmIENhdGVnb3J5LmVxdWFsIHguY2F0ZWdvcnkgeS5jYXRlZ29yeVxuICAgICYmIEUuZXF1YWwgeC5kZXNjIHkuZGVzY1xuICA7O1xuXG4gIGxldCBjb21wYXJlIHggeSA9XG4gICAgbGV0IGMgPSBjb21wYXJlICh4Lmhhc2ggOiBpbnQpIHkuaGFzaCBpblxuICAgIGlmIGMgPD4gMFxuICAgIHRoZW4gY1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGMgPSBDYXRlZ29yeS5jb21wYXJlIHguY2F0ZWdvcnkgeS5jYXRlZ29yeSBpblxuICAgICAgaWYgYyA8PiAwIHRoZW4gYyBlbHNlIGNvbXBhcmUgeC5kZXNjIHkuZGVzYylcbiAgOztcblxuICBsZXQgc3RhdHVzIHMgPVxuICAgIG1hdGNoIHMuc3RhdHVzIHdpdGhcbiAgICB8IFNvbWUgc3QgLT4gc3RcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBzdCA9XG4gICAgICAgIG1hdGNoIHMuZGVzYyB3aXRoXG4gICAgICAgIHwgW10gLT4gRmFpbGVkXG4gICAgICAgIHwgRS5UTWF0Y2ggbSA6OiBfIC0+IE1hdGNoIChNYXJrX2luZm9zLm1ha2UgbS5tYXJrcywgbS5wbWFya3MpXG4gICAgICAgIHwgXyAtPiBSdW5uaW5nXG4gICAgICBpblxuICAgICAgcy5zdGF0dXMgPC0gU29tZSBzdDtcbiAgICAgIHN0XG4gIDs7XG5cbiAgbW9kdWxlIFRhYmxlID0gSGFzaHRibC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBlcXVhbCA9IGVxdWFsXG4gICAgICBsZXQgaGFzaCB0ID0gdC5oYXNoXG4gICAgZW5kKVxuZW5kXG5cbigqKioqIEZpbmQgYSBmcmVlIGluZGV4ICoqKiopXG5cbm1vZHVsZSBXb3JraW5nX2FyZWEgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQml0X3ZlY3Rvci50IHJlZlxuXG4gIGxldCBjcmVhdGUgKCkgPSByZWYgKEJpdF92ZWN0b3IuY3JlYXRlX3plcm8gMSlcbiAgbGV0IGluZGV4X2NvdW50IHcgPSBCaXRfdmVjdG9yLmxlbmd0aCAhd1xuXG4gIGxldCByZWMgbWFya191c2VkX2luZGljZXMgdGJsID1cbiAgICBMaXN0Lml0ZXIgfmY6KGZ1bmN0aW9uXG4gICAgICB8IEUuVFNlcSAobCwgXywgXykgLT4gbWFya191c2VkX2luZGljZXMgdGJsIGxcbiAgICAgIHwgRS5URXhwIChtYXJrcywgXykgfCBFLlRNYXRjaCBtYXJrcyAtPlxuICAgICAgICBMaXN0Lml0ZXIgbWFya3MubWFya3MgfmY6KGZ1biAoXywgaSkgLT4gaWYgaSA+PSAwIHRoZW4gQml0X3ZlY3Rvci5zZXQgdGJsIGkgdHJ1ZSkpXG4gIDs7XG5cbiAgbGV0IHJlYyBmaW5kX2ZyZWUgdGJsIGlkeCBsZW4gPVxuICAgIGlmIGlkeCA9IGxlbiB8fCBub3QgKEJpdF92ZWN0b3IuZ2V0IHRibCBpZHgpIHRoZW4gaWR4IGVsc2UgZmluZF9mcmVlIHRibCAoaWR4ICsgMSkgbGVuXG4gIDs7XG5cbiAgbGV0IGZyZWVfaW5kZXggdGJsX3JlZiBsID1cbiAgICBsZXQgdGJsID0gIXRibF9yZWYgaW5cbiAgICBCaXRfdmVjdG9yLnJlc2V0X3plcm8gdGJsO1xuICAgIG1hcmtfdXNlZF9pbmRpY2VzIHRibCBsO1xuICAgIGxldCBsZW4gPSBCaXRfdmVjdG9yLmxlbmd0aCB0YmwgaW5cbiAgICBsZXQgaWR4ID0gZmluZF9mcmVlIHRibCAwIGxlbiBpblxuICAgIGlmIGlkeCA9IGxlbiB0aGVuIHRibF9yZWYgOj0gQml0X3ZlY3Rvci5jcmVhdGVfemVybyAoMiAqIGxlbik7XG4gICAgaWR4XG4gIDs7XG5lbmRcblxuKCoqKiogQ29tcHV0YXRpb24gb2YgdGhlIG5leHQgc3RhdGUgKioqKilcblxubGV0IHJlYyByZW1vdmVfZHVwbGljYXRlcyBwcmV2IGwgeSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFtdLCBwcmV2XG4gIHwgKEUuVE1hdGNoIF8gYXMgeCkgOjogXyAtPlxuICAgICgqIFRydW5jYXRlIGFmdGVyIGZpcnN0IG1hdGNoICopXG4gICAgWyB4IF0sIHByZXZcbiAgfCBFLlRTZXEgKGwsIHgsIGtpbmQpIDo6IHIgLT5cbiAgICBsZXQgbCwgcHJldiA9IHJlbW92ZV9kdXBsaWNhdGVzIHByZXYgbCB4IGluXG4gICAgbGV0IHIsIHByZXYgPSByZW1vdmVfZHVwbGljYXRlcyBwcmV2IHIgeSBpblxuICAgIEUudHNlcSBraW5kIGwgeCByLCBwcmV2XG4gIHwgKEUuVEV4cCAoX21hcmtzLCB7IGRlZiA9IEVwczsgXyB9KSBhcyBlKSA6OiByIC0+XG4gICAgaWYgTGlzdC5tZW1xIHkuaWQgfnNldDpwcmV2XG4gICAgdGhlbiByZW1vdmVfZHVwbGljYXRlcyBwcmV2IHIgeVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHIsIHByZXYgPSByZW1vdmVfZHVwbGljYXRlcyAoeS5pZCA6OiBwcmV2KSByIHkgaW5cbiAgICAgIGUgOjogciwgcHJldilcbiAgfCAoRS5URXhwIChfbWFya3MsIHgpIGFzIGUpIDo6IHIgLT5cbiAgICBpZiBMaXN0Lm1lbXEgeC5pZCB+c2V0OnByZXZcbiAgICB0aGVuIHJlbW92ZV9kdXBsaWNhdGVzIHByZXYgciB5XG4gICAgZWxzZSAoXG4gICAgICBsZXQgciwgcHJldiA9IHJlbW92ZV9kdXBsaWNhdGVzICh4LmlkIDo6IHByZXYpIHIgeSBpblxuICAgICAgZSA6OiByLCBwcmV2KVxuOztcblxudHlwZSBjdHggPVxuICB7IGMgOiBDc2V0LmNcbiAgOyBwcmV2X2NhdCA6IENhdGVnb3J5LnRcbiAgOyBuZXh0X2NhdCA6IENhdGVnb3J5LnRcbiAgOyBtYXJrcyA6IE1hcmtzLnRcbiAgfVxuXG5sZXQgcmVjIGRlbHRhXzEgKHsgYzsgbWFya3M7IF8gfSBhcyBjdHgpIHggcmVtID1cbiAgKCpGb3JtYXQuZXByaW50ZiBcIiVkQC5cIiB4LmlkOyopXG4gIG1hdGNoIHguZGVmIHdpdGhcbiAgfCBDc3QgcyAtPiBpZiBDc2V0Lm1lbSBjIHMgdGhlbiBFLnRleHAgbWFya3MgZXBzX2V4cHIgOjogcmVtIGVsc2UgcmVtXG4gIHwgQWx0IGwgLT4gZGVsdGFfYWx0IGN0eCBsIHJlbVxuICB8IFNlcSAoa2luZCwgeSwgeikgLT5cbiAgICBsZXQgeSA9IGRlbHRhXzEgY3R4IHkgW10gaW5cbiAgICBkZWx0YV9zZXEgY3R4IGtpbmQgeSB6IHJlbVxuICB8IFJlcCAocmVwX2tpbmQsIGtpbmQsIHkpIC0+XG4gICAgbGV0IHksIG1hcmtzJyA9XG4gICAgICBsZXQgeSA9IGRlbHRhXzEgY3R4IHkgW10gaW5cbiAgICAgIG1hdGNoIERlc2MuZmlyc3RfbWF0Y2ggeSB3aXRoXG4gICAgICB8IE5vbmUgLT4geSwgbWFya3NcbiAgICAgIHwgU29tZSBtYXJrcyAtPiBEZXNjLnJlbW92ZV9tYXRjaGVzIHksIG1hcmtzXG4gICAgaW5cbiAgICAobWF0Y2ggcmVwX2tpbmQgd2l0aFxuICAgICB8IGBHcmVlZHkgLT4gRS50c2VxIGtpbmQgeSB4IChFLlRNYXRjaCBtYXJrcycgOjogcmVtKVxuICAgICB8IGBOb25fZ3JlZWR5IC0+IEUuVE1hdGNoIG1hcmtzIDo6IEUudHNlcSBraW5kIHkgeCByZW0pXG4gIHwgRXBzIC0+IEUuVE1hdGNoIG1hcmtzIDo6IHJlbVxuICB8IE1hcmsgaSAtPlxuICAgIGxldCBtYXJrcyA9IE1hcmtzLnNldF9tYXJrIG1hcmtzIGkgaW5cbiAgICBFLlRNYXRjaCBtYXJrcyA6OiByZW1cbiAgfCBQbWFyayBpIC0+XG4gICAgbGV0IG1hcmtzID0gTWFya3Muc2V0X3BtYXJrIG1hcmtzIGkgaW5cbiAgICBFLlRNYXRjaCBtYXJrcyA6OiByZW1cbiAgfCBFcmFzZSAoYiwgZSkgLT4gRS5UTWF0Y2ggKE1hcmtzLmZpbHRlciBtYXJrcyBiIGUpIDo6IHJlbVxuICB8IEJlZm9yZSBjYXQgLT5cbiAgICBpZiBDYXRlZ29yeS5pbnRlcnNlY3QgY3R4Lm5leHRfY2F0IGNhdCB0aGVuIEUuVE1hdGNoIG1hcmtzIDo6IHJlbSBlbHNlIHJlbVxuICB8IEFmdGVyIGNhdCAtPlxuICAgIGlmIENhdGVnb3J5LmludGVyc2VjdCBjdHgucHJldl9jYXQgY2F0IHRoZW4gRS5UTWF0Y2ggbWFya3MgOjogcmVtIGVsc2UgcmVtXG5cbmFuZCBkZWx0YV9hbHQgY3R4IGwgcmVtID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmVtXG4gIHwgeSA6OiByIC0+IGRlbHRhXzEgY3R4IHkgKGRlbHRhX2FsdCBjdHggciByZW0pXG5cbmFuZCBkZWx0YV9zZXEgY3R4IChraW5kIDogU2VtLnQpIHkgeiByZW0gPVxuICBtYXRjaCBEZXNjLmZpcnN0X21hdGNoIHkgd2l0aFxuICB8IE5vbmUgLT4gRS50c2VxIGtpbmQgeSB6IHJlbVxuICB8IFNvbWUgbWFya3MgLT5cbiAgICBsZXQgY3R4ID0geyBjdHggd2l0aCBtYXJrcyB9IGluXG4gICAgKG1hdGNoIGtpbmQgd2l0aFxuICAgICB8IGBMb25nZXN0IC0+IEUudHNlcSBraW5kIChEZXNjLnJlbW92ZV9tYXRjaGVzIHkpIHogKGRlbHRhXzEgY3R4IHogcmVtKVxuICAgICB8IGBTaG9ydGVzdCAtPiBkZWx0YV8xIGN0eCB6IChFLnRzZXEga2luZCAoRGVzYy5yZW1vdmVfbWF0Y2hlcyB5KSB6IHJlbSlcbiAgICAgfCBgRmlyc3QgLT5cbiAgICAgICBsZXQgeSwgeScgPSBEZXNjLnNwbGl0X2F0X21hdGNoIHkgaW5cbiAgICAgICBFLnRzZXEga2luZCB5IHogKGRlbHRhXzEgY3R4IHogKEUudHNlcSBraW5kIHknIHogcmVtKSkpXG47O1xuXG5sZXQgcmVjIGRlbHRhXzMgY3R4IHggcmVtID1cbiAgbWF0Y2ggeCB3aXRoXG4gIHwgRS5UU2VxICh5LCB6LCBraW5kKSAtPlxuICAgIGxldCB5ID0gZGVsdGFfNCBjdHggeSBbXSBpblxuICAgIGRlbHRhX3NlcSBjdHgga2luZCB5IHogcmVtXG4gIHwgRS5URXhwIChtYXJrcywgZSkgLT4gZGVsdGFfMSB7IGN0eCB3aXRoIG1hcmtzIH0gZSByZW1cbiAgfCBFLlRNYXRjaCBfIC0+IHggOjogcmVtXG5cbmFuZCBkZWx0YV80IGN0eCBsIHJlbSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IHJlbVxuICB8IHkgOjogciAtPiBkZWx0YV8zIGN0eCB5IChkZWx0YV80IGN0eCByIHJlbSlcbjs7XG5cbmxldCBkZWx0YSB0YmxfcmVmIG5leHRfY2F0IGNoYXIgKHN0IDogU3RhdGUudCkgPVxuICBsZXQgZXhwciwgXyA9XG4gICAgbGV0IHByZXZfY2F0ID0gc3QuY2F0ZWdvcnkgaW5cbiAgICBsZXQgY3R4ID0geyBjID0gY2hhcjsgbmV4dF9jYXQ7IHByZXZfY2F0OyBtYXJrcyA9IE1hcmtzLmVtcHR5IH0gaW5cbiAgICByZW1vdmVfZHVwbGljYXRlcyBbXSAoZGVsdGFfNCBjdHggc3QuZGVzYyBbXSkgZXBzX2V4cHJcbiAgaW5cbiAgbGV0IGlkeCA9IFdvcmtpbmdfYXJlYS5mcmVlX2luZGV4IHRibF9yZWYgZXhwciBpblxuICBsZXQgZXhwciA9IERlc2Muc2V0X2lkeCBpZHggZXhwciBpblxuICBTdGF0ZS5tayBpZHggbmV4dF9jYXQgZXhwclxuOztcblxuKCoqKiopXG5cbmxldCByZWMgcmVkX3RyID0gZnVuY3Rpb25cbiAgfCAoW10gfCBbIF8gXSkgYXMgbCAtPiBsXG4gIHwgKChzMSwgc3QxKSBhcyB0cjEpIDo6ICgoczIsIHN0MikgYXMgdHIyKSA6OiByZW0gLT5cbiAgICBpZiBTdGF0ZS5lcXVhbCBzdDEgc3QyXG4gICAgdGhlbiByZWRfdHIgKChDc2V0LnVuaW9uIHMxIHMyLCBzdDEpIDo6IHJlbSlcbiAgICBlbHNlIHRyMSA6OiByZWRfdHIgKHRyMiA6OiByZW0pXG47O1xuXG5sZXQgc2ltcGxfdHIgbCA9XG4gIExpc3Quc29ydFxuICAgIH5jbXA6KGZ1biAoczEsIF8pIChzMiwgXykgLT4gY29tcGFyZSBzMSBzMilcbiAgICAocmVkX3RyIChMaXN0LnNvcnQgfmNtcDooZnVuIChfLCBzdDEpIChfLCBzdDIpIC0+IFN0YXRlLmNvbXBhcmUgc3QxIHN0MikgbCkpXG47O1xuXG4oKioqKilcblxubGV0IHByZXBlbmRfZGVyaXYgaW5pdCA9IExpc3QuZm9sZF9yaWdodCB+aW5pdCB+ZjooZnVuIChzLCB4KSBsIC0+IENzZXQucHJlcGVuZCBzIHggbClcblxubGV0IHJlYyByZXN0cmljdCBzID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChzJywgeCkgOjogcmVtIC0+XG4gICAgbGV0IHMnID0gQ3NldC5pbnRlciBzIHMnIGluXG4gICAgaWYgQ3NldC5pc19lbXB0eSBzJyB0aGVuIHJlc3RyaWN0IHMgcmVtIGVsc2UgKHMnLCB4KSA6OiByZXN0cmljdCBzIHJlbVxuOztcblxubGV0IHByZXBlbmRfbWFya3MgPVxuICBsZXQgcmVjIHByZXBlbmRfbWFya3NfZXhwciBtID0gZnVuY3Rpb25cbiAgICB8IEUuVFNlcSAobCwgZSwgcykgLT4gRS5UU2VxIChwcmVwZW5kX21hcmtzX2V4cHJfbHN0IG0gbCwgZSwgcylcbiAgICB8IEUuVEV4cCAobScsIGUpIC0+IEUuVEV4cCAoTWFya3MubWVyZ2UgbSBtJywgZSlcbiAgICB8IEUuVE1hdGNoIG0nIC0+IEUuVE1hdGNoIChNYXJrcy5tZXJnZSBtIG0nKVxuICBhbmQgcHJlcGVuZF9tYXJrc19leHByX2xzdCBtIGwgPSBMaXN0Lm1hcCB+ZjoocHJlcGVuZF9tYXJrc19leHByIG0pIGwgaW5cbiAgZnVuIG0gLT4gTGlzdC5tYXAgfmY6KGZ1biAocywgeCkgLT4gcywgcHJlcGVuZF9tYXJrc19leHByX2xzdCBtIHgpXG47O1xuXG5sZXQgcmVjIGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IHggcmVtID1cbiAgbWF0Y2ggeC5kZWYgd2l0aFxuICB8IENzdCBzIC0+IENzZXQucHJlcGVuZCBzIFsgRS50ZXhwIG1hcmtzIGVwc19leHByIF0gcmVtXG4gIHwgQWx0IGwgLT4gZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgbCByZW1cbiAgfCBTZXEgKGtpbmQsIHksIHopIC0+XG4gICAgbGV0IHkgPSBkZXJpdl8xIGFsbF9jaGFycyBjYXRlZ29yaWVzIG1hcmtzIGNhdCB5IFsgYWxsX2NoYXJzLCBbXSBdIGluXG4gICAgZGVyaXZfc2VxIGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCBraW5kIHkgeiByZW1cbiAgfCBSZXAgKHJlcF9raW5kLCBraW5kLCB5KSAtPlxuICAgIGxldCB5ID0gZGVyaXZfMSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgeSBbIGFsbF9jaGFycywgW10gXSBpblxuICAgIExpc3QuZm9sZF9yaWdodCB+aW5pdDpyZW0geSB+ZjooZnVuIChzLCB6KSByZW0gLT5cbiAgICAgIGxldCB6JywgbWFya3MnID1cbiAgICAgICAgbWF0Y2ggRGVzYy5maXJzdF9tYXRjaCB6IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHosIG1hcmtzXG4gICAgICAgIHwgU29tZSBtYXJrcycgLT4gRGVzYy5yZW1vdmVfbWF0Y2hlcyB6LCBtYXJrcydcbiAgICAgIGluXG4gICAgICBDc2V0LnByZXBlbmRcbiAgICAgICAgc1xuICAgICAgICAobWF0Y2ggcmVwX2tpbmQgd2l0aFxuICAgICAgICAgfCBgR3JlZWR5IC0+IEUudHNlcSBraW5kIHonIHggWyBFLlRNYXRjaCBtYXJrcycgXVxuICAgICAgICAgfCBgTm9uX2dyZWVkeSAtPiBFLlRNYXRjaCBtYXJrcyA6OiBFLnRzZXEga2luZCB6JyB4IFtdKVxuICAgICAgICByZW0pXG4gIHwgRXBzIC0+IENzZXQucHJlcGVuZCBhbGxfY2hhcnMgWyBFLlRNYXRjaCBtYXJrcyBdIHJlbVxuICB8IE1hcmsgaSAtPiBDc2V0LnByZXBlbmQgYWxsX2NoYXJzIFsgRS5UTWF0Y2ggKE1hcmtzLnNldF9tYXJrIG1hcmtzIGkpIF0gcmVtXG4gIHwgUG1hcmsgXyAtPiBDc2V0LnByZXBlbmQgYWxsX2NoYXJzIFsgRS5UTWF0Y2ggbWFya3MgXSByZW1cbiAgfCBFcmFzZSAoYiwgZSkgLT4gQ3NldC5wcmVwZW5kIGFsbF9jaGFycyBbIEUuVE1hdGNoIChNYXJrcy5lcmFzZSBtYXJrcyBiIGUpIF0gcmVtXG4gIHwgQmVmb3JlIGNhdCAtPiBDc2V0LnByZXBlbmQgKExpc3QuYXNzcSBjYXQgY2F0ZWdvcmllcykgWyBFLlRNYXRjaCBtYXJrcyBdIHJlbVxuICB8IEFmdGVyIGNhdCcgLT5cbiAgICBpZiBDYXRlZ29yeS5pbnRlcnNlY3QgY2F0IGNhdCdcbiAgICB0aGVuIENzZXQucHJlcGVuZCBhbGxfY2hhcnMgWyBFLlRNYXRjaCBtYXJrcyBdIHJlbVxuICAgIGVsc2UgcmVtXG5cbmFuZCBkZXJpdl8yIGFsbF9jaGFycyBjYXRlZ29yaWVzIG1hcmtzIGNhdCBsIHJlbSA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IHJlbVxuICB8IHkgOjogciAtPlxuICAgIGRlcml2XzFcbiAgICAgIGFsbF9jaGFyc1xuICAgICAgY2F0ZWdvcmllc1xuICAgICAgbWFya3NcbiAgICAgIGNhdFxuICAgICAgeVxuICAgICAgKGRlcml2XzIgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IHIgcmVtKVxuXG5hbmQgZGVyaXZfc2VxIGFsbF9jaGFycyBjYXRlZ29yaWVzIGNhdCBraW5kIHkgeiByZW0gPVxuICBpZiBMaXN0LmV4aXN0cyB5IH5mOihmdW4gKF9zLCB4bCkgLT4gRGVzYy5leGlzdHNfdG1hdGNoIHhsKVxuICB0aGVuIChcbiAgICBsZXQgeicgPSBkZXJpdl8xIGFsbF9jaGFycyBjYXRlZ29yaWVzIE1hcmtzLmVtcHR5IGNhdCB6IFsgYWxsX2NoYXJzLCBbXSBdIGluXG4gICAgTGlzdC5mb2xkX3JpZ2h0IH5pbml0OnJlbSB5IH5mOihmdW4gKHMsIHkpIHJlbSAtPlxuICAgICAgbWF0Y2ggRGVzYy5maXJzdF9tYXRjaCB5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgeSB6IFtdKSByZW1cbiAgICAgIHwgU29tZSBtYXJrcyAtPlxuICAgICAgICBsZXQgeicnID0gcHJlcGVuZF9tYXJrcyBtYXJrcyB6JyB8PiByZXN0cmljdCBzIGluXG4gICAgICAgIChtYXRjaCBraW5kIHdpdGhcbiAgICAgICAgIHwgYExvbmdlc3QgLT5cbiAgICAgICAgICAgQ3NldC5wcmVwZW5kXG4gICAgICAgICAgICAgc1xuICAgICAgICAgICAgIChFLnRzZXEga2luZCAoRGVzYy5yZW1vdmVfbWF0Y2hlcyB5KSB6IFtdKVxuICAgICAgICAgICAgIChwcmVwZW5kX2Rlcml2IHonJyByZW0pXG4gICAgICAgICB8IGBTaG9ydGVzdCAtPlxuICAgICAgICAgICBwcmVwZW5kX2Rlcml2XG4gICAgICAgICAgICAgeicnXG4gICAgICAgICAgICAgKENzZXQucHJlcGVuZCBzIChFLnRzZXEga2luZCAoRGVzYy5yZW1vdmVfbWF0Y2hlcyB5KSB6IFtdKSByZW0pXG4gICAgICAgICB8IGBGaXJzdCAtPlxuICAgICAgICAgICBsZXQgeScsIHknJyA9IERlc2Muc3BsaXRfYXRfbWF0Y2ggeSBpblxuICAgICAgICAgICBDc2V0LnByZXBlbmRcbiAgICAgICAgICAgICBzXG4gICAgICAgICAgICAgKEUudHNlcSBraW5kIHknIHogW10pXG4gICAgICAgICAgICAgKHByZXBlbmRfZGVyaXYgeicnIChDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgeScnIHogW10pIHJlbSkpKSkpXG4gIGVsc2VcbiAgICBMaXN0LmZvbGRfcmlnaHQgeSB+aW5pdDpyZW0gfmY6KGZ1biAocywgeGwpIHJlbSAtPlxuICAgICAgQ3NldC5wcmVwZW5kIHMgKEUudHNlcSBraW5kIHhsIHogW10pIHJlbSlcbjs7XG5cbmxldCByZWMgZGVyaXZfMyBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgeCByZW0gPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBFLlRTZXEgKHksIHosIGtpbmQpIC0+XG4gICAgbGV0IHknID0gZGVyaXZfNCBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgeSBbIGFsbF9jaGFycywgW10gXSBpblxuICAgIGRlcml2X3NlcSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQga2luZCB5JyB6IHJlbVxuICB8IEUuVEV4cCAobWFya3MsIGUpIC0+IGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IGUgcmVtXG4gIHwgRS5UTWF0Y2ggXyAtPiBDc2V0LnByZXBlbmQgYWxsX2NoYXJzIFsgeCBdIHJlbVxuXG5hbmQgZGVyaXZfNCBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgbCByZW0gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByZW1cbiAgfCB5IDo6IHIgLT4gZGVyaXZfMyBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgeSAoZGVyaXZfNCBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgciByZW0pXG47O1xuXG5sZXQgZGVyaXYgdGJsX3JlZiBhbGxfY2hhcnMgY2F0ZWdvcmllcyAoc3QgOiBTdGF0ZS50KSA9XG4gIGxldCBkZXIgPSBkZXJpdl80IGFsbF9jaGFycyBjYXRlZ29yaWVzIHN0LmNhdGVnb3J5IHN0LmRlc2MgWyBhbGxfY2hhcnMsIFtdIF0gaW5cbiAgc2ltcGxfdHJcbiAgICAoTGlzdC5mb2xkX3JpZ2h0IGRlciB+aW5pdDpbXSB+ZjooZnVuIChzLCBleHByKSByZW0gLT5cbiAgICAgICBsZXQgZXhwcicsIF8gPSByZW1vdmVfZHVwbGljYXRlcyBbXSBleHByIGVwc19leHByIGluXG4gICAgICAgKCpcbiAgICAgICAgICBGb3JtYXQuZXByaW50ZiBcIkBbPDM+QFslYUBdOiAlYSAvICVhQF1ALlwiIENzZXQucHJpbnQgcyBwcmludF9zdGF0ZSBleHByIHByaW50X3N0YXRlIGV4cHInO1xuICAgICAgICopXG4gICAgICAgbGV0IGlkeCA9IFdvcmtpbmdfYXJlYS5mcmVlX2luZGV4IHRibF9yZWYgZXhwcicgaW5cbiAgICAgICBsZXQgZXhwcicnID0gRGVzYy5zZXRfaWR4IGlkeCBleHByJyBpblxuICAgICAgIExpc3QuZm9sZF9yaWdodCBjYXRlZ29yaWVzIH5pbml0OnJlbSB+ZjooZnVuIChjYXQnLCBzJykgcmVtIC0+XG4gICAgICAgICBsZXQgcycnID0gQ3NldC5pbnRlciBzIHMnIGluXG4gICAgICAgICBpZiBDc2V0LmlzX2VtcHR5IHMnJyB0aGVuIHJlbSBlbHNlIChzJycsIFN0YXRlLm1rIGlkeCBjYXQnIGV4cHInJykgOjogcmVtKSkpXG47O1xuXG4oKioqKilcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoxODI0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2J5dGVzX3NldCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiUmVfQ3NldCIsIlN0ZGxpYl9DaGFyIiwiU3RkbGliX0J5dGVzIiwicmVwciIsInQiLCJjb2xvciIsImxlbmd0aCIsIlJlcHIiLCJnZXRfY2hhciIsImMiLCJnZXQiLCJ0cmFuc2xhdGVfY29sb3JzIiwiY20iLCJjc2V0IiwicGFyYW0iLCJsIiwiaiIsImkiLCJzdGFydCIsInN0b3AiLCJUYWJsZSIsIm1ha2UiLCJmbGF0dGVuIiwiY29sb3JfcmVwciIsInYiLCJzcGxpdCIsInNldCIsIlJlX0NvbG9yX21hcCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlL2NvbG9yX21hcC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxZQUFBQyxLQUFBQyxHQUFBQztBQUFBQSxJQ2dCd0IsT0FBSCxtQkFBRyw4QkFBa0I7QUFBQTtBQUFBLE9BQUFDLFNEaEIxQywrQkFBQUMsT0FBQTtBQUFBLFlBQUFDLFNBQUFKLEdBQUFLO0FBQUFBLElDdUJ3QixPQUFILG1CQUFHLDBCQUFjO0FBQUE7QUFBQSxZQUFBQyxJQUFBTixHQUFBSztBQUFBQSxRQUFBLE1BQ0c7QUFBQSxJQUFlO0FBQUE7QUFBQSxZQUFBRSxpQkFBQUMsSUFBQUM7QUFBQUEsSUFHcEQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQUMsT0FBQUM7QUFBQUE7QUFBQUEsZUFBQUMsSUFBeUM7QUFBQSxlQUFBQyxJQUFBO0FBQUEsZUFBQUMsUUFDM0I7QUFBQSxlQUFBQyxPQUNEO0FBQUEscUJBQ0E7QUFBQSxjQUFzQixxQ0FBRztBQUFBO0FBQUE7QUFBQSxPQUFBQyxRRDlCMUM7QUFBQSxZQUFBQyxLQUFBUCxPQ2tDYywwQ0FBcUI7QUFBQSxZQUFBUSxRQUFBVjtBQUFBQTtBQUFBQSxLQUFBSCxJQUd6QjtBQUFBLEtBQUFjLGFBQ1M7QUFBQSxLQUFBQyxJQUNqQjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsUUFBQVAsSUFBNkI7QUFBQTtBQUFBLEtBRXhCLHdDQUE4QjtBQUFBLEtBQ2pDLHFCQUFjO0FBQUEsZUFDVTtBQUFBLEtBQXhCO0FBQUEsZUFBb0M7QUFBQTtBQUFBLGdCQUVaO0FBQUEsTUFBMUIsZ0RBQXdCO0FBQUE7QUFBQSxLQUZjO0FBQUE7QUFBQSxHQUUwQjtBQUFBLFlBQUFRLE1BQUFyQixHQUFBc0I7QUFBQUEsSUFLaEU7QUFBQTtBQUFBO0FBQUEsc0JBQUFULEdBQUFEO0FBQUFBLGNBQ0Usa0JBQVk7QUFBQSxjQUNDLE9BQWIsa0JBQWEscUNBQXlCO0FBQUEsZUFBQztBQUFBO0FBQUEsT0FBQVcsZUR0RDNDIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBJbiByZWFsaXR5LCB0aGlzIGNhbiByZWFsbHkgYmUgcmVwcmVzZW50ZWQgYXMgYSBib29sIGFycmF5LlxuXG4gICBUaGUgcmVwcmVzZW50YXRpb24gaXMgYmVzdCB0aG91Z2h0IG9mIGFzIGEgbGlzdCBvZiBhbGwgY2hhcnMgYWxvbmcgd2l0aCBhXG4gICBmbGFnOlxuXG4gICAoYSwgMCksIChiLCAxKSwgKGMsIDApLCAoZCwgMCksIC4uLlxuXG4gICBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBjb2xvciBhcmUgcmVwcmVzZW50ZWQgYnkgc2VxdW5jZXMgb2ZcbiAgIGNoYXJhY3RlcnMgd2l0aCB0aGUgZmxhZyBzZXQgdG8gMC5cbiopXG5cbnR5cGUgdCA9IEJ5dGVzLnRcblxubW9kdWxlIFJlcHIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgbGV0IHJlcHIgdCBjb2xvciA9IHQuW0NzZXQudG9faW50IGNvbG9yXVxuICBsZXQgbGVuZ3RoID0gU3RyaW5nLmxlbmd0aFxuZW5kXG5cbm1vZHVsZSBUYWJsZSA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmdcblxuICBsZXQgZ2V0X2NoYXIgdCBjID0gdC5bQ3NldC50b19pbnQgY11cbiAgbGV0IGdldCB0IGMgPSBDc2V0Lm9mX2ludCBAQCBDaGFyLmNvZGUgdC5bQ2hhci5jb2RlIGNdXG5cbiAgbGV0IHRyYW5zbGF0ZV9jb2xvcnMgKGNtIDogdCkgY3NldCA9XG4gICAgQ3NldC5mb2xkX3JpZ2h0IGNzZXQgfmluaXQ6Q3NldC5lbXB0eSB+ZjooZnVuIChpLCBqKSBsIC0+XG4gICAgICBsZXQgc3RhcnQgPSBnZXRfY2hhciBjbSBpIGluXG4gICAgICBsZXQgc3RvcCA9IGdldF9jaGFyIGNtIGogaW5cbiAgICAgIENzZXQudW5pb24gKENzZXQuY3NlcSBzdGFydCBzdG9wKSBsKVxuICA7O1xuZW5kXG5cbmxldCBtYWtlICgpID0gQnl0ZXMubWFrZSAyNTcgJ1xcMDAwJ1xuXG5sZXQgZmxhdHRlbiBjbSA9XG4gIGxldCBjID0gQnl0ZXMuY3JlYXRlIDI1NiBpblxuICBsZXQgY29sb3JfcmVwciA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IHYgPSByZWYgMCBpblxuICBCeXRlcy5zZXQgYyAwICdcXDAwMCc7XG4gIEJ5dGVzLnNldCBjb2xvcl9yZXByIDAgJ1xcMDAwJztcbiAgZm9yIGkgPSAxIHRvIDI1NSBkb1xuICAgIGlmIEJ5dGVzLmdldCBjbSBpIDw+ICdcXDAwMCcgdGhlbiBpbmNyIHY7XG4gICAgQnl0ZXMuc2V0IGMgaSAoQ2hhci5jaHIgIXYpO1xuICAgIEJ5dGVzLnNldCBjb2xvcl9yZXByICF2IChDaGFyLmNociBpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGMsIEJ5dGVzLnN1Yl9zdHJpbmcgY29sb3JfcmVwciAwICghdiArIDEpXG47O1xuXG4oKiBtYXJrIGFsbCB0aGUgZW5kcG9pbnRzIG9mIHRoZSBpbnRlcnZhbHMgb2YgdGhlIGNoYXIgc2V0IHdpdGggdGhlIDEgYnl0ZSAqKVxubGV0IHNwbGl0IHQgc2V0ID1cbiAgQ3NldC5pdGVyIHNldCB+ZjooZnVuIGkgaiAtPlxuICAgIEJ5dGVzLnNldCB0IChDc2V0LnRvX2ludCBpKSAnXFwwMDEnO1xuICAgIEJ5dGVzLnNldCB0IChDc2V0LnRvX2ludCBqICsgMSkgJ1xcMDAxJylcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTkxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X1JlX3JlcG4iLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDciLCJhNCIsImE1IiwiYTYiLCJnbG9iYWxfZGF0YSIsInMiLCJlbXB0eV9hbHRlcm5hdGl2ZSIsIlJlX0ZtdCIsIlN0ZGxpYl9Gb3JtYXQiLCJSZV9QbWFyayIsIlJlX0F1dG9tYXRhIiwiUmVfQ3NldCIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiU3RkbGliX0ludCIsIlN0ZGxpYl9PcHRpb24iLCJSZV9JbXBvcnQiLCJTdGRsaWIiLCJSZV9Db2xvcl9tYXAiLCJTdGRsaWJfU3RyaW5nIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfQnVmZmVyIiwiY3N0X0FsdGVybmF0aXZlIiwiY3N0X05vX2Nhc2UiLCJjc3RfQ2FzZSIsImNzdF9CZWdfb2ZfbGluZSIsImNzdF9FbmRfb2ZfbGluZSIsImNzdF9CZWdfb2Zfd29yZCIsImNzdF9FbmRfb2Zfd29yZCIsImNzdF9Ob3RfYm91bmQiLCJjc3RfQmVnX29mX3N0ciIsImNzdF9FbmRfb2Zfc3RyIiwiY3N0X0xhc3RfZW5kX29mX2xpbmUiLCJjc3RfU3RhcnQiLCJjc3RfU3RvcCIsImNzdF9SZXBlYXQiLCJjc3RfTmFtZWRfZ3JvdXAiLCJjc3RfR3JvdXAiLCJjc3RfTm9fZ3JvdXAiLCJjc3RfTmVzdCIsImNzdF9QbWFyayIsImNzdF9TZW0iLCJjc3RfU2VtX2dyZWVkeSIsImNzdF9TZXQiLCJjc3RfSW50ZXJzZWN0aW9uIiwiY3N0X0NvbXBsZW1lbnQiLCJjc3RfRGlmZmVyZW5jZSIsInBwX2FzdCIsImZtdCIsImFzdCIsInZhciIsInJlIiwiYWx0IiwiYyIsInBwX2dlbiIsInBwX2NzZXQiLCJ0IiwicHAiLCJjc2V0IiwiYSIsInJlbCIsInN0b3AiLCJzdGFydCIsInBhcmFtIiwibWF0Y2giLCJuIiwiciIsIm0iLCJzZW0iLCJrIiwic2VxIiwiYiIsImVxdWFsIiwieDEiLCJ4MiIsInMyIiwiczEiLCJ5IiwieCIsImVxIiwibDIiLCJsMSIsImoyIiwiaTIiLCJqMSIsImkxIiwicjIiLCJtMiIsInIxIiwibTEiLCJyZXAiLCJoYW5kbGVfY2FzZV9jc2V0IiwiaWduX2Nhc2UiLCJsIiwiaGFuZGxlX2Nhc2UiLCJqIiwiaSIsInN0ciIsImFzX3NldF9lbGVtcyIsImVsZW1zIiwiZSIsImVtcHR5IiwiZXBzaWxvbiIsInJlcG4iLCJyZXAxIiwib3B0IiwiYm93IiwiZW93Iiwid29yZCIsImJvcyIsImVvcyIsIndob2xlX3N0cmluZyIsImNzdF9SZV9pbnRlciIsImNzdF9SZV9jb21wbCIsImNzdF9SZV9kaWZmIiwibWFrZV9zZXQiLCJwcmVzZXJ2ZV9zZXQiLCJsb25nZXN0Iiwic2hvcnRlc3QiLCJmaXJzdCIsImdyZWVkeSIsIm5vbl9ncmVlZHkiLCJncm91cCIsIm5hbWUiLCJub19ncm91cCIsIm5lc3QiLCJzZXQiLCJtYXJrIiwiYXNfc2V0X29yX2Vycm9yIiwiaW50ZXIiLCJjb21wbCIsImRpZmYiLCJjYXNlIiwibm9fY2FzZSIsIndpdG5lc3MiLCJ4cyIsImZyb20iLCJ3IiwibWVyZ2Vfc2VxdWVuY2VzIiwiY29sb3JpemUiLCJjb2xvcl9tYXAiLCJyZWdleHAiLCJsbmwiLCJhbmNob3JlZCIsImFscyIsInRfb2ZfY3NldCIsIlJlX0FzdCJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlL2FzdC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUMsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FB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QW9FO0FBQUFBLE1BMUZuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEaFNKIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJvcGVuIEltcG9ydFxuXG50eXBlICgnYSwgXykgYXN0ID1cbiAgfCBBbHRlcm5hdGl2ZSA6ICdhIGxpc3QgLT4gKCdhLCBbPiBgVW5jYXNlZCBdKSBhc3RcbiAgfCBOb19jYXNlIDogJ2EgLT4gKCdhLCBbPiBgQ2FzZWQgXSkgYXN0XG4gIHwgQ2FzZSA6ICdhIC0+ICgnYSwgWz4gYENhc2VkIF0pIGFzdFxuXG5sZXQgZW1wdHlfYWx0ZXJuYXRpdmUgOiAoJ2EsICdiKSBhc3QgPSBBbHRlcm5hdGl2ZSBbXVxuXG5sZXQgZXF1YWxfYXN0ICh0eXBlIGEpIGVxICh4IDogKGEsIFsgYFVuY2FzZWQgXSkgYXN0KSAoeSA6IChhLCBbIGBVbmNhc2VkIF0pIGFzdCkgPVxuICBtYXRjaCB4LCB5IHdpdGhcbiAgfCBBbHRlcm5hdGl2ZSBhLCBBbHRlcm5hdGl2ZSBiIC0+IExpc3QuZXF1YWwgfmVxIGEgYlxuOztcblxubGV0IHBwX2FzdCAodHlwZSBhIGIpIGYgZm10IChhc3QgOiAoYSwgYikgYXN0KSA9XG4gIGxldCBvcGVuIEZtdCBpblxuICBsZXQgdmFyIHMgcmUgPSBzZXhwIGZtdCBzIGYgcmUgaW5cbiAgbWF0Y2ggYXN0IHdpdGhcbiAgfCBBbHRlcm5hdGl2ZSBhbHQgLT4gc2V4cCBmbXQgXCJBbHRlcm5hdGl2ZVwiIChsaXN0IGYpIGFsdFxuICB8IENhc2UgYyAtPiB2YXIgXCJDYXNlXCIgY1xuICB8IE5vX2Nhc2UgYyAtPiB2YXIgXCJOb19jYXNlXCIgY1xuOztcblxudHlwZSBjc2V0ID1cbiAgfCBDc2V0IG9mIENzZXQudFxuICB8IEludGVyc2VjdGlvbiBvZiBjc2V0IGxpc3RcbiAgfCBDb21wbGVtZW50IG9mIGNzZXQgbGlzdFxuICB8IERpZmZlcmVuY2Ugb2YgY3NldCAqIGNzZXRcbiAgfCBDYXN0IG9mIChjc2V0LCBbIGBDYXNlZCB8IGBVbmNhc2VkIF0pIGFzdFxuXG50eXBlICgnYSwgJ2Nhc2UpIGdlbiA9XG4gIHwgU2V0IG9mICdhXG4gIHwgQXN0IG9mICgoJ2EsICdjYXNlKSBnZW4sICdjYXNlKSBhc3RcbiAgfCBTZXF1ZW5jZSBvZiAoJ2EsICdjYXNlKSBnZW4gbGlzdFxuICB8IFJlcGVhdCBvZiAoJ2EsICdjYXNlKSBnZW4gKiBpbnQgKiBpbnQgb3B0aW9uXG4gIHwgQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkXG4gIHwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmRcbiAgfCBCZWdfb2Zfc3RyXG4gIHwgRW5kX29mX3N0clxuICB8IExhc3RfZW5kX29mX2xpbmVcbiAgfCBTdGFydFxuICB8IFN0b3BcbiAgfCBHcm91cCBvZiBzdHJpbmcgb3B0aW9uICogKCdhLCAnY2FzZSkgZ2VuXG4gIHwgTm9fZ3JvdXAgb2YgKCdhLCAnY2FzZSkgZ2VuXG4gIHwgTmVzdCBvZiAoJ2EsICdjYXNlKSBnZW5cbiAgfCBQbWFyayBvZiBQbWFyay50ICogKCdhLCAnY2FzZSkgZ2VuXG4gIHwgU2VtIG9mIEF1dG9tYXRhLlNlbS50ICogKCdhLCAnY2FzZSkgZ2VuXG4gIHwgU2VtX2dyZWVkeSBvZiBBdXRvbWF0YS5SZXBfa2luZC50ICogKCdhLCAnY2FzZSkgZ2VuXG5cbmxldCByZWMgcHBfZ2VuIHBwX2NzZXQgZm10IHQgPVxuICBsZXQgb3BlbiBGb3JtYXQgaW5cbiAgbGV0IG9wZW4gRm10IGluXG4gIGxldCBwcCA9IHBwX2dlbiBwcF9jc2V0IGluXG4gIGxldCB2YXIgcyByZSA9IHNleHAgZm10IHMgcHAgcmUgaW5cbiAgbGV0IHNlcSBzIHJlbCA9IHNleHAgZm10IHMgKGxpc3QgcHApIHJlbCBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXQgY3NldCAtPiBwcF9jc2V0IGZtdCBjc2V0XG4gIHwgU2VxdWVuY2Ugc3EgLT4gc2VxIFwiU2VxdWVuY2VcIiBzcVxuICB8IFJlcGVhdCAocmUsIHN0YXJ0LCBzdG9wKSAtPlxuICAgIGxldCBwcCcgZm10ICgpID0gZnByaW50ZiBmbXQgXCIlYUAgJWQlYVwiIHBwIHJlIHN0YXJ0IG9wdGludCBzdG9wIGluXG4gICAgc2V4cCBmbXQgXCJSZXBlYXRcIiBwcCcgKClcbiAgfCBCZWdfb2ZfbGluZSAtPiBzdHIgZm10IFwiQmVnX29mX2xpbmVcIlxuICB8IEVuZF9vZl9saW5lIC0+IHN0ciBmbXQgXCJFbmRfb2ZfbGluZVwiXG4gIHwgQmVnX29mX3dvcmQgLT4gc3RyIGZtdCBcIkJlZ19vZl93b3JkXCJcbiAgfCBFbmRfb2Zfd29yZCAtPiBzdHIgZm10IFwiRW5kX29mX3dvcmRcIlxuICB8IE5vdF9ib3VuZCAtPiBzdHIgZm10IFwiTm90X2JvdW5kXCJcbiAgfCBCZWdfb2Zfc3RyIC0+IHN0ciBmbXQgXCJCZWdfb2Zfc3RyXCJcbiAgfCBFbmRfb2Zfc3RyIC0+IHN0ciBmbXQgXCJFbmRfb2Zfc3RyXCJcbiAgfCBMYXN0X2VuZF9vZl9saW5lIC0+IHN0ciBmbXQgXCJMYXN0X2VuZF9vZl9saW5lXCJcbiAgfCBTdGFydCAtPiBzdHIgZm10IFwiU3RhcnRcIlxuICB8IFN0b3AgLT4gc3RyIGZtdCBcIlN0b3BcIlxuICB8IEdyb3VwIChOb25lLCBjKSAtPiB2YXIgXCJHcm91cFwiIGNcbiAgfCBHcm91cCAoU29tZSBuLCBjKSAtPiBzZXhwIGZtdCBcIk5hbWVkX2dyb3VwXCIgKHBhaXIgc3RyIHBwKSAobiwgYylcbiAgfCBOZXN0IGMgLT4gdmFyIFwiTmVzdFwiIGNcbiAgfCBQbWFyayAobSwgcikgLT4gc2V4cCBmbXQgXCJQbWFya1wiIChwYWlyIFBtYXJrLnBwIHBwKSAobSwgcilcbiAgfCBBc3QgYSAtPiBwcF9hc3QgcHAgZm10IGFcbiAgfCBTZW0gKHNlbSwgYSkgLT4gc2V4cCBmbXQgXCJTZW1cIiAocGFpciBBdXRvbWF0YS5TZW0ucHAgcHApIChzZW0sIGEpXG4gIHwgU2VtX2dyZWVkeSAoaywgcmUpIC0+IHNleHAgZm10IFwiU2VtX2dyZWVkeVwiIChwYWlyIEF1dG9tYXRhLlJlcF9raW5kLnBwIHBwKSAoaywgcmUpXG4gIHwgTm9fZ3JvdXAgYyAtPiB2YXIgXCJOb19ncm91cFwiIGNcbjs7XG5cbmxldCByZWMgcHBfY3NldCBmbXQgY3NldCA9XG4gIGxldCBvcGVuIEZtdCBpblxuICBsZXQgc2VxIHMgcmVsID0gc2V4cCBmbXQgcyAobGlzdCBwcF9jc2V0KSByZWwgaW5cbiAgbWF0Y2ggY3NldCB3aXRoXG4gIHwgQ2FzdCBzIC0+IHBwX2FzdCBwcF9jc2V0IGZtdCBzXG4gIHwgQ3NldCBzIC0+IHNleHAgZm10IFwiU2V0XCIgQ3NldC5wcCBzXG4gIHwgSW50ZXJzZWN0aW9uIGMgLT4gc2VxIFwiSW50ZXJzZWN0aW9uXCIgY1xuICB8IENvbXBsZW1lbnQgYyAtPiBzZXEgXCJDb21wbGVtZW50XCIgY1xuICB8IERpZmZlcmVuY2UgKGEsIGIpIC0+IHNleHAgZm10IFwiRGlmZmVyZW5jZVwiIChwYWlyIHBwX2NzZXQgcHBfY3NldCkgKGEsIGIpXG47O1xuXG5sZXQgcmVjIGVxdWFsIGNzZXQgeDEgeDIgPVxuICBtYXRjaCB4MSwgeDIgd2l0aFxuICB8IFNldCBzMSwgU2V0IHMyIC0+IGNzZXQgczEgczJcbiAgfCBTZXF1ZW5jZSBsMSwgU2VxdWVuY2UgbDIgLT4gTGlzdC5lcXVhbCB+ZXE6KGVxdWFsIGNzZXQpIGwxIGwyXG4gIHwgUmVwZWF0ICh4MScsIGkxLCBqMSksIFJlcGVhdCAoeDInLCBpMiwgajIpIC0+XG4gICAgSW50LmVxdWFsIGkxIGkyICYmIE9wdGlvbi5lcXVhbCBJbnQuZXF1YWwgajEgajIgJiYgZXF1YWwgY3NldCB4MScgeDInXG4gIHwgQmVnX29mX2xpbmUsIEJlZ19vZl9saW5lXG4gIHwgRW5kX29mX2xpbmUsIEVuZF9vZl9saW5lXG4gIHwgQmVnX29mX3dvcmQsIEJlZ19vZl93b3JkXG4gIHwgRW5kX29mX3dvcmQsIEVuZF9vZl93b3JkXG4gIHwgTm90X2JvdW5kLCBOb3RfYm91bmRcbiAgfCBCZWdfb2Zfc3RyLCBCZWdfb2Zfc3RyXG4gIHwgRW5kX29mX3N0ciwgRW5kX29mX3N0clxuICB8IExhc3RfZW5kX29mX2xpbmUsIExhc3RfZW5kX29mX2xpbmVcbiAgfCBTdGFydCwgU3RhcnRcbiAgfCBTdG9wLCBTdG9wIC0+IHRydWVcbiAgfCBHcm91cCBfLCBHcm91cCBfIC0+XG4gICAgKCogRG8gbm90IG1lcmdlIGdyb3VwcyEgKilcbiAgICBmYWxzZVxuICB8IFBtYXJrIChtMSwgcjEpLCBQbWFyayAobTIsIHIyKSAtPiBQbWFyay5lcXVhbCBtMSBtMiAmJiBlcXVhbCBjc2V0IHIxIHIyXG4gIHwgTmVzdCB4LCBOZXN0IHkgLT4gZXF1YWwgY3NldCB4IHlcbiAgfCBBc3QgeCwgQXN0IHkgLT4gZXF1YWxfYXN0IChlcXVhbCBjc2V0KSB4IHlcbiAgfCBTZW0gKHNlbSwgYSksIFNlbSAoc2VtJywgYScpIC0+IFBvbHkuZXF1YWwgc2VtIHNlbScgJiYgZXF1YWwgY3NldCBhIGEnXG4gIHwgU2VtX2dyZWVkeSAocmVwLCBhKSwgU2VtX2dyZWVkeSAocmVwJywgYScpIC0+IFBvbHkuZXF1YWwgcmVwIHJlcCcgJiYgZXF1YWwgY3NldCBhIGEnXG4gIHwgXyAtPiBmYWxzZVxuOztcblxudHlwZSB0ID0gKGNzZXQsIFsgYENhc2VkIHwgYFVuY2FzZWQgXSkgZ2VuXG50eXBlIG5vX2Nhc2UgPSAoQ3NldC50LCBbIGBVbmNhc2VkIF0pIGdlblxuXG5sZXQgcHAgPSBwcF9nZW4gcHBfY3NldFxubGV0IGNzZXQgY3NldCA9IFNldCAoQ3NldCBjc2V0KVxuXG5sZXQgcmVjIGhhbmRsZV9jYXNlX2NzZXQgaWduX2Nhc2UgPSBmdW5jdGlvblxuICB8IENzZXQgcyAtPiBpZiBpZ25fY2FzZSB0aGVuIENzZXQuY2FzZV9pbnNlbnMgcyBlbHNlIHNcbiAgfCBDYXN0IChBbHRlcm5hdGl2ZSBsKSAtPiBMaXN0Lm1hcCB+ZjooaGFuZGxlX2Nhc2VfY3NldCBpZ25fY2FzZSkgbCB8PiBDc2V0LnVuaW9uX2FsbFxuICB8IENvbXBsZW1lbnQgbCAtPlxuICAgIExpc3QubWFwIH5mOihoYW5kbGVfY2FzZV9jc2V0IGlnbl9jYXNlKSBsIHw+IENzZXQudW5pb25fYWxsIHw+IENzZXQuZGlmZiBDc2V0LmNhbnlcbiAgfCBEaWZmZXJlbmNlIChyLCByJykgLT5cbiAgICBDc2V0LmludGVyXG4gICAgICAoaGFuZGxlX2Nhc2VfY3NldCBpZ25fY2FzZSByKVxuICAgICAgKENzZXQuZGlmZiBDc2V0LmNhbnkgKGhhbmRsZV9jYXNlX2NzZXQgaWduX2Nhc2UgcicpKVxuICB8IEludGVyc2VjdGlvbiBsIC0+IExpc3QubWFwIH5mOihoYW5kbGVfY2FzZV9jc2V0IGlnbl9jYXNlKSBsIHw+IENzZXQuaW50ZXJzZWN0X2FsbFxuICB8IENhc3QgKE5vX2Nhc2UgYSkgLT4gaGFuZGxlX2Nhc2VfY3NldCB0cnVlIGFcbiAgfCBDYXN0IChDYXNlIGEpIC0+IGhhbmRsZV9jYXNlX2NzZXQgZmFsc2UgYVxuOztcblxubGV0IHJlYyBoYW5kbGVfY2FzZSBpZ25fY2FzZSA6IHQgLT4gKENzZXQudCwgWyBgVW5jYXNlZCBdKSBnZW4gPSBmdW5jdGlvblxuICB8IFNldCBzIC0+IFNldCAoaGFuZGxlX2Nhc2VfY3NldCBpZ25fY2FzZSBzKVxuICB8IFNlcXVlbmNlIGwgLT4gU2VxdWVuY2UgKExpc3QubWFwIH5mOihoYW5kbGVfY2FzZSBpZ25fY2FzZSkgbClcbiAgfCBBc3QgKEFsdGVybmF0aXZlIGwpIC0+XG4gICAgbGV0IGwgPSBMaXN0Lm1hcCB+ZjooaGFuZGxlX2Nhc2UgaWduX2Nhc2UpIGwgaW5cbiAgICBBc3QgKEFsdGVybmF0aXZlIGwpXG4gIHwgUmVwZWF0IChyLCBpLCBqKSAtPiBSZXBlYXQgKGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIsIGksIGopXG4gIHwgKCBCZWdfb2ZfbGluZVxuICAgIHwgRW5kX29mX2xpbmVcbiAgICB8IEJlZ19vZl93b3JkXG4gICAgfCBFbmRfb2Zfd29yZFxuICAgIHwgTm90X2JvdW5kXG4gICAgfCBCZWdfb2Zfc3RyXG4gICAgfCBFbmRfb2Zfc3RyXG4gICAgfCBMYXN0X2VuZF9vZl9saW5lXG4gICAgfCBTdGFydFxuICAgIHwgU3RvcCApIGFzIHIgLT4gclxuICB8IFNlbSAoaywgcikgLT4gU2VtIChrLCBoYW5kbGVfY2FzZSBpZ25fY2FzZSByKVxuICB8IFNlbV9ncmVlZHkgKGssIHIpIC0+IFNlbV9ncmVlZHkgKGssIGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG4gIHwgR3JvdXAgKG4sIHIpIC0+IEdyb3VwIChuLCBoYW5kbGVfY2FzZSBpZ25fY2FzZSByKVxuICB8IE5vX2dyb3VwIHIgLT4gTm9fZ3JvdXAgKGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG4gIHwgTmVzdCByIC0+IE5lc3QgKGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIpXG4gIHwgQXN0IChDYXNlIHIpIC0+IGhhbmRsZV9jYXNlIGZhbHNlIHJcbiAgfCBBc3QgKE5vX2Nhc2UgcikgLT4gaGFuZGxlX2Nhc2UgdHJ1ZSByXG4gIHwgUG1hcmsgKGksIHIpIC0+IFBtYXJrIChpLCBoYW5kbGVfY2FzZSBpZ25fY2FzZSByKVxuOztcblxubW9kdWxlIEV4cG9ydCA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCBwcCA9IHBwXG5cbiAgbGV0IHNlcSA9IGZ1bmN0aW9uXG4gICAgfCBbIHIgXSAtPiByXG4gICAgfCBsIC0+IFNlcXVlbmNlIGxcbiAgOztcblxuICBsZXQgc3RyIHMgPVxuICAgIGxldCBsID0gcmVmIFtdIGluXG4gICAgZm9yIGkgPSBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgICBsIDo9IFNldCAoQ3NldCAoQ3NldC5jc2luZ2xlIHMuW2ldKSkgOjogIWxcbiAgICBkb25lO1xuICAgIHNlcSAhbFxuICA7O1xuXG4gIGxldCBhc19zZXRfZWxlbXMgZWxlbXMgPVxuICAgIG1hdGNoXG4gICAgICBMaXN0Lm1hcCBlbGVtcyB+ZjooZnVuY3Rpb25cbiAgICAgICAgfCBTZXQgZSAtPiBlXG4gICAgICAgIHwgXyAtPiByYWlzZV9ub3RyYWNlIEV4aXQpXG4gICAgd2l0aFxuICAgIHwgZXhjZXB0aW9uIEV4aXQgLT4gTm9uZVxuICAgIHwgZSAtPiBTb21lIGVcbiAgOztcblxuICBsZXQgZW1wdHkgOiB0ID0gQXN0IGVtcHR5X2FsdGVybmF0aXZlXG5cbiAgbGV0IGFsdCAoZWxlbXMgOiB0IGxpc3QpIDogdCA9XG4gICAgbWF0Y2ggZWxlbXMgd2l0aFxuICAgIHwgW10gLT4gZW1wdHlcbiAgICB8IFsgeCBdIC0+IHhcbiAgICB8IF8gLT5cbiAgICAgIChtYXRjaCBhc19zZXRfZWxlbXMgZWxlbXMgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBBc3QgKEFsdGVybmF0aXZlIGVsZW1zKVxuICAgICAgIHwgU29tZSBlbGVtcyAtPiBTZXQgKENhc3QgKEFsdGVybmF0aXZlIGVsZW1zKSkpXG4gIDs7XG5cbiAgbGV0IGVwc2lsb24gPSBzZXEgW11cblxuICBsZXQgcmVwbiByIGkgaiA9XG4gICAgaWYgaSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnJlcG5cIjtcbiAgICBtYXRjaCBqLCBpIHdpdGhcbiAgICB8IFNvbWUgaiwgXyB3aGVuIGogPCBpIC0+IGludmFsaWRfYXJnIFwiUmUucmVwblwiXG4gICAgfCBTb21lIDAsIDAgLT4gZXBzaWxvblxuICAgIHwgU29tZSAxLCAxIC0+IHJcbiAgICB8IF8gLT4gUmVwZWF0IChyLCBpLCBqKVxuICA7O1xuXG4gIGxldCByZXAgciA9IHJlcG4gciAwIE5vbmVcbiAgbGV0IHJlcDEgciA9IHJlcG4gciAxIE5vbmVcbiAgbGV0IG9wdCByID0gcmVwbiByIDAgKFNvbWUgMSlcbiAgbGV0IGJvbCA9IEJlZ19vZl9saW5lXG4gIGxldCBlb2wgPSBFbmRfb2ZfbGluZVxuICBsZXQgYm93ID0gQmVnX29mX3dvcmRcbiAgbGV0IGVvdyA9IEVuZF9vZl93b3JkXG4gIGxldCB3b3JkIHIgPSBzZXEgWyBib3c7IHI7IGVvdyBdXG4gIGxldCBub3RfYm91bmRhcnkgPSBOb3RfYm91bmRcbiAgbGV0IGJvcyA9IEJlZ19vZl9zdHJcbiAgbGV0IGVvcyA9IEVuZF9vZl9zdHJcbiAgbGV0IHdob2xlX3N0cmluZyByID0gc2VxIFsgYm9zOyByOyBlb3MgXVxuICBsZXQgbGVvbCA9IExhc3RfZW5kX29mX2xpbmVcbiAgbGV0IHN0YXJ0ID0gU3RhcnRcbiAgbGV0IHN0b3AgPSBTdG9wXG5cbiAgdHlwZSAnYiBmID0geyBmIDogJ2EuICdhIC0+ICgnYSwgJ2IpIGFzdCB9XG5cbiAgbGV0IG1ha2Vfc2V0IGYgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBTZXQgeCAtPiBTZXQgKENhc3QgKGYuZiB4KSlcbiAgICB8IF8gLT4gQXN0IChmLmYgdClcbiAgOztcblxuICBsZXQgcHJlc2VydmVfc2V0IGYgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBTZXQgXyAtPiB0XG4gICAgfCBfIC0+IGYgdFxuICA7O1xuXG4gIGxldCBsb25nZXN0ID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBTZW0gKGBMb25nZXN0LCB0KSlcbiAgbGV0IHNob3J0ZXN0ID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBTZW0gKGBTaG9ydGVzdCwgdCkpXG4gIGxldCBmaXJzdCA9IHByZXNlcnZlX3NldCAoZnVuIHQgLT4gU2VtIChgRmlyc3QsIHQpKVxuICBsZXQgZ3JlZWR5ID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBTZW1fZ3JlZWR5IChgR3JlZWR5LCB0KSlcbiAgbGV0IG5vbl9ncmVlZHkgPSBwcmVzZXJ2ZV9zZXQgKGZ1biB0IC0+IFNlbV9ncmVlZHkgKGBOb25fZ3JlZWR5LCB0KSlcbiAgbGV0IGdyb3VwID9uYW1lIHIgPSBHcm91cCAobmFtZSwgcilcbiAgbGV0IG5vX2dyb3VwID0gcHJlc2VydmVfc2V0IChmdW4gdCAtPiBOb19ncm91cCB0KVxuICBsZXQgbmVzdCByID0gTmVzdCByXG4gIGxldCBzZXQgc3RyID0gY3NldCAoQ3NldC5zZXQgc3RyKVxuXG4gIGxldCBtYXJrIHIgPVxuICAgIGxldCBpID0gUG1hcmsuZ2VuICgpIGluXG4gICAgaSwgUG1hcmsgKGksIHIpXG4gIDs7XG5cbiAgKCoqKiogQ2hhcmFjdGVyIHNldHMgKioqKilcbiAgbGV0IGFzX3NldF9vcl9lcnJvciBuYW1lIGVsZW1zID1cbiAgICBtYXRjaCBhc19zZXRfZWxlbXMgZWxlbXMgd2l0aFxuICAgIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBuYW1lXG4gICAgfCBTb21lIHMgLT4gc1xuICA7O1xuXG4gIGxldCBpbnRlciBlbGVtcyA9IFNldCAoSW50ZXJzZWN0aW9uIChhc19zZXRfb3JfZXJyb3IgXCJSZS5pbnRlclwiIGVsZW1zKSlcbiAgbGV0IGNvbXBsIGVsZW1zID0gU2V0IChDb21wbGVtZW50IChhc19zZXRfb3JfZXJyb3IgXCJSZS5jb21wbFwiIGVsZW1zKSlcblxuICBsZXQgZGlmZiByIHInID1cbiAgICBtYXRjaCByLCByJyB3aXRoXG4gICAgfCBTZXQgciwgU2V0IHInIC0+IFNldCAoRGlmZmVyZW5jZSAociwgcicpKVxuICAgIHwgXywgXyAtPiBpbnZhbGlkX2FyZyBcIlJlLmRpZmZcIlxuICA7O1xuXG4gIGxldCBjYXNlID1cbiAgICBsZXQgZiA9IHsgZiA9IChmdW4gciAtPiBDYXNlIHIpIH0gaW5cbiAgICBmdW4gdCAtPiBtYWtlX3NldCBmIHRcbiAgOztcblxuICBsZXQgbm9fY2FzZSA9XG4gICAgbGV0IGYgPSB7IGYgPSAoZnVuIHIgLT4gTm9fY2FzZSByKSB9IGluXG4gICAgZnVuIHQgLT4gbWFrZV9zZXQgZiB0XG4gIDs7XG5cbiAgbGV0IHdpdG5lc3MgdCA9XG4gICAgbGV0IHJlYyB3aXRuZXNzICh0IDogbm9fY2FzZSkgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFNldCBjIC0+IFN0cmluZy5tYWtlIDEgKENzZXQudG9fY2hhciAoQ3NldC5waWNrIGMpKVxuICAgICAgfCBTZXF1ZW5jZSB4cyAtPiBTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QubWFwIH5mOndpdG5lc3MgeHMpXG4gICAgICB8IEFzdCAoQWx0ZXJuYXRpdmUgKHggOjogXykpIC0+IHdpdG5lc3MgeFxuICAgICAgfCBBc3QgKEFsdGVybmF0aXZlIFtdKSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgUmVwZWF0IChyLCBmcm9tLCBfdG8pIC0+XG4gICAgICAgIGxldCB3ID0gd2l0bmVzcyByIGluXG4gICAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCB3ICogZnJvbSkgaW5cbiAgICAgICAgZm9yIF9pID0gMSB0byBmcm9tIGRvXG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYiB3XG4gICAgICAgIGRvbmU7XG4gICAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gICAgICB8IE5vX2dyb3VwIHIgLT4gd2l0bmVzcyByXG4gICAgICB8IFNlbV9ncmVlZHkgKF8sIHIpIHwgU2VtIChfLCByKSB8IE5lc3QgciB8IFBtYXJrIChfLCByKSB8IEdyb3VwIChfLCByKSAtPiB3aXRuZXNzIHJcbiAgICAgIHwgQmVnX29mX2xpbmVcbiAgICAgIHwgRW5kX29mX2xpbmVcbiAgICAgIHwgQmVnX29mX3dvcmRcbiAgICAgIHwgRW5kX29mX3dvcmRcbiAgICAgIHwgTm90X2JvdW5kXG4gICAgICB8IEJlZ19vZl9zdHJcbiAgICAgIHwgTGFzdF9lbmRfb2ZfbGluZVxuICAgICAgfCBTdGFydFxuICAgICAgfCBTdG9wXG4gICAgICB8IEVuZF9vZl9zdHIgLT4gXCJcIlxuICAgIGluXG4gICAgd2l0bmVzcyAoaGFuZGxlX2Nhc2UgZmFsc2UgdClcbiAgOztcbmVuZFxuXG5vcGVuIEV4cG9ydFxuXG5sZXQgcmVjIG1lcmdlX3NlcXVlbmNlcyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCBBc3QgKEFsdGVybmF0aXZlIGwnKSA6OiByIC0+IG1lcmdlX3NlcXVlbmNlcyAobCcgQCByKVxuICB8IFNlcXVlbmNlICh4IDo6IHkpIDo6IHIgLT5cbiAgICAobWF0Y2ggbWVyZ2Vfc2VxdWVuY2VzIHIgd2l0aFxuICAgICB8IFNlcXVlbmNlICh4JyA6OiB5JykgOjogcicgd2hlbiBlcXVhbCBDc2V0LmVxdWFsIHggeCcgLT5cbiAgICAgICBTZXF1ZW5jZSBbIHg7IEFzdCAoQWx0ZXJuYXRpdmUgWyBzZXEgeTsgc2VxIHknIF0pIF0gOjogcidcbiAgICAgfCByJyAtPiBTZXF1ZW5jZSAoeCA6OiB5KSA6OiByJylcbiAgfCB4IDo6IHIgLT4geCA6OiBtZXJnZV9zZXF1ZW5jZXMgclxuOztcblxuKCpYWFggVXNlIGEgYmV0dGVyIGFsZ29yaXRobSBhbGxvd2luZyBub24tY29udGlndW91cyByZWdpb25zPyAqKVxuXG5sZXQgY29sb3JpemUgY29sb3JfbWFwIChyZWdleHAgOiBub19jYXNlKSA9XG4gIGxldCBsbmwgPSByZWYgZmFsc2UgaW5cbiAgbGV0IHJlYyBjb2xvcml6ZSByZWdleHAgPVxuICAgIG1hdGNoIChyZWdleHAgOiBub19jYXNlKSB3aXRoXG4gICAgfCBTZXQgcyAtPiBDb2xvcl9tYXAuc3BsaXQgY29sb3JfbWFwIHNcbiAgICB8IFNlcXVlbmNlIGwgLT4gTGlzdC5pdGVyIH5mOmNvbG9yaXplIGxcbiAgICB8IEFzdCAoQWx0ZXJuYXRpdmUgbCkgLT4gTGlzdC5pdGVyIH5mOmNvbG9yaXplIGxcbiAgICB8IFJlcGVhdCAociwgXywgXykgLT4gY29sb3JpemUgclxuICAgIHwgQmVnX29mX2xpbmUgfCBFbmRfb2ZfbGluZSAtPiBDb2xvcl9tYXAuc3BsaXQgY29sb3JfbWFwIENzZXQubmxcbiAgICB8IEJlZ19vZl93b3JkIHwgRW5kX29mX3dvcmQgfCBOb3RfYm91bmQgLT4gQ29sb3JfbWFwLnNwbGl0IGNvbG9yX21hcCBDc2V0LmN3b3JkXG4gICAgfCBCZWdfb2Zfc3RyIHwgRW5kX29mX3N0ciB8IFN0YXJ0IHwgU3RvcCAtPiAoKVxuICAgIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBsbmwgOj0gdHJ1ZVxuICAgIHwgTm9fZ3JvdXAgciB8IEdyb3VwIChfLCByKSB8IE5lc3QgciB8IFBtYXJrIChfLCByKSAtPiBjb2xvcml6ZSByXG4gICAgfCBTZW0gKF8sIHIpIHwgU2VtX2dyZWVkeSAoXywgcikgLT4gY29sb3JpemUgclxuICBpblxuICBjb2xvcml6ZSByZWdleHA7XG4gICFsbmxcbjs7XG5cbmxldCByZWMgYW5jaG9yZWRfYXN0IDogKHQsIF8pIGFzdCAtPiBib29sID0gZnVuY3Rpb25cbiAgfCBBbHRlcm5hdGl2ZSBhbHMgLT4gTGlzdC5mb3JfYWxsIH5mOmFuY2hvcmVkIGFsc1xuICB8IE5vX2Nhc2UgciB8IENhc2UgciAtPiBhbmNob3JlZCByXG5cbmFuZCBhbmNob3JlZCA6IHQgLT4gYm9vbCA9IGZ1bmN0aW9uXG4gIHwgQXN0IGEgLT4gYW5jaG9yZWRfYXN0IGFcbiAgfCBTZXF1ZW5jZSBsIC0+IExpc3QuZXhpc3RzIH5mOmFuY2hvcmVkIGxcbiAgfCBSZXBlYXQgKHIsIGksIF8pIC0+IGkgPiAwICYmIGFuY2hvcmVkIHJcbiAgfCBOb19ncm91cCByIHwgU2VtIChfLCByKSB8IFNlbV9ncmVlZHkgKF8sIHIpIHwgR3JvdXAgKF8sIHIpIHwgTmVzdCByIHwgUG1hcmsgKF8sIHIpIC0+XG4gICAgYW5jaG9yZWQgclxuICB8IFNldCBfXG4gIHwgQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkXG4gIHwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmRcbiAgfCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0b3AgLT4gZmFsc2VcbiAgfCBCZWdfb2Zfc3RyIHwgU3RhcnQgLT4gdHJ1ZVxuOztcblxubGV0IHRfb2ZfY3NldCB4ID0gU2V0IHhcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNzIyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJSZV9Bc3QiLCJTdGRsaWJfTGlzdExhYmVscyIsInZpZXdfYXN0IiwidCIsImEiLCJ2aWV3IiwicGFyYW0iLCJjc2V0Iiwic2V0Iiwic2V0cyIsInkiLCJ4IiwiYXN0IiwicyIsIm5hbWUiLCJwbWFyayIsInNlbSIsIlJlX1ZpZXciXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS92aWV3Lm1sIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsWUFBQUMsU0FBQVAsR0FBQVE7QUFBQUEsSUM4QkU7QUFBQTtBQUFBLFdBQUFDLElBQUEsTUFDK0IsbURBQWU7QUFBQTtBQUFBLFdBQUFBLE1BRDlDLE1BRXVCLCtCQUFLO0FBQUEsbUJBQUFBLE1BRjVCLE1BR2lCLDhCQUFLO0FBQUE7QUFBQTtBQUFBLFlBQUFDLEtBQUFDO0FBQUFBLElBWUE7QUFBQTtBQUFBO0FBQUEsUUFPTDtBQUFBO0FBQUEsUUFDQTtBQUFBO0FBQUEsUUFDQTtBQUFBO0FBQUEsUUFDQTtBQUFBO0FBQUEsUUFDRjtBQUFBO0FBQUEsUUFDQztBQUFBO0FBQUEsUUFDQTtBQUFBO0FBQUEsUUFDTTtBQUFBO0FBQUEsUUFDWDtBQUFBLGdCQUNEO0FBQUE7QUFBQSxJQWhCWTtBQUFBO0FBQUEsV0FBQUMsT0FBQTtBQUFBLE9BUnRCO0FBQUE7QUFBQSxjQUFBQyxNQUFBLFNBQ2M7QUFBQTtBQUFBLGNBQUFDLE9BRGQ7QUFBQSxVQUVvQywrREFBZ0M7QUFBQTtBQUFBLGNBQUFBLFNBRnBFO0FBQUEsVUFHZ0MsaUVBQWdDO0FBQUE7QUFBQSxjQUFBQyxJQUhoRSxTQUFBQyxJQUFBLGVBSW9EO0FBQUEsVUFBakIsMENBQWU7QUFBQSxzQkFBQUMsTUFKbEQsU0FLYywrQkF1QndCO0FBQUE7QUFBQTtBQUFBLFdBQUFDLElBcEJoQixVQUVYLHlCQUFBRixHQUFtQixTQUFDLEtBa0JPO0FBQUE7QUFBQSxXQUFBRSxNQXBCaEIsVUFLTjtBQUFBO0FBQUEsV0FBQUgsTUFMTSxVQUFBQyxNQUFBLFVBQUFSLElBQUE7QUFBQSxPQU1BO0FBQUE7QUFBQSxXQUFBQSxNQU5BLFVBQUFXLE9BQUEsVUFrQkQ7QUFBQTtBQUFBLFdBQUFWLElBbEJDLFVBaUJOO0FBQUE7QUFBQSxXQUFBRCxNQWpCTSxVQW1CVjtBQUFBO0FBQUEsV0FBQUEsTUFuQlUsVUFBQVksUUFBQSxVQW9CQTtBQUFBO0FBQUEsV0FBQVgsTUFwQkEsVUFBQVksTUFBQSxVQUdKO0FBQUEsbUJBQUFaLE1BSEksVUFBQVksUUFBQSxVQUlHO0FBQUE7QUFBQSxHQWdCYTtBQUFBLE9BQUFDLFVEakV4QyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBJbXBvcnRcblxudHlwZSB0ID1cbiAgfCBTZXQgb2YgQ3NldC50XG4gIHwgU2VxdWVuY2Ugb2YgQXN0LnQgbGlzdFxuICB8IEFsdGVybmF0aXZlIG9mIEFzdC50IGxpc3RcbiAgfCBSZXBlYXQgb2YgQXN0LnQgKiBpbnQgKiBpbnQgb3B0aW9uXG4gIHwgQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkXG4gIHwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmRcbiAgfCBCZWdfb2Zfc3RyXG4gIHwgRW5kX29mX3N0clxuICB8IExhc3RfZW5kX29mX2xpbmVcbiAgfCBTdGFydFxuICB8IFN0b3BcbiAgfCBTZW0gb2YgQXV0b21hdGEuU2VtLnQgKiBBc3QudFxuICB8IFNlbV9ncmVlZHkgb2YgQXV0b21hdGEuUmVwX2tpbmQudCAqIEFzdC50XG4gIHwgR3JvdXAgb2Ygc3RyaW5nIG9wdGlvbiAqIEFzdC50XG4gIHwgTm9fZ3JvdXAgb2YgQXN0LnRcbiAgfCBOZXN0IG9mIEFzdC50XG4gIHwgQ2FzZSBvZiBBc3QudFxuICB8IE5vX2Nhc2Ugb2YgQXN0LnRcbiAgfCBJbnRlcnNlY3Rpb24gb2YgQXN0LnQgbGlzdFxuICB8IENvbXBsZW1lbnQgb2YgQXN0LnQgbGlzdFxuICB8IERpZmZlcmVuY2Ugb2YgQXN0LnQgKiBBc3QudFxuICB8IFBtYXJrIG9mIFBtYXJrLnQgKiBBc3QudFxuXG5sZXQgdmlld19hc3QgZiAodCA6IF8gQXN0LmFzdCkgOiB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgQWx0ZXJuYXRpdmUgYSAtPiBBbHRlcm5hdGl2ZSAoTGlzdC5tYXAgfmYgYSlcbiAgfCBOb19jYXNlIGEgLT4gTm9fY2FzZSAoZiBhKVxuICB8IENhc2UgYSAtPiBDYXNlIChmIGEpXG47O1xuXG5sZXQgdmlld19zZXQgKGNzZXQgOiBBc3QuY3NldCkgOiB0ID1cbiAgbWF0Y2ggY3NldCB3aXRoXG4gIHwgQ3NldCBzZXQgLT4gU2V0IHNldFxuICB8IEludGVyc2VjdGlvbiBzZXRzIC0+IEludGVyc2VjdGlvbiAoTGlzdC5tYXAgc2V0cyB+ZjpBc3QudF9vZl9jc2V0KVxuICB8IENvbXBsZW1lbnQgc2V0cyAtPiBDb21wbGVtZW50IChMaXN0Lm1hcCBzZXRzIH5mOkFzdC50X29mX2NzZXQpXG4gIHwgRGlmZmVyZW5jZSAoeCwgeSkgLT4gRGlmZmVyZW5jZSAoQXN0LnRfb2ZfY3NldCB4LCBBc3QudF9vZl9jc2V0IHkpXG4gIHwgQ2FzdCBhc3QgLT4gdmlld19hc3QgQXN0LnRfb2ZfY3NldCBhc3Rcbjs7XG5cbmxldCB2aWV3IDogQXN0LnQgLT4gdCA9IGZ1bmN0aW9uXG4gIHwgU2V0IHMgLT4gdmlld19zZXQgc1xuICB8IEFzdCBzIC0+IHZpZXdfYXN0IChmdW4geCAtPiB4KSBzXG4gIHwgU2VtIChzZW0sIGEpIC0+IFNlbSAoc2VtLCBhKVxuICB8IFNlbV9ncmVlZHkgKHNlbSwgYSkgLT4gU2VtX2dyZWVkeSAoc2VtLCBhKVxuICB8IFNlcXVlbmNlIHMgLT4gU2VxdWVuY2Ugc1xuICB8IFJlcGVhdCAodCwgeCwgeSkgLT4gUmVwZWF0ICh0LCB4LCB5KVxuICB8IEJlZ19vZl9saW5lIC0+IEJlZ19vZl9saW5lXG4gIHwgRW5kX29mX2xpbmUgLT4gRW5kX29mX2xpbmVcbiAgfCBCZWdfb2Zfd29yZCAtPiBCZWdfb2Zfd29yZFxuICB8IEVuZF9vZl93b3JkIC0+IEVuZF9vZl93b3JkXG4gIHwgTm90X2JvdW5kIC0+IE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHIgLT4gQmVnX29mX3N0clxuICB8IEVuZF9vZl9zdHIgLT4gRW5kX29mX3N0clxuICB8IExhc3RfZW5kX29mX2xpbmUgLT4gTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0YXJ0IC0+IFN0YXJ0XG4gIHwgU3RvcCAtPiBTdG9wXG4gIHwgTm9fZ3JvdXAgYSAtPiBOb19ncm91cCBhXG4gIHwgR3JvdXAgKG5hbWUsIHQpIC0+IEdyb3VwIChuYW1lLCB0KVxuICB8IE5lc3QgdCAtPiBOZXN0IHRcbiAgfCBQbWFyayAocG1hcmssIHQpIC0+IFBtYXJrIChwbWFyaywgdClcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjgxOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWFrZV92ZWN0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiZHVtbXlfb2Zmc2V0IiwiU3RkbGliX0Zvcm1hdCIsIlN0ZGxpYl9BcnJheSIsIlJlX0ZtdCIsIlN0ZGxpYl9TdHJpbmciLCJSZV9NYXJrX2luZm9zIiwiU3RkbGliIiwiY3N0X0dyb3VwIiwib2Zmc2V0IiwidCIsImkiLCJtYXRjaCIsInN0b3AiLCJzdGFydCIsImdldCIsInAyIiwicDEiLCJzdWJzIiwidGVzdCIsImdldF9vcHQiLCJhbGxfb2Zmc2V0IiwicmVzIiwiYWxsIiwicHAiLCJmbXQiLCJvZmZzZXRzIiwic3RycyIsIm1hdGNoZXMiLCJwcF9tYXRjaCIsInBhcmFtIiwic3RyIiwibmJfZ3JvdXBzIiwiUmVfR3JvdXAiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9ncm91cC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLFlBQUFDLE9BQUFDLEdBQUFDO0FBQUFBLFFBQUFDLFFDVVE7QUFBQSxJQUEyQixZQUN2QjtBQUFBO0FBQUEsS0FBQUEsVUFEdUI7QUFBQSxLQUFBQyxPQUFBO0FBQUEsS0FBQUMsUUFBQTtBQUFBLFdBRU87QUFBQSxJQUFoQix5REFBYztBQUFBLEdBQWU7QUFBQSxZQUFBQyxJQUFBTCxHQUFBQztBQUFBQSxRQUFBQyxRQUl4QyxjQUFBSSxLQUFVLFVBQUFDLEtBQUE7QUFBQSxJQUN2QiwyREFBMkI7QUFBQTtBQUFBLFlBQUFILE1BQUFJLE1BQUFQLEdBR04seUJBQWU7QUFBQSxZQUFBRSxLQUFBSyxNQUFBUCxHQUNoQix5QkFBZTtBQUFBLFlBQUFRLEtBQUFULEdBQUFDLEdBQ3RCLDRDQUF5QjtBQUFBLFlBQUFTLFFBQUFWLEdBQUFDLEdBQ25CLHdCQUFtQixjQUFtQjtBQUFBLFlBQUFVLFdBQUFYO0FBQUFBLFFBQUFZLE1BSS9DO0FBQUEsSUFDVjtBQUFBO0FBQUE7QUFBQSxlQUFBWCxHQUFBRyxPQUFBRDtBQUFBQTtBQUFBQSxRQUFBSSxLQUNXO0FBQUEsUUFBQUQsS0FDQTtBQUFBLE9BQ1Q7QUFBQSxPQUFpQjtBQUFBO0FBQUEsSUFBQztBQUFBLEdBQ2pCO0FBQUEsWUFBQU8sSUFBQWI7QUFBQUEsUUFBQVksTUFNTztBQUFBLElBQ1Y7QUFBQTtBQUFBO0FBQUEsZUFBQVgsR0FBQUcsT0FBQUQ7QUFBQUE7QUFBQUEsUUFBQUksS0FDVztBQUFBLFFBQUFELEtBQ0E7QUFBQSxjQUNFO0FBQUEsT0FBWDtBQUFBLE9BQXNDO0FBQUE7QUFBQSxJQUFDO0FBQUEsR0FDdEM7QUFBQSxZQUFBUSxHQUFBQyxLQUFBZjtBQUFBQTtBQUFBQSxLQUFBZ0IsVUFLYTtBQUFBLEtBQUFDLE9BQ0g7QUFBQTtBQUFBLE9BQ0c7QUFBQTtBQUFBO0FBQUEsa0JBQUFoQjtBQUFBQSxjQUFBLE1BQW9EO0FBQUEsVUFBVixpREFBUTtBQUFBLFNBQWE7QUFBQSxLQUFBaUIsVUFBN0U7QUFBQSxhQUFBQyxTQUFBSixLQUFBSztBQUFBQSxTQUFBbEIsUUFJVyxVQUFBQyxPQUFBLFVBQUFDLFFBQUEsVUFBQWlCLE1BQUE7QUFBQSxLQUEyQixpRUFBNkM7QUFBQTtBQUFBLGNBQ3BFO0FBQUEsSUFBZSwwREFBUTtBQUFBO0FBQUEsWUFBQUMsVUFBQXRCLEdBR3hCLFlBQVE7QUFBQTtBQUFBLElBQUF1QjtBQUFBQSxNRDFEMUIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIFJlc3VsdCBvZiBhIHN1Y2Nlc3NmdWwgbWF0Y2guICopXG50eXBlIHQgPVxuICB7IHMgOiBzdHJpbmdcbiAgOyBtYXJrcyA6IE1hcmtfaW5mb3MudFxuICA7IHBtYXJrcyA6IFBtYXJrLlNldC50XG4gIDsgZ3BvcyA6IGludCBhcnJheVxuICA7IGdjb3VudCA6IGludFxuICB9XG5cbmxldCBvZmZzZXQgdCBpID1cbiAgbWF0Y2ggTWFya19pbmZvcy5vZmZzZXQgdC5tYXJrcyBpIHdpdGhcbiAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IFNvbWUgKHN0YXJ0LCBzdG9wKSAtPiB0Lmdwb3MuKHN0YXJ0KSwgdC5ncG9zLihzdG9wKVxuOztcblxubGV0IGdldCB0IGkgPVxuICBsZXQgcDEsIHAyID0gb2Zmc2V0IHQgaSBpblxuICBTdHJpbmcuc3ViIHQucyBwMSAocDIgLSBwMSlcbjs7XG5cbmxldCBzdGFydCBzdWJzIGkgPSBmc3QgKG9mZnNldCBzdWJzIGkpXG5sZXQgc3RvcCBzdWJzIGkgPSBzbmQgKG9mZnNldCBzdWJzIGkpXG5sZXQgdGVzdCB0IGkgPSBNYXJrX2luZm9zLnRlc3QgdC5tYXJrcyBpXG5sZXQgZ2V0X29wdCB0IGkgPSBpZiB0ZXN0IHQgaSB0aGVuIFNvbWUgKGdldCB0IGkpIGVsc2UgTm9uZVxubGV0IGR1bW15X29mZnNldCA9IC0xLCAtMVxuXG5sZXQgYWxsX29mZnNldCB0ID1cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgdC5nY291bnQgZHVtbXlfb2Zmc2V0IGluXG4gIE1hcmtfaW5mb3MuaXRlcmkgdC5tYXJrcyB+ZjooZnVuIGkgc3RhcnQgc3RvcCAtPlxuICAgIGxldCBwMSA9IHQuZ3Bvcy4oc3RhcnQpIGluXG4gICAgbGV0IHAyID0gdC5ncG9zLihzdG9wKSBpblxuICAgIHJlcy4oaSkgPC0gcDEsIHAyKTtcbiAgcmVzXG47O1xuXG5sZXQgZHVtbXlfc3RyaW5nID0gXCJcIlxuXG5sZXQgYWxsIHQgPVxuICBsZXQgcmVzID0gQXJyYXkubWFrZSB0Lmdjb3VudCBkdW1teV9zdHJpbmcgaW5cbiAgTWFya19pbmZvcy5pdGVyaSB0Lm1hcmtzIH5mOihmdW4gaSBzdGFydCBzdG9wIC0+XG4gICAgbGV0IHAxID0gdC5ncG9zLihzdGFydCkgaW5cbiAgICBsZXQgcDIgPSB0Lmdwb3MuKHN0b3ApIGluXG4gICAgcmVzLihpKSA8LSBTdHJpbmcuc3ViIHQucyBwMSAocDIgLSBwMSkpO1xuICByZXNcbjs7XG5cbmxldCBwcCBmbXQgdCA9XG4gIGxldCBtYXRjaGVzID1cbiAgICBsZXQgb2Zmc2V0cyA9IGFsbF9vZmZzZXQgdCBpblxuICAgIGxldCBzdHJzID0gYWxsIHQgaW5cbiAgICBBcnJheS50b19saXN0IChBcnJheS5pbml0IChBcnJheS5sZW5ndGggc3RycykgKGZ1biBpIC0+IHN0cnMuKGkpLCBvZmZzZXRzLihpKSkpXG4gIGluXG4gIGxldCBvcGVuIEZvcm1hdCBpblxuICBsZXQgb3BlbiBGbXQgaW5cbiAgbGV0IHBwX21hdGNoIGZtdCAoc3RyLCAoc3RhcnQsIHN0b3ApKSA9IGZwcmludGYgZm10IFwiQFsoJXMgKCVkICVkKSlAXVwiIHN0ciBzdGFydCBzdG9wIGluXG4gIHNleHAgZm10IFwiR3JvdXBcIiAobGlzdCBwcF9tYXRjaCkgbWF0Y2hlc1xuOztcblxubGV0IG5iX2dyb3VwcyB0ID0gdC5nY291bnRcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyOTYyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9tYWtlX3ZlY3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImdsb2JhbF9kYXRhIiwiU3RkbGliX0ludCIsIlJlX0ltcG9ydCIsIlJlX0NzZXQiLCJSZV9Db2xvcl9tYXAiLCJTdGRsaWJfQ2hhciIsIlJlX0F1dG9tYXRhIiwiUmVfQ2F0ZWdvcnkiLCJSZV9Bc3QiLCJTdGRsaWJfTGlzdExhYmVscyIsIlN0ZGxpYiIsIlN0ZGxpYl9BcnJheSIsIml0ZXIiLCJuIiwidiIsImJyZWFrIiwiZHVtbXkiLCJnZXRfaW5mbyIsInBhcmFtIiwiZm9sbG93X3RyYW5zaXRpb24iLCJjb2xvciIsInNldF90cmFuc2l0aW9uIiwic3QiLCJpbmZvIiwidW5rbm93bl9zdGF0ZSIsInBwX3JlIiwiY2giLCJyZSIsImdyb3VwX2NvdW50IiwiZ3JvdXBfbmFtZXMiLCJjYXRlZ29yeSIsImZpbmRfc3RhdGUiLCJkZXNjIiwibmNvbCIsIm1hdGNoIiwiYnJlYWtfc3RhdGUiLCJyZWFsX2lkeCIsInN0YXRlIiwiZGVsdGEiLCJjYXQiLCJsZW4iLCJwb3MiLCJ2YWxpZGF0ZSIsInMiLCJuZXh0IiwiY29sb3JzIiwiZ2V0X2NvbG9yIiwic2xlbiIsInNjYW5fc3RyIiwiaW5pdGlhbF9zdGF0ZSIsImdyb3VwcyIsImxhc3QiLCJyZWFsX2MiLCJwb3NpdGlvbnMiLCJzdDAiLCJzdGF0ZV9pbmZvIiwiaWR4IiwiZmluYWxfYm91bmRhcnlfY2hlY2siLCJmaW5hbF9jYXQiLCJyZXMiLCJtYXRjaF9zdHIiLCJwYXJ0aWFsIiwiaW5pdGlhbF9jYXQiLCJzdGF0dXMiLCJwbWFya3MiLCJtYXJrcyIsIm5vX21hdGNoX3N0YXJ0c19iZWZvcmUiLCJlbmZvcmNlX2tpbmQiLCJpZHMiLCJraW5kIiwiY3IiLCJ0cmFuc2xhdGUiLCJjdHgiLCJhc3QiLCJjYWNoZSIsIm5hbWVzIiwiZ3JlZWR5IiwiaWduX2dyb3VwIiwiaSIsImwiLCJtZXJnZWRfc2VxdWVuY2VzIiwiciIsImoiLCJyZW0iLCJwIiwibmFtZSIsImIiLCJlIiwidHJhbnNfc2VxIiwiY29tcGlsZSIsInJlZ2V4cCIsImNvbG9yX21hcCIsIm5lZWRfbG5sIiwiY29sb3JfcmVwciIsIm5jb2xvciIsImxubCIsImluaXRpYWwiLCJSZV9Db21waWxlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvcmUvY29tcGlsZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFB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QUFBQTtBQUFBLFlBQzJDO0FBQUEsWUFBdkI7QUFBQSxZQUFMO0FBQUEsWUFBVDtBQUFBLE1BQUFBLFdBQU47QUFBQTtBQUFBLEtBQUFBLFNBcENLO0FBQUEsS0FBQUMsWUFDRztBQUFBLEtBQUFDLFdBQ0Q7QUFBQSxLQUFBMUQsUUFDVTtBQUFBLEtBQUEyRCxhQUEyQjtBQUFBLEtBQUFoRCxTQUFBO0FBQUEsS0FBQWlELFNBQ3ZDO0FBQUEsS0FBQUMsTUFDYjtBQUFBLEtBQUFELFdBQ0E7QUFBQSxXQUVVO0FBQUE7QUFBQSxLQUFBdEI7QUFBQUEsT0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUFBdEMsVUFVSTtBQUFBLEtBQUFtQyxPQUFvQjtBQUFBLEtBQUFZLElBQUE7QUFBQSxLQUFBZSxVQUMxQjtBQUFBLEtBQUFwRSxjQVNPO0FBQUEsS0FBQUMsY0FEQTtBQUFBLFdBN0tKO0FBQUEsSUFESDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHdCQUErQjtBQUFBLEdBdUxzQjtBQUFBO0FBQUEsSUFBQW9FO0FBQUFBLE1BbmZtQjtBQUFBO0FBQUE7QUFBQSxFRHpEbEYiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4gSW1wb3J0XG5cbmxldCByZWMgaXRlciBuIGYgdiA9IGlmIEludC5lcXVhbCBuIDAgdGhlbiB2IGVsc2UgaXRlciAobiAtIDEpIGYgKGYgdilcbmxldCB1bmtub3duID0gLTJcbmxldCBicmVhayA9IC0zXG5cbnR5cGUgbWF0Y2hfaW5mbyA9XG4gIHwgTWF0Y2ggb2YgR3JvdXAudFxuICB8IEZhaWxlZFxuICB8IFJ1bm5pbmcgb2YgeyBub19tYXRjaF9zdGFydHNfYmVmb3JlIDogaW50IH1cblxudHlwZSBzdGF0ZV9pbmZvID1cbiAgeyBpZHggOiBpbnRcbiAgOyAoKiBJbmRleCBvZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgcG9zaXRpb24gdGFibGUuXG4gICAgICAgTm90IHlldCBjb21wdXRlZCB0cmFuc2l0aW9ucyBwb2ludCB0byBhIGR1bW15IHN0YXRlIHdoZXJlXG4gICAgICAgW2lkeF0gaXMgc2V0IHRvIFt1bmtub3duXTtcbiAgICAgICBJZiBbaWR4XSBpcyBzZXQgdG8gW2JyZWFrXSBmb3Igc3RhdGVzIHRoYXQgZWl0aGVyIGFsd2F5c1xuICAgICAgIHN1Y2NlZWQgb3IgYWx3YXlzIGZhaWwuICopXG4gICAgcmVhbF9pZHggOiBpbnRcbiAgOyAoKiBUaGUgcmVhbCBpbmRleCwgaW4gY2FzZSBbaWR4XSBpcyBzZXQgdG8gW2JyZWFrXSAqKVxuICAgIG11dGFibGUgZmluYWwgOiAoQ2F0ZWdvcnkudCAqIChBdXRvbWF0YS5pZHggKiBBdXRvbWF0YS5zdGF0dXMpKSBsaXN0XG4gIDsgKCogTWFwcGluZyBmcm9tIHRoZSBjYXRlZ29yeSBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG9cbiAgICAgICAtIHRoZSBpbmRleCB3aGVyZSB0aGUgbmV4dCBwb3NpdGlvbiBzaG91bGQgYmUgc2F2ZWRcbiAgICAgICAtIHBvc3NpYmx5LCB0aGUgbGlzdCBvZiBtYXJrcyAoYW5kIHRoZSBjb3JyZXNwb25kaW5nIGluZGljZXMpXG4gICAgICAgICBjb3JyZXNwb25kaW5nIHRvIHRoZSBiZXN0IG1hdGNoICopXG4gICAgZGVzYyA6IEF1dG9tYXRhLlN0YXRlLnQgKCogRGVzY3JpcHRpb24gb2YgdGhpcyBzdGF0ZSBvZiB0aGUgYXV0b21hdGEgKilcbiAgfVxuXG4oKiBBIHN0YXRlIFt0XSBpcyBhIHBhaXIgY29tcG9zZWQgb2Ygc29tZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAgIHN0YXRlIFtzdGF0ZV9pbmZvXSBhbmQgYSB0cmFuc2l0aW9uIHRhYmxlIFt0IGFycmF5XSwgaW5kZXhlZCBieVxuICAgY29sb3IuIEZvciBwZXJmb3JtYW5jZSByZWFzb24sIHRvIGF2b2lkIGFuIGluZGlyZWN0aW9uLCB3ZSBtYW51YWxseVxuICAgdW5ib3ggdGhlIHRyYW5zaXRpb24gdGFibGU6IHdlIGFsbG9jYXRlIGEgc2luZ2xlIGFycmF5LCB3aXRoIHRoZVxuICAgc3RhdGUgaW5mb3JtYXRpb24gYXQgaW5kZXggMCwgZm9sbG93ZWQgYnkgdGhlIHRyYW5zaXRpb25zLiAqKVxubW9kdWxlIFN0YXRlIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBtYWtlIDogbmNvbDppbnQgLT4gc3RhdGVfaW5mbyAtPiB0XG4gIHZhbCBnZXRfaW5mbyA6IHQgLT4gc3RhdGVfaW5mb1xuICB2YWwgZm9sbG93X3RyYW5zaXRpb24gOiB0IC0+IGNvbG9yOkNzZXQuYyAtPiB0XG4gIHZhbCBzZXRfdHJhbnNpdGlvbiA6IHQgLT4gY29sb3I6Q3NldC5jIC0+IHQgLT4gdW5pdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IFRhYmxlIG9mIHQgYXJyYXkgW0BAdW5ib3hlZF1cblxuICBsZXQgZ2V0X2luZm8gKFRhYmxlIHN0KSA6IHN0YXRlX2luZm8gPSBPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgc3QgMClcbiAgW0BAaW5saW5lIGFsd2F5c11cbiAgOztcblxuICBsZXQgc2V0X2luZm8gKFRhYmxlIHN0KSAoaW5mbyA6IHN0YXRlX2luZm8pID0gc3QuKDApIDwtIE9iai5tYWdpYyBpbmZvXG5cbiAgbGV0IGZvbGxvd190cmFuc2l0aW9uIChUYWJsZSBzdCkgfmNvbG9yID0gQXJyYXkudW5zYWZlX2dldCBzdCAoMSArIENzZXQudG9faW50IGNvbG9yKVxuICBbQEBpbmxpbmUgYWx3YXlzXVxuICA7O1xuXG4gIGxldCBzZXRfdHJhbnNpdGlvbiAoVGFibGUgc3QpIH5jb2xvciBzdCcgPSBzdC4oMSArIENzZXQudG9faW50IGNvbG9yKSA8LSBzdCdcbiAgbGV0IGR1bW15IChpbmZvIDogc3RhdGVfaW5mbykgPSBUYWJsZSBbfCBPYmoubWFnaWMgaW5mbyB8XVxuXG4gIGxldCB1bmtub3duX3N0YXRlID1cbiAgICBkdW1teSB7IGlkeCA9IHVua25vd247IHJlYWxfaWR4ID0gMDsgZmluYWwgPSBbXTsgZGVzYyA9IEF1dG9tYXRhLlN0YXRlLmR1bW15IH1cbiAgOztcblxuICBsZXQgbWFrZSB+bmNvbCBzdGF0ZSA9XG4gICAgbGV0IHN0ID0gVGFibGUgKEFycmF5Lm1ha2UgKG5jb2wgKyAxKSB1bmtub3duX3N0YXRlKSBpblxuICAgIHNldF9pbmZvIHN0IHN0YXRlO1xuICAgIHN0XG4gIDs7XG5lbmRcblxuKCogQXV0b21hdGEgKGNvbXBpbGVkIHJlZ3VsYXIgZXhwcmVzc2lvbikgKilcbnR5cGUgcmUgPVxuICB7IGluaXRpYWwgOiBBdXRvbWF0YS5leHByXG4gIDsgKCogVGhlIHdob2xlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zdGF0ZXMgOiAoQ2F0ZWdvcnkudCAqIFN0YXRlLnQpIGxpc3RcbiAgOyAoKiBJbml0aWFsIHN0YXRlcywgaW5kZXhlZCBieSBpbml0aWFsIGNhdGVnb3J5ICopXG4gICAgY29sb3JzIDogQ29sb3JfbWFwLlRhYmxlLnRcbiAgOyAoKiBDb2xvciB0YWJsZSAqKVxuICAgIGNvbG9yX3JlcHIgOiBDb2xvcl9tYXAuUmVwci50XG4gIDsgKCogVGFibGUgZnJvbSBjb2xvcnMgdG8gb25lIGNoYXJhY3RlciBvZiB0aGlzIGNvbG9yICopXG4gICAgbmNvbG9yIDogaW50XG4gIDsgKCogTnVtYmVyIG9mIGNvbG9ycy4gKilcbiAgICBsbmwgOiBpbnRcbiAgOyAoKiBDb2xvciBvZiB0aGUgbGFzdCBuZXdsaW5lLiAtMSBpZiB1bm5lY2Vzc2FyeSAqKVxuICAgIHRibCA6IEF1dG9tYXRhLldvcmtpbmdfYXJlYS50XG4gIDsgKCogVGVtcG9yYXJ5IHRhYmxlIHVzZWQgdG8gY29tcHV0ZSB0aGUgZmlyc3QgYXZhaWxhYmxlIGluZGV4XG4gICAgICAgd2hlbiBjb21wdXRpbmcgYSBuZXcgc3RhdGUgKilcbiAgICBzdGF0ZXMgOiBTdGF0ZS50IEF1dG9tYXRhLlN0YXRlLlRhYmxlLnRcbiAgOyAoKiBTdGF0ZXMgb2YgdGhlIGRldGVybWluaXN0aWMgYXV0b21hdGEgKilcbiAgICBncm91cF9uYW1lcyA6IChzdHJpbmcgKiBpbnQpIGxpc3RcbiAgOyAoKiBOYW1lZCBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICAgIGdyb3VwX2NvdW50IDogaW50ICgqIE51bWJlciBvZiBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICB9XG5cbmxldCBwcF9yZSBjaCByZSA9IEF1dG9tYXRhLnBwIGNoIHJlLmluaXRpYWxcbmxldCBwcmludF9yZSA9IHBwX3JlXG5sZXQgZ3JvdXBfY291bnQgcmUgPSByZS5ncm91cF9jb3VudFxubGV0IGdyb3VwX25hbWVzIHJlID0gcmUuZ3JvdXBfbmFtZXNcblxuKCogSW5mb3JtYXRpb24gdXNlZCBkdXJpbmcgbWF0Y2hpbmcgKilcbnR5cGUgaW5mbyA9XG4gIHsgcmUgOiByZVxuICA7ICgqIFRoZSBhdXRvbWF0YSAqKVxuICAgIG11dGFibGUgcG9zaXRpb25zIDogaW50IGFycmF5XG4gIDsgKCogQXJyYXkgb2YgbWFyayBwb3NpdGlvbnNcbiAgICAgICBUaGUgbWFyayBhcmUgb2ZmIGJ5IG9uZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAqKVxuICAgIHBvcyA6IGludFxuICA7ICgqIFBvc2l0aW9uIHdoZXJlIHRoZSBtYXRjaCBpcyBzdGFydGVkICopXG4gICAgbGFzdCA6IGludCAoKiBQb3NpdGlvbiB3aGVyZSB0aGUgbWF0Y2ggc2hvdWxkIHN0b3AgKilcbiAgfVxuXG4oKioqKilcblxubGV0IGNhdGVnb3J5IHJlIH5jb2xvciA9XG4gIGlmIENzZXQudG9faW50IGNvbG9yID0gLTFcbiAgdGhlbiBDYXRlZ29yeS5pbmV4aXN0YW50ICgqIFNwZWNpYWwgY2F0ZWdvcnkgZm9yIHRoZSBsYXN0IG5ld2xpbmUgKilcbiAgZWxzZSBpZiBDc2V0LnRvX2ludCBjb2xvciA9IHJlLmxubFxuICB0aGVuIENhdGVnb3J5LihsYXN0bmV3bGluZSArKyBuZXdsaW5lICsrIG5vdF9sZXR0ZXIpXG4gIGVsc2UgQ2F0ZWdvcnkuZnJvbV9jaGFyIChDb2xvcl9tYXAuUmVwci5yZXByIHJlLmNvbG9yX3JlcHIgY29sb3IpXG47O1xuXG4oKioqKilcblxubGV0IG1rX3N0YXRlIG5jb2wgZGVzYyA9XG4gIGxldCBicmVha19zdGF0ZSA9XG4gICAgbWF0Y2ggQXV0b21hdGEuU3RhdGUuc3RhdHVzIGRlc2Mgd2l0aFxuICAgIHwgQXV0b21hdGEuUnVubmluZyAtPiBmYWxzZVxuICAgIHwgQXV0b21hdGEuRmFpbGVkIHwgQXV0b21hdGEuTWF0Y2ggXyAtPiB0cnVlXG4gIGluXG4gIGxldCBzdCA9XG4gICAgbGV0IHJlYWxfaWR4ID0gQXV0b21hdGEuU3RhdGUuaWR4IGRlc2MgaW5cbiAgICB7IGlkeCA9IChpZiBicmVha19zdGF0ZSB0aGVuIGJyZWFrIGVsc2UgcmVhbF9pZHgpOyByZWFsX2lkeDsgZmluYWwgPSBbXTsgZGVzYyB9XG4gIGluXG4gIFN0YXRlLm1ha2Ugfm5jb2w6KGlmIGJyZWFrX3N0YXRlIHRoZW4gMCBlbHNlIG5jb2wpIHN0XG47O1xuXG5sZXQgZmluZF9zdGF0ZSByZSBkZXNjID1cbiAgdHJ5IEF1dG9tYXRhLlN0YXRlLlRhYmxlLmZpbmQgcmUuc3RhdGVzIGRlc2Mgd2l0aFxuICB8IE5vdF9mb3VuZCAtPlxuICAgIGxldCBzdCA9IG1rX3N0YXRlIHJlLm5jb2xvciBkZXNjIGluXG4gICAgQXV0b21hdGEuU3RhdGUuVGFibGUuYWRkIHJlLnN0YXRlcyBkZXNjIHN0O1xuICAgIHN0XG47O1xuXG4oKioqKiBNYXRjaCB3aXRoIG1hcmtzICoqKiopXG5cbmxldCBkZWx0YSBpbmZvIGNhdCB+Y29sb3Igc3QgPVxuICBsZXQgZGVzYyA9IEF1dG9tYXRhLmRlbHRhIGluZm8ucmUudGJsIGNhdCBjb2xvciBzdC5kZXNjIGluXG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaW5mby5wb3NpdGlvbnMgaW5cbiAgaWYgQXV0b21hdGEuU3RhdGUuaWR4IGRlc2MgPSBsZW4gJiYgbGVuID4gMFxuICB0aGVuIChcbiAgICBsZXQgcG9zID0gaW5mby5wb3NpdGlvbnMgaW5cbiAgICBpbmZvLnBvc2l0aW9ucyA8LSBBcnJheS5tYWtlICgyICogbGVuKSAwO1xuICAgIEFycmF5LmJsaXQgcG9zIDAgaW5mby5wb3NpdGlvbnMgMCBsZW4pO1xuICBkZXNjXG47O1xuXG5sZXQgdmFsaWRhdGUgaW5mbyAocyA6IHN0cmluZykgfnBvcyBzdCA9XG4gIGxldCBjb2xvciA9IENvbG9yX21hcC5UYWJsZS5nZXQgaW5mby5yZS5jb2xvcnMgcy5bcG9zXSBpblxuICBsZXQgc3QnID1cbiAgICBsZXQgZGVzYycgPVxuICAgICAgbGV0IGNhdCA9IGNhdGVnb3J5IGluZm8ucmUgfmNvbG9yIGluXG4gICAgICBkZWx0YSBpbmZvIGNhdCB+Y29sb3IgKFN0YXRlLmdldF9pbmZvIHN0KVxuICAgIGluXG4gICAgZmluZF9zdGF0ZSBpbmZvLnJlIGRlc2MnXG4gIGluXG4gIFN0YXRlLnNldF90cmFuc2l0aW9uIHN0IH5jb2xvciBzdCdcbjs7XG5cbmxldCBuZXh0IGNvbG9ycyBzdCBzIHBvcyA9XG4gIFN0YXRlLmZvbGxvd190cmFuc2l0aW9uIHN0IH5jb2xvcjooQ29sb3JfbWFwLlRhYmxlLmdldCBjb2xvcnMgKFN0cmluZy51bnNhZmVfZ2V0IHMgcG9zKSlcbjs7XG5cbmxldCByZWMgbG9vcCBpbmZvIH5jb2xvcnMgfnBvc2l0aW9ucyBzIH5wb3Mgfmxhc3Qgc3QwIHN0ID1cbiAgaWYgcG9zIDwgbGFzdFxuICB0aGVuIChcbiAgICBsZXQgc3QnID0gbmV4dCBjb2xvcnMgc3QgcyBwb3MgaW5cbiAgICBsZXQgc3RhdGVfaW5mbyA9IFN0YXRlLmdldF9pbmZvIHN0JyBpblxuICAgIGxldCBpZHggPSBzdGF0ZV9pbmZvLmlkeCBpblxuICAgIGlmIGlkeCA+PSAwXG4gICAgdGhlbiAoXG4gICAgICBBcnJheS51bnNhZmVfc2V0IHBvc2l0aW9ucyBpZHggcG9zO1xuICAgICAgbG9vcCBpbmZvIH5jb2xvcnMgfnBvc2l0aW9ucyBzIH5wb3M6KHBvcyArIDEpIH5sYXN0IHN0JyBzdCcpXG4gICAgZWxzZSBpZiBpZHggPSBicmVha1xuICAgIHRoZW4gKFxuICAgICAgQXJyYXkudW5zYWZlX3NldCBwb3NpdGlvbnMgc3RhdGVfaW5mby5yZWFsX2lkeCBwb3M7XG4gICAgICBzdCcpXG4gICAgZWxzZSAoXG4gICAgICAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSBpbmZvIHMgfnBvcyBzdDA7XG4gICAgICBsb29wIGluZm8gfmNvbG9ycyB+cG9zaXRpb25zOmluZm8ucG9zaXRpb25zIHMgfnBvcyB+bGFzdCBzdDAgc3QwKSlcbiAgZWxzZSBzdFxuOztcblxubGV0IHJlYyBsb29wX25vX21hcmsgaW5mbyB+Y29sb3JzIHMgfnBvcyB+bGFzdCBzdDAgc3QgPVxuICBpZiBwb3MgPCBsYXN0XG4gIHRoZW4gKFxuICAgIGxldCBzdCcgPSBuZXh0IGNvbG9ycyBzdCBzIHBvcyBpblxuICAgIGxldCBzdGF0ZV9pbmZvID0gU3RhdGUuZ2V0X2luZm8gc3QnIGluXG4gICAgbGV0IGlkeCA9IHN0YXRlX2luZm8uaWR4IGluXG4gICAgaWYgaWR4ID49IDBcbiAgICB0aGVuIGxvb3Bfbm9fbWFyayBpbmZvIH5jb2xvcnMgcyB+cG9zOihwb3MgKyAxKSB+bGFzdCBzdCcgc3QnXG4gICAgZWxzZSBpZiBpZHggPSBicmVha1xuICAgIHRoZW4gc3QnXG4gICAgZWxzZSAoXG4gICAgICAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSBpbmZvIHMgfnBvcyBzdDA7XG4gICAgICBsb29wX25vX21hcmsgaW5mbyB+Y29sb3JzIHMgfnBvcyB+bGFzdCBzdDAgc3QwKSlcbiAgZWxzZSBzdFxuOztcblxubGV0IGZpbmFsIGluZm8gc3QgY2F0ID1cbiAgdHJ5IExpc3QuYXNzcSBjYXQgc3QuZmluYWwgd2l0aFxuICB8IE5vdF9mb3VuZCAtPlxuICAgIGxldCBzdCcgPSBkZWx0YSBpbmZvIGNhdCB+Y29sb3I6KENzZXQub2ZfaW50ICgtMSkpIHN0IGluXG4gICAgbGV0IHJlcyA9IEF1dG9tYXRhLlN0YXRlLmlkeCBzdCcsIEF1dG9tYXRhLlN0YXRlLnN0YXR1cyBzdCcgaW5cbiAgICBzdC5maW5hbCA8LSAoY2F0LCByZXMpIDo6IHN0LmZpbmFsO1xuICAgIHJlc1xuOztcblxubGV0IGZpbmRfaW5pdGlhbF9zdGF0ZSByZSBjYXQgPVxuICB0cnkgTGlzdC5hc3NxIGNhdCByZS5pbml0aWFsX3N0YXRlcyB3aXRoXG4gIHwgTm90X2ZvdW5kIC0+XG4gICAgbGV0IHN0ID0gZmluZF9zdGF0ZSByZSAoQXV0b21hdGEuU3RhdGUuY3JlYXRlIGNhdCByZS5pbml0aWFsKSBpblxuICAgIHJlLmluaXRpYWxfc3RhdGVzIDwtIChjYXQsIHN0KSA6OiByZS5pbml0aWFsX3N0YXRlcztcbiAgICBzdFxuOztcblxubGV0IGdldF9jb2xvciByZSAocyA6IHN0cmluZykgcG9zID1cbiAgaWYgcG9zIDwgMFxuICB0aGVuIENzZXQub2ZfaW50IEBAIC0xXG4gIGVsc2UgKFxuICAgIGxldCBzbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgaWYgcG9zID49IHNsZW5cbiAgICB0aGVuIENzZXQub2ZfaW50ICgtMSlcbiAgICBlbHNlIGlmIHBvcyA9IHNsZW4gLSAxICYmIHJlLmxubCA8PiAtMSAmJiBDaGFyLmVxdWFsIHMuW3Bvc10gJ1xcbidcbiAgICB0aGVuICgqIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGxhc3QgbmV3bGluZSAqKVxuICAgICAgQ3NldC5vZl9pbnQgcmUubG5sXG4gICAgZWxzZSBDb2xvcl9tYXAuVGFibGUuZ2V0IHJlLmNvbG9ycyBzLltwb3NdKVxuOztcblxubGV0IHJlYyBoYW5kbGVfbGFzdF9uZXdsaW5lIGluZm8gfnBvcyBzdCB+Z3JvdXBzID1cbiAgbGV0IHN0JyA9IFN0YXRlLmZvbGxvd190cmFuc2l0aW9uIHN0IH5jb2xvcjooQ3NldC5vZl9pbnQgaW5mby5yZS5sbmwpIGluXG4gIGxldCBpbmZvJyA9IFN0YXRlLmdldF9pbmZvIHN0JyBpblxuICBpZiBpbmZvJy5pZHggPj0gMFxuICB0aGVuIChcbiAgICBpZiBncm91cHMgdGhlbiBpbmZvLnBvc2l0aW9ucy4oaW5mbycuaWR4KSA8LSBwb3M7XG4gICAgc3QnKVxuICBlbHNlIGlmIGluZm8nLmlkeCA9IGJyZWFrXG4gIHRoZW4gKFxuICAgIGlmIGdyb3VwcyB0aGVuIGluZm8ucG9zaXRpb25zLihpbmZvJy5yZWFsX2lkeCkgPC0gcG9zO1xuICAgIHN0JylcbiAgZWxzZSAoXG4gICAgKCogVW5rbm93biAqKVxuICAgIGxldCBjb2xvciA9IENzZXQub2ZfaW50IGluZm8ucmUubG5sIGluXG4gICAgbGV0IHN0JyA9XG4gICAgICBsZXQgZGVzYycgPVxuICAgICAgICBsZXQgY2F0ID0gY2F0ZWdvcnkgaW5mby5yZSB+Y29sb3IgaW5cbiAgICAgICAgbGV0IHJlYWxfYyA9IENvbG9yX21hcC5UYWJsZS5nZXQgaW5mby5yZS5jb2xvcnMgJ1xcbicgaW5cbiAgICAgICAgZGVsdGEgaW5mbyBjYXQgfmNvbG9yOnJlYWxfYyAoU3RhdGUuZ2V0X2luZm8gc3QpXG4gICAgICBpblxuICAgICAgZmluZF9zdGF0ZSBpbmZvLnJlIGRlc2MnXG4gICAgaW5cbiAgICBTdGF0ZS5zZXRfdHJhbnNpdGlvbiBzdCB+Y29sb3Igc3QnO1xuICAgIGhhbmRsZV9sYXN0X25ld2xpbmUgaW5mbyB+cG9zIHN0IH5ncm91cHMpXG47O1xuXG5sZXQgcmVjIHNjYW5fc3RyIGluZm8gKHMgOiBzdHJpbmcpIGluaXRpYWxfc3RhdGUgfmdyb3VwcyA9XG4gIGxldCBwb3MgPSBpbmZvLnBvcyBpblxuICBsZXQgbGFzdCA9IGluZm8ubGFzdCBpblxuICBpZiBsYXN0ID0gU3RyaW5nLmxlbmd0aCBzXG4gICAgICYmIGluZm8ucmUubG5sIDw+IC0xXG4gICAgICYmIGxhc3QgPiBwb3NcbiAgICAgJiYgQ2hhci5lcXVhbCAoU3RyaW5nLmdldCBzIChsYXN0IC0gMSkpICdcXG4nXG4gIHRoZW4gKFxuICAgIGxldCBpbmZvID0geyBpbmZvIHdpdGggbGFzdCA9IGxhc3QgLSAxIH0gaW5cbiAgICBsZXQgc3QgPSBzY2FuX3N0ciBpbmZvIHMgaW5pdGlhbF9zdGF0ZSB+Z3JvdXBzIGluXG4gICAgaWYgKFN0YXRlLmdldF9pbmZvIHN0KS5pZHggPSBicmVha1xuICAgIHRoZW4gc3RcbiAgICBlbHNlIGhhbmRsZV9sYXN0X25ld2xpbmUgaW5mbyB+cG9zOihsYXN0IC0gMSkgc3Qgfmdyb3VwcylcbiAgZWxzZSBpZiBncm91cHNcbiAgdGhlblxuICAgIGxvb3BcbiAgICAgIGluZm9cbiAgICAgIH5jb2xvcnM6aW5mby5yZS5jb2xvcnNcbiAgICAgIH5wb3NpdGlvbnM6aW5mby5wb3NpdGlvbnNcbiAgICAgIHNcbiAgICAgIH5wb3NcbiAgICAgIH5sYXN0XG4gICAgICBpbml0aWFsX3N0YXRlXG4gICAgICBpbml0aWFsX3N0YXRlXG4gIGVsc2UgbG9vcF9ub19tYXJrIGluZm8gfmNvbG9yczppbmZvLnJlLmNvbG9ycyBzIH5wb3Mgfmxhc3QgaW5pdGlhbF9zdGF0ZSBpbml0aWFsX3N0YXRlXG47O1xuXG4oKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBmaW5hbCBib3VuZGFyeSBjaGVjayBvbiB0aGUgaW5wdXQuXG4gICBUaGlzIGlzIHVzZWZ1bCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBvdXRwdXQgZmFpbGVkIGJlY2F1c2VcbiAgIG9mIGluc3VmZmljaWVudCBpbnB1dCwgb3IgdG8gdmVyaWZ5IHRoYXQgdGhlIG91dHB1dCBhY3R1YWxseVxuICAgbWF0Y2hlcyBmb3IgcmVnZXggdGhhdCBoYXZlIGJvdW5kYXJ5IGNvbmRpdGlvbnMgd2l0aCByZXNwZWN0XG4gICB0byB0aGUgaW5wdXQgc3RyaW5nLlxuKilcbmxldCBmaW5hbF9ib3VuZGFyeV9jaGVjayB+bGFzdCB+c2xlbiByZSBzIH5pbmZvIH5zdCB+Z3JvdXBzID1cbiAgbGV0IGlkeCwgcmVzID1cbiAgICBsZXQgZmluYWxfY2F0ID1cbiAgICAgIENhdGVnb3J5LihcbiAgICAgICAgc2VhcmNoX2JvdW5kYXJ5XG4gICAgICAgICsrIGlmIGxhc3QgPSBzbGVuIHRoZW4gaW5leGlzdGFudCBlbHNlIGNhdGVnb3J5IHJlIH5jb2xvcjooZ2V0X2NvbG9yIHJlIHMgbGFzdCkpXG4gICAgaW5cbiAgICBmaW5hbCBpbmZvIChTdGF0ZS5nZXRfaW5mbyBzdCkgZmluYWxfY2F0XG4gIGluXG4gIChtYXRjaCBncm91cHMsIHJlcyB3aXRoXG4gICB8IHRydWUsIE1hdGNoIF8gLT4gaW5mby5wb3NpdGlvbnMuKGlkeCkgPC0gbGFzdFxuICAgfCBfIC0+ICgpKTtcbiAgcmVzXG47O1xuXG5sZXQgbWF0Y2hfc3RyIH5ncm91cHMgfnBhcnRpYWwgcmUgcyB+cG9zIH5sZW4gPVxuICBsZXQgc2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbGFzdCA9IGlmIGxlbiA9IC0xIHRoZW4gc2xlbiBlbHNlIHBvcyArIGxlbiBpblxuICBsZXQgaW5mbyA9XG4gICAgeyByZVxuICAgIDsgcG9zXG4gICAgOyBsYXN0XG4gICAgOyBwb3NpdGlvbnMgPVxuICAgICAgICAoaWYgZ3JvdXBzXG4gICAgICAgICB0aGVuIChcbiAgICAgICAgICAgbGV0IG4gPSBBdXRvbWF0YS5Xb3JraW5nX2FyZWEuaW5kZXhfY291bnQgcmUudGJsICsgMSBpblxuICAgICAgICAgICBpZiBuIDw9IDEwIHRoZW4gW3wgMDsgMDsgMDsgMDsgMDsgMDsgMDsgMDsgMDsgMCB8XSBlbHNlIEFycmF5Lm1ha2UgbiAwKVxuICAgICAgICAgZWxzZSBbfHxdKVxuICAgIH1cbiAgaW5cbiAgbGV0IHN0ID1cbiAgICBsZXQgaW5pdGlhbF9zdGF0ZSA9XG4gICAgICBsZXQgaW5pdGlhbF9jYXQgPVxuICAgICAgICBDYXRlZ29yeS4oXG4gICAgICAgICAgc2VhcmNoX2JvdW5kYXJ5XG4gICAgICAgICAgKysgaWYgcG9zID0gMCB0aGVuIGluZXhpc3RhbnQgZWxzZSBjYXRlZ29yeSByZSB+Y29sb3I6KGdldF9jb2xvciByZSBzIChwb3MgLSAxKSkpXG4gICAgICBpblxuICAgICAgZmluZF9pbml0aWFsX3N0YXRlIHJlIGluaXRpYWxfY2F0XG4gICAgaW5cbiAgICBzY2FuX3N0ciBpbmZvIHMgaW5pdGlhbF9zdGF0ZSB+Z3JvdXBzXG4gIGluXG4gIG1hdGNoXG4gICAgbGV0IHN0YXRlX2luZm8gPSBTdGF0ZS5nZXRfaW5mbyBzdCBpblxuICAgIGlmIHN0YXRlX2luZm8uaWR4ID0gYnJlYWsgfHwgKHBhcnRpYWwgJiYgbm90IGdyb3VwcylcbiAgICB0aGVuIEF1dG9tYXRhLlN0YXRlLnN0YXR1cyBzdGF0ZV9pbmZvLmRlc2NcbiAgICBlbHNlIGlmIHBhcnRpYWwgJiYgZ3JvdXBzXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBBdXRvbWF0YS5TdGF0ZS5zdGF0dXMgc3RhdGVfaW5mby5kZXNjIHdpdGhcbiAgICAgIHwgKE1hdGNoIF8gfCBGYWlsZWQpIGFzIHN0YXR1cyAtPiBzdGF0dXNcbiAgICAgIHwgUnVubmluZyAtPlxuICAgICAgICAoKiBUaGlzIGNvdWxkIGJlIGJlY2F1c2UgaXQncyBzdGlsbCBub3QgZnVsbHkgbWF0Y2hlZCwgb3IgaXRcbiAgICAgICAgICAgY291bGQgYmUgdGhhdCBiZWNhdXNlIHdlIG5lZWQgdG8gcnVuIHNwZWNpYWwgZW5kIG9mIGlucHV0XG4gICAgICAgICAgIGNoZWNrcy4gKilcbiAgICAgICAgKG1hdGNoIGZpbmFsX2JvdW5kYXJ5X2NoZWNrIH5sYXN0IH5zbGVuIHJlIHMgfmluZm8gfnN0IH5ncm91cHMgd2l0aFxuICAgICAgICAgfCBNYXRjaCBfIGFzIHN0YXR1cyAtPiBzdGF0dXNcbiAgICAgICAgIHwgRmFpbGVkIHwgUnVubmluZyAtPlxuICAgICAgICAgICAoKiBBIGZhaWx1cmUgaGVyZSBqdXN0IG1lYW5zIHRoYXQgd2UgbmVlZCBtb3JlIGRhdGEsIGkuZS5cbiAgICAgICAgICAgICAgaXQncyBhIHBhcnRpYWwgbWF0Y2guICopXG4gICAgICAgICAgIFJ1bm5pbmcpKVxuICAgIGVsc2UgZmluYWxfYm91bmRhcnlfY2hlY2sgfmxhc3QgfnNsZW4gcmUgcyB+aW5mbyB+c3Qgfmdyb3Vwc1xuICB3aXRoXG4gIHwgTWF0Y2ggKG1hcmtzLCBwbWFya3MpIC0+XG4gICAgTWF0Y2ggeyBzOyBtYXJrczsgcG1hcmtzOyBncG9zID0gaW5mby5wb3NpdGlvbnM7IGdjb3VudCA9IHJlLmdyb3VwX2NvdW50IH1cbiAgfCBGYWlsZWQgLT4gRmFpbGVkXG4gIHwgUnVubmluZyAtPlxuICAgIGxldCBub19tYXRjaF9zdGFydHNfYmVmb3JlID0gaWYgZ3JvdXBzIHRoZW4gaW5mby5wb3NpdGlvbnMuKDApIGVsc2UgMCBpblxuICAgIFJ1bm5pbmcgeyBub19tYXRjaF9zdGFydHNfYmVmb3JlIH1cbjs7XG5cbmxldCBta19yZSB+aW5pdGlhbCB+Y29sb3JzIH5jb2xvcl9yZXByIH5uY29sb3IgfmxubCB+Z3JvdXBfbmFtZXMgfmdyb3VwX2NvdW50ID1cbiAgeyBpbml0aWFsXG4gIDsgaW5pdGlhbF9zdGF0ZXMgPSBbXVxuICA7IGNvbG9yc1xuICA7IGNvbG9yX3JlcHJcbiAgOyBuY29sb3JcbiAgOyBsbmxcbiAgOyB0YmwgPSBBdXRvbWF0YS5Xb3JraW5nX2FyZWEuY3JlYXRlICgpXG4gIDsgc3RhdGVzID0gQXV0b21hdGEuU3RhdGUuVGFibGUuY3JlYXRlIDk3XG4gIDsgZ3JvdXBfbmFtZXNcbiAgOyBncm91cF9jb3VudFxuICB9XG47O1xuXG4oKioqKiBDb21waWxhdGlvbiAqKioqKVxuXG5tb2R1bGUgQSA9IEF1dG9tYXRhXG5cbmxldCBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3IgPVxuICBtYXRjaCBraW5kLCBraW5kJyB3aXRoXG4gIHwgYEZpcnN0LCBgRmlyc3QgLT4gY3JcbiAgfCBgRmlyc3QsIGsgLT4gQS5zZXEgaWRzIGsgY3IgKEEuZXBzIGlkcylcbiAgfCBfIC0+IGNyXG47O1xuXG50eXBlIGNvbnRleHQgPVxuICB7IGlkcyA6IEEuSWRzLnRcbiAgOyBraW5kIDogQS5TZW0udFxuICA7IGlnbl9ncm91cCA6IGJvb2xcbiAgOyBncmVlZHkgOiBBLlJlcF9raW5kLnRcbiAgOyBwb3MgOiBBLk1hcmsudCByZWZcbiAgOyBuYW1lcyA6IChzdHJpbmcgKiBpbnQpIGxpc3QgcmVmXG4gIDsgY2FjaGUgOiBDc2V0LnQgQ3NldC5DU2V0TWFwLnQgcmVmXG4gIDsgY29sb3JzIDogQ29sb3JfbWFwLlRhYmxlLnRcbiAgfVxuXG5sZXQgdHJhbnNfc2V0IGNhY2hlIChjbSA6IENvbG9yX21hcC5UYWJsZS50KSBzID1cbiAgbWF0Y2ggQ3NldC5vbmVfY2hhciBzIHdpdGhcbiAgfCBTb21lIGkgLT4gQ3NldC5jc2luZ2xlIChDb2xvcl9tYXAuVGFibGUuZ2V0X2NoYXIgY20gaSlcbiAgfCBOb25lIC0+XG4gICAgbGV0IHYgPSBDc2V0Lmhhc2hfcmVjIHMsIHMgaW5cbiAgICAodHJ5IENzZXQuQ1NldE1hcC5maW5kIHYgIWNhY2hlIHdpdGhcbiAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBsZXQgbCA9IENvbG9yX21hcC5UYWJsZS50cmFuc2xhdGVfY29sb3JzIGNtIHMgaW5cbiAgICAgICBjYWNoZSA6PSBDc2V0LkNTZXRNYXAuYWRkIHYgbCAhY2FjaGU7XG4gICAgICAgbClcbjs7XG5cbmxldCBtYWtlX3JlcGVhdGVyIGlkcyBjciBraW5kIGdyZWVkeSA9XG4gIG1hdGNoIGdyZWVkeSB3aXRoXG4gIHwgYEdyZWVkeSAtPiBmdW4gcmVtIC0+IEEuYWx0IGlkcyBbIEEuc2VxIGlkcyBraW5kIChBLnJlbmFtZSBpZHMgY3IpIHJlbTsgQS5lcHMgaWRzIF1cbiAgfCBgTm9uX2dyZWVkeSAtPlxuICAgIGZ1biByZW0gLT4gQS5hbHQgaWRzIFsgQS5lcHMgaWRzOyBBLnNlcSBpZHMga2luZCAoQS5yZW5hbWUgaWRzIGNyKSByZW0gXVxuOztcblxuKCogWFhYIHNob3VsZCBwcm9iYWJseSBjb21wdXRlIGEgY2F0ZWdvcnkgbWFzayAqKVxubGV0IHJlYyB0cmFuc2xhdGVcbiAgKHsgaWRzOyBraW5kOyBpZ25fZ3JvdXA7IGdyZWVkeTsgcG9zOyBuYW1lczsgY2FjaGU7IGNvbG9ycyB9IGFzIGN0eClcbiAgKGFzdCA6IEFzdC5ub19jYXNlKVxuICA9XG4gIG1hdGNoIGFzdCB3aXRoXG4gIHwgU2V0IHMgLT4gQS5jc3QgaWRzICh0cmFuc19zZXQgY2FjaGUgY29sb3JzIHMpLCBraW5kXG4gIHwgU2VxdWVuY2UgbCAtPiB0cmFuc19zZXEgY3R4IGwsIGtpbmRcbiAgfCBBc3QgKEFsdGVybmF0aXZlIGwpIC0+XG4gICAgKG1hdGNoIEFzdC5tZXJnZV9zZXF1ZW5jZXMgbCB3aXRoXG4gICAgIHwgWyByJyBdIC0+XG4gICAgICAgbGV0IGNyLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggcicgaW5cbiAgICAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3IsIGtpbmRcbiAgICAgfCBtZXJnZWRfc2VxdWVuY2VzIC0+XG4gICAgICAgKCBBLmFsdFxuICAgICAgICAgICBpZHNcbiAgICAgICAgICAgKExpc3QubWFwIG1lcmdlZF9zZXF1ZW5jZXMgfmY6KGZ1biByJyAtPlxuICAgICAgICAgICAgICBsZXQgY3IsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByJyBpblxuICAgICAgICAgICAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3IpKVxuICAgICAgICwga2luZCApKVxuICB8IFJlcGVhdCAocicsIGksIGopIC0+XG4gICAgbGV0IGNyLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggcicgaW5cbiAgICBsZXQgcmVtID1cbiAgICAgIG1hdGNoIGogd2l0aFxuICAgICAgfCBOb25lIC0+IEEucmVwIGlkcyBncmVlZHkga2luZCcgY3JcbiAgICAgIHwgU29tZSBqIC0+XG4gICAgICAgIGxldCBmID0gbWFrZV9yZXBlYXRlciBpZHMgY3Iga2luZCcgZ3JlZWR5IGluXG4gICAgICAgIGl0ZXIgKGogLSBpKSBmIChBLmVwcyBpZHMpXG4gICAgaW5cbiAgICBpdGVyIGkgKGZ1biByZW0gLT4gQS5zZXEgaWRzIGtpbmQnIChBLnJlbmFtZSBpZHMgY3IpIHJlbSkgcmVtLCBraW5kXG4gIHwgQmVnX29mX2xpbmUgLT4gQS5hZnRlciBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbmV3bGluZSksIGtpbmRcbiAgfCBFbmRfb2ZfbGluZSAtPiBBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbmV3bGluZSksIGtpbmRcbiAgfCBCZWdfb2Zfd29yZCAtPlxuICAgICggQS5zZXFcbiAgICAgICAgaWRzXG4gICAgICAgIGBGaXJzdFxuICAgICAgICAoQS5hZnRlciBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbm90X2xldHRlcikpXG4gICAgICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkubGV0dGVyKVxuICAgICwga2luZCApXG4gIHwgRW5kX29mX3dvcmQgLT5cbiAgICAoIEEuc2VxXG4gICAgICAgIGlkc1xuICAgICAgICBgRmlyc3RcbiAgICAgICAgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LmxldHRlcilcbiAgICAgICAgKEEuYmVmb3JlIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBub3RfbGV0dGVyKSlcbiAgICAsIGtpbmQgKVxuICB8IE5vdF9ib3VuZCAtPlxuICAgICggQS5hbHRcbiAgICAgICAgaWRzXG4gICAgICAgIFsgQS5zZXEgaWRzIGBGaXJzdCAoQS5hZnRlciBpZHMgQ2F0ZWdvcnkubGV0dGVyKSAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LmxldHRlcilcbiAgICAgICAgOyAobGV0IGNhdCA9IENhdGVnb3J5LihpbmV4aXN0YW50ICsrIG5vdF9sZXR0ZXIpIGluXG4gICAgICAgICAgIEEuc2VxIGlkcyBgRmlyc3QgKEEuYWZ0ZXIgaWRzIGNhdCkgKEEuYmVmb3JlIGlkcyBjYXQpKVxuICAgICAgICBdXG4gICAgLCBraW5kIClcbiAgfCBCZWdfb2Zfc3RyIC0+IEEuYWZ0ZXIgaWRzIENhdGVnb3J5LmluZXhpc3RhbnQsIGtpbmRcbiAgfCBFbmRfb2Zfc3RyIC0+IEEuYmVmb3JlIGlkcyBDYXRlZ29yeS5pbmV4aXN0YW50LCBraW5kXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbGFzdG5ld2xpbmUpLCBraW5kXG4gIHwgU3RhcnQgLT4gQS5hZnRlciBpZHMgQ2F0ZWdvcnkuc2VhcmNoX2JvdW5kYXJ5LCBraW5kXG4gIHwgU3RvcCAtPiBBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuc2VhcmNoX2JvdW5kYXJ5LCBraW5kXG4gIHwgU2VtIChraW5kJywgcicpIC0+XG4gICAgbGV0IGNyLCBraW5kJycgPSB0cmFuc2xhdGUgeyBjdHggd2l0aCBraW5kID0ga2luZCcgfSByJyBpblxuICAgIGVuZm9yY2Vfa2luZCBpZHMga2luZCcga2luZCcnIGNyLCBraW5kJ1xuICB8IFNlbV9ncmVlZHkgKGdyZWVkeScsIHInKSAtPiB0cmFuc2xhdGUgeyBjdHggd2l0aCBncmVlZHkgPSBncmVlZHknIH0gcidcbiAgfCBHcm91cCAobiwgcicpIC0+XG4gICAgaWYgaWduX2dyb3VwXG4gICAgdGhlbiB0cmFuc2xhdGUgY3R4IHInXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcCA9ICFwb3MgaW5cbiAgICAgIGxldCAoKSA9XG4gICAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgICB8IFNvbWUgbmFtZSAtPiBuYW1lcyA6PSAobmFtZSwgQS5NYXJrLmdyb3VwX2NvdW50IHApIDo6ICFuYW1lc1xuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgIGluXG4gICAgICBwb3MgOj0gQS5NYXJrLm5leHQyICFwb3M7XG4gICAgICBsZXQgY3IsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByJyBpblxuICAgICAgKCBBLnNlcSBpZHMgYEZpcnN0IChBLm1hcmsgaWRzIHApIChBLnNlcSBpZHMgYEZpcnN0IGNyIChBLm1hcmsgaWRzIChBLk1hcmsubmV4dCBwKSkpXG4gICAgICAsIGtpbmQnICkpXG4gIHwgTm9fZ3JvdXAgcicgLT4gdHJhbnNsYXRlIHsgY3R4IHdpdGggaWduX2dyb3VwID0gdHJ1ZSB9IHInXG4gIHwgTmVzdCByJyAtPlxuICAgIGxldCBiID0gIXBvcyBpblxuICAgIGxldCBjciwga2luZCcgPSB0cmFuc2xhdGUgY3R4IHInIGluXG4gICAgbGV0IGUgPSBBLk1hcmsucHJldiAhcG9zIGluXG4gICAgaWYgZSA8IGIgdGhlbiBjciwga2luZCcgZWxzZSBBLnNlcSBpZHMgYEZpcnN0IChBLmVyYXNlIGlkcyBiIGUpIGNyLCBraW5kJ1xuICB8IFBtYXJrIChpLCByJykgLT5cbiAgICBsZXQgY3IsIGtpbmQnID0gdHJhbnNsYXRlIGN0eCByJyBpblxuICAgIEEuc2VxIGlkcyBgRmlyc3QgKEEucG1hcmsgaWRzIGkpIGNyLCBraW5kJ1xuXG5hbmQgdHJhbnNfc2VxICh7IGlkczsga2luZDsgXyB9IGFzIGN0eCkgPSBmdW5jdGlvblxuICB8IFtdIC0+IEEuZXBzIGlkc1xuICB8IFsgciBdIC0+XG4gICAgbGV0IGNyJywga2luZCcgPSB0cmFuc2xhdGUgY3R4IHIgaW5cbiAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3InXG4gIHwgciA6OiByZW0gLT5cbiAgICBsZXQgY3InLCBraW5kJyA9IHRyYW5zbGF0ZSBjdHggciBpblxuICAgIGxldCBjcicnID0gdHJhbnNfc2VxIGN0eCByZW0gaW5cbiAgICBpZiBBLmlzX2VwcyBjcicnIHRoZW4gY3InIGVsc2UgaWYgQS5pc19lcHMgY3InIHRoZW4gY3InJyBlbHNlIEEuc2VxIGlkcyBraW5kJyBjcicgY3InJ1xuOztcblxubGV0IGNvbXBpbGVfMSByZWdleHAgPVxuICBsZXQgcmVnZXhwID0gQXN0LmhhbmRsZV9jYXNlIGZhbHNlIHJlZ2V4cCBpblxuICBsZXQgY29sb3JfbWFwID0gQ29sb3JfbWFwLm1ha2UgKCkgaW5cbiAgbGV0IG5lZWRfbG5sID0gQXN0LmNvbG9yaXplIGNvbG9yX21hcCByZWdleHAgaW5cbiAgbGV0IGNvbG9ycywgY29sb3JfcmVwciA9IENvbG9yX21hcC5mbGF0dGVuIGNvbG9yX21hcCBpblxuICBsZXQgbmNvbG9yID0gQ29sb3JfbWFwLlJlcHIubGVuZ3RoIGNvbG9yX3JlcHIgaW5cbiAgbGV0IGxubCA9IGlmIG5lZWRfbG5sIHRoZW4gbmNvbG9yIGVsc2UgLTEgaW5cbiAgbGV0IG5jb2xvciA9IGlmIG5lZWRfbG5sIHRoZW4gbmNvbG9yICsgMSBlbHNlIG5jb2xvciBpblxuICBsZXQgY3R4ID1cbiAgICB7IGlkcyA9IEEuSWRzLmNyZWF0ZSAoKVxuICAgIDsga2luZCA9IGBGaXJzdFxuICAgIDsgaWduX2dyb3VwID0gZmFsc2VcbiAgICA7IGdyZWVkeSA9IGBHcmVlZHlcbiAgICA7IHBvcyA9IHJlZiBBLk1hcmsuc3RhcnRcbiAgICA7IG5hbWVzID0gcmVmIFtdXG4gICAgOyBjYWNoZSA9IHJlZiBDc2V0LkNTZXRNYXAuZW1wdHlcbiAgICA7IGNvbG9yc1xuICAgIH1cbiAgaW5cbiAgbGV0IHIsIGtpbmQgPSB0cmFuc2xhdGUgY3R4IHJlZ2V4cCBpblxuICBsZXQgciA9IGVuZm9yY2Vfa2luZCBjdHguaWRzIGBGaXJzdCBraW5kIHIgaW5cbiAgKCpGb3JtYXQuZXByaW50ZiBcIjwlZCAlZD5ALlwiICFpZHMgbmNvbDsqKVxuICBta19yZVxuICAgIH5pbml0aWFsOnJcbiAgICB+Y29sb3JzXG4gICAgfmNvbG9yX3JlcHJcbiAgICB+bmNvbG9yXG4gICAgfmxubFxuICAgIH5ncm91cF9uYW1lczooTGlzdC5yZXYgIShjdHgubmFtZXMpKVxuICAgIH5ncm91cF9jb3VudDooQS5NYXJrLmdyb3VwX2NvdW50ICEoY3R4LnBvcykpXG47O1xuXG5sZXQgY29tcGlsZSByID1cbiAgbGV0IG9wZW4gQXN0LkV4cG9ydCBpblxuICBjb21waWxlXzFcbiAgICAoaWYgQXN0LmFuY2hvcmVkIHJcbiAgICAgdGhlbiBncm91cCByXG4gICAgIGVsc2Ugc2VxIFsgc2hvcnRlc3QgKHJlcCAoQXN0LmNzZXQgQ3NldC5jYW55KSk7IGdyb3VwIHIgXSlcbjs7XG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MzY1NiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X1JlX2FsbCIsImNzdF9SZV9zcGxpdCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfbWxfc3RyaW5nX2xlbmd0aCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw2IiwiYTMiLCJhNCIsImE1IiwiZ2xvYmFsX2RhdGEiLCJBc3NlcnRfZmFpbHVyZSIsIlJlX0NvbXBpbGUiLCJTdGRsaWJfU3RyaW5nIiwiUmVfR3JvdXAiLCJTdGRsaWIiLCJTdGRsaWJfU2VxIiwiYWxsIiwib3B0IiwibGVuIiwicmUiLCJzIiwicG9zIiwibCIsImxpbWl0IiwiYXV4Iiwib25fbWF0Y2giLCJwYXJhbSIsIm1hdGNoIiwic3Vic3RyIiwicDIiLCJwMSIsIm1hdGNoZXMiLCJzdWIiLCJzcGxpdF9mdWxsIiwic3RhdGUiLCJpIiwib2xkX2kiLCJ4IiwidGV4dCIsInNwbGl0Iiwic2VxIiwiZmlsdGVyIiwidGwiLCJzcGxpdF9kZWxpbSIsImRlbGltIiwiUmVfU2VhcmNoIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvcmUvc2VhcmNoLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFB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QUEsVUFBQWIsUUFBTTtBQUFBLE1BQU0sWUFDQztBQUFBLFVBQUFBLFVBREQ7QUFBQTtBQUFBLFdBQUFlLEtBQUEsVUFBQXRCLElBQUE7QUFBQSxPQUdzQyw0QkFBVCx5QkFBUztBQUFBO0FBQUEsVUFBQW9CLFFBSHRDO0FBQUEsTUFFaUI7QUFBQTtBQUFBLElBQ3NCO0FBQUEsSUFFckQ7QUFBQSxHQUFVO0FBQUEsWUFBQUcsWUFBQXRCLEtBQUFILEtBQUFDLElBQUFDO0FBQUFBLFFBQUFvQixNQUlBO0FBQUEsYUFBQUMsT0FBQUcsT0FBQUosS0FBQWQ7QUFBQUEsU0FBQWtCLFVBRVIsT0FBQUosUUFBQTtBQUFBO0FBQUEsVUFBQWIsUUFBTTtBQUFBLE1BQU0sWUFDQyxxQ0FBQUQsT0FBc0MsU0FBTyxNQUtNO0FBQUEsVUFBQUMsVUFOcEQ7QUFBQTtBQUFBLFdBQUFlLEtBQUEsVUFBQXRCLElBQUEsa0JBTTZCO0FBQUEsT0FBc0IsNEJBQXRCLDhCQUFzQjtBQUFBO0FBQUEsVUFBQW9CLFFBTm5EO0FBQUEsTUFHVjtBQUFBLE9BQ0sseUJBQUFkLE9BQXdCLDBCQUF3QixHQUFoRDtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUEsSUFDeUQ7QUFBQSxjQUVsRTtBQUFBLHlCRDlHRiw4QkM4R0U7QUFBQSxHQUFzQjtBQUFBLE9BQUFtQixZRDlHeEIiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsImxldCBhbGwgPyhwb3MgPSAwKSA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiUmUuYWxsXCI7XG4gICgqIGluZGV4IG9mIHRoZSBmaXJzdCBwb3NpdGlvbiB3ZSBkbyBub3QgY29uc2lkZXIuXG4gICAgICFwb3MgPCBsaW1pdCBpcyBhbiBpbnZhcmlhbnQgKilcbiAgbGV0IGxpbWl0ID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHNcbiAgICB8IFNvbWUgbCAtPlxuICAgICAgaWYgbCA8IDAgfHwgcG9zICsgbCA+IFN0cmluZy5sZW5ndGggcyB0aGVuIGludmFsaWRfYXJnIFwiUmUuYWxsXCI7XG4gICAgICBwb3MgKyBsXG4gIGluXG4gICgqIGl0ZXJhdGUgb24gbWF0Y2hlcy4gV2hlbiBhIG1hdGNoIGlzIGZvdW5kLCBzZWFyY2ggZm9yIHRoZSBuZXh0XG4gICAgIG9uZSBqdXN0IGFmdGVyIGl0cyBlbmQgKilcbiAgbGV0IHJlYyBhdXggcG9zIG9uX21hdGNoICgpID1cbiAgICBpZiBwb3MgPiBsaW1pdFxuICAgIHRoZW4gU2VxLk5pbCAoKiBubyBtb3JlIG1hdGNoZXMgKilcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoXG4gICAgICAgIENvbXBpbGUubWF0Y2hfc3RyIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIH5wb3MgfmxlbjoobGltaXQgLSBwb3MpXG4gICAgICB3aXRoXG4gICAgICB8IE1hdGNoIHN1YnN0ciAtPlxuICAgICAgICBsZXQgcDEsIHAyID0gR3JvdXAub2Zmc2V0IHN1YnN0ciAwIGluXG4gICAgICAgIGlmIG9uX21hdGNoICYmIHAxID0gcG9zICYmIHAxID0gcDJcbiAgICAgICAgdGhlbiAoKiBza2lwIGVtcHR5IG1hdGNoIHJpZ2h0IGFmdGVyIGEgbWF0Y2ggKilcbiAgICAgICAgICBhdXggKHBvcyArIDEpIGZhbHNlICgpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgIGxldCBwb3MgPSBpZiBwMSA9IHAyIHRoZW4gcDIgKyAxIGVsc2UgcDIgaW5cbiAgICAgICAgICBTZXEuQ29ucyAoc3Vic3RyLCBhdXggcG9zIChwMSA8PiBwMikpKVxuICAgICAgfCBSdW5uaW5nIF8gfCBGYWlsZWQgLT4gU2VxLk5pbClcbiAgaW5cbiAgYXV4IHBvcyBmYWxzZVxuOztcblxubGV0IG1hdGNoZXMgP3BvcyA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgYWxsID9wb3MgP2xlbiByZSBzIHw+IFNlcS5tYXAgKGZ1biBzdWIgLT4gR3JvdXAuZ2V0IHN1YiAwKVxuOztcblxubGV0IHNwbGl0X2Z1bGwgPyhwb3MgPSAwKSA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiUmUuc3BsaXRcIjtcbiAgbGV0IGxpbWl0ID1cbiAgICBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHNcbiAgICB8IFNvbWUgbCAtPlxuICAgICAgaWYgbCA8IDAgfHwgcG9zICsgbCA+IFN0cmluZy5sZW5ndGggcyB0aGVuIGludmFsaWRfYXJnIFwiUmUuc3BsaXRcIjtcbiAgICAgIHBvcyArIGxcbiAgaW5cbiAgKCogaTogc3RhcnQgb2YgZGVsaW1pdGVkIHN0cmluZ1xuICAgICBwb3M6IGZpcnN0IHBvc2l0aW9uIGFmdGVyIGxhc3QgbWF0Y2ggb2YgW3JlXVxuICAgICBsaW1pdDogZmlyc3QgaW5kZXggd2UgaWdub3JlICghcG9zIDwgbGltaXQgaXMgYW4gaW52YXJpYW50KSAqKVxuICBsZXQgcG9zMCA9IHBvcyBpblxuICBsZXQgcmVjIGF1eCBzdGF0ZSBpIHBvcyAoKSA9XG4gICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgIHwgYElkbGUgd2hlbiBwb3MgPiBsaW1pdCAtPlxuICAgICAgKCogV2UgaGFkIGFuIGVtcHR5IG1hdGNoIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZyAqKVxuICAgICAgYXNzZXJ0IChpID0gbGltaXQpO1xuICAgICAgU2VxLk5pbFxuICAgIHwgYElkbGUgLT5cbiAgICAgIChtYXRjaFxuICAgICAgICAgQ29tcGlsZS5tYXRjaF9zdHIgfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOmZhbHNlIHJlIHMgfnBvcyB+bGVuOihsaW1pdCAtIHBvcylcbiAgICAgICB3aXRoXG4gICAgICAgfCBNYXRjaCBzdWJzdHIgLT5cbiAgICAgICAgIGxldCBwMSwgcDIgPSBHcm91cC5vZmZzZXQgc3Vic3RyIDAgaW5cbiAgICAgICAgIGxldCBwb3MgPSBpZiBwMSA9IHAyIHRoZW4gcDIgKyAxIGVsc2UgcDIgaW5cbiAgICAgICAgIGxldCBvbGRfaSA9IGkgaW5cbiAgICAgICAgIGxldCBpID0gcDIgaW5cbiAgICAgICAgIGlmIG9sZF9pID0gcDEgJiYgcDEgPSBwMiAmJiBwMSA+IHBvczBcbiAgICAgICAgIHRoZW4gKCogU2tpcCBlbXB0eSBtYXRjaCByaWdodCBhZnRlciBhIGRlbGltaXRlciAqKVxuICAgICAgICAgICBhdXggc3RhdGUgaSBwb3MgKClcbiAgICAgICAgIGVsc2UgaWYgcDEgPiBwb3MwXG4gICAgICAgICB0aGVuIChcbiAgICAgICAgICAgKCogc3RyaW5nIGRvZXMgbm90IHN0YXJ0IGJ5IGEgZGVsaW1pdGVyICopXG4gICAgICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLnN1YiBzIG9sZF9pIChwMSAtIG9sZF9pKSBpblxuICAgICAgICAgICBsZXQgc3RhdGUgPSBgWWllbGQgKGBEZWxpbSBzdWJzdHIpIGluXG4gICAgICAgICAgIFNlcS5Db25zIChgVGV4dCB0ZXh0LCBhdXggc3RhdGUgaSBwb3MpKVxuICAgICAgICAgZWxzZSBTZXEuQ29ucyAoYERlbGltIHN1YnN0ciwgYXV4IHN0YXRlIGkgcG9zKVxuICAgICAgIHwgUnVubmluZyBfIC0+IFNlcS5OaWxcbiAgICAgICB8IEZhaWxlZCAtPlxuICAgICAgICAgaWYgaSA8IGxpbWl0XG4gICAgICAgICB0aGVuIChcbiAgICAgICAgICAgbGV0IHRleHQgPSBTdHJpbmcuc3ViIHMgaSAobGltaXQgLSBpKSBpblxuICAgICAgICAgICAoKiB5aWVsZCBsYXN0IHN0cmluZyAqKVxuICAgICAgICAgICBTZXEuQ29ucyAoYFRleHQgdGV4dCwgYXV4IHN0YXRlIGxpbWl0IHBvcykpXG4gICAgICAgICBlbHNlIFNlcS5OaWwpXG4gICAgfCBgWWllbGQgeCAtPiBTZXEuQ29ucyAoeCwgYXV4IGBJZGxlIGkgcG9zKVxuICBpblxuICBhdXggYElkbGUgcG9zIHBvc1xuOztcblxubGV0IHNwbGl0ID9wb3MgP2xlbiByZSBzIDogXyBTZXEudCA9XG4gIGxldCBzZXEgPSBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIGluXG4gIGxldCByZWMgZmlsdGVyIHNlcSAoKSA9XG4gICAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IFNlcS5OaWwgLT4gU2VxLk5pbFxuICAgIHwgU2VxLkNvbnMgKGBEZWxpbSBfLCB0bCkgLT4gZmlsdGVyIHRsICgpXG4gICAgfCBTZXEuQ29ucyAoYFRleHQgcywgdGwpIC0+IFNlcS5Db25zIChzLCBmaWx0ZXIgdGwpXG4gIGluXG4gIGZpbHRlciBzZXFcbjs7XG5cbmxldCBzcGxpdF9kZWxpbSA/cG9zID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICBsZXQgc2VxID0gc3BsaXRfZnVsbCA/cG9zID9sZW4gcmUgcyBpblxuICBsZXQgcmVjIGZpbHRlciB+ZGVsaW0gc2VxICgpID1cbiAgICBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgU2VxLk5pbCAtPiBpZiBkZWxpbSB0aGVuIFNlcS5Db25zIChcIlwiLCBmdW4gKCkgLT4gU2VxLk5pbCkgZWxzZSBTZXEuTmlsXG4gICAgfCBTZXEuQ29ucyAoYERlbGltIF8sIHRsKSAtPlxuICAgICAgaWYgZGVsaW1cbiAgICAgIHRoZW4gU2VxLkNvbnMgKFwiXCIsIGZ1biAoKSAtPiBmaWx0ZXIgfmRlbGltOnRydWUgdGwgKCkpXG4gICAgICBlbHNlIGZpbHRlciB+ZGVsaW06dHJ1ZSB0bCAoKVxuICAgIHwgU2VxLkNvbnMgKGBUZXh0IHMsIHRsKSAtPiBTZXEuQ29ucyAocywgZmlsdGVyIH5kZWxpbTpmYWxzZSB0bClcbiAgaW5cbiAgZmlsdGVyIH5kZWxpbTp0cnVlIHNlcVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjozODU1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiY2FtbF9jYWxsNCIsImEzIiwiY2FtbF9jYWxsNiIsImE0IiwiYTUiLCJnbG9iYWxfZGF0YSIsIlJlX1NlYXJjaCIsIlN0ZGxpYl9TZXEiLCJTdGRsaWJfTGlzdExhYmVscyIsIlJlX1BtYXJrIiwiU3RkbGliIiwiUmVfQ29tcGlsZSIsIlJlX0NzZXQiLCJSZV9Bc3QiLCJSZV9Hcm91cCIsImNzZXQiLCJjaGFyIiwiYyIsInJnIiwiYW55Iiwibm90bmwiLCJsb3dlciIsInVwcGVyIiwiYWxwaGEiLCJkaWdpdCIsImFsbnVtIiwid29yZGMiLCJhc2NpaSIsImJsYW5rIiwiY250cmwiLCJncmFwaCIsInByaW50IiwicHVuY3QiLCJzcGFjZSIsInhkaWdpdCIsImluY2x1ZGUiLCJlbXB0eSIsImVwc2lsb24iLCJzdHIiLCJub19jYXNlIiwiY2FzZSIsImRpZmYiLCJjb21wbCIsInJlcG4iLCJpbnRlciIsInNldCIsIm1hcmsiLCJuZXN0Iiwibm9fZ3JvdXAiLCJ3aG9sZV9zdHJpbmciLCJsZW9sIiwibG9uZ2VzdCIsImdyZWVkeSIsIm5vbl9ncmVlZHkiLCJzdG9wIiwibm90X2JvdW5kYXJ5IiwiZ3JvdXAiLCJ3b3JkIiwiZmlyc3QiLCJib3MiLCJib3ciLCJlb3ciLCJlb3MiLCJib2wiLCJzdGFydCIsImVvbCIsIm9wdCIsInJlcCIsInJlcDEiLCJhbHQiLCJzaG9ydGVzdCIsInNlcSIsInBwIiwid2l0bmVzcyIsImV4ZWNfaW50ZXJuYWwiLCJwYXJ0aWFsIiwiZ3JvdXBzIiwicmUiLCJzIiwicG9zIiwibGVuIiwiZXhlYyIsIm1hdGNoIiwic3Vic3RyIiwiZXhlY19vcHQiLCJleGVjcCIsImV4ZWNfcGFydGlhbCIsImV4ZWNfcGFydGlhbF9kZXRhaWxlZCIsIm5vX21hdGNoX3N0YXJ0c19iZWZvcmUiLCJtYXJrZWQiLCJnIiwicCIsIm1hcmtfc2V0IiwiZXF1YWwiLCJjb21wYXJlIiwiZ2VuX29mX3NlcSIsInIiLCJwYXJhbSIsInRsIiwieCIsInNwbGl0X2dlbiIsInNwbGl0X2Z1bGxfZ2VuIiwiYWxsX2dlbiIsIm1hdGNoZXNfZ2VuIiwic3BsaXRfZnVsbF9zZXEiLCJzcGxpdF9zZXEiLCJtYXRjaGVzX3NlcSIsImFsbF9zZXEiLCJnZXQiLCJnZXRfb2ZzIiwiZ2V0X2FsbCIsImdldF9hbGxfb2ZzIiwidGVzdCIsImxpc3Rfb2Zfc2VxIiwibCIsImFsbCIsIm1hdGNoZXMiLCJzcGxpdF9mdWxsIiwic3BsaXQiLCJzcGxpdF9kZWxpbSIsImNvbXBpbGUiLCJwcF9yZSIsInByaW50X3JlIiwiZ3JvdXBfbmFtZXMiLCJncm91cF9jb3VudCIsIlJlX0NvcmUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9jb3JlLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLFlBQUFDLE9BQUFDLEdDMEJvQixPQUFnQixpQkFBaEIsMkJBQWdCO0FBQUEsWUFBQUMsR0FBQUQsS0FBQUE7QUFBQUEsSUFDZixPQUFnQixpQkFBaEIsZ0NBQWdCO0FBQUE7QUFBQTtBQUFBLElBQUFFLE1BQ3pCO0FBQUEsSUFBQUMsUUFDRTtBQUFBLElBQUFDLFFBQ0E7QUFBQSxJQUFBQyxRQUNBO0FBQUEsSUFBQUMsUUFDQTtBQUFBLElBQUFDLFFBQ0E7QUFBQSxJQUFBQyxRQUNBO0FBQUEsSUFBQUMsUUFDQTtBQUFBLElBQUFDLFFBQ0E7QUFBQSxJQUFBQyxRQUNBO0FBQUEsSUFBQUMsUUFDQTtBQUFBLElBQUFDLFFBQ0E7QUFBQSxJQUFBQyxRQUNBO0FBQUEsSUFBQUMsUUFDQTtBQUFBLElBQUFDLFFBQ0E7QUFBQSxJQUFBQyxTQUNDO0FBQUEsSUFBQUMsVUFBZ0I7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9B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QUFILElBQUFDO0FBQUFBLElBQ3BDLE9BQWlDLFlBQWpDLDBDQUFnRDtBQUFBO0FBQUE7QUFBQSxJQUFBMEMsVUE3SnBEO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRDNDL0IiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm9wZW4gSW1wb3J0XG5cbmluY2x1ZGUgc3RydWN0XG4gIGxldCBjc2V0ID0gQXN0LmNzZXRcbiAgbGV0IGNoYXIgYyA9IGNzZXQgKENzZXQuY3NpbmdsZSBjKVxuICBsZXQgcmcgYyBjJyA9IGNzZXQgKENzZXQuY3NlcSBjIGMnKVxuICBsZXQgYW55ID0gY3NldCBDc2V0LmNhbnlcbiAgbGV0IG5vdG5sID0gY3NldCBDc2V0Lm5vdG5sXG4gIGxldCBsb3dlciA9IGNzZXQgQ3NldC5sb3dlclxuICBsZXQgdXBwZXIgPSBjc2V0IENzZXQudXBwZXJcbiAgbGV0IGFscGhhID0gY3NldCBDc2V0LmFscGhhXG4gIGxldCBkaWdpdCA9IGNzZXQgQ3NldC5jZGlnaXRcbiAgbGV0IGFsbnVtID0gY3NldCBDc2V0LmFsbnVtXG4gIGxldCB3b3JkYyA9IGNzZXQgQ3NldC53b3JkY1xuICBsZXQgYXNjaWkgPSBjc2V0IENzZXQuYXNjaWlcbiAgbGV0IGJsYW5rID0gY3NldCBDc2V0LmJsYW5rXG4gIGxldCBjbnRybCA9IGNzZXQgQ3NldC5jbnRybFxuICBsZXQgZ3JhcGggPSBjc2V0IENzZXQuZ3JhcGhcbiAgbGV0IHByaW50ID0gY3NldCBDc2V0LnByaW50XG4gIGxldCBwdW5jdCA9IGNzZXQgQ3NldC5wdW5jdFxuICBsZXQgc3BhY2UgPSBjc2V0IENzZXQuc3BhY2VcbiAgbGV0IHhkaWdpdCA9IGNzZXQgQ3NldC54ZGlnaXRcbmVuZFxuXG5pbmNsdWRlIEFzdC5FeHBvcnRcblxubGV0IGV4ZWNfaW50ZXJuYWwgPyhwb3MgPSAwKSA/KGxlbiA9IC0xKSB+cGFydGlhbCB+Z3JvdXBzIHJlIHMgPVxuICBDb21waWxlLm1hdGNoX3N0ciB+Z3JvdXBzIH5wYXJ0aWFsIHJlIHMgfnBvcyB+bGVuXG47O1xuXG5sZXQgZXhlYyA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgP3BvcyA/bGVuIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIHdpdGhcbiAgfCBNYXRjaCBzdWJzdHIgLT4gc3Vic3RyXG4gIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbjs7XG5cbmxldCBleGVjX29wdCA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgP3BvcyA/bGVuIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIHdpdGhcbiAgfCBNYXRjaCBzdWJzdHIgLT4gU29tZSBzdWJzdHJcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCBleGVjcCA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgfmdyb3VwczpmYWxzZSB+cGFydGlhbDpmYWxzZSA/cG9zID9sZW4gcmUgcyB3aXRoXG4gIHwgTWF0Y2ggX3N1YnN0ciAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGV4ZWNfcGFydGlhbCA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgfmdyb3VwczpmYWxzZSB+cGFydGlhbDp0cnVlID9wb3MgP2xlbiByZSBzIHdpdGhcbiAgfCBNYXRjaCBfIC0+IGBGdWxsXG4gIHwgUnVubmluZyBfIC0+IGBQYXJ0aWFsXG4gIHwgRmFpbGVkIC0+IGBNaXNtYXRjaFxuOztcblxubGV0IGV4ZWNfcGFydGlhbF9kZXRhaWxlZCA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOnRydWUgP3BvcyA/bGVuIHJlIHMgd2l0aFxuICB8IE1hdGNoIGdyb3VwIC0+IGBGdWxsIGdyb3VwXG4gIHwgUnVubmluZyB7IG5vX21hdGNoX3N0YXJ0c19iZWZvcmUgfSAtPiBgUGFydGlhbCBub19tYXRjaF9zdGFydHNfYmVmb3JlXG4gIHwgRmFpbGVkIC0+IGBNaXNtYXRjaFxuOztcblxubW9kdWxlIE1hcmsgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gUG1hcmsudFxuXG4gIGxldCB0ZXN0IChnIDogR3JvdXAudCkgcCA9IFBtYXJrLlNldC5tZW0gcCBnLnBtYXJrc1xuICBsZXQgYWxsIChnIDogR3JvdXAudCkgPSBnLnBtYXJrc1xuXG4gIG1vZHVsZSBTZXQgPSBQbWFyay5TZXRcblxuICBsZXQgZXF1YWwgPSBQbWFyay5lcXVhbFxuICBsZXQgY29tcGFyZSA9IFBtYXJrLmNvbXBhcmVcbmVuZFxuXG50eXBlIHNwbGl0X3Rva2VuID1cbiAgWyBgVGV4dCBvZiBzdHJpbmdcbiAgfCBgRGVsaW0gb2YgR3JvdXAudFxuICBdXG5cbm1vZHVsZSBHZW4gPSBzdHJ1Y3RcbiAgdHlwZSAnYSBnZW4gPSB1bml0IC0+ICdhIG9wdGlvblxuXG4gIGxldCBnZW5fb2Zfc2VxIChzIDogJ2EgU2VxLnQpIDogJ2EgZ2VuID1cbiAgICBsZXQgciA9IHJlZiBzIGluXG4gICAgZnVuICgpIC0+XG4gICAgICBtYXRjaCAhciAoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gTm9uZVxuICAgICAgfCBTZXEuQ29ucyAoeCwgdGwpIC0+XG4gICAgICAgIHIgOj0gdGw7XG4gICAgICAgIFNvbWUgeFxuICA7O1xuXG4gIGxldCBzcGxpdCA/cG9zID9sZW4gcmUgcyA6IF8gZ2VuID0gU2VhcmNoLnNwbGl0ID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcbiAgbGV0IHNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgOiBfIGdlbiA9IFNlYXJjaC5zcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcbiAgbGV0IGFsbCA/cG9zID9sZW4gcmUgcyA9IFNlYXJjaC5hbGwgP3BvcyA/bGVuIHJlIHMgfD4gZ2VuX29mX3NlcVxuICBsZXQgbWF0Y2hlcyA/cG9zID9sZW4gcmUgcyA9IFNlYXJjaC5tYXRjaGVzID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcbmVuZFxuXG5tb2R1bGUgR3JvdXAgPSBHcm91cFxuXG4oKiogezIgRGVwcmVjYXRlZCBmdW5jdGlvbnN9ICopXG5cbmxldCBzcGxpdF9mdWxsX3NlcSA9IFNlYXJjaC5zcGxpdF9mdWxsXG5sZXQgc3BsaXRfc2VxID0gU2VhcmNoLnNwbGl0XG5sZXQgbWF0Y2hlc19zZXEgPSBTZWFyY2gubWF0Y2hlc1xubGV0IGFsbF9zZXEgPSBTZWFyY2guYWxsXG5cbnR5cGUgJ2EgZ2VuID0gJ2EgR2VuLmdlblxuXG5sZXQgYWxsX2dlbiA9IEdlbi5hbGxcbmxldCBtYXRjaGVzX2dlbiA9IEdlbi5tYXRjaGVzXG5sZXQgc3BsaXRfZ2VuID0gR2VuLnNwbGl0XG5sZXQgc3BsaXRfZnVsbF9nZW4gPSBHZW4uc3BsaXRfZnVsbFxuXG50eXBlIHN1YnN0cmluZ3MgPSBHcm91cC50XG5cbmxldCBnZXQgPSBHcm91cC5nZXRcbmxldCBnZXRfb2ZzID0gR3JvdXAub2Zmc2V0XG5sZXQgZ2V0X2FsbCA9IEdyb3VwLmFsbFxubGV0IGdldF9hbGxfb2ZzID0gR3JvdXAuYWxsX29mZnNldFxubGV0IHRlc3QgPSBHcm91cC50ZXN0XG5cbnR5cGUgbWFya2lkID0gTWFyay50XG5cbmxldCBtYXJrZWQgPSBNYXJrLnRlc3RcbmxldCBtYXJrX3NldCA9IE1hcmsuYWxsXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKlxuICAgSW5mb3JtYXRpb24gYWJvdXQgdGhlIHByZXZpb3VzIGNoYXJhY3RlcjpcbiAgIC0gZG9lcyBub3QgZXhpc3RzXG4gICAtIGlzIGEgbGV0dGVyXG4gICAtIGlzIG5vdCBhIGxldHRlclxuICAgLSBpcyBhIG5ld2xpbmVcbiAgIC0gaXMgbGFzdCBuZXdsaW5lXG5cbiAgIEJlZ2lubmluZyBvZiB3b3JkOlxuICAgLSBwcmV2aW91cyBpcyBub3QgYSBsZXR0ZXIgb3IgZG9lcyBub3QgZXhpc3RcbiAgIC0gY3VycmVudCBpcyBhIGxldHRlciBvciBkb2VzIG5vdCBleGlzdFxuXG4gICBFbmQgb2Ygd29yZDpcbiAgIC0gcHJldmlvdXMgaXMgYSBsZXR0ZXIgb3IgZG9lcyBub3QgZXhpc3RcbiAgIC0gY3VycmVudCBpcyBub3QgYSBsZXR0ZXIgb3IgZG9lcyBub3QgZXhpc3RcblxuICAgQmVnaW5uaW5nIG9mIGxpbmU6XG4gICAtIHByZXZpb3VzIGlzIGEgbmV3bGluZSBvciBkb2VzIG5vdCBleGlzdFxuXG4gICBCZWdpbm5pbmcgb2YgYnVmZmVyOlxuICAgLSBwcmV2aW91cyBkb2VzIG5vdCBleGlzdFxuXG4gICBFbmQgb2YgYnVmZmVyXG4gICAtIGN1cnJlbnQgZG9lcyBub3QgZXhpc3RcblxuICAgRW5kIG9mIGxpbmVcbiAgIC0gY3VycmVudCBpcyBhIG5ld2xpbmUgb3IgZG9lcyBub3QgZXhpc3RcbiopXG5cbigqXG4gICBSZXA6IGUgPSBULGUgfCAoKVxuICAtIHNlbWFudGljcyBvZiB0aGUgY29tbWEgKHNob3J0ZXN0L2xvbmdlc3QvZmlyc3QpXG4gIC0gc2VtYW50aWNzIG9mIHRoZSB1bmlvbiAoZ3JlZWR5L25vbi1ncmVlZHkpXG5cbkJvdW5kZWQgcmVwZXRpdGlvblxuICBhezAsM30gPSAoYSwoYSxhPyk/KT9cbiopXG5cbnR5cGUgZ3JvdXBzID0gR3JvdXAudFxuXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBsZXQgbGlzdF9vZl9zZXEgKHMgOiAnYSBTZXEudCkgOiAnYSBsaXN0ID1cbiAgICBTZXEuZm9sZF9sZWZ0IChmdW4gbCB4IC0+IHggOjogbCkgW10gcyB8PiBMaXN0LnJldlxuICA7O1xuXG4gIGxldCBhbGwgP3BvcyA/bGVuIHJlIHMgPSBTZWFyY2guYWxsID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG4gIGxldCBtYXRjaGVzID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLm1hdGNoZXMgP3BvcyA/bGVuIHJlIHMgfD4gbGlzdF9vZl9zZXFcbiAgbGV0IHNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgPSBTZWFyY2guc3BsaXRfZnVsbCA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuICBsZXQgc3BsaXQgP3BvcyA/bGVuIHJlIHMgPSBTZWFyY2guc3BsaXQgP3BvcyA/bGVuIHJlIHMgfD4gbGlzdF9vZl9zZXFcbiAgbGV0IHNwbGl0X2RlbGltID9wb3MgP2xlbiByZSBzID0gU2VhcmNoLnNwbGl0X2RlbGltID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG5lbmRcblxuaW5jbHVkZSBMaXN0XG5cbmluY2x1ZGUgc3RydWN0XG4gIG9wZW4gQ29tcGlsZVxuXG4gIHR5cGUgbm9ucmVjIHJlID0gcmVcblxuICBsZXQgY29tcGlsZSA9IGNvbXBpbGVcbiAgbGV0IHBwX3JlID0gcHBfcmVcbiAgbGV0IHByaW50X3JlID0gcHJpbnRfcmVcbiAgbGV0IGdyb3VwX25hbWVzID0gZ3JvdXBfbmFtZXNcbiAgbGV0IGdyb3VwX2NvdW50ID0gZ3JvdXBfY291bnRcbmVuZFxuXG5tb2R1bGUgU2VxID0gU2VhcmNoXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDE1MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiUGFyc2VfZXJyb3IiLCJjcmVhdGUiLCJzdHIiLCJ1bmdldCIsInQiLCJqdW5rIiwiZW9zIiwidGVzdCIsImMiLCJ0ZXN0MiIsImFjY2VwdCIsInIiLCJhY2NlcHQyIiwiZ2V0IiwiYWNjZXB0X3MiLCJzIiwibGVuIiwiaiIsImludGVnZXIiLCJkIiwiaSIsIlJlX1BhcnNlX2J1ZmZlciJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlL3BhcnNlX2J1ZmZlci5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLE9BQUFDLEtDT2lCLG1CQUFnQjtBQUFBLFlBQUFDLE1BQUFDLEdBQ25CLDhCQUFrQjtBQUFBLFlBQUFDLEtBQUFELEdBQ25CLDhCQUFrQjtBQUFBLFlBQUFFLElBQUFGLEdBQ25CLG9EQUEyQjtBQUFBLFlBQUFHLEtBQUFILEdBQUFJO0FBQUFBO0FBQUFBLEtBQUEsTUFDbkI7QUFBQSxXQUFPLE1BQUs7QUFBQSxJQUFMO0FBQUEsR0FBc0I7QUFBQSxZQUFBQyxNQUFBTCxHQUFBSSxLQUFBQTtBQUFBQSxRQUFBLE1BRy9DO0FBQUE7QUFBQTtBQUFBLFlBQW1DO0FBQUEsWUFBYSxNQUFRO0FBQUE7QUFBQSxlQUF4RDtBQUFBO0FBQUEsR0FBOEU7QUFBQSxZQUFBRSxPQUFBTixHQUFBSTtBQUFBQSxRQUFBRyxJQUl0RTtBQUFBLElBQ1IsTUFBVTtBQUFBLElBQ1Y7QUFBQSxHQUFDO0FBQUEsWUFBQUMsUUFBQVIsR0FBQUksS0FBQUE7QUFBQUEsUUFBQUcsSUFJTztBQUFBLElBQ1IsTUFBVTtBQUFBLElBQ1Y7QUFBQSxHQUFDO0FBQUEsWUFBQUUsSUFBQVQ7QUFBQUEsUUFBQU8sSUFJTztBQUFBLElBQ1I7QUFBQSxJQUNBO0FBQUEsR0FBQztBQUFBLFlBQUFHLFNBQUFWLEdBQUFXO0FBQUFBLFFBQUFDLE1BSUQ7QUFBQSxJQUNBO0FBQUE7QUFBQTtBQUFBLFVBQUFDLElBQUE7QUFBQTtBQUFBLE9BRUk7QUFBQSxrQkFBaUI7QUFBQSxRQUFWLGtDQUFpQztBQUFBO0FBQUEsa0JEdkM5QztBQUFBLGlCQ3VDTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FHRjtBQUFBLGVBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSxlRDNDSjtBQUFBLDJCQzZDWTtBQUFBLEtEN0NaO0FBQUE7QUFBQSxHQzZDaUI7QUFBQSxZQUFBQyxRQUFBZDtBQUFBQSxJQWtCWixXQUNFO0FBQUEsUUFBQWUsTUFFRztBQUFBLElBQUssdUJBR1QsVUFBTztBQUFBLFFBQUFDLE1BRlksY0FBQUEsSUFBQTtBQUFBO0FBQUEsS0FsQnBCLFdBQ0U7QUFBQSxTQUFBRCxJQUVHO0FBQUEsS0FBSyxxQkFNVCxVQUFPO0FBQUEsU0FBQUMsTUFKUDtBQUFBLEtBQ0EsWUFBZTtBQUFBLEtBQ2Y7QUFBQTtBQUFBLEdBY0s7QUFBQTtBQUFBLElBQUFDO0FBQUFBLE1EdEVYIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJ0eXBlIHQgPVxuICB7IHN0ciA6IHN0cmluZ1xuICA7IG11dGFibGUgcG9zIDogaW50XG4gIH1cblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5cbmxldCBjcmVhdGUgc3RyID0geyBzdHI7IHBvcyA9IDAgfVxubGV0IHVuZ2V0IHQgPSB0LnBvcyA8LSB0LnBvcyAtIDFcbmxldCBqdW5rIHQgPSB0LnBvcyA8LSB0LnBvcyArIDFcbmxldCBlb3MgdCA9IHQucG9zID0gU3RyaW5nLmxlbmd0aCB0LnN0clxubGV0IHRlc3QgdCBjID0gKG5vdCAoZW9zIHQpKSAmJiB0LnN0ci5bdC5wb3NdID0gY1xuXG5sZXQgdGVzdDIgdCBjIGMnID1cbiAgdC5wb3MgKyAxIDwgU3RyaW5nLmxlbmd0aCB0LnN0ciAmJiB0LnN0ci5bdC5wb3NdID0gYyAmJiB0LnN0ci5bdC5wb3MgKyAxXSA9IGMnXG47O1xuXG5sZXQgYWNjZXB0IHQgYyA9XG4gIGxldCByID0gdGVzdCB0IGMgaW5cbiAgaWYgciB0aGVuIHQucG9zIDwtIHQucG9zICsgMTtcbiAgclxuOztcblxubGV0IGFjY2VwdDIgdCBjIGMnID1cbiAgbGV0IHIgPSB0ZXN0MiB0IGMgYycgaW5cbiAgaWYgciB0aGVuIHQucG9zIDwtIHQucG9zICsgMjtcbiAgclxuOztcblxubGV0IGdldCB0ID1cbiAgbGV0IHIgPSB0LnN0ci5bdC5wb3NdIGluXG4gIHQucG9zIDwtIHQucG9zICsgMTtcbiAgclxuOztcblxubGV0IGFjY2VwdF9zIHQgcycgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzJyBpblxuICB0cnlcbiAgICBmb3IgaiA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdHJ5IGlmIHMnLltqXSA8PiB0LnN0ci5bdC5wb3MgKyBqXSB0aGVuIHJhaXNlX25vdHJhY2UgRXhpdCB3aXRoXG4gICAgICB8IF8gLT4gcmFpc2Vfbm90cmFjZSBFeGl0XG4gICAgZG9uZTtcbiAgICB0LnBvcyA8LSB0LnBvcyArIGxlbjtcbiAgICB0cnVlXG4gIHdpdGhcbiAgfCBFeGl0IC0+IGZhbHNlXG47O1xuXG5sZXQgcmVjIGludGVnZXInIHQgaSA9XG4gIGlmIGVvcyB0XG4gIHRoZW4gU29tZSBpXG4gIGVsc2UgKFxuICAgIG1hdGNoIGdldCB0IHdpdGhcbiAgICB8ICcwJyAuLiAnOScgYXMgZCAtPlxuICAgICAgbGV0IGknID0gKDEwICogaSkgKyAoQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJzAnKSBpblxuICAgICAgaWYgaScgPCBpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBpbnRlZ2VyJyB0IGknXG4gICAgfCBfIC0+XG4gICAgICB1bmdldCB0O1xuICAgICAgU29tZSBpKVxuOztcblxubGV0IGludGVnZXIgdCA9XG4gIGlmIGVvcyB0XG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBtYXRjaCBnZXQgdCB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGQgLT4gaW50ZWdlcicgdCAoQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJzAnKVxuICAgIHwgXyAtPlxuICAgICAgdW5nZXQgdDtcbiAgICAgIE5vbmUpXG47O1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQyNjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJSZV9Db3JlIiwiU3RkbGliX0xpc3QiLCJSZV9QYXJzZV9idWZmZXIiLCJQYXJzZV9lcnJvciIsIk5vdF9zdXBwb3J0ZWQiLCJyZSIsIm9wdCIsInMiLCJjYXNlIiwiYnVmIiwiYWNjZXB0IiwiYWNjZXB0MiIsImVvcyIsInBhcmFtIiwidGVzdDIiLCJnZXQiLCJyZWdleHAiLCJsZWZ0IiwiYnJhbmNoIiwiciIsImMiLCJicmFja2V0IiwiY2hhciIsInJlcyIsImNvbXBpbGUiLCJjb21waWxlX3BhdCIsIlJlX0VtYWNzIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvcmUvZW1hY3MubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLFlBQUFDLEdBQUFDLEtBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLFNDc0hPO0FBQUEsS0FBQUMsTUExRks7QUFBQSxLQUFBQyxTQUNHO0FBQUEsS0FBQUMsVUFDQztBQUFBLGFBQUFDLElBQUFDLE9BQ0QsMENBQW9CO0FBQUEsUUFBQUMsUUFDckI7QUFBQSxhQUFBQyxJQUFBRixPQUNDLDBDQUFvQjtBQUFBLGFBQUFHLE9BQUFIO0FBQUFBLFNBQUFJLE9BQ0wsV0FBQUEsU0FBVztBQUFBO0FBQUEsTUFFbEMsbUNBQWdFO0FBQUE7QUFBQSxhQUFsQjtBQUFBLE9BQUFBLFNBQWhCO0FBQUEsTUFBNEI7QUFBQTtBQUFBLElBRnhCO0FBQUEsYUFBQUMsT0FBQUw7QUFBQUEsU0FBQUksT0FHdkI7QUFBQTtBQUFBLE1BRVg7QUFBQTtBQUFBO0FBQUEsYUFBVSxnQ0FBa0I7QUFBQTtBQUFBLFVBYTVCO0FBQUEsWUFBQUUsSUFDRTtBQUFBLGVBQ0c7QUFBQSxZQUFBQSxJQUNIO0FBQUEsZUFDRztBQUFBLFlBQUFBLElBQ0g7QUFBQSxlQUNHO0FBQUEsUUFDQTtBQUFBLG1CQUF5QixZQUFBQSxJQUFZO0FBQUE7QUFBQSxtQkFBYSxZQUFBQSxJQUFZO0FBQUE7QUFBQSxRQUM5RDtBQUFBLFNBZ0NILFdBQVk7QUFBQSxhQUFBQyxNQUNUO0FBQUE7QUFBQTtBQUFBLFVBQU07QUFBQSxjQUFBRCxJQUVMO0FBQUE7QUFBQTtBQUFBLFNBRGM7QUFBQTtBQUFBLFFBaENsQjtBQUFBLGFBQUFBLE1BRU87QUFBQSxTQUNEO0FBQUEsVUFBd0I7QUFBQSxhQUFBQSxJQUMvQjtBQUFBO0FBQUEsZ0JBQ007QUFBQSxhQUFBQSxJQUNIO0FBQUEsZ0JBQ0c7QUFBQSxhQUFBQSxJQUNIO0FBQUEsZ0JBQ0c7QUFBQSxhQUFBQSxJQUNIO0FBQUEsZ0JBQ0c7QUFBQTtBQUFBLFVBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBLGFBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBLGFBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBLGFBQUFBLElBQ0g7QUFBQSxnQkFDRztBQUFBO0FBQUEsZ0JBQ2dCO0FBQUEsVUFBQUEsSUFBVztBQUFBLGdCQUMzQjtBQUFBO0FBQUEsZ0JBQ2tCO0FBQUEsVUFBQUEsSUFBVztBQUFBO0FBQUEsU0FFaEMsV0FBWTtBQUFBLGFBQUFDLElBQ1Q7QUFBQTtBQUFBO0FBQUEsVUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBRUk7QUFBQTtBQUFBO0FBQUEsWUFGSjtBQUFBLFVBR0w7QUFBQTtBQUFBLGFBQUFELElBRjBEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQTVDbEU7QUFBQSxhQUNFO0FBQUEsYUFDRztBQUFBO0FBQUEsZUFDSDtBQUFBLGVBQ0cseUJBQ0g7QUFBQSxRQUFBRixTQVJpQjtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQURWO0FBQUEsTUFBZSxtQ0FISDtBQUFBO0FBQUE7QUFBQSxhQUFBSSxRQUFBZDtBQUFBQSxTQUFBQSxNQTREeEI7QUFBQTtBQUFBLHNCQUFjLHdCQUNUO0FBQUEsVUFBQWEsSUFFSztBQUFBLE1BQ0w7QUFBQSxPQUVFO0FBQUEsa0JBQ2U7QUFBQSxRQUFiLDJDQUFTO0FBQUE7QUFBQSxXQUFBQSxNQUVILFdBQUFiLE1BQ0E7QUFBQSxPQUFVO0FBQUE7QUFBQSxlQUFBQSxNQUNULHNDQUFTO0FBQUE7QUFBQSxJQUFPO0FBQUEsYUFBQWUsT0FBQVQ7QUFBQUEsS0FFN0IsV0FBWTtBQUFBLEtBQ2YsYUFBTTtBQUFBO0FBQUEsUUFBQVUsTUFFRTtBQUFBLElBQ0gsZUFBYztBQUFBLElBTXJCLHNCQUFvQiw0QkFBWTtBQUFBO0FBQUEsT0FBQUMsVUR4SGxDO0FBQUEsWUFBQUMsWUFBQW5CLEtBQUFDO0FBQUFBLFFBQUFDLFNDNEhnQjtBQUFBLElBQTJCLE9BQVksb0JBQVosbUJBQVk7QUFBQTtBQUFBLE9BQUFrQixXRDVIdkQiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5leGNlcHRpb24gTm90X3N1cHBvcnRlZFxuXG5sZXQgcGFyc2UgcyA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBhY2NlcHQyID0gUGFyc2VfYnVmZmVyLmFjY2VwdDIgYnVmIGluXG4gIGxldCBlb3MgKCkgPSBQYXJzZV9idWZmZXIuZW9zIGJ1ZiBpblxuICBsZXQgdGVzdDIgPSBQYXJzZV9idWZmZXIudGVzdDIgYnVmIGluXG4gIGxldCBnZXQgKCkgPSBQYXJzZV9idWZmZXIuZ2V0IGJ1ZiBpblxuICBsZXQgcmVjIHJlZ2V4cCAoKSA9IHJlZ2V4cCcgKGJyYW5jaCAoKSlcbiAgYW5kIHJlZ2V4cCcgbGVmdCA9XG4gICAgaWYgYWNjZXB0MiAnXFxcXCcgJ3wnIHRoZW4gcmVnZXhwJyAoUmUuYWx0IFsgbGVmdDsgYnJhbmNoICgpIF0pIGVsc2UgbGVmdFxuICBhbmQgYnJhbmNoICgpID0gYnJhbmNoJyBbXVxuICBhbmQgYnJhbmNoJyBsZWZ0ID1cbiAgICBpZiBlb3MgKCkgfHwgdGVzdDIgJ1xcXFwnICd8JyB8fCB0ZXN0MiAnXFxcXCcgJyknXG4gICAgdGhlbiBSZS5zZXEgKExpc3QucmV2IGxlZnQpXG4gICAgZWxzZSBicmFuY2gnIChwaWVjZSAoKSA6OiBsZWZ0KVxuICBhbmQgcGllY2UgKCkgPVxuICAgIGxldCByID0gYXRvbSAoKSBpblxuICAgIGlmIGFjY2VwdCAnKidcbiAgICB0aGVuIFJlLnJlcCByXG4gICAgZWxzZSBpZiBhY2NlcHQgJysnXG4gICAgdGhlbiBSZS5yZXAxIHJcbiAgICBlbHNlIGlmIGFjY2VwdCAnPydcbiAgICB0aGVuIFJlLm9wdCByXG4gICAgZWxzZSByXG4gIGFuZCBhdG9tICgpID1cbiAgICBpZiBhY2NlcHQgJy4nXG4gICAgdGhlbiBSZS5ub3RubFxuICAgIGVsc2UgaWYgYWNjZXB0ICdeJ1xuICAgIHRoZW4gUmUuYm9sXG4gICAgZWxzZSBpZiBhY2NlcHQgJyQnXG4gICAgdGhlbiBSZS5lb2xcbiAgICBlbHNlIGlmIGFjY2VwdCAnWydcbiAgICB0aGVuIGlmIGFjY2VwdCAnXicgdGhlbiBSZS5jb21wbCAoYnJhY2tldCBbXSkgZWxzZSBSZS5hbHQgKGJyYWNrZXQgW10pXG4gICAgZWxzZSBpZiBhY2NlcHQgJ1xcXFwnXG4gICAgdGhlblxuICAgICAgaWYgYWNjZXB0ICcoJ1xuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0MiAnXFxcXCcgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICBSZS5ncm91cCByKVxuICAgICAgZWxzZSBpZiBhY2NlcHQgJ2AnXG4gICAgICB0aGVuIFJlLmJvc1xuICAgICAgZWxzZSBpZiBhY2NlcHQgJ1xcJydcbiAgICAgIHRoZW4gUmUuZW9zXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPSdcbiAgICAgIHRoZW4gUmUuc3RhcnRcbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdiJ1xuICAgICAgdGhlbiBSZS5hbHQgWyBSZS5ib3c7IFJlLmVvdyBdXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnQidcbiAgICAgIHRoZW4gUmUubm90X2JvdW5kYXJ5XG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPCdcbiAgICAgIHRoZW4gUmUuYm93XG4gICAgICBlbHNlIGlmIGFjY2VwdCAnPidcbiAgICAgIHRoZW4gUmUuZW93XG4gICAgICBlbHNlIGlmIGFjY2VwdCAndydcbiAgICAgIHRoZW4gUmUuYWx0IFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF1cbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdXJ1xuICAgICAgdGhlbiBSZS5jb21wbCBbIFJlLmFsbnVtOyBSZS5jaGFyICdfJyBdXG4gICAgICBlbHNlIChcbiAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAgIHwgKCcqJyB8ICcrJyB8ICc/JyB8ICdbJyB8ICddJyB8ICcuJyB8ICdeJyB8ICckJyB8ICdcXFxcJykgYXMgYyAtPiBSZS5jaGFyIGNcbiAgICAgICAgfCAnMCcgLi4gJzknIC0+IHJhaXNlIE5vdF9zdXBwb3J0ZWRcbiAgICAgICAgfCBfIC0+IHJhaXNlIFBhcnNlX2Vycm9yKVxuICAgIGVsc2UgKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAnKicgfCAnKycgfCAnPycgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIHwgYyAtPiBSZS5jaGFyIGMpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IGMgPSBjaGFyICgpIGluXG4gICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICB0aGVuXG4gICAgICAgIGlmIGFjY2VwdCAnXSdcbiAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgYycgPSBjaGFyICgpIGluXG4gICAgICAgICAgYnJhY2tldCAoUmUucmcgYyBjJyA6OiBzKSlcbiAgICAgIGVsc2UgYnJhY2tldCAoUmUuY2hhciBjIDo6IHMpKVxuICBhbmQgY2hhciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgZ2V0ICgpXG4gIGluXG4gIGxldCByZXMgPSByZWdleHAgKCkgaW5cbiAgaWYgbm90IChlb3MgKCkpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gIHJlc1xuOztcblxubGV0IHJlID8oY2FzZSA9IHRydWUpIHMgPVxuICBsZXQgciA9IHBhcnNlIHMgaW5cbiAgaWYgY2FzZSB0aGVuIHIgZWxzZSBSZS5ub19jYXNlIHJcbjs7XG5cbmxldCBjb21waWxlID0gUmUuY29tcGlsZVxubGV0IGNvbXBpbGVfcGF0ID8oY2FzZSA9IHRydWUpIHMgPSBjb21waWxlIChyZSB+Y2FzZSBzKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjQ0MzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9vYmpfdGFnIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIkNhbWxpbnRlcm5hbExhenkiLCJSZV9Db3JlIiwiU3RkbGliIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9CeXRlcyIsIlJlX0VtYWNzIiwiY29tcGlsZV9yZWdleHAiLCJzIiwiYyIsInJlIiwicGFyYW0iLCJzdGF0ZSIsImNzdF9TdHJfcmVwbGFjZV9pbGxlZ2FsX2JhY2tzbCIsImNzdF9TdHJfZ3JvdXBfYmVnaW5uaW5nIiwiY3N0X1N0cl9ncm91cF9lbmQiLCJzdHJpbmdfbWF0Y2giLCJwIiwic3RyaW5nX3BhcnRpYWxfbWF0Y2giLCJtYXRjaCIsInNlYXJjaF9mb3J3YXJkIiwicmVzIiwic2VhcmNoX2JhY2t3YXJkIiwidmFsaWRfZ3JvdXAiLCJuIiwibSIsIm9mZnNldF9ncm91cCIsImkiLCJyZXBsYWNlbWVudF90ZXh0IiwicmVwbCIsIm9yaWciLCJsZW4iLCJxIiwiZSIsImIiLCJkIiwicXVvdGUiLCJidWYiLCJzdHJpbmdfYmVmb3JlIiwic3RyaW5nX2FmdGVyIiwiZmlyc3RfY2hhcnMiLCJsYXN0X2NoYXJzIiwicmVnZXhwIiwicmVnZXhwX2Nhc2VfZm9sZCIsInJlZ2V4cF9zdHJpbmciLCJyZWdleHBfc3RyaW5nX2Nhc2VfZm9sZCIsImdyb3VwX2JlZ2lubmluZyIsInBvcyIsImdyb3VwX2VuZCIsIm1hdGNoZWRfZ3JvdXAiLCJ0eHQiLCJyZXBsYWNlX21hdGNoZWQiLCJtYXRjaGVkIiwibWF0Y2hfYmVnaW5uaW5nIiwibWF0Y2hfZW5kIiwibWF0Y2hlZF9zdHJpbmciLCJzdWJzdGl0dXRlX2ZpcnN0IiwiZXhwciIsInJlcGxfZnVuIiwidGV4dCIsImdsb2JhbF9zdWJzdGl0dXRlIiwiYWNjdSIsInN0YXJ0IiwibGFzdF93YXNfZW1wdHkiLCJzdGFydHBvcyIsImVuZF9wb3MiLCJyZXBsX3RleHQiLCJnbG9iYWxfcmVwbGFjZSIsInJlcGxhY2VfZmlyc3QiLCJzZWFyY2hfZm9yd2FyZF9wcm9ncmVzcyIsImJvdW5kZWRfc3BsaXQiLCJudW0iLCJzcGxpdCIsImJvdW5kZWRfc3BsaXRfZGVsaW0iLCJzcGxpdF9kZWxpbSIsImJvdW5kZWRfZnVsbF9zcGxpdCIsImZ1bGxfc3BsaXQiLCJSZV9TdHIiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9zdHIubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFSLEdBQUFDLElBQUFFLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBbEIsUUFBQTtBQUFBLElBQUFBLE1BQUE7QUFBQSxJQUFBbUIsbUJBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxZQUFBQyxlQUFBQyxHQUFBQztBQUFBQSxRQUFBQyxLQzBCVztBQUFBLElBQ1Q7QUFBQTtBQUFBO0FBQUEsc0JBQUFDO0FBQUFBO0FBQUFBLGVBQUEsT0FBOEI7QUFBQSxjQUF5QjtBQUFBO0FBQUEsaUNEM0J6RCxxQ0MyQkU7QUFBQSxHQUF1RjtBQUFBO0FBQUEsSUFBQUMsUUQzQnpGO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFB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LElBQWdCO0FBQUE7QUFBQSxZQUFBMkIsWUFBQWpCLE1BQUFFO0FBQUFBLElBR3pCLHlDQUErQjtBQUFBO0FBQUEsWUFBQWdCLG1CQUFBbEIsTUFBQUUsTUFBQVk7QUFBQUEsYUFBQUMsTUFBQVgsTUFBQUMsT0FBQXRDO0FBQUFBLEtBUXZELHlDQUNLO0FBQUEsS0FDQSxZQUNLLGdEQUF5QjtBQUFBLEtBQzlCO0FBQUE7QUFBQSxPQUFBdUIsTUFFUztBQUFBLE9BQUF2QyxJQUNGO0FBQUEsTUFDUjtBQUFBO0FBQUEsY0FJSTtBQUFBO0FBQUEsVUFGRjtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUNtQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBR2hCLHlCQUF3QjtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCRHBTckM7QUFBQSw0QkNzUzBCLGdEQUF5QjtBQUFBLE1EdFNuRDtBQUFBO0FBQUEsSUNzUzREO0FBQUEsY0FFakQ7QUFBQSxJQUFnQjtBQUFBO0FBQUEsWUFBQW9FLFdBQUFuQixNQUFBRSxNQUdBLHdDQUE4QjtBQUFBO0FBQUEsSUFBQWtCO0FBQUFBLE1EM1N6RCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqKVxuKCogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqKVxuKCogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAqKVxuKCogIGxpbmtpbmcgZXhjZXB0aW9uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2RpZmllZCBieSBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnIgZm9yIGludGVncmF0aW9uIGluIFJFICopXG5cbigqICRJZDogcmVfc3RyLm1sLHYgMS4zIDIwMDIvMDcvMDMgMTU6NDc6NTQgdm91aWxsb24gRXhwICQgKilcblxubW9kdWxlIFJlID0gQ29yZVxuXG50eXBlIHJlZ2V4cCA9XG4gIHsgcmUgOiBSZS50XG4gIDsgbXRjaCA6IFJlLnJlIExhenkudFxuICA7IHNyY2ggOiBSZS5yZSBMYXp5LnRcbiAgfVxuXG5sZXQgY29tcGlsZV9yZWdleHAgcyBjID1cbiAgbGV0IHJlID0gRW1hY3MucmUgfmNhc2U6KG5vdCBjKSBzIGluXG4gIHsgcmU7IG10Y2ggPSBsYXp5IChSZS5jb21waWxlIChSZS5zZXEgWyBSZS5zdGFydDsgcmUgXSkpOyBzcmNoID0gbGF6eSAoUmUuY29tcGlsZSByZSkgfVxuOztcblxubGV0IHN0YXRlID0gcmVmIE5vbmVcblxubGV0IHN0cmluZ19tYXRjaCByZSBzIHAgPVxuICB0cnlcbiAgICBzdGF0ZSA6PSBTb21lIChSZS5leGVjIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5tdGNoKSBzKTtcbiAgICB0cnVlXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT5cbiAgICBzdGF0ZSA6PSBOb25lO1xuICAgIGZhbHNlXG47O1xuXG5sZXQgc3RyaW5nX3BhcnRpYWxfbWF0Y2ggcmUgcyBwID1cbiAgbWF0Y2ggUmUuZXhlY19wYXJ0aWFsIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5tdGNoKSBzIHdpdGhcbiAgfCBgRnVsbCAtPiBzdHJpbmdfbWF0Y2ggcmUgcyBwXG4gIHwgYFBhcnRpYWwgLT4gdHJ1ZVxuICB8IGBNaXNtYXRjaCAtPiBmYWxzZVxuOztcblxubGV0IHNlYXJjaF9mb3J3YXJkIHJlIHMgcCA9XG4gIHRyeVxuICAgIGxldCByZXMgPSBSZS5leGVjIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5zcmNoKSBzIGluXG4gICAgc3RhdGUgOj0gU29tZSByZXM7XG4gICAgZnN0IChSZS5Hcm91cC5vZmZzZXQgcmVzIDApXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT5cbiAgICBzdGF0ZSA6PSBOb25lO1xuICAgIHJhaXNlIE5vdF9mb3VuZFxuOztcblxubGV0IHJlYyBzZWFyY2hfYmFja3dhcmQgcmUgcyBwID1cbiAgdHJ5XG4gICAgbGV0IHJlcyA9IFJlLmV4ZWMgfnBvczpwIChMYXp5LmZvcmNlIHJlLm10Y2gpIHMgaW5cbiAgICBzdGF0ZSA6PSBTb21lIHJlcztcbiAgICBwXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT5cbiAgICBzdGF0ZSA6PSBOb25lO1xuICAgIGlmIHAgPSAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2Ugc2VhcmNoX2JhY2t3YXJkIHJlIHMgKHAgLSAxKVxuOztcblxubGV0IHZhbGlkX2dyb3VwIG4gPVxuICBuID49IDBcbiAgJiYgbiA8IDEwXG4gICYmXG4gIG1hdGNoICFzdGF0ZSB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgbSAtPiBuIDwgUmUuR3JvdXAubmJfZ3JvdXBzIG1cbjs7XG5cbmxldCBvZmZzZXRfZ3JvdXAgaSA9XG4gIG1hdGNoICFzdGF0ZSB3aXRoXG4gIHwgU29tZSBtIC0+IFJlLkdyb3VwLm9mZnNldCBtIGlcbiAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZFxuOztcblxubGV0IGdyb3VwX2xlbiBpID1cbiAgdHJ5XG4gICAgbGV0IGIsIGUgPSBvZmZzZXRfZ3JvdXAgaSBpblxuICAgIGUgLSBiXG4gIHdpdGhcbiAgfCBOb3RfZm91bmQgLT4gMFxuOztcblxubGV0IHJlYyByZXBsX2xlbmd0aCByZXBsIHAgcSBsZW4gPVxuICBpZiBwIDwgbGVuXG4gIHRoZW5cbiAgICBpZiByZXBsLltwXSA8PiAnXFxcXCdcbiAgICB0aGVuIHJlcGxfbGVuZ3RoIHJlcGwgKHAgKyAxKSAocSArIDEpIGxlblxuICAgIGVsc2UgKFxuICAgICAgbGV0IHAgPSBwICsgMSBpblxuICAgICAgaWYgcCA9IGxlbiB0aGVuIGZhaWx3aXRoIFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCI7XG4gICAgICBsZXQgcSA9XG4gICAgICAgIG1hdGNoIHJlcGwuW3BdIHdpdGhcbiAgICAgICAgfCAnXFxcXCcgLT4gcSArIDFcbiAgICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gcSArIGdyb3VwX2xlbiAoQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnKVxuICAgICAgICB8IF8gLT4gcSArIDJcbiAgICAgIGluXG4gICAgICByZXBsX2xlbmd0aCByZXBsIChwICsgMSkgcSBsZW4pXG4gIGVsc2UgcVxuOztcblxubGV0IHJlYyByZXBsYWNlIG9yaWcgcmVwbCBwIHJlcyBxIGxlbiA9XG4gIGlmIHAgPCBsZW5cbiAgdGhlbiAoXG4gICAgbGV0IGMgPSByZXBsLltwXSBpblxuICAgIGlmIGMgPD4gJ1xcXFwnXG4gICAgdGhlbiAoXG4gICAgICBCeXRlcy5zZXQgcmVzIHEgYztcbiAgICAgIHJlcGxhY2Ugb3JpZyByZXBsIChwICsgMSkgcmVzIChxICsgMSkgbGVuKVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcmVwbC5bcCArIDFdIHdpdGhcbiAgICAgIHwgJ1xcXFwnIC0+XG4gICAgICAgIEJ5dGVzLnNldCByZXMgcSAnXFxcXCc7XG4gICAgICAgIHJlcGxhY2Ugb3JpZyByZXBsIChwICsgMikgcmVzIChxICsgMSkgbGVuXG4gICAgICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgICAgICBsZXQgZCA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQgYiwgZSA9IG9mZnNldF9ncm91cCAoQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnKSBpblxuICAgICAgICAgICAgbGV0IGQgPSBlIC0gYiBpblxuICAgICAgICAgICAgaWYgZCA+IDAgdGhlbiBTdHJpbmcuYmxpdCBvcmlnIGIgcmVzIHEgZDtcbiAgICAgICAgICAgIGRcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBOb3RfZm91bmQgLT4gMFxuICAgICAgICBpblxuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIGQpIGxlblxuICAgICAgfCBjIC0+XG4gICAgICAgIEJ5dGVzLnNldCByZXMgcSAnXFxcXCc7XG4gICAgICAgIEJ5dGVzLnNldCByZXMgKHEgKyAxKSBjO1xuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIDIpIGxlbikpXG47O1xuXG5sZXQgcmVwbGFjZW1lbnRfdGV4dCByZXBsIG9yaWcgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCByZXBsIGluXG4gIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgKHJlcGxfbGVuZ3RoIHJlcGwgMCAwIGxlbikgaW5cbiAgcmVwbGFjZSBvcmlnIHJlcGwgMCByZXMgMCAoU3RyaW5nLmxlbmd0aCByZXBsKTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbjs7XG5cbmxldCBxdW90ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAoMiAqIGxlbikgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgfCAoJ1snIHwgJ10nIHwgJyonIHwgJy4nIHwgJ1xcXFwnIHwgJz8nIHwgJysnIHwgJ14nIHwgJyQnKSBhcyBjIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJztcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgIHwgYyAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgZG9uZTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuOztcblxubGV0IHN0cmluZ19iZWZvcmUgcyBuID0gU3RyaW5nLnN1YiBzIDAgblxubGV0IHN0cmluZ19hZnRlciBzIG4gPSBTdHJpbmcuc3ViIHMgbiAoU3RyaW5nLmxlbmd0aCBzIC0gbilcbmxldCBmaXJzdF9jaGFycyBzIG4gPSBTdHJpbmcuc3ViIHMgMCBuXG5sZXQgbGFzdF9jaGFycyBzIG4gPSBTdHJpbmcuc3ViIHMgKFN0cmluZy5sZW5ndGggcyAtIG4pIG5cbmxldCByZWdleHAgZSA9IGNvbXBpbGVfcmVnZXhwIGUgZmFsc2VcbmxldCByZWdleHBfY2FzZV9mb2xkIGUgPSBjb21waWxlX3JlZ2V4cCBlIHRydWVcbmxldCByZWdleHBfc3RyaW5nIHMgPSBjb21waWxlX3JlZ2V4cCAocXVvdGUgcykgZmFsc2VcbmxldCByZWdleHBfc3RyaW5nX2Nhc2VfZm9sZCBzID0gY29tcGlsZV9yZWdleHAgKHF1b3RlIHMpIHRydWVcblxubGV0IGdyb3VwX2JlZ2lubmluZyBuID1cbiAgaWYgbm90ICh2YWxpZF9ncm91cCBuKSB0aGVuIGludmFsaWRfYXJnIFwiU3RyLmdyb3VwX2JlZ2lubmluZ1wiO1xuICBsZXQgcG9zID0gZnN0IChvZmZzZXRfZ3JvdXAgbikgaW5cbiAgaWYgcG9zID0gLTEgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZSBwb3Ncbjs7XG5cbmxldCBncm91cF9lbmQgbiA9XG4gIGlmIG5vdCAodmFsaWRfZ3JvdXAgbikgdGhlbiBpbnZhbGlkX2FyZyBcIlN0ci5ncm91cF9lbmRcIjtcbiAgbGV0IHBvcyA9IHNuZCAob2Zmc2V0X2dyb3VwIG4pIGluXG4gIGlmIHBvcyA9IC0xIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2UgcG9zXG47O1xuXG5sZXQgbWF0Y2hlZF9ncm91cCBuIHR4dCA9XG4gIGxldCBiLCBlID0gb2Zmc2V0X2dyb3VwIG4gaW5cbiAgU3RyaW5nLnN1YiB0eHQgYiAoZSAtIGIpXG47O1xuXG5sZXQgcmVwbGFjZV9tYXRjaGVkIHJlcGwgbWF0Y2hlZCA9IHJlcGxhY2VtZW50X3RleHQgcmVwbCBtYXRjaGVkXG5cbmxldCBtYXRjaF9iZWdpbm5pbmcgKCkgPSBncm91cF9iZWdpbm5pbmcgMFxuYW5kIG1hdGNoX2VuZCAoKSA9IGdyb3VwX2VuZCAwXG5hbmQgbWF0Y2hlZF9zdHJpbmcgdHh0ID0gbWF0Y2hlZF9ncm91cCAwIHR4dFxuXG5sZXQgc3Vic3RpdHV0ZV9maXJzdCBleHByIHJlcGxfZnVuIHRleHQgPVxuICB0cnlcbiAgICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmQgZXhwciB0ZXh0IDAgaW5cbiAgICBTdHJpbmcuY29uY2F0XG4gICAgICBcIlwiXG4gICAgICBbIHN0cmluZ19iZWZvcmUgdGV4dCBwb3M7IHJlcGxfZnVuIHRleHQ7IHN0cmluZ19hZnRlciB0ZXh0IChtYXRjaF9lbmQgKCkpIF1cbiAgd2l0aFxuICB8IE5vdF9mb3VuZCAtPiB0ZXh0XG47O1xuXG5sZXQgZ2xvYmFsX3N1YnN0aXR1dGUgZXhwciByZXBsX2Z1biB0ZXh0ID1cbiAgbGV0IHJlYyByZXBsYWNlIGFjY3Ugc3RhcnQgbGFzdF93YXNfZW1wdHkgPVxuICAgIGxldCBzdGFydHBvcyA9IGlmIGxhc3Rfd2FzX2VtcHR5IHRoZW4gc3RhcnQgKyAxIGVsc2Ugc3RhcnQgaW5cbiAgICBpZiBzdGFydHBvcyA+IFN0cmluZy5sZW5ndGggdGV4dFxuICAgIHRoZW4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggc2VhcmNoX2ZvcndhcmQgZXhwciB0ZXh0IHN0YXJ0cG9zIHdpdGhcbiAgICAgIHwgcG9zIC0+XG4gICAgICAgIGxldCBlbmRfcG9zID0gbWF0Y2hfZW5kICgpIGluXG4gICAgICAgIGxldCByZXBsX3RleHQgPSByZXBsX2Z1biB0ZXh0IGluXG4gICAgICAgIHJlcGxhY2VcbiAgICAgICAgICAocmVwbF90ZXh0IDo6IFN0cmluZy5zdWIgdGV4dCBzdGFydCAocG9zIC0gc3RhcnQpIDo6IGFjY3UpXG4gICAgICAgICAgZW5kX3Bvc1xuICAgICAgICAgIChlbmRfcG9zID0gcG9zKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IHN0cmluZ19hZnRlciB0ZXh0IHN0YXJ0IDo6IGFjY3UpXG4gIGluXG4gIFN0cmluZy5jb25jYXQgXCJcIiAoTGlzdC5yZXYgKHJlcGxhY2UgW10gMCBmYWxzZSkpXG47O1xuXG5sZXQgZ2xvYmFsX3JlcGxhY2UgZXhwciByZXBsIHRleHQgPSBnbG9iYWxfc3Vic3RpdHV0ZSBleHByIChyZXBsYWNlbWVudF90ZXh0IHJlcGwpIHRleHRcbmFuZCByZXBsYWNlX2ZpcnN0IGV4cHIgcmVwbCB0ZXh0ID0gc3Vic3RpdHV0ZV9maXJzdCBleHByIChyZXBsYWNlbWVudF90ZXh0IHJlcGwpIHRleHRcblxubGV0IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIHJlIHMgcCA9XG4gIGxldCBwb3MgPSBzZWFyY2hfZm9yd2FyZCByZSBzIHAgaW5cbiAgaWYgbWF0Y2hfZW5kICgpID4gcFxuICB0aGVuIHBvc1xuICBlbHNlIGlmIHAgPCBTdHJpbmcubGVuZ3RoIHNcbiAgdGhlbiBzZWFyY2hfZm9yd2FyZCByZSBzIChwICsgMSlcbiAgZWxzZSByYWlzZSBOb3RfZm91bmRcbjs7XG5cbmxldCBib3VuZGVkX3NwbGl0IGV4cHIgdGV4dCBudW0gPVxuICBsZXQgc3RhcnQgPSBpZiBzdHJpbmdfbWF0Y2ggZXhwciB0ZXh0IDAgdGhlbiBtYXRjaF9lbmQgKCkgZWxzZSAwIGluXG4gIGxldCByZWMgc3BsaXQgYWNjdSBzdGFydCBuID1cbiAgICBpZiBzdGFydCA+PSBTdHJpbmcubGVuZ3RoIHRleHRcbiAgICB0aGVuIGFjY3VcbiAgICBlbHNlIGlmIG4gPSAxXG4gICAgdGhlbiBzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCA6OiBhY2N1XG4gICAgZWxzZSAoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3MgLSBzdGFydCkgOjogYWNjdSkgKG1hdGNoX2VuZCAoKSkgKG4gLSAxKVxuICAgICAgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdSlcbiAgaW5cbiAgTGlzdC5yZXYgKHNwbGl0IFtdIHN0YXJ0IG51bSlcbjs7XG5cbmxldCBzcGxpdCBleHByIHRleHQgPSBib3VuZGVkX3NwbGl0IGV4cHIgdGV4dCAwXG5cbmxldCBib3VuZGVkX3NwbGl0X2RlbGltIGV4cHIgdGV4dCBudW0gPVxuICBsZXQgcmVjIHNwbGl0IGFjY3Ugc3RhcnQgbiA9XG4gICAgaWYgc3RhcnQgPiBTdHJpbmcubGVuZ3RoIHRleHRcbiAgICB0aGVuIGFjY3VcbiAgICBlbHNlIGlmIG4gPSAxXG4gICAgdGhlbiBzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCA6OiBhY2N1XG4gICAgZWxzZSAoXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3MgLSBzdGFydCkgOjogYWNjdSkgKG1hdGNoX2VuZCAoKSkgKG4gLSAxKVxuICAgICAgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQgOjogYWNjdSlcbiAgaW5cbiAgaWYgdGV4dCA9IFwiXCIgdGhlbiBbXSBlbHNlIExpc3QucmV2IChzcGxpdCBbXSAwIG51bSlcbjs7XG5cbmxldCBzcGxpdF9kZWxpbSBleHByIHRleHQgPSBib3VuZGVkX3NwbGl0X2RlbGltIGV4cHIgdGV4dCAwXG5cbnR5cGUgc3BsaXRfcmVzdWx0ID1cbiAgfCBUZXh0IG9mIHN0cmluZ1xuICB8IERlbGltIG9mIHN0cmluZ1xuXG5sZXQgYm91bmRlZF9mdWxsX3NwbGl0IGV4cHIgdGV4dCBudW0gPVxuICBsZXQgcmVjIHNwbGl0IGFjY3Ugc3RhcnQgbiA9XG4gICAgaWYgc3RhcnQgPj0gU3RyaW5nLmxlbmd0aCB0ZXh0XG4gICAgdGhlbiBhY2N1XG4gICAgZWxzZSBpZiBuID0gMVxuICAgIHRoZW4gVGV4dCAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3VcbiAgICBlbHNlIChcbiAgICAgIHRyeVxuICAgICAgICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmRfcHJvZ3Jlc3MgZXhwciB0ZXh0IHN0YXJ0IGluXG4gICAgICAgIGxldCBzID0gbWF0Y2hlZF9zdHJpbmcgdGV4dCBpblxuICAgICAgICBpZiBwb3MgPiBzdGFydFxuICAgICAgICB0aGVuXG4gICAgICAgICAgc3BsaXRcbiAgICAgICAgICAgIChEZWxpbSBzIDo6IFRleHQgKFN0cmluZy5zdWIgdGV4dCBzdGFydCAocG9zIC0gc3RhcnQpKSA6OiBhY2N1KVxuICAgICAgICAgICAgKG1hdGNoX2VuZCAoKSlcbiAgICAgICAgICAgIChuIC0gMSlcbiAgICAgICAgZWxzZSBzcGxpdCAoRGVsaW0gcyA6OiBhY2N1KSAobWF0Y2hfZW5kICgpKSAobiAtIDEpXG4gICAgICB3aXRoXG4gICAgICB8IE5vdF9mb3VuZCAtPiBUZXh0IChzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCkgOjogYWNjdSlcbiAgaW5cbiAgTGlzdC5yZXYgKHNwbGl0IFtdIDAgbnVtKVxuOztcblxubGV0IGZ1bGxfc3BsaXQgZXhwciB0ZXh0ID0gYm91bmRlZF9mdWxsX3NwbGl0IGV4cHIgdGV4dCAwXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDk3MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0X1JlX3JlcGxhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsNCIsImEyIiwiYTMiLCJjYW1sX2NhbGw2IiwiYTQiLCJhNSIsImdsb2JhbF9kYXRhIiwiUmVfQ29tcGlsZSIsIlN0ZGxpYl9CdWZmZXIiLCJSZV9Hcm91cCIsIlN0ZGxpYiIsInJlcGxhY2UiLCJsZW4iLCJvcHQiLCJyZSIsInMiLCJwb3MiLCJhbGwiLCJsIiwibGltaXQiLCJidWYiLCJvbl9tYXRjaCIsIm1hdGNoIiwic3Vic3RyIiwicDIiLCJwMSIsInJlcGxhY2luZyIsInJlcGxhY2Vfc3RyaW5nIiwiYnkiLCJwYXJhbSIsIlJlX1JlcGxhY2UiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9yZXBsYWNlLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxrQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFQLEdBQUFDLElBQUFFLElBQUFFLElBQUFDLElBQUFFLElBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFsQixpQkFBQTtBQUFBLElBQUFBLG1CQUFBO0FBQUEsWUFBQW1CLFFBQUEsS0FBQUMsS0FBQUMsS0FBQUMsSUFBQWxCLEdBQUFtQjtBQUFBQSxRQUFBQyxNQ0FZLGtCQUFBQyxNQUFBO0FBQUEsSUFDVixZQUFnQjtBQUFBLElBQ2hCO0FBQUE7QUFBQSxNQUFBQyxJQUFBO0FBQUEsWUFJSTtBQUFBO0FBQUEsYUFBMkM7QUFBQSxTQUFBQyxRQUMzQztBQUFBO0FBQUE7QUFBQSxTQUFBQSxRQUhRO0FBQUE7QUFBQSxLQUFBQyxNQU1GLDZCQUFWO0FBQUEsS0FBQUosUUFxQ0E7QUFBQSxLQUFBSyxXQUFBO0FBQUE7QUFBQSxLQWxDRTtBQUFBO0FBQUEsT0FBQUM7QUFBQUEsU0FHSTtBQUFBLE1BQTBFO0FBQUEsT0E2QmhFO0FBQUE7QUFBQTtBQUFBLFFBQUFDLFNBN0JnRTtBQUFBLFFBQUFELFVBRzdEO0FBQUEsUUFBQUUsS0FBcUI7QUFBQSxRQUFBQyxLQUFBO0FBQUEsT0FDbEM7QUFBQSxRQUNLO0FBQUEsbUJBR29DO0FBQUEsU0FBcEI7QUFBQTtBQUFBLFlBQUFULFFBQ25CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQUdBO0FBQUEsV0FBQVUsWUFFZ0I7QUFBQSxPQUNoQjtBQUFBLE9BQStCO0FBQUEsWUFBQUwsYUFJN0I7QUFBQTtBQUFBLFNBRVE7QUFBQSxvQkFFb0M7QUFBQSxVQUFwQjtBQUFBO0FBQUEsYUFBQUwsUUFDbkI7QUFBQTtBQUFBO0FBQUEsYUFBQUEsUUFDRztBQUFBLFFBTlI7QUFBQTtBQUFBO0FBQUE7QUFBQSxPQVFHO0FBQUE7QUFBQTtBQUFBLEtBSUMsd0NBQ0s7QUFBQTtBQUFBO0FBQUEsWUFBQVcsZUFBQVgsS0FBQUosS0FBQUssS0FBQUgsSUFBQWMsSUFBQWI7QUFBQUEsSUFHd0IsMkNBQUFjLE9BQXlDLFVBQUUsS0FBQztBQUFBO0FBQUEsT0FBQUMsYURuRHpGIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJsZXQgcmVwbGFjZSA/KHBvcyA9IDApID9sZW4gPyhhbGwgPSB0cnVlKSByZSB+ZiBzID1cbiAgaWYgcG9zIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiUmUucmVwbGFjZVwiO1xuICBsZXQgbGltaXQgPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc1xuICAgIHwgU29tZSBsIC0+XG4gICAgICBpZiBsIDwgMCB8fCBwb3MgKyBsID4gU3RyaW5nLmxlbmd0aCBzIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5yZXBsYWNlXCI7XG4gICAgICBwb3MgKyBsXG4gIGluXG4gICgqIGJ1ZmZlciBpbnRvIHdoaWNoIHdlIHdyaXRlIHRoZSByZXN1bHQgKilcbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcykgaW5cbiAgKCogaXRlcmF0ZSBvbiBtYXRjaGVkIHN1YnN0cmluZ3MuICopXG4gIGxldCByZWMgaXRlciBwb3Mgb25fbWF0Y2ggPVxuICAgIGlmIHBvcyA8PSBsaW1pdFxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2hcbiAgICAgICAgQ29tcGlsZS5tYXRjaF9zdHIgfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOmZhbHNlIHJlIHMgfnBvcyB+bGVuOihsaW1pdCAtIHBvcylcbiAgICAgIHdpdGhcbiAgICAgIHwgTWF0Y2ggc3Vic3RyIC0+XG4gICAgICAgIGxldCBwMSwgcDIgPSBHcm91cC5vZmZzZXQgc3Vic3RyIDAgaW5cbiAgICAgICAgaWYgcG9zID0gcDEgJiYgcDEgPSBwMiAmJiBvbl9tYXRjaFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBpZiB3ZSBtYXRjaGVkIGFuIGVtcHR5IHN0cmluZyByaWdodCBhZnRlciBhIG1hdGNoLFxuICAgICAgICAgICAgIHdlIG11c3QgbWFudWFsbHkgYWR2YW5jZSBieSAxICopXG4gICAgICAgICAgaWYgcDIgPCBsaW1pdCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgcy5bcDJdO1xuICAgICAgICAgIGl0ZXIgKHAyICsgMSkgZmFsc2UpXG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGFkZCBzdHJpbmcgYmV0d2VlbiBwcmV2aW91cyBtYXRjaCBhbmQgY3VycmVudCBtYXRjaCAqKVxuICAgICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzIHBvcyAocDEgLSBwb3MpO1xuICAgICAgICAgICgqIHdoYXQgc2hvdWxkIHdlIHJlcGxhY2UgdGhlIG1hdGNoZWQgZ3JvdXAgd2l0aD8gKilcbiAgICAgICAgICBsZXQgcmVwbGFjaW5nID0gZiBzdWJzdHIgaW5cbiAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgcmVwbGFjaW5nO1xuICAgICAgICAgIGlmIGFsbFxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICgqIGlmIHdlIG1hdGNoZWQgYW4gZW1wdHkgc3RyaW5nLCB3ZSBtdXN0IG1hbnVhbGx5IGFkdmFuY2UgYnkgMSAqKVxuICAgICAgICAgICAgaXRlclxuICAgICAgICAgICAgICAoaWYgcDEgPSBwMlxuICAgICAgICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICAgICAgICgqIGEgbm9uIGNoYXIgY291bGQgYmUgcGFzdCB0aGUgZW5kIG9mIHN0cmluZy4gZS5nLiAkICopXG4gICAgICAgICAgICAgICAgIGlmIHAyIDwgbGltaXQgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmIHMuW3AyXTtcbiAgICAgICAgICAgICAgICAgcDIgKyAxKVxuICAgICAgICAgICAgICAgZWxzZSBwMilcbiAgICAgICAgICAgICAgKHAxIDw+IHAyKVxuICAgICAgICAgIGVsc2UgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHMgcDIgKGxpbWl0IC0gcDIpKVxuICAgICAgfCBSdW5uaW5nIF8gLT4gKClcbiAgICAgIHwgRmFpbGVkIC0+IEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzIHBvcyAobGltaXQgLSBwb3MpKVxuICBpblxuICBpdGVyIHBvcyBmYWxzZTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuOztcblxubGV0IHJlcGxhY2Vfc3RyaW5nID9wb3MgP2xlbiA/YWxsIHJlIH5ieSBzID0gcmVwbGFjZSA/cG9zID9sZW4gP2FsbCByZSBzIH5mOihmdW4gXyAtPiBieSlcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1MDg0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJiZWciLCJSZV9Db3JlIiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfU3RyaW5nIiwiU3RkbGliIiwiUmVfUGFyc2VfYnVmZmVyIiwiUGFyc2VfZXJyb3IiLCJtdWwiLCJsIiwicyIsImV4cGxpY2l0X3BlcmlvZCIsInQiLCJzbGFzaGVzIiwiYXBwZW5kIiwib3B0IiwicGllY2UiLCJhbV9hdF9zdGFydF9vZl9jb21wb25lbnQiLCJuZXh0IiwibWF0Y2giLCJyZW1haW5pbmciLCJvbmUiLCJleHBsaWNpdF9zbGFzaCIsImVuY2xvc2VkIiwiYyIsImhpZ2giLCJsb3ciLCJlbmNsb3NlZF9zZXQiLCJraW5kIiwic2V0IiwiZW5jbG9zdXJlIiwiZXhhY3RseSIsInN0YXRlIiwiY2hhcnMiLCJtYW55X21hbnkiLCJmaXJzdF9leHBsaWNpdF9wZXJpb2QiLCJtYXRjaF9jb21wb25lbnQiLCJnbG9iIiwic3RyIiwiYW5jaG9yZWQiLCJwYXRobmFtZSIsIm1hdGNoX2JhY2tzbGFzaGVzIiwicGVyaW9kIiwiZXhwYW5kX2JyYWNlcyIsImRvdWJsZV9hc3RlcmlzayIsInRvX3JlIiwiYnVmIiwiZW9zIiwicGFyYW0iLCJyZWFkIiwiY2hhciIsInBpZWNlcyIsInJlIiwibm90X2VtcHR5IiwibWF5YmVfZW1wdHkiLCJleHBsIiwiaW5uZXIiLCJpIiwiYWNjIiwiZ2xvYngiLCJSZV9HbG9iIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvcmUvZ2xvYi5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQVYsTUFBQTtBQUFBLElBQUFXLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLElBQUFDLEtBQUFBO0FBQUFBO0FBQUFBLEtBQUE7QUFBQSxPQ29GNEI7QUFBQTtBQUFBLGtCQUFBQztBQUFBQSxVQUFvQjtBQUFBO0FBQUEsNEJBQUFBLEtBQW9CLHFDQUFNO0FBQUEscUJBQUk7QUFBQTtBQUFBO0FBQUEsSUFBSTtB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bnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG5tb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIGVuY2xvc2VkID1cbiAgfCBDaGFyIG9mIGNoYXJcbiAgfCBSYW5nZSBvZiBjaGFyICogY2hhclxuXG50eXBlIHBpZWNlID1cbiAgfCBFeGFjdGx5IG9mIGNoYXJcbiAgfCBBbnlfb2Ygb2YgZW5jbG9zZWQgbGlzdFxuICB8IEFueV9idXQgb2YgZW5jbG9zZWQgbGlzdFxuICB8IE9uZVxuICB8IE1hbnlcbiAgfCBNYW55TWFueVxuXG50eXBlIHQgPSBwaWVjZSBsaXN0XG5cbmxldCBvZl9zdHJpbmcgfmRvdWJsZV9hc3RlcmlzayBzIDogdCA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGVvcyAoKSA9IFBhcnNlX2J1ZmZlci5lb3MgYnVmIGluXG4gIGxldCByZWFkIGMgPSBQYXJzZV9idWZmZXIuYWNjZXB0IGJ1ZiBjIGluXG4gIGxldCBjaGFyICgpID1cbiAgICBpZ25vcmUgKHJlYWQgJ1xcXFwnIDogYm9vbCk7XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgUGFyc2VfYnVmZmVyLmdldCBidWZcbiAgaW5cbiAgbGV0IGVuY2xvc2VkICgpIDogZW5jbG9zZWQgbGlzdCA9XG4gICAgbGV0IHJlYyBsb29wIHMgPVxuICAgICAgKCogVGhpcyByZXR1cm5zIHRoZSBsaXN0IGluIHJldmVyc2Ugb3JkZXIsIGJ1dCBvcmRlciBpc24ndCBpbXBvcnRhbnRcbiAgICAgICAgIGFueXdheSAqKVxuICAgICAgaWYgcyA8PiBbXSAmJiByZWFkICddJ1xuICAgICAgdGhlbiBzXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGMgPSBjaGFyICgpIGluXG4gICAgICAgIGlmIG5vdCAocmVhZCAnLScpXG4gICAgICAgIHRoZW4gbG9vcCAoQ2hhciBjIDo6IHMpXG4gICAgICAgIGVsc2UgaWYgcmVhZCAnXSdcbiAgICAgICAgdGhlbiBDaGFyIGMgOjogQ2hhciAnLScgOjogc1xuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgYycgPSBjaGFyICgpIGluXG4gICAgICAgICAgbG9vcCAoUmFuZ2UgKGMsIGMnKSA6OiBzKSkpXG4gICAgaW5cbiAgICBsb29wIFtdXG4gIGluXG4gIGxldCBwaWVjZSBhY2MgPVxuICAgIGlmIGRvdWJsZV9hc3RlcmlzayAmJiBQYXJzZV9idWZmZXIuYWNjZXB0X3MgYnVmIFwiLyoqXCJcbiAgICB0aGVuIE1hbnlNYW55IDo6IChpZiBlb3MgKCkgdGhlbiBFeGFjdGx5ICcvJyA6OiBhY2MgZWxzZSBhY2MpXG4gICAgZWxzZSBpZiByZWFkICcqJ1xuICAgIHRoZW4gKGlmIGRvdWJsZV9hc3RlcmlzayAmJiByZWFkICcqJyB0aGVuIE1hbnlNYW55IGVsc2UgTWFueSkgOjogYWNjXG4gICAgZWxzZSBpZiByZWFkICc/J1xuICAgIHRoZW4gT25lIDo6IGFjY1xuICAgIGVsc2UgaWYgbm90IChyZWFkICdbJylcbiAgICB0aGVuIEV4YWN0bHkgKGNoYXIgKCkpIDo6IGFjY1xuICAgIGVsc2UgaWYgcmVhZCAnXicgfHwgcmVhZCAnISdcbiAgICB0aGVuIEFueV9idXQgKGVuY2xvc2VkICgpKSA6OiBhY2NcbiAgICBlbHNlIEFueV9vZiAoZW5jbG9zZWQgKCkpIDo6IGFjY1xuICBpblxuICBsZXQgcmVjIGxvb3AgcGllY2VzID0gaWYgZW9zICgpIHRoZW4gTGlzdC5yZXYgcGllY2VzIGVsc2UgbG9vcCAocGllY2UgcGllY2VzKSBpblxuICBsb29wIFtdXG47O1xuXG5sZXQgbXVsIGwgbCcgPSBMaXN0LmZsYXR0ZW4gKExpc3QubWFwIChmdW4gcyAtPiBMaXN0Lm1hcCAoZnVuIHMnIC0+IHMgXiBzJykgbCcpIGwpXG5cbmxldCBleHBsb2RlIHN0ciA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlYyBleHBsIGlubmVyIHMgaSBhY2MgYmVnID1cbiAgICBpZiBpID49IGxcbiAgICB0aGVuIChcbiAgICAgIGlmIGlubmVyIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtdWwgYmVnIFsgU3RyaW5nLnN1YiBzdHIgcyAoaSAtIHMpIF0sIGkpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXFwnIC0+IGV4cGwgaW5uZXIgcyAoaSArIDIpIGFjYyBiZWdcbiAgICAgIHwgJ3snIC0+XG4gICAgICAgIGxldCB0LCBpJyA9IGV4cGwgdHJ1ZSAoaSArIDEpIChpICsgMSkgW10gWyBcIlwiIF0gaW5cbiAgICAgICAgZXhwbCBpbm5lciBpJyBpJyBhY2MgKG11bCBiZWcgKG11bCBbIFN0cmluZy5zdWIgc3RyIHMgKGkgLSBzKSBdIHQpKVxuICAgICAgfCAnLCcgd2hlbiBpbm5lciAtPlxuICAgICAgICBleHBsIGlubmVyIChpICsgMSkgKGkgKyAxKSAobXVsIGJlZyBbIFN0cmluZy5zdWIgc3RyIHMgKGkgLSBzKSBdIEAgYWNjKSBbIFwiXCIgXVxuICAgICAgfCAnfScgd2hlbiBpbm5lciAtPiBtdWwgYmVnIFsgU3RyaW5nLnN1YiBzdHIgcyAoaSAtIHMpIF0gQCBhY2MsIGkgKyAxXG4gICAgICB8IF8gLT4gZXhwbCBpbm5lciBzIChpICsgMSkgYWNjIGJlZylcbiAgaW5cbiAgTGlzdC5yZXYgKGZzdCAoZXhwbCBmYWxzZSAwIDAgW10gWyBcIlwiIF0pKVxuOztcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgeyByZV9waWVjZXMgOiBSZS50IGxpc3QgKCogbGFzdCBwaWVjZSBhdCBoZWFkIG9mIGxpc3QuICopXG4gICAgOyByZW1haW5pbmcgOiBwaWVjZSBsaXN0ICgqIGxhc3QgcGllY2UgYXQgdGFpbCBvZiBsaXN0LiAqKVxuICAgIDsgYW1fYXRfc3RhcnRfb2ZfcGF0dGVybiA6IGJvb2wgKCogdHJ1ZSBhdCBzdGFydCBvZiBwYXR0ZXJuICopXG4gICAgOyBhbV9hdF9zdGFydF9vZl9jb21wb25lbnQgOiBib29sXG4gICAgICAgICgqIHRydWUgYXQgc3RhcnQgb2YgcGF0dGVybiBvciBpbW1lZGlhdGVseVxuICAgICAgICAgICBhZnRlciAnLycgKilcbiAgICA7IHBhdGhuYW1lIDogYm9vbFxuICAgIDsgbWF0Y2hfYmFja3NsYXNoZXMgOiBib29sXG4gICAgOyBwZXJpb2QgOiBib29sXG4gICAgfVxuXG4gIGxldCBjcmVhdGUgfnBlcmlvZCB+cGF0aG5hbWUgfm1hdGNoX2JhY2tzbGFzaGVzIHJlbWFpbmluZyA9XG4gICAgeyByZV9waWVjZXMgPSBbXVxuICAgIDsgYW1fYXRfc3RhcnRfb2ZfcGF0dGVybiA9IHRydWVcbiAgICA7IGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCA9IHRydWVcbiAgICA7IHBhdGhuYW1lXG4gICAgOyBtYXRjaF9iYWNrc2xhc2hlc1xuICAgIDsgcGVyaW9kXG4gICAgOyByZW1haW5pbmdcbiAgICB9XG4gIDs7XG5cbiAgbGV0IGV4cGxpY2l0X3BlcmlvZCB0ID1cbiAgICB0LnBlcmlvZCAmJiAodC5hbV9hdF9zdGFydF9vZl9wYXR0ZXJuIHx8ICh0LmFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCAmJiB0LnBhdGhuYW1lKSlcbiAgOztcblxuICBsZXQgZXhwbGljaXRfc2xhc2ggdCA9IHQucGF0aG5hbWVcbiAgbGV0IHNsYXNoZXMgdCA9IGlmIHQubWF0Y2hfYmFja3NsYXNoZXMgdGhlbiBbICcvJzsgJ1xcXFwnIF0gZWxzZSBbICcvJyBdXG5cbiAgbGV0IGFwcGVuZCA/KGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCA9IGZhbHNlKSB0IHBpZWNlID1cbiAgICB7IHQgd2l0aFxuICAgICAgcmVfcGllY2VzID0gcGllY2UgOjogdC5yZV9waWVjZXNcbiAgICA7IGFtX2F0X3N0YXJ0X29mX3BhdHRlcm4gPSBmYWxzZVxuICAgIDsgYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50XG4gICAgfVxuICA7O1xuXG4gIGxldCB0b19yZSB0ID0gUmUuc2VxIChMaXN0LnJldiB0LnJlX3BpZWNlcylcblxuICBsZXQgbmV4dCB0ID1cbiAgICBtYXRjaCB0LnJlbWFpbmluZyB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBwaWVjZSA6OiByZW1haW5pbmcgLT4gU29tZSAocGllY2UsIHsgdCB3aXRoIHJlbWFpbmluZyB9KVxuICA7O1xuZW5kXG5cbmxldCBvbmUgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QgPVxuICBSZS5jb21wbFxuICAgIChMaXN0LmNvbmNhdFxuICAgICAgIFsgKGlmIGV4cGxpY2l0X3NsYXNoIHRoZW4gTGlzdC5tYXAgUmUuY2hhciBzbGFzaGVzIGVsc2UgW10pXG4gICAgICAgOyAoaWYgZXhwbGljaXRfcGVyaW9kIHRoZW4gWyBSZS5jaGFyICcuJyBdIGVsc2UgW10pXG4gICAgICAgXSlcbjs7XG5cbmxldCBlbmNsb3NlZCBlbmNsb3NlZCA9XG4gIG1hdGNoIGVuY2xvc2VkIHdpdGhcbiAgfCBDaGFyIGMgLT4gUmUuY2hhciBjXG4gIHwgUmFuZ2UgKGxvdywgaGlnaCkgLT4gUmUucmcgbG93IGhpZ2hcbjs7XG5cbmxldCBlbmNsb3NlZF9zZXQgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Qga2luZCBzZXQgPVxuICBsZXQgc2V0ID0gTGlzdC5tYXAgZW5jbG9zZWQgc2V0IGluXG4gIGxldCBlbmNsb3N1cmUgPVxuICAgIG1hdGNoIGtpbmQgd2l0aFxuICAgIHwgYEFueV9vZiAtPiBSZS5hbHQgc2V0XG4gICAgfCBgQW55X2J1dCAtPiBSZS5jb21wbCBzZXRcbiAgaW5cbiAgUmUuaW50ZXIgWyBlbmNsb3N1cmU7IG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZCBdXG47O1xuXG5sZXQgZXhhY3RseSBzdGF0ZSBjID1cbiAgbGV0IHNsYXNoZXMgPSBTdGF0ZS5zbGFzaGVzIHN0YXRlIGluXG4gIGxldCBhbV9hdF9zdGFydF9vZl9jb21wb25lbnQgPSBMaXN0Lm1lbSBjIHNsYXNoZXMgaW5cbiAgbGV0IGNoYXJzID0gaWYgYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50IHRoZW4gc2xhc2hlcyBlbHNlIFsgYyBdIGluXG4gIFN0YXRlLmFwcGVuZCBzdGF0ZSAoUmUuYWx0IChMaXN0Lm1hcCBSZS5jaGFyIGNoYXJzKSkgfmFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudFxuOztcblxubGV0IG1hbnlfbWFueSBzdGF0ZSA9XG4gIGxldCBleHBsaWNpdF9wZXJpb2QgPSBzdGF0ZS5TdGF0ZS5wZXJpb2QgJiYgc3RhdGUuU3RhdGUucGF0aG5hbWUgaW5cbiAgbGV0IGZpcnN0X2V4cGxpY2l0X3BlcmlvZCA9IFN0YXRlLmV4cGxpY2l0X3BlcmlvZCBzdGF0ZSBpblxuICBsZXQgc2xhc2hlcyA9IFN0YXRlLnNsYXNoZXMgc3RhdGUgaW5cbiAgbGV0IG1hdGNoX2NvbXBvbmVudCB+ZXhwbGljaXRfcGVyaW9kID1cbiAgICBSZS5zZXFcbiAgICAgIFsgb25lIH5leHBsaWNpdF9zbGFzaDp0cnVlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2RcbiAgICAgIDsgUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDpmYWxzZSlcbiAgICAgIF1cbiAgaW5cbiAgKCogV2UgbXVzdCBtYXRjaCBjb21wb25lbnRzIGluZGl2aWR1YWxseSB3aGVuIFtwZXJpb2RdIGZsYWcgaXMgc2V0LFxuICAgICBtYWtpbmcgc3VyZSB0byBub3QgbWF0Y2ggW1wiZm9vLy5iYXJcIl0uICopXG4gIFN0YXRlLmFwcGVuZFxuICAgIHN0YXRlXG4gICAgKFJlLnNlcVxuICAgICAgIFsgUmUub3B0IChtYXRjaF9jb21wb25lbnQgfmV4cGxpY2l0X3BlcmlvZDpmaXJzdF9leHBsaWNpdF9wZXJpb2QpXG4gICAgICAgOyBSZS5yZXBcbiAgICAgICAgICAgKFJlLnNlcVxuICAgICAgICAgICAgICBbIFJlLmFsdCAoTGlzdC5tYXAgUmUuY2hhciBzbGFzaGVzKVxuICAgICAgICAgICAgICA7IFJlLm9wdCAobWF0Y2hfY29tcG9uZW50IH5leHBsaWNpdF9wZXJpb2QpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgXSlcbjs7XG5cbmxldCBtYW55IChzdGF0ZSA6IFN0YXRlLnQpID1cbiAgbGV0IGV4cGxpY2l0X3NsYXNoID0gU3RhdGUuZXhwbGljaXRfc2xhc2ggc3RhdGUgaW5cbiAgbGV0IGV4cGxpY2l0X3BlcmlvZCA9IFN0YXRlLmV4cGxpY2l0X3BlcmlvZCBzdGF0ZSBpblxuICBsZXQgc2xhc2hlcyA9IFN0YXRlLnNsYXNoZXMgc3RhdGUgaW5cbiAgKCogV2hldGhlciB3ZSBtdXN0IGV4cGxpY2l0bHkgbWF0Y2ggcGVyaW9kIGRlcGVuZHMgb24gdGhlIHN1cnJvdW5kaW5nXG4gICAgIGNoYXJhY3RlcnMsIGJ1dCBzbGFzaGVzIGFyZSBlYXN5IHRvIGV4cGxpY2l0IG1hdGNoLiBUaGlzIGNvbmRpdGlvbmFsXG4gICAgIHNwbGl0cyBvdXQgc29tZSBzaW1wbGUgY2FzZXMuICopXG4gIGlmIG5vdCBleHBsaWNpdF9wZXJpb2RcbiAgdGhlbiBTdGF0ZS5hcHBlbmQgc3RhdGUgKFJlLnJlcCAob25lIH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kKSlcbiAgZWxzZSBpZiBub3QgZXhwbGljaXRfc2xhc2hcbiAgdGhlblxuICAgICgqIEluIHRoaXMgc3RhdGUsIHdlIGV4cGxpY2l0bHkgbWF0Y2ggcGVyaW9kcyBvbmx5IGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyAqKVxuICAgIFN0YXRlLmFwcGVuZFxuICAgICAgc3RhdGVcbiAgICAgIChSZS5vcHRcbiAgICAgICAgIChSZS5zZXFcbiAgICAgICAgICAgIFsgb25lIH5leHBsaWNpdF9zbGFzaDpmYWxzZSB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kXG4gICAgICAgICAgICA7IFJlLnJlcCAob25lIH5leHBsaWNpdF9zbGFzaDpmYWxzZSB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kOmZhbHNlKVxuICAgICAgICAgICAgXSkpXG4gIGVsc2UgKFxuICAgIGxldCBub3RfZW1wdHkgPVxuICAgICAgUmUuc2VxXG4gICAgICAgIFsgb25lIH5leHBsaWNpdF9zbGFzaDp0cnVlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q6dHJ1ZVxuICAgICAgICA7IFJlLnJlcCAob25lIH5leHBsaWNpdF9zbGFzaDp0cnVlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q6ZmFsc2UpXG4gICAgICAgIF1cbiAgICBpblxuICAgICgqIFttYXliZV9lbXB0eV0gaXMgdGhlIGRlZmF1bHQgdHJhbnNsYXRpb24gb2YgTWFueSwgZXhjZXB0IGluIHNvbWUgc3BlY2lhbFxuICAgICAgIGNhc2VzLiAqKVxuICAgIGxldCBtYXliZV9lbXB0eSA9IFJlLm9wdCBub3RfZW1wdHkgaW5cbiAgICBsZXQgZW5jbG9zZWRfc2V0IHN0YXRlIGtpbmQgc2V0ID1cbiAgICAgIFN0YXRlLmFwcGVuZFxuICAgICAgICBzdGF0ZVxuICAgICAgICAoUmUuYWx0XG4gICAgICAgICAgIFsgZW5jbG9zZWRfc2V0IGtpbmQgc2V0IH5leHBsaWNpdF9zbGFzaDp0cnVlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q6dHJ1ZVxuICAgICAgICAgICA7IFJlLnNlcVxuICAgICAgICAgICAgICAgWyBub3RfZW1wdHlcbiAgICAgICAgICAgICAgIDsgKCogU2luY2UgW25vdF9lbXB0eV0gbWF0Y2hlZCwgc3Vic2VxdWVudCBkb3RzIGFyZSBub3QgbGVhZGluZy4gKilcbiAgICAgICAgICAgICAgICAgZW5jbG9zZWRfc2V0XG4gICAgICAgICAgICAgICAgICAga2luZFxuICAgICAgICAgICAgICAgICAgIHNldFxuICAgICAgICAgICAgICAgICAgIH5leHBsaWNpdF9zbGFzaDp0cnVlXG4gICAgICAgICAgICAgICAgICAgfnNsYXNoZXNcbiAgICAgICAgICAgICAgICAgICB+ZXhwbGljaXRfcGVyaW9kOmZhbHNlXG4gICAgICAgICAgICAgICBdXG4gICAgICAgICAgIF0pXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb2thaGVhZCBzdGF0ZSA9XG4gICAgICBtYXRjaCBTdGF0ZS5uZXh0IHN0YXRlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBTdGF0ZS5hcHBlbmQgc3RhdGUgbWF5YmVfZW1wdHlcbiAgICAgICgqIGdsb2IgKiogPT09IGdsb2IgKiAuICopXG4gICAgICB8IFNvbWUgKE1hbnksIHN0YXRlKSAtPiBsb29rYWhlYWQgc3RhdGVcbiAgICAgIHwgU29tZSAoRXhhY3RseSBjLCBzdGF0ZSkgLT5cbiAgICAgICAgbGV0IHN0YXRlID0gU3RhdGUuYXBwZW5kIHN0YXRlIChpZiBjID0gJy4nIHRoZW4gbm90X2VtcHR5IGVsc2UgbWF5YmVfZW1wdHkpIGluXG4gICAgICAgIGV4YWN0bHkgc3RhdGUgY1xuICAgICAgKCogZ2xvYiAqPyA9PT0gZ2xvYiA/KiAqKVxuICAgICAgfCBTb21lIChPbmUsIHN0YXRlKSAtPiBTdGF0ZS5hcHBlbmQgc3RhdGUgbm90X2VtcHR5XG4gICAgICB8IFNvbWUgKEFueV9vZiBlbmNsb3NlZCwgc3RhdGUpIC0+IGVuY2xvc2VkX3NldCBzdGF0ZSBgQW55X29mIGVuY2xvc2VkXG4gICAgICB8IFNvbWUgKEFueV9idXQgZW5jbG9zZWQsIHN0YXRlKSAtPiBlbmNsb3NlZF9zZXQgc3RhdGUgYEFueV9idXQgZW5jbG9zZWRcbiAgICAgICgqICogdGhlbiAqKiA9PT0gKiogKilcbiAgICAgIHwgU29tZSAoTWFueU1hbnksIHN0YXRlKSAtPiBtYW55X21hbnkgc3RhdGVcbiAgICBpblxuICAgIGxvb2thaGVhZCBzdGF0ZSlcbjs7XG5cbmxldCBwaWVjZSBzdGF0ZSBwaWVjZSA9XG4gIGxldCBleHBsaWNpdF9zbGFzaCA9IFN0YXRlLmV4cGxpY2l0X3NsYXNoIHN0YXRlIGluXG4gIGxldCBleHBsaWNpdF9wZXJpb2QgPSBTdGF0ZS5leHBsaWNpdF9wZXJpb2Qgc3RhdGUgaW5cbiAgbGV0IHNsYXNoZXMgPSBTdGF0ZS5zbGFzaGVzIHN0YXRlIGluXG4gIG1hdGNoIHBpZWNlIHdpdGhcbiAgfCBPbmUgLT4gU3RhdGUuYXBwZW5kIHN0YXRlIChvbmUgfmV4cGxpY2l0X3NsYXNoIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2QpXG4gIHwgTWFueSAtPiBtYW55IHN0YXRlXG4gIHwgQW55X29mIGVuY2xvc2VkIC0+XG4gICAgU3RhdGUuYXBwZW5kXG4gICAgICBzdGF0ZVxuICAgICAgKGVuY2xvc2VkX3NldCBgQW55X29mIH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kIGVuY2xvc2VkKVxuICB8IEFueV9idXQgZW5jbG9zZWQgLT5cbiAgICBTdGF0ZS5hcHBlbmRcbiAgICAgIHN0YXRlXG4gICAgICAoZW5jbG9zZWRfc2V0IGBBbnlfYnV0IH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kIGVuY2xvc2VkKVxuICB8IEV4YWN0bHkgYyAtPiBleGFjdGx5IHN0YXRlIGNcbiAgfCBNYW55TWFueSAtPiBtYW55X21hbnkgc3RhdGVcbjs7XG5cbmxldCBnbG9iIH5wYXRobmFtZSB+bWF0Y2hfYmFja3NsYXNoZXMgfnBlcmlvZCBnbG9iID1cbiAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICBtYXRjaCBTdGF0ZS5uZXh0IHN0YXRlIHdpdGhcbiAgICB8IE5vbmUgLT4gU3RhdGUudG9fcmUgc3RhdGVcbiAgICB8IFNvbWUgKHAsIHN0YXRlKSAtPiBsb29wIChwaWVjZSBzdGF0ZSBwKVxuICBpblxuICBsb29wIChTdGF0ZS5jcmVhdGUgfnBhdGhuYW1lIH5tYXRjaF9iYWNrc2xhc2hlcyB+cGVyaW9kIGdsb2IpXG47O1xuXG5sZXQgZ2xvYlxuICA/KGFuY2hvcmVkID0gZmFsc2UpXG4gID8ocGF0aG5hbWUgPSB0cnVlKVxuICA/KG1hdGNoX2JhY2tzbGFzaGVzID0gZmFsc2UpXG4gID8ocGVyaW9kID0gdHJ1ZSlcbiAgPyhleHBhbmRfYnJhY2VzID0gZmFsc2UpXG4gID8oZG91YmxlX2FzdGVyaXNrID0gdHJ1ZSlcbiAgc1xuICA9XG4gIGxldCB0b19yZSBzID1cbiAgICBsZXQgcmUgPSBnbG9iIH5wYXRobmFtZSB+bWF0Y2hfYmFja3NsYXNoZXMgfnBlcmlvZCAob2Zfc3RyaW5nIH5kb3VibGVfYXN0ZXJpc2sgcykgaW5cbiAgICBpZiBhbmNob3JlZCB0aGVuIFJlLndob2xlX3N0cmluZyByZSBlbHNlIHJlXG4gIGluXG4gIGlmIGV4cGFuZF9icmFjZXMgdGhlbiBSZS5hbHQgKExpc3QubWFwIHRvX3JlIChleHBsb2RlIHMpKSBlbHNlIHRvX3JlIHNcbjs7XG5cbmxldCBnbG9iJyA/YW5jaG9yZWQgcGVyaW9kIHMgPSBnbG9iID9hbmNob3JlZCB+cGVyaW9kIHNcbmxldCBnbG9ieCA/YW5jaG9yZWQgcyA9IGdsb2IgP2FuY2hvcmVkIH5leHBhbmRfYnJhY2VzOnRydWUgc1xubGV0IGdsb2J4JyA/YW5jaG9yZWQgcGVyaW9kIHMgPSBnbG9iID9hbmNob3JlZCB+ZXhwYW5kX2JyYWNlczp0cnVlIH5wZXJpb2Qgc1xuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjU1MzYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9hbG51bSIsImNzdF9hbHBoYSIsImNzdF9hc2NpaSIsImNzdF9ibGFuayIsImNzdF9jbnRybCIsImNzdF9kaWdpdCIsImNzdF9ncmFwaCIsImNzdF9sb3dlciIsImNzdF9wcmludCIsImNzdF9wdW5jdCIsImNzdF9zcGFjZSIsImNzdF91cHBlciIsImNzdF93b3JkIiwiY3N0X3hkaWdpdCIsImNhbWxfbGlzdF9vZl9qc19hcnJheSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJjc3QiLCJuYW1lcyIsIlJlX1BhcnNlX2J1ZmZlciIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliIiwiUmVfQ29yZSIsImNzdF9JbnZhbGlkX3BjcmVfY2xhc3MiLCJvZl9uYW1lIiwiY2xhc3MiLCJzd2l0Y2giLCJwYXJzZSIsImJ1ZiIsImFjY2VwdCIsImFjY2VwdF9zIiwiY29tcGwiLCJjbHMiLCJwb3NpeF9jbGFzcyIsIlJlX1Bvc2l4X2NsYXNzIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvcmUvcG9zaXhfY2xhc3MubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxZQUFBQyxRQUFBQztBQUFBQSxRQUFBQyxXQ0VjO0FBQUE7QUFBQSx1QkFPQztBQUFBLEtBUEQsMEJBUUM7QUFBQSxLQVJELDBCQVlDO0FBQUEsS0FaRCwwQkFTQztBQUFBLEtBVEQsMEJBVUM7QUFBQSxLQVZELHlCQVdBO0FBQUEsS0FYQSwyQkFjRTtBQUFBO0FBQUE7QUFBQSxLQWRGLDBCQUVDO0FBQUEsS0FGRCwwQkFDQztBQUFBLEtBREQsMEJBR0M7QUFBQSxLQUhELDBCQUlDO0FBQUEsS0FKRCwwQkFLQztBQUFBLEtBTEQsMEJBTUM7QUFBQSxLQU5ELDBCQWFDO0FBQUE7QUFBQSxjQUVXO0FBQUEsSUFBaUM7QUFBQTtBQUFBLFlBQUFDLE1BQUFDO0FBQUFBO0FBQUFBLEtBQUFDLFNBc0I1QztBQUFBLEtBQUFDLFdBQ0U7QUFBQSxJQUNULDZCQUNLO0FBQUEsUUFBQUMsUUFFRztBQUFBLElBQ1osUUFBQUMsTUFDTTtBQUFBO0FBQUEsZUQ5Q1Y7QUFBQTtBQUFBLE1DK0NxQjtBQUFBLEtEL0NyQjtBQUFBO0FBQUEsSUNpRFc7QUFBQSxLQUFxQjtBQUFBO0FBQUEsS0FBQUMsY0FDVjtBQUFBLFdBQ2xCLFFBQW9CO0FBQUEsSUFBcEI7QUFBQSxHQUE4RDtBQUFBLE9BQUFDLGlCRG5EbEUiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm1vZHVsZSBSZSA9IENvcmVcblxubGV0IG9mX25hbWUgPSBmdW5jdGlvblxuICB8IFwiYWxwaGFcIiAtPiBSZS5hbHBoYVxuICB8IFwiYWxudW1cIiAtPiBSZS5hbG51bVxuICB8IFwiYXNjaWlcIiAtPiBSZS5hc2NpaVxuICB8IFwiYmxhbmtcIiAtPiBSZS5ibGFua1xuICB8IFwiY250cmxcIiAtPiBSZS5jbnRybFxuICB8IFwiZGlnaXRcIiAtPiBSZS5kaWdpdFxuICB8IFwibG93ZXJcIiAtPiBSZS5sb3dlclxuICB8IFwicHJpbnRcIiAtPiBSZS5wcmludFxuICB8IFwic3BhY2VcIiAtPiBSZS5zcGFjZVxuICB8IFwidXBwZXJcIiAtPiBSZS51cHBlclxuICB8IFwid29yZFwiIC0+IFJlLndvcmRjXG4gIHwgXCJwdW5jdFwiIC0+IFJlLnB1bmN0XG4gIHwgXCJncmFwaFwiIC0+IFJlLmdyYXBoXG4gIHwgXCJ4ZGlnaXRcIiAtPiBSZS54ZGlnaXRcbiAgfCBjbGFzc18gLT4gaW52YWxpZF9hcmcgKFwiSW52YWxpZCBwY3JlIGNsYXNzOiBcIiBeIGNsYXNzXylcbjs7XG5cbmxldCBuYW1lcyA9XG4gIFsgXCJhbHBoYVwiXG4gIDsgXCJhbG51bVwiXG4gIDsgXCJhc2NpaVwiXG4gIDsgXCJibGFua1wiXG4gIDsgXCJjbnRybFwiXG4gIDsgXCJkaWdpdFwiXG4gIDsgXCJsb3dlclwiXG4gIDsgXCJwcmludFwiXG4gIDsgXCJzcGFjZVwiXG4gIDsgXCJ1cHBlclwiXG4gIDsgXCJ3b3JkXCJcbiAgOyBcInB1bmN0XCJcbiAgOyBcImdyYXBoXCJcbiAgOyBcInhkaWdpdFwiXG4gIF1cbjs7XG5cbmxldCBwYXJzZSBidWYgPVxuICBsZXQgYWNjZXB0ID0gUGFyc2VfYnVmZmVyLmFjY2VwdCBidWYgaW5cbiAgbGV0IGFjY2VwdF9zID0gUGFyc2VfYnVmZmVyLmFjY2VwdF9zIGJ1ZiBpblxuICBtYXRjaCBhY2NlcHQgJzonIHdpdGhcbiAgfCBmYWxzZSAtPiBOb25lXG4gIHwgdHJ1ZSAtPlxuICAgIGxldCBjb21wbCA9IGFjY2VwdCAnXicgaW5cbiAgICBsZXQgY2xzID1cbiAgICAgIHRyeSBMaXN0LmZpbmQgYWNjZXB0X3MgbmFtZXMgd2l0aFxuICAgICAgfCBOb3RfZm91bmQgLT4gcmFpc2UgUGFyc2VfYnVmZmVyLlBhcnNlX2Vycm9yXG4gICAgaW5cbiAgICBpZiBub3QgKGFjY2VwdF9zIFwiOl1cIikgdGhlbiByYWlzZSBQYXJzZV9idWZmZXIuUGFyc2VfZXJyb3I7XG4gICAgbGV0IHBvc2l4X2NsYXNzID0gb2ZfbmFtZSBjbHMgaW5cbiAgICBTb21lIChpZiBjb21wbCB0aGVuIFJlLmNvbXBsIFsgcG9zaXhfY2xhc3MgXSBlbHNlIHBvc2l4X2NsYXNzKVxuOztcbiJdLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjo1NjQzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InJlLmNtYS5qcyIsIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfTGlzdCIsIlJlX0NvcmUiLCJSZV9QYXJzZV9idWZmZXIiLCJTdGRsaWIiLCJTdGRsaWJfQnVmZmVyIiwiUmVfUG9zaXhfY2xhc3MiLCJQYXJzZV9lcnJvciIsIk5vdF9zdXBwb3J0ZWQiLCJyZSIsIm9wdCIsInMiLCJvcHRzIiwidW5ncmVlZHkiLCJkb3RhbGwiLCJkb2xsYXJfZW5kb25seSIsIm11bHRpbGluZSIsImJ1ZiIsImFjY2VwdCIsImVvcyIsInBhcmFtIiwidGVzdCIsImMiLCJnZXQiLCJncmVlZHlfbW9kIiwiciIsImdyIiwicmVnZXhwIiwibGVmdCIsImJyYW5jaCIsIm1hdGNoIiwiaSIsImoiLCJhdG9tIiwic3dpdGNoZXIiLCJjMSIsImMyIiwiY29kZSIsImIiLCJuYW1lIiwiaGV4ZGlnaXQiLCJkIiwiYnJhY2tldCIsInN0IiwiY2hhciIsInNldCIsInJlcyIsImNvbXBpbGUiLCJjb21waWxlX3BhdCIsIlJlX1BlcmwiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9wZXJsLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFB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QTtBQUFBLFVBQ0E7QUFBQTtBQUFBLFVBSUE7QUFBQTtBQUFBLFVBSEE7QUFBQTtBQUFBLG9CQUN5QjtBQUFBLFVBQXBCLG1FQUFrQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0JBTW5CO0FBQUE7QUFBQTtBQUFBLHdCQUNiO0FBQUEsS0FDVDtBQUFBLElBQ0c7QUFBQSxRQUFBd0IsTUFTSjtBQUFBLElBQ0gsZUFBYztBQUFBO0FBQUEsS0FBQXJCO0FBQUFBLE9Bc0JWO0FBQUEsVUFBOEI7QUFBQTtBQUFBLEtBQUFBO0FBQUFBLE9BQzlCO0FBQUEsVUFBOEI7QUFBQTtBQUFBLElBQ3pDO0FBQUEsR0FBQztBQUFBLE9BQUFzQixVRDdQSDtBQUFBLFlBQUFDLFlBQUF0QyxLQUFBQztBQUFBQSxRQUFBQyxPQ2lRZ0I7QUFBQSxJQUF5QixPQUFZLG9CQUFaLGlCQUFZO0FBQUE7QUFBQSxPQUFBcUMsVURqUXJEIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG5tb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvciA9IFBhcnNlX2J1ZmZlci5QYXJzZV9lcnJvclxuZXhjZXB0aW9uIE5vdF9zdXBwb3J0ZWRcblxubGV0IHBhcnNlIG11bHRpbGluZSBkb2xsYXJfZW5kb25seSBkb3RhbGwgdW5ncmVlZHkgcyA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBlb3MgKCkgPSBQYXJzZV9idWZmZXIuZW9zIGJ1ZiBpblxuICBsZXQgdGVzdCBjID0gUGFyc2VfYnVmZmVyLnRlc3QgYnVmIGMgaW5cbiAgbGV0IHVuZ2V0ICgpID0gUGFyc2VfYnVmZmVyLnVuZ2V0IGJ1ZiBpblxuICBsZXQgZ2V0ICgpID0gUGFyc2VfYnVmZmVyLmdldCBidWYgaW5cbiAgbGV0IGdyZWVkeV9tb2QgciA9XG4gICAgbGV0IGdyID0gYWNjZXB0ICc/JyBpblxuICAgIGxldCBnciA9IGlmIHVuZ3JlZWR5IHRoZW4gbm90IGdyIGVsc2UgZ3IgaW5cbiAgICBpZiBnciB0aGVuIFJlLm5vbl9ncmVlZHkgciBlbHNlIFJlLmdyZWVkeSByXG4gIGluXG4gIGxldCByZWMgcmVnZXhwICgpID0gcmVnZXhwJyAoYnJhbmNoICgpKVxuICBhbmQgcmVnZXhwJyBsZWZ0ID0gaWYgYWNjZXB0ICd8JyB0aGVuIHJlZ2V4cCcgKFJlLmFsdCBbIGxlZnQ7IGJyYW5jaCAoKSBdKSBlbHNlIGxlZnRcbiAgYW5kIGJyYW5jaCAoKSA9IGJyYW5jaCcgW11cbiAgYW5kIGJyYW5jaCcgbGVmdCA9XG4gICAgaWYgZW9zICgpIHx8IHRlc3QgJ3wnIHx8IHRlc3QgJyknXG4gICAgdGhlbiBSZS5zZXEgKExpc3QucmV2IGxlZnQpXG4gICAgZWxzZSBicmFuY2gnIChwaWVjZSAoKSA6OiBsZWZ0KVxuICBhbmQgcGllY2UgKCkgPVxuICAgIGxldCByID0gYXRvbSAoKSBpblxuICAgIGlmIGFjY2VwdCAnKidcbiAgICB0aGVuIGdyZWVkeV9tb2QgKFJlLnJlcCByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICcrJ1xuICAgIHRoZW4gZ3JlZWR5X21vZCAoUmUucmVwMSByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICc/J1xuICAgIHRoZW4gZ3JlZWR5X21vZCAoUmUub3B0IHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJ3snXG4gICAgdGhlbiAoXG4gICAgICBtYXRjaCBQYXJzZV9idWZmZXIuaW50ZWdlciBidWYgd2l0aFxuICAgICAgfCBTb21lIGkgLT5cbiAgICAgICAgbGV0IGogPSBpZiBhY2NlcHQgJywnIHRoZW4gUGFyc2VfYnVmZmVyLmludGVnZXIgYnVmIGVsc2UgU29tZSBpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0ICd9JykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgKG1hdGNoIGogd2l0aFxuICAgICAgICAgfCBTb21lIGogd2hlbiBqIDwgaSAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgICAgfCBfIC0+ICgpKTtcbiAgICAgICAgZ3JlZWR5X21vZCAoUmUucmVwbiByIGkgailcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICB1bmdldCAoKTtcbiAgICAgICAgcilcbiAgICBlbHNlIHJcbiAgYW5kIGF0b20gKCkgPVxuICAgIGlmIGFjY2VwdCAnLidcbiAgICB0aGVuIGlmIGRvdGFsbCB0aGVuIFJlLmFueSBlbHNlIFJlLm5vdG5sXG4gICAgZWxzZSBpZiBhY2NlcHQgJygnXG4gICAgdGhlblxuICAgICAgaWYgYWNjZXB0ICc/J1xuICAgICAgdGhlblxuICAgICAgICBpZiBhY2NlcHQgJzonXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIHIpXG4gICAgICAgIGVsc2UgaWYgYWNjZXB0ICcjJ1xuICAgICAgICB0aGVuIGNvbW1lbnQgKClcbiAgICAgICAgZWxzZSBpZiBhY2NlcHQgJzwnXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBuYW1lID0gbmFtZSAoKSBpblxuICAgICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIFJlLmdyb3VwIH5uYW1lIHIpXG4gICAgICAgIGVsc2UgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgciA9IHJlZ2V4cCAoKSBpblxuICAgICAgICBpZiBub3QgKGFjY2VwdCAnKScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIFJlLmdyb3VwIHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJ14nXG4gICAgdGhlbiBpZiBtdWx0aWxpbmUgdGhlbiBSZS5ib2wgZWxzZSBSZS5ib3NcbiAgICBlbHNlIGlmIGFjY2VwdCAnJCdcbiAgICB0aGVuIGlmIG11bHRpbGluZSB0aGVuIFJlLmVvbCBlbHNlIGlmIGRvbGxhcl9lbmRvbmx5IHRoZW4gUmUubGVvbCBlbHNlIFJlLmVvc1xuICAgIGVsc2UgaWYgYWNjZXB0ICdbJ1xuICAgIHRoZW4gaWYgYWNjZXB0ICdeJyB0aGVuIFJlLmNvbXBsIChicmFja2V0IFtdKSBlbHNlIFJlLmFsdCAoYnJhY2tldCBbXSlcbiAgICBlbHNlIGlmIGFjY2VwdCAnXFxcXCdcbiAgICB0aGVuIChcbiAgICAgICgqIFhYWFxuICAgICAgICAgLSBCYWNrLXJlZmVyZW5jZXNcbiAgICAgICAgIC0gXFxjeCAoY29udHJvbC14KSwgXFxkZGRcbiAgICAgICopXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICB8ICd3JyAtPiBSZS5hbHQgWyBSZS5hbG51bTsgUmUuY2hhciAnXycgXVxuICAgICAgfCAnVycgLT4gUmUuY29tcGwgWyBSZS5hbG51bTsgUmUuY2hhciAnXycgXVxuICAgICAgfCAncycgLT4gUmUuc3BhY2VcbiAgICAgIHwgJ1MnIC0+IFJlLmNvbXBsIFsgUmUuc3BhY2UgXVxuICAgICAgfCAnZCcgLT4gUmUuZGlnaXRcbiAgICAgIHwgJ0QnIC0+IFJlLmNvbXBsIFsgUmUuZGlnaXQgXVxuICAgICAgfCAnYicgLT4gUmUuYWx0IFsgUmUuYm93OyBSZS5lb3cgXVxuICAgICAgfCAnQicgLT4gUmUubm90X2JvdW5kYXJ5XG4gICAgICB8ICdBJyAtPiBSZS5ib3NcbiAgICAgIHwgJ1onIC0+IFJlLmxlb2xcbiAgICAgIHwgJ3onIC0+IFJlLmVvc1xuICAgICAgfCAnRycgLT4gUmUuc3RhcnRcbiAgICAgIHwgJ2UnIC0+IFJlLmNoYXIgJ1xceDFiJ1xuICAgICAgfCAnZicgLT4gUmUuY2hhciAnXFx4MGMnXG4gICAgICB8ICduJyAtPiBSZS5jaGFyICdcXG4nXG4gICAgICB8ICdyJyAtPiBSZS5jaGFyICdcXHInXG4gICAgICB8ICd0JyAtPiBSZS5jaGFyICdcXHQnXG4gICAgICB8ICd4JyAtPlxuICAgICAgICBsZXQgYzEgPSBoZXhkaWdpdCAoKSBpblxuICAgICAgICBsZXQgYzIgPSBoZXhkaWdpdCAoKSBpblxuICAgICAgICBsZXQgY29kZSA9IChjMSAqIDE2KSArIGMyIGluXG4gICAgICAgIFJlLmNoYXIgKGNoYXJfb2ZfaW50IGNvZGUpXG4gICAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICB8ICcwJyAuLiAnOScgLT4gcmFpc2UgTm90X3N1cHBvcnRlZFxuICAgICAgfCBjIC0+IFJlLmNoYXIgYylcbiAgICBlbHNlIChcbiAgICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgIHwgJyonIHwgJysnIHwgJz8nIHwgJ3snIHwgJ1xcXFwnIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICB8IGMgLT4gUmUuY2hhciBjKVxuICBhbmQgaGV4ZGlnaXQgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGQgLT4gQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJzAnXG4gICAgfCAnYScgLi4gJ2YnIGFzIGQgLT4gQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJ2EnICsgMTBcbiAgICB8ICdBJyAuLiAnRicgYXMgZCAtPiBDaGFyLmNvZGUgZCAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICBhbmQgbmFtZSAoKSA9XG4gICAgaWYgZW9zICgpXG4gICAgdGhlbiByYWlzZSBQYXJzZV9lcnJvclxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgIHwgKCdfJyB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onKSBhcyBjIC0+XG4gICAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAzMiBpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjO1xuICAgICAgICBuYW1lJyBiXG4gICAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3IpXG4gIGFuZCBuYW1lJyBiID1cbiAgICBpZiBlb3MgKClcbiAgICB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAoJ18nIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknKSBhcyBjIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGM7XG4gICAgICAgIG5hbWUnIGJcbiAgICAgIHwgJz4nIC0+IEJ1ZmZlci5jb250ZW50cyBiXG4gICAgICB8IF8gLT4gcmFpc2UgUGFyc2VfZXJyb3IpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggY2hhciAoKSB3aXRoXG4gICAgICB8IGBTZXQgc3QgLT4gYnJhY2tldCAoc3QgOjogcylcbiAgICAgIHwgYENoYXIgYyAtPlxuICAgICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBhY2NlcHQgJ10nXG4gICAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyYWNrZXRcbiAgICAgICAgICAgICAgKG1hdGNoIGNoYXIgKCkgd2l0aFxuICAgICAgICAgICAgICAgfCBgQ2hhciBjJyAtPiBSZS5yZyBjIGMnIDo6IHNcbiAgICAgICAgICAgICAgIHwgYFNldCBzdCcgLT4gUmUuY2hhciBjIDo6IFJlLmNoYXIgJy0nIDo6IHN0JyA6OiBzKVxuICAgICAgICBlbHNlIGJyYWNrZXQgKFJlLmNoYXIgYyA6OiBzKSlcbiAgYW5kIGNoYXIgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgaWYgYyA9ICdbJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgYWNjZXB0ICc9JyB0aGVuIHJhaXNlIE5vdF9zdXBwb3J0ZWQ7XG4gICAgICBtYXRjaCBQb3NpeF9jbGFzcy5wYXJzZSBidWYgd2l0aFxuICAgICAgfCBTb21lIHNldCAtPiBgU2V0IHNldFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIGlmIGFjY2VwdCAnLidcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgbGV0IGMgPSBnZXQgKCkgaW5cbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnLicpIHRoZW4gcmFpc2UgTm90X3N1cHBvcnRlZDtcbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnXScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgYENoYXIgYylcbiAgICAgICAgZWxzZSBgQ2hhciBjKVxuICAgIGVsc2UgaWYgYyA9ICdcXFxcJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBsZXQgYyA9IGdldCAoKSBpblxuICAgICAgKCogWFhYXG4gICAgICAgICBcXDEyNywgLi4uXG4gICAgICAqKVxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICdiJyAtPiBgQ2hhciAnXFwwMDgnXG4gICAgICB8ICduJyAtPiBgQ2hhciAnXFxuJyAoKlhYWCopXG4gICAgICB8ICdyJyAtPiBgQ2hhciAnXFxyJyAoKlhYWCopXG4gICAgICB8ICd0JyAtPiBgQ2hhciAnXFx0JyAoKlhYWCopXG4gICAgICB8ICd3JyAtPiBgU2V0IChSZS5hbHQgWyBSZS5hbG51bTsgUmUuY2hhciAnXycgXSlcbiAgICAgIHwgJ1cnIC0+IGBTZXQgKFJlLmNvbXBsIFsgUmUuYWxudW07IFJlLmNoYXIgJ18nIF0pXG4gICAgICB8ICdzJyAtPiBgU2V0IFJlLnNwYWNlXG4gICAgICB8ICdTJyAtPiBgU2V0IChSZS5jb21wbCBbIFJlLnNwYWNlIF0pXG4gICAgICB8ICdkJyAtPiBgU2V0IFJlLmRpZ2l0XG4gICAgICB8ICdEJyAtPiBgU2V0IChSZS5jb21wbCBbIFJlLmRpZ2l0IF0pXG4gICAgICB8ICdhJyAuLiAneicgfCAnQScgLi4gJ1onIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgICB8ICcwJyAuLiAnOScgLT4gcmFpc2UgTm90X3N1cHBvcnRlZFxuICAgICAgfCBfIC0+IGBDaGFyIGMpXG4gICAgZWxzZSBgQ2hhciBjXG4gIGFuZCBjb21tZW50ICgpID1cbiAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICBpZiBhY2NlcHQgJyknXG4gICAgdGhlbiBSZS5lcHNpbG9uXG4gICAgZWxzZSAoXG4gICAgICBQYXJzZV9idWZmZXIuanVuayBidWY7XG4gICAgICBjb21tZW50ICgpKVxuICBpblxuICBsZXQgcmVzID0gcmVnZXhwICgpIGluXG4gIGlmIG5vdCAoZW9zICgpKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICByZXNcbjs7XG5cbnR5cGUgb3B0ID1cbiAgWyBgVW5ncmVlZHlcbiAgfCBgRG90YWxsXG4gIHwgYERvbGxhcl9lbmRvbmx5XG4gIHwgYE11bHRpbGluZVxuICB8IGBBbmNob3JlZFxuICB8IGBDYXNlbGVzc1xuICBdXG5cbmxldCByZSA/KG9wdHMgPSBbXSkgcyA9XG4gIGxldCByID1cbiAgICBwYXJzZVxuICAgICAgKExpc3QubWVtcSBgTXVsdGlsaW5lIG9wdHMpXG4gICAgICAoTGlzdC5tZW1xIGBEb2xsYXJfZW5kb25seSBvcHRzKVxuICAgICAgKExpc3QubWVtcSBgRG90YWxsIG9wdHMpXG4gICAgICAoTGlzdC5tZW1xIGBVbmdyZWVkeSBvcHRzKVxuICAgICAgc1xuICBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgQW5jaG9yZWQgb3B0cyB0aGVuIFJlLnNlcSBbIFJlLnN0YXJ0OyByIF0gZWxzZSByIGluXG4gIGxldCByID0gaWYgTGlzdC5tZW1xIGBDYXNlbGVzcyBvcHRzIHRoZW4gUmUubm9fY2FzZSByIGVsc2UgciBpblxuICByXG47O1xuXG5sZXQgY29tcGlsZSA9IFJlLmNvbXBpbGVcbmxldCBjb21waWxlX3BhdCA/KG9wdHMgPSBbXSkgcyA9IGNvbXBpbGUgKHJlIH5vcHRzIHMpXG4iXSwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjA0MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImdsb2JhbF9kYXRhIiwiUmVfQ29yZSIsIlN0ZGxpYl9MaXN0IiwiU3RkbGliX0J5dGVzIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9CdWZmZXIiLCJTdGRsaWIiLCJTdGRsaWJfQXJyYXkiLCJSZV9QZXJsIiwiUGFyc2VfZXJyb3IiLCJOb3Rfc3VwcG9ydGVkIiwicmUiLCJvcHQiLCJwYXQiLCJmbGFncyIsIm9wdHMiLCJwYXJhbSIsInJlZ2V4cCIsImV4dHJhY3QiLCJyZXgiLCJzIiwiZXhlYyIsInBvcyIsImdldF9zdWJzdHJpbmciLCJpIiwibmFtZXMiLCJnZXRfbmFtZWRfc3Vic3RyaW5nIiwibmFtZSIsIm1hdGNoIiwicmVtIiwibiIsImdldF9zdWJzdHJpbmdfb2ZzIiwicG1hdGNoIiwic3Vic3RpdHV0ZSIsInN1YnN0Iiwic3RyIiwiYiIsIm9uX21hdGNoIiwic3MiLCJmaW4iLCJzdGFydCIsInNwbGl0IiwiZmluaXNoIiwibGFzdCIsImFjY3UiLCJxdW90ZSIsImxlbiIsImJ1ZiIsImMiLCJyIiwiZnVsbF9zcGxpdCIsIm1heCIsInJlc3VsdHMiLCJtYXRjaGVzIiwiZCIsImRlbGltIiwibCIsIlJlX1BjcmUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9yZS9wY3JlLm1sIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGdCQUFBO0FBQUE7QUFBQSxZQUFBQyxHQUFBQyxLQUFBQztBQUFBQTtBQUFBQSxLQUFBQyxRQ3NCTztBQUFBLEtBQUFDO0FBQUFBLE9BRUg7QUFBQTtB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QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFFRTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBO0FBQUE7QUFBQSxPQUVBO0FBQUEsT0FDQTtBQUFBO0FBQUEsZ0JBUkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBQUFGLFFBVUYsUUFBQUcsSUFwQlE7QUFBQSxJQUNSO0FBQUEsSUFBK0Isc0NBbUJIO0FBQUE7QUFBQSxZQUFBQyxXQUFBdEMsS0FBQU8sS0FBQUM7QUFBQUEsUUFBQStCLE1BR2Y7QUFBQSxJQUNiLG1DQUNLO0FBQUEsSUFDQSxjQUNBO0FBQUE7QUFBQSxLQUFBQyxVQUVXO0FBQUEsS0FBQUM7QUFBQUEsT0FFWjtBQUFBO0FBQUEsa0JBQUFyQztBQUFBQSxVQUNFLDhCQUFBSSxJQUFBLFVBQ2U7QUFBQTtBQUFBLFdBQUFrQyxJQURmO0FBQUEsV0FBQUQsVUFHa0I7QUFBQSxXQUFBRSxRQUNGO0FBQUEsV0FBQUMsSUFDWjtBQUFBLGlCQUdDO0FBQUE7QUFBQTtBQUFBLGVBQUFoQyxJQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUVTO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFBbUQ7QUFBQSxZQUE3QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQUcvQix5REFBVztBQUFBLFNBQUU7QUFBQTtBQUFBLElBR3RCLDJDQUFvQjtBQUFBO0FBQUE7QUFBQSxJQUFBaUM7QUFBQUEsTUR2S3hCIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvciA9IFBlcmwuUGFyc2VfZXJyb3JcbmV4Y2VwdGlvbiBOb3Rfc3VwcG9ydGVkID0gUGVybC5Ob3Rfc3VwcG9ydGVkXG5cbnR5cGUgcmVnZXhwID0gUmUucmVcblxudHlwZSBmbGFnID1cbiAgWyBgQ0FTRUxFU1NcbiAgfCBgTVVMVElMSU5FXG4gIHwgYEFOQ0hPUkVEXG4gIHwgYERPVEFMTFxuICBdXG5cbnR5cGUgc3BsaXRfcmVzdWx0ID1cbiAgfCBUZXh0IG9mIHN0cmluZ1xuICB8IERlbGltIG9mIHN0cmluZ1xuICB8IEdyb3VwIG9mIGludCAqIHN0cmluZ1xuICB8IE5vR3JvdXBcblxudHlwZSBncm91cHMgPSBDb3JlLkdyb3VwLnRcblxubGV0IHJlID8oZmxhZ3MgPSBbXSkgcGF0ID1cbiAgbGV0IG9wdHMgPVxuICAgIExpc3QubWFwXG4gICAgICAoZnVuY3Rpb25cbiAgICAgICAgfCBgQ0FTRUxFU1MgLT4gYENhc2VsZXNzXG4gICAgICAgIHwgYE1VTFRJTElORSAtPiBgTXVsdGlsaW5lXG4gICAgICAgIHwgYEFOQ0hPUkVEIC0+IGBBbmNob3JlZFxuICAgICAgICB8IGBET1RBTEwgLT4gYERvdGFsbClcbiAgICAgIGZsYWdzXG4gIGluXG4gIFBlcmwucmUgfm9wdHMgcGF0XG47O1xuXG5sZXQgcmVnZXhwID9mbGFncyBwYXQgPSBSZS5jb21waWxlIChyZSA/ZmxhZ3MgcGF0KVxubGV0IGV4dHJhY3QgfnJleCBzID0gUmUuR3JvdXAuYWxsIChSZS5leGVjIHJleCBzKVxubGV0IGV4ZWMgfnJleCA/cG9zIHMgPSBSZS5leGVjIHJleCA/cG9zIHNcbmxldCBnZXRfc3Vic3RyaW5nIHMgaSA9IFJlLkdyb3VwLmdldCBzIGlcbmxldCBuYW1lcyByZXggPSBSZS5ncm91cF9uYW1lcyByZXggfD4gTGlzdC5tYXAgZnN0IHw+IEFycmF5Lm9mX2xpc3RcblxubGV0IGdldF9uYW1lZF9zdWJzdHJpbmcgcmV4IG5hbWUgcyA9XG4gIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IChuLCBpKSA6OiByZW0gd2hlbiBuID0gbmFtZSAtPlxuICAgICAgKHRyeSBnZXRfc3Vic3RyaW5nIHMgaSB3aXRoXG4gICAgICAgfCBOb3RfZm91bmQgLT4gbG9vcCByZW0pXG4gICAgfCBfIDo6IHJlbSAtPiBsb29wIHJlbVxuICBpblxuICBsb29wIChSZS5ncm91cF9uYW1lcyByZXgpXG47O1xuXG5sZXQgZ2V0X3N1YnN0cmluZ19vZnMgcyBpID0gUmUuR3JvdXAub2Zmc2V0IHMgaVxubGV0IHBtYXRjaCB+cmV4IHMgPSBSZS5leGVjcCByZXggc1xuXG5sZXQgc3Vic3RpdHV0ZSB+cmV4IH5zdWJzdCBzdHIgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICBsZXQgcmVjIGxvb3AgcG9zIG9uX21hdGNoID1cbiAgICBpZiBSZS5leGVjcCB+cG9zIHJleCBzdHJcbiAgICB0aGVuIChcbiAgICAgIGxldCBzcyA9IFJlLmV4ZWMgfnBvcyByZXggc3RyIGluXG4gICAgICBsZXQgc3RhcnQsIGZpbiA9IFJlLkdyb3VwLm9mZnNldCBzcyAwIGluXG4gICAgICBpZiBvbl9tYXRjaCAmJiBzdGFydCA9IHBvcyAmJiBzdGFydCA9IGZpblxuICAgICAgdGhlbiAoXG4gICAgICAgIGlmICgqIEVtcHR5IG1hdGNoIGZvbGxvd2luZyBhIG1hdGNoICopXG4gICAgICAgICAgIHBvcyA8IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIHN0ci5bcG9zXTtcbiAgICAgICAgICBsb29wIChwb3MgKyAxKSBmYWxzZSkpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHBhdCA9IFJlLkdyb3VwLmdldCBzcyAwIGluXG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGIgc3RyIHBvcyAoc3RhcnQgLSBwb3MpO1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIChzdWJzdCBwYXQpO1xuICAgICAgICBpZiBzdGFydCA9IGZpblxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBpZiAoKiBNYW51YWxseSBhZHZhbmNlIGJ5IG9uZSBhZnRlciBhbiBlbXB0eSBtYXRjaCAqKVxuICAgICAgICAgICAgIGZpbiA8IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiBzdHIuW2Zpbl07XG4gICAgICAgICAgICBsb29wIChmaW4gKyAxKSBmYWxzZSkpXG4gICAgICAgIGVsc2UgbG9vcCBmaW4gdHJ1ZSkpXG4gICAgZWxzZSBCdWZmZXIuYWRkX3N1YnN0cmluZyBiIHN0ciBwb3MgKFN0cmluZy5sZW5ndGggc3RyIC0gcG9zKVxuICBpblxuICBsb29wIDAgZmFsc2U7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG47O1xuXG5sZXQgc3BsaXQgfnJleCBzdHIgPVxuICBsZXQgZmluaXNoIHN0ciBsYXN0IGFjY3UgPVxuICAgIGxldCBhY2N1ID0gU3RyaW5nLnN1YiBzdHIgbGFzdCAoU3RyaW5nLmxlbmd0aCBzdHIgLSBsYXN0KSA6OiBhY2N1IGluXG4gICAgTGlzdC5yZXYgYWNjdVxuICBpblxuICBsZXQgcmVjIGxvb3AgYWNjdSBsYXN0IHBvcyBvbl9tYXRjaCA9XG4gICAgaWYgUmUuZXhlY3AgfnBvcyByZXggc3RyXG4gICAgdGhlbiAoXG4gICAgICBsZXQgc3MgPSBSZS5leGVjIH5wb3MgcmV4IHN0ciBpblxuICAgICAgbGV0IHN0YXJ0LCBmaW4gPSBSZS5Hcm91cC5vZmZzZXQgc3MgMCBpblxuICAgICAgaWYgb25fbWF0Y2ggJiYgc3RhcnQgPSBwb3MgJiYgc3RhcnQgPSBmaW5cbiAgICAgIHRoZW5cbiAgICAgICAgaWYgKCogRW1wdHkgbWF0Y2ggZm9sbG93aW5nIGEgbWF0Y2ggKilcbiAgICAgICAgICAgcG9zID0gU3RyaW5nLmxlbmd0aCBzdHJcbiAgICAgICAgdGhlbiBmaW5pc2ggc3RyIGxhc3QgYWNjdVxuICAgICAgICBlbHNlIGxvb3AgYWNjdSBsYXN0IChwb3MgKyAxKSBmYWxzZVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBhY2N1ID0gU3RyaW5nLnN1YiBzdHIgbGFzdCAoc3RhcnQgLSBsYXN0KSA6OiBhY2N1IGluXG4gICAgICAgIGlmIHN0YXJ0ID0gZmluXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiAoKiBNYW51YWxseSBhZHZhbmNlIGJ5IG9uZSBhZnRlciBhbiBlbXB0eSBtYXRjaCAqKVxuICAgICAgICAgICAgIGZpbiA9IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICAgICAgdGhlbiBmaW5pc2ggc3RyIGZpbiBhY2N1XG4gICAgICAgICAgZWxzZSBsb29wIGFjY3UgZmluIChmaW4gKyAxKSBmYWxzZVxuICAgICAgICBlbHNlIGxvb3AgYWNjdSBmaW4gZmluIHRydWUpKVxuICAgIGVsc2UgZmluaXNoIHN0ciBsYXN0IGFjY3VcbiAgaW5cbiAgbG9vcCBbXSAwIDAgZmFsc2Vcbjs7XG5cbigqIEZyb20gUENSRSAqKVxubGV0IHN0cmluZ191bnNhZmVfc3ViIHMgb2ZzIGxlbiA9XG4gIGxldCByID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICBCeXRlcy51bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJcbjs7XG5cbmxldCBxdW90ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChsZW4gbHNsIDEpIGluXG4gIGxldCBwb3MgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgfCAoJ1xcXFwnIHwgJ14nIHwgJyQnIHwgJy4nIHwgJ1snIHwgJ3wnIHwgJygnIHwgJyknIHwgJz8nIHwgJyonIHwgJysnIHwgJ3snKSBhcyBjIC0+XG4gICAgICBCeXRlcy51bnNhZmVfc2V0IGJ1ZiAhcG9zICdcXFxcJztcbiAgICAgIGluY3IgcG9zO1xuICAgICAgQnl0ZXMudW5zYWZlX3NldCBidWYgIXBvcyBjO1xuICAgICAgaW5jciBwb3NcbiAgICB8IGMgLT5cbiAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgYnVmICFwb3MgYztcbiAgICAgIGluY3IgcG9zXG4gIGRvbmU7XG4gIHN0cmluZ191bnNhZmVfc3ViIGJ1ZiAwICFwb3Ncbjs7XG5cbmxldCBmdWxsX3NwbGl0ID8obWF4ID0gMCkgfnJleCBzID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBzID0gMFxuICB0aGVuIFtdXG4gIGVsc2UgaWYgbWF4ID0gMVxuICB0aGVuIFsgVGV4dCBzIF1cbiAgZWxzZSAoXG4gICAgbGV0IHJlc3VsdHMgPSBSZS5zcGxpdF9mdWxsIHJleCBzIGluXG4gICAgbGV0IG1hdGNoZXMgPVxuICAgICAgTGlzdC5tYXBcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBgVGV4dCBzIC0+IFsgVGV4dCBzIF1cbiAgICAgICAgICB8IGBEZWxpbSBkIC0+XG4gICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IFJlLkdyb3VwLmFsbF9vZmZzZXQgZCBpblxuICAgICAgICAgICAgbGV0IGRlbGltID0gUmUuR3JvdXAuZ2V0IGQgMCBpblxuICAgICAgICAgICAgRGVsaW0gZGVsaW1cbiAgICAgICAgICAgIDo6XG4gICAgICAgICAgICAobGV0IGwgPSByZWYgW10gaW5cbiAgICAgICAgICAgICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIG1hdGNoZXMgLSAxIGRvXG4gICAgICAgICAgICAgICBsXG4gICAgICAgICAgICAgICA6PSAoaWYgbWF0Y2hlcy4oaSkgPSAoLTEsIC0xKSB0aGVuIE5vR3JvdXAgZWxzZSBHcm91cCAoaSwgUmUuR3JvdXAuZ2V0IGQgaSkpXG4gICAgICAgICAgICAgICAgICA6OiAhbFxuICAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICAgTGlzdC5yZXYgIWwpKVxuICAgICAgICByZXN1bHRzXG4gICAgaW5cbiAgICBMaXN0LmNvbmNhdCBtYXRjaGVzKVxuOztcblxudHlwZSBzdWJzdHJpbmdzID0gR3JvdXAudFxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjYzMzIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJnbG9iYWxfZGF0YSIsIlJlX0NvcmUiLCJTdGRsaWJfTGlzdCIsIlJlX1BhcnNlX2J1ZmZlciIsIlJlX1Bvc2l4X2NsYXNzIiwiUGFyc2VfZXJyb3IiLCJOb3Rfc3VwcG9ydGVkIiwicmUiLCJvcHQiLCJzIiwib3B0cyIsIm5ld2xpbmUiLCJidWYiLCJhY2NlcHQiLCJlb3MiLCJwYXJhbSIsInRlc3QiLCJjIiwiZ2V0IiwicmVnZXhwIiwibGVmdCIsImJyYW5jaCIsInIiLCJtYXRjaCIsImkiLCJqIiwiYnJhY2tldCIsInN0IiwiY2hhciIsInNldCIsInJlcyIsImNvbXBpbGUiLCJjb21waWxlX3BhdCIsIlJlX1Bvc2l4Il0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvcmUvcG9zaXgubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUFBQTtBQUFBLFlBQUFDLEdBQUFDLEtBQUFDO0FBQUFBO0FBQUFBLEtBQUFDLE9Da0pPO0FBQUEsS0FBQUMsVUFDUztBQUFBLEtBQUFDLE1BL0dKO0FBQUEsS0FBQUMsU0FDRztBQUFBLGFBQUFDLElBQUFDLE9BQ0EsMENB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RU07QUFBQSxRQUFBYSxNQUVKO0FBQUEsSUFDSCxlQUFjO0FBQUE7QUFBQSxLQUFBUjtBQUFBQSxPQVlWO0FBQUEsVUFBMkI7QUFBQTtBQUFBLEtBQUFBO0FBQUFBLE9BQzNCO0FBQUEsVUFBMkI7QUFBQTtBQUFBLElBQ3RDO0FBQUEsR0FBQztBQUFBLFlBQUFTLFFBQUF4QjtBQUFBQSxRQUFBLE1BR3lCO0FBQUEsSUFBZTtBQUFBO0FBQUEsWUFBQXlCLFlBQUF4QixLQUFBQztBQUFBQSxRQUFBQyxPQUMzQjtBQUFBLElBQXlCLE9BQVksUUFBWixpQkFBWTtBQUFBO0FBQUEsT0FBQXVCLFdEMUpyRCIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxuKCpcbiAgIFdoYXQgd2UgY291bGQgKHNob3VsZD8pIGRvOlxuICAgLSBhKiA9PT4gbG9uZ2VzdCAoKHNob3J0ZXN0IChub19ncm91cCBhKSogKSwgYSB8ICgpKSAgKCEhISlcbiAgIC0gYWJjIHVuZGVyc3Rvb2QgYXMgKGFiKWNcbiAgIC0gXCIoKGE/KXxiKVwiIGFnYWluc3QgXCJhYlwiIHNob3VsZCBub3QgYmluZCB0aGUgZmlyc3Qgc3VicGF0dGVybiB0byBhbnl0aGluZ1xuXG4gICBOb3RlIHRoYXQgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIGhhbmRsZSBcIigoKGFiKWMpZCllXCIgZWZmaWNpZW50bHlcbiopXG5tb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvciA9IFBhcnNlX2J1ZmZlci5QYXJzZV9lcnJvclxuZXhjZXB0aW9uIE5vdF9zdXBwb3J0ZWRcblxubGV0IHBhcnNlIG5ld2xpbmUgcyA9XG4gIGxldCBidWYgPSBQYXJzZV9idWZmZXIuY3JlYXRlIHMgaW5cbiAgbGV0IGFjY2VwdCA9IFBhcnNlX2J1ZmZlci5hY2NlcHQgYnVmIGluXG4gIGxldCBlb3MgKCkgPSBQYXJzZV9idWZmZXIuZW9zIGJ1ZiBpblxuICBsZXQgdGVzdCBjID0gUGFyc2VfYnVmZmVyLnRlc3QgYnVmIGMgaW5cbiAgbGV0IHVuZ2V0ICgpID0gUGFyc2VfYnVmZmVyLnVuZ2V0IGJ1ZiBpblxuICBsZXQgZ2V0ICgpID0gUGFyc2VfYnVmZmVyLmdldCBidWYgaW5cbiAgbGV0IHJlYyByZWdleHAgKCkgPSByZWdleHAnIChicmFuY2ggKCkpXG4gIGFuZCByZWdleHAnIGxlZnQgPSBpZiBhY2NlcHQgJ3wnIHRoZW4gcmVnZXhwJyAoUmUuYWx0IFsgbGVmdDsgYnJhbmNoICgpIF0pIGVsc2UgbGVmdFxuICBhbmQgYnJhbmNoICgpID0gYnJhbmNoJyBbXVxuICBhbmQgYnJhbmNoJyBsZWZ0ID1cbiAgICBpZiBlb3MgKCkgfHwgdGVzdCAnfCcgfHwgdGVzdCAnKSdcbiAgICB0aGVuIFJlLnNlcSAoTGlzdC5yZXYgbGVmdClcbiAgICBlbHNlIGJyYW5jaCcgKHBpZWNlICgpIDo6IGxlZnQpXG4gIGFuZCBwaWVjZSAoKSA9XG4gICAgbGV0IHIgPSBhdG9tICgpIGluXG4gICAgaWYgYWNjZXB0ICcqJ1xuICAgIHRoZW4gUmUucmVwIChSZS5uZXN0IHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJysnXG4gICAgdGhlbiBSZS5yZXAxIChSZS5uZXN0IHIpXG4gICAgZWxzZSBpZiBhY2NlcHQgJz8nXG4gICAgdGhlbiBSZS5vcHQgclxuICAgIGVsc2UgaWYgYWNjZXB0ICd7J1xuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggUGFyc2VfYnVmZmVyLmludGVnZXIgYnVmIHdpdGhcbiAgICAgIHwgU29tZSBpIC0+XG4gICAgICAgIGxldCBqID0gaWYgYWNjZXB0ICcsJyB0aGVuIFBhcnNlX2J1ZmZlci5pbnRlZ2VyIGJ1ZiBlbHNlIFNvbWUgaSBpblxuICAgICAgICBpZiBub3QgKGFjY2VwdCAnfScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIChtYXRjaCBqIHdpdGhcbiAgICAgICAgIHwgU29tZSBqIHdoZW4gaiA8IGkgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgICAgIHwgXyAtPiAoKSk7XG4gICAgICAgIFJlLnJlcG4gKFJlLm5lc3QgcikgaSBqXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgdW5nZXQgKCk7XG4gICAgICAgIHIpXG4gICAgZWxzZSByXG4gIGFuZCBhdG9tICgpID1cbiAgICBpZiBhY2NlcHQgJy4nXG4gICAgdGhlbiBpZiBuZXdsaW5lIHRoZW4gUmUubm90bmwgZWxzZSBSZS5hbnlcbiAgICBlbHNlIGlmIGFjY2VwdCAnKCdcbiAgICB0aGVuIChcbiAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICBpZiBub3QgKGFjY2VwdCAnKScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBSZS5ncm91cCByKVxuICAgIGVsc2UgaWYgYWNjZXB0ICdeJ1xuICAgIHRoZW4gaWYgbmV3bGluZSB0aGVuIFJlLmJvbCBlbHNlIFJlLmJvc1xuICAgIGVsc2UgaWYgYWNjZXB0ICckJ1xuICAgIHRoZW4gaWYgbmV3bGluZSB0aGVuIFJlLmVvbCBlbHNlIFJlLmVvc1xuICAgIGVsc2UgaWYgYWNjZXB0ICdbJ1xuICAgIHRoZW5cbiAgICAgIGlmIGFjY2VwdCAnXidcbiAgICAgIHRoZW4gUmUuZGlmZiAoUmUuY29tcGwgKGJyYWNrZXQgW10pKSAoUmUuY2hhciAnXFxuJylcbiAgICAgIGVsc2UgUmUuYWx0IChicmFja2V0IFtdKVxuICAgIGVsc2UgaWYgYWNjZXB0ICdcXFxcJ1xuICAgIHRoZW4gKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAoJ3wnIHwgJygnIHwgJyknIHwgJyonIHwgJysnIHwgJz8nIHwgJ1snIHwgJy4nIHwgJ14nIHwgJyQnIHwgJ3snIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgIFJlLmNoYXIgY1xuICAgICAgfCBfIC0+IHJhaXNlIFBhcnNlX2Vycm9yKVxuICAgIGVsc2UgKFxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgfCAnKicgfCAnKycgfCAnPycgfCAneycgfCAnXFxcXCcgLT4gcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIHwgYyAtPiBSZS5jaGFyIGMpXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJ1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggY2hhciAoKSB3aXRoXG4gICAgICB8IGBTZXQgc3QgLT4gYnJhY2tldCAoc3QgOjogcylcbiAgICAgIHwgYENoYXIgYyAtPlxuICAgICAgICBpZiBhY2NlcHQgJy0nXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiBhY2NlcHQgJ10nXG4gICAgICAgICAgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogc1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyYWNrZXRcbiAgICAgICAgICAgICAgKG1hdGNoIGNoYXIgKCkgd2l0aFxuICAgICAgICAgICAgICAgfCBgQ2hhciBjJyAtPiBSZS5yZyBjIGMnIDo6IHNcbiAgICAgICAgICAgICAgIHwgYFNldCBzdCcgLT4gUmUuY2hhciBjIDo6IFJlLmNoYXIgJy0nIDo6IHN0JyA6OiBzKVxuICAgICAgICBlbHNlIGJyYWNrZXQgKFJlLmNoYXIgYyA6OiBzKSlcbiAgYW5kIGNoYXIgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgaWYgYyA9ICdbJ1xuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggUG9zaXhfY2xhc3MucGFyc2UgYnVmIHdpdGhcbiAgICAgIHwgU29tZSBzZXQgLT4gYFNldCBzZXRcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBpZiBhY2NlcHQgJy4nXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJy4nKSB0aGVuIHJhaXNlIE5vdF9zdXBwb3J0ZWQ7XG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJ10nKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIGBDaGFyIGMpXG4gICAgICAgIGVsc2UgYENoYXIgYylcbiAgICBlbHNlIGBDaGFyIGNcbiAgaW5cbiAgbGV0IHJlcyA9IHJlZ2V4cCAoKSBpblxuICBpZiBub3QgKGVvcyAoKSkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgcmVzXG47O1xuXG50eXBlIG9wdCA9XG4gIFsgYElDYXNlXG4gIHwgYE5vU3ViXG4gIHwgYE5ld2xpbmVcbiAgXVxuXG5sZXQgcmUgPyhvcHRzID0gW10pIHMgPVxuICBsZXQgciA9IHBhcnNlIChMaXN0Lm1lbXEgYE5ld2xpbmUgb3B0cykgcyBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgSUNhc2Ugb3B0cyB0aGVuIFJlLm5vX2Nhc2UgciBlbHNlIHIgaW5cbiAgbGV0IHIgPSBpZiBMaXN0Lm1lbXEgYE5vU3ViIG9wdHMgdGhlbiBSZS5ub19ncm91cCByIGVsc2UgciBpblxuICByXG47O1xuXG5sZXQgY29tcGlsZSByZSA9IFJlLmNvbXBpbGUgKFJlLmxvbmdlc3QgcmUpXG5sZXQgY29tcGlsZV9wYXQgPyhvcHRzID0gW10pIHMgPSBjb21waWxlIChyZSB+b3B0cyBzKVxuIl0sImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjY1NjMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmUuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiUmVfQ29yZSIsIlJlX1JlcGxhY2UiLCJHcm91cCIsImNvbXBpbGUiLCJncm91cF9jb3VudCIsImdyb3VwX25hbWVzIiwiZXhlYyIsImV4ZWNfb3B0IiwiZXhlY3AiLCJleGVjX3BhcnRpYWwiLCJleGVjX3BhcnRpYWxfZGV0YWlsZWQiLCJNYXJrIiwiYWxsIiwiYWxsX2dlbiIsImFsbF9zZXEiLCJtYXRjaGVzIiwibWF0Y2hlc19nZW4iLCJtYXRjaGVzX3NlcSIsInNwbGl0Iiwic3BsaXRfZGVsaW0iLCJzcGxpdF9nZW4iLCJzcGxpdF9zZXEiLCJzcGxpdF9mdWxsIiwic3BsaXRfZnVsbF9nZW4iLCJzcGxpdF9mdWxsX3NlcSIsIlNlcSIsInN0ciIsImNoYXIiLCJhbHQiLCJzZXEiLCJlbXB0eSIsImVwc2lsb24iLCJyZXAiLCJyZXAxIiwicmVwbiIsIm9wdCIsImJvbCIsImVvbCIsImJvdyIsImVvdyIsImJvcyIsImVvcyIsImxlb2wiLCJzdGFydCIsInN0b3AiLCJ3b3JkIiwibm90X2JvdW5kYXJ5Iiwid2hvbGVfc3RyaW5nIiwibG9uZ2VzdCIsInNob3J0ZXN0IiwiZmlyc3QiLCJncmVlZHkiLCJub25fZ3JlZWR5IiwiZ3JvdXAiLCJub19ncm91cCIsIm5lc3QiLCJtYXJrIiwic2V0IiwicmciLCJpbnRlciIsImRpZmYiLCJjb21wbCIsImFueSIsIm5vdG5sIiwiYWxudW0iLCJ3b3JkYyIsImFscGhhIiwiYXNjaWkiLCJibGFuayIsImNudHJsIiwiZGlnaXQiLCJncmFwaCIsImxvd2VyIiwicHJpbnQiLCJwdW5jdCIsInNwYWNlIiwidXBwZXIiLCJ4ZGlnaXQiLCJjYXNlIiwibm9fY2FzZSIsInBwIiwicHBfcmUiLCJwcmludF9yZSIsIndpdG5lc3MiLCJnZXQiLCJnZXRfb2ZzIiwiZ2V0X2FsbCIsImdldF9hbGxfb2ZzIiwidGVzdCIsIm1hcmtlZCIsIm1hcmtfc2V0IiwicmVwbGFjZSIsInJlcGxhY2Vfc3RyaW5nIiwiUmUiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE1BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxLQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJpZ25vcmVMaXN0IjpbMF19fV19
