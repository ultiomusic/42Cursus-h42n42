// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Ocsigen_lib_base
//# unitInfo: Requires: CamlinternalLazy, Lwt, Stdlib, Stdlib__List, Stdlib__Map, Stdlib__Set, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = "",
    cst$6 = "..",
    cst$7 = "/",
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = cst$7,
    cst$3 = cst$7,
    cst$2 = cst$5,
    cst$0 = cst$5,
    cst$1 = ":",
    cst = cst$5,
    advert =
      "Page generated by OCaml with Ocsigen.\nSee http://ocsigen.org/ and http://caml.inria.fr/ for information",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Lwt = global_data.Lwt,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set,
    Ocsigen_Internal_Error =
      [248, "Ocsigen_lib_base.Ocsigen_Internal_Error", caml_fresh_oo_id(0)],
    Input_is_too_large =
      [248, "Ocsigen_lib_base.Input_is_too_large", caml_fresh_oo_id(0)],
    Ocsigen_Bad_Request =
      [248, "Ocsigen_lib_base.Ocsigen_Bad_Request", caml_fresh_oo_id(0)],
    Ocsigen_Request_too_long =
      [248, "Ocsigen_lib_base.Ocsigen_Request_too_long", caml_fresh_oo_id(0)],
    symbol_bind = Lwt[6],
    symbol = Lwt[71];
   function symbol$0(___){
    var _$_ = runtime.caml_obj_tag(___);
    if(250 === _$_) return ___[1];
    if(246 !== _$_ && 244 !== _$_) return ___;
    return caml_call1(CamlinternalLazy[2], ___);
   }
   function symbol$1(x, f){return caml_call1(f, x);}
   function symbol$2(f, x){return caml_call1(f, x);}
   function comp(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function curry(f, x, y){return caml_call1(f, [0, x, y]);}
   function uncurry(f, param){
    var y = param[2], x = param[1];
    return caml_call2(f, x, y);
   }
   function fst(param){var a = param[1]; return a;}
   function snd(param){var a = param[2]; return a;}
   function thd(param){var a = param[3]; return a;}
   var Tuple3 = [0, fst, snd, thd];
   function map(f, param){
    if(! param) return 0;
    var x = param[1];
    return [0, caml_call1(f, x)];
   }
   function get(f, param){
    if(! param) return caml_call1(f, 0);
    var x = param[1];
    return x;
   }
   function get$0(a, param){if(! param) return a; var x = param[1]; return x;}
   function iter(f, param){
    if(! param) return 0;
    var x = param[1];
    return caml_call1(f, x);
   }
   function return$0(x){return [0, x];}
   function bind(opt, k){
    if(! opt) return 0;
    var x = opt[1];
    return caml_call1(k, x);
   }
   function to_list(param){
    if(! param) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function map$0(f, param){
    if(! param) return caml_call1(Lwt[4], 0);
    var x = param[1];
    return caml_call2
            (symbol_bind,
             caml_call1(f, x),
             function(v){return caml_call1(Lwt[4], [0, v]);});
   }
   function get$1(f, param){
    if(! param) return caml_call1(f, 0);
    var x = param[1];
    return caml_call1(Lwt[4], x);
   }
   function get$2(a, param){
    if(! param) return a;
    var x = param[1];
    return caml_call1(Lwt[4], x);
   }
   function iter$0(f, param){
    if(! param) return caml_call1(Lwt[4], 0);
    var x = param[1];
    return caml_call1(f, x);
   }
   function bind$0(opt, k){
    if(! opt) return caml_call1(Lwt[4], 0);
    var x = opt[1];
    return caml_call1(k, x);
   }
   var
    Lwt$0 = [0, map$0, get$1, get$2, iter$0, bind$0],
    Option = [0, map, get, get$0, iter, return$0, bind, to_list, Lwt$0],
    length = Stdlib_List[1],
    compare_lengths = Stdlib_List[2],
    compare_length_with = Stdlib_List[3],
    is_empty = Stdlib_List[4],
    cons = Stdlib_List[5],
    hd = Stdlib_List[6],
    tl = Stdlib_List[7],
    nth = Stdlib_List[8],
    nth_opt = Stdlib_List[9],
    rev = Stdlib_List[10],
    init = Stdlib_List[11],
    append = Stdlib_List[12],
    rev_append = Stdlib_List[13],
    concat = Stdlib_List[14],
    flatten = Stdlib_List[15],
    equal = Stdlib_List[16],
    compare = Stdlib_List[17],
    iter$1 = Stdlib_List[18],
    iteri = Stdlib_List[19],
    map$1 = Stdlib_List[20],
    mapi = Stdlib_List[21],
    rev_map = Stdlib_List[22],
    filter_map = Stdlib_List[23],
    concat_map = Stdlib_List[24],
    fold_left_map = Stdlib_List[25],
    fold_left = Stdlib_List[26],
    fold_right = Stdlib_List[27],
    iter2 = Stdlib_List[28],
    map2 = Stdlib_List[29],
    rev_map2 = Stdlib_List[30],
    fold_left2 = Stdlib_List[31],
    fold_right2 = Stdlib_List[32],
    for_all = Stdlib_List[33],
    exists = Stdlib_List[34],
    for_all2 = Stdlib_List[35],
    exists2 = Stdlib_List[36],
    mem = Stdlib_List[37],
    memq = Stdlib_List[38],
    find = Stdlib_List[39],
    find_opt = Stdlib_List[40],
    find_index = Stdlib_List[41],
    find_map = Stdlib_List[42],
    find_mapi = Stdlib_List[43],
    filter = Stdlib_List[44],
    find_all = Stdlib_List[45],
    filteri = Stdlib_List[46],
    partition = Stdlib_List[47],
    partition_map = Stdlib_List[48],
    assoc = Stdlib_List[49],
    assoc_opt = Stdlib_List[50],
    assq = Stdlib_List[51],
    assq_opt = Stdlib_List[52],
    mem_assoc = Stdlib_List[53],
    mem_assq = Stdlib_List[54],
    remove_assoc = Stdlib_List[55],
    remove_assq = Stdlib_List[56],
    split = Stdlib_List[57],
    combine = Stdlib_List[58],
    sort = Stdlib_List[59],
    stable_sort = Stdlib_List[60],
    fast_sort = Stdlib_List[61],
    sort_uniq = Stdlib_List[62],
    merge = Stdlib_List[63],
    to_seq = Stdlib_List[64],
    of_seq = Stdlib_List[65],
    _a_ = [0, 0, 0],
    cst_Clist_value = "Clist.value";
   function map_filter(f, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(Stdlib_List[10], acc);
     var q = param[2], t = param[1], match = caml_call1(f, t);
     if(match){
      var r = match[1], acc$0 = [0, r, acc];
      acc = acc$0;
      param = q;
     }
     else
      param = q;
    }
   }
   function remove_first_if_any(a, param){
    if(! param) return 0;
    var b = param[1], l = param[2];
    if(caml_equal(a, b)) return l;
    var l$0 = param[2];
    return [0, b, remove_first_if_any(a, l$0)];
   }
   function remove_first_if_any_q(a, param){
    if(! param) return 0;
    var b = param[1], l = param[2];
    if(a === b) return l;
    var l$0 = param[2];
    return [0, b, remove_first_if_any_q(a, l$0)];
   }
   function remove_first(a, param){
    if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var b = param[1], l = param[2];
    if(caml_equal(a, b)) return l;
    var l$0 = param[2];
    return [0, b, remove_first(a, l$0)];
   }
   function remove_first_q(a, param){
    if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var b = param[1], l = param[2];
    if(a === b) return l;
    var l$0 = param[2];
    return [0, b, remove_first_q(a, l$0)];
   }
   function remove_all(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var b = param$0[1], l = param$0[2];
     if(! caml_equal(a, b)){
      var l$0 = param$0[2];
      return [0, b, remove_all(a, l$0)];
     }
     param$0 = l;
    }
   }
   function remove_all_q(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var b = param$0[1], l = param$0[2];
     if(a !== b){var l$0 = param$0[2]; return [0, b, remove_all_q(a, l$0)];}
     param$0 = l;
    }
   }
   function remove_all_assoc(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var _Z_ = param$0[1], l = param$0[2], b = _Z_[1];
     if(! caml_equal(a, b)){
      var l$0 = param$0[2];
      return [0, _Z_, remove_all_assoc(a, l$0)];
     }
     param$0 = l;
    }
   }
   function remove_all_assoc_q(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var _Y_ = param$0[1], l = param$0[2], b = _Y_[1];
     if(a !== b){
      var l$0 = param$0[2];
      return [0, _Y_, remove_all_assoc_q(a, l$0)];
     }
     param$0 = l;
    }
   }
   function last(param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var b = param$0[1];
     if(! param$0[2]) return b;
     var l = param$0[2];
     param$0 = l;
    }
   }
   function assoc_remove(a, param){
    if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var _X_ = param[1], l = param[2], c = _X_[2], b = _X_[1];
    if(caml_equal(a, b)) return [0, c, l];
    var
     l$0 = param[2],
     match = assoc_remove(a, l$0),
     ll = match[2],
     v = match[1];
    return [0, v, [0, _X_, ll]];
   }
   function is_prefix(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return 1;
     if(l2$0){
      var ll2 = l2$0[2], b = l2$0[1], ll1 = l1$0[2], a = l1$0[1];
      if(caml_equal(a, b)){l1$0 = ll1; l2$0 = ll2; continue;}
     }
     return 0;
    }
   }
   function chop(n, xs){
    var n$0 = n, xs$0 = xs;
    for(;;){
     if(0 >= n$0) return xs$0;
     if(! xs$0) return 0;
     var xs$1 = xs$0[2], n$1 = n$0 - 1 | 0;
     n$0 = n$1;
     xs$0 = xs$1;
    }
   }
   function split_at(n, xs){
    if(0 >= n) return [0, 0, xs];
    if(! xs) return _a_;
    var
     xs$0 = xs[2],
     x = xs[1],
     match = split_at(n - 1 | 0, xs$0),
     r = match[2],
     l = match[1];
    return [0, [0, x, l], r];
   }
   function make(c){
    var x = [];
    runtime.caml_update_dummy(x, [0, c, x, x]);
    return x;
   }
   function make$0(c){return make([0, c]);}
   function create(param){return make(0);}
   function insert(p, x){
    var n = p[3];
    p[3] = x;
    x[2] = p;
    x[3] = n;
    n[2] = x;
    return 0;
   }
   function remove(x){
    var p = x[2], n = x[3];
    p[3] = n;
    n[2] = p;
    x[3] = x;
    x[2] = x;
    return 0;
   }
   function in_list(x){return x[3] !== x ? 1 : 0;}
   function is_empty$0(set){return set[3] === set ? 1 : 0;}
   function value(c){
    var match = c[1];
    if(! match) return caml_call1(Stdlib[2], cst_Clist_value);
    var c$0 = match[1];
    return c$0;
   }
   function iter$2(f, node){
    var node$0 = node;
    for(;;){
     var match = node$0[3][1];
     if(! match) return 0;
     var c = match[1];
     caml_call1(f, c);
     var node$1 = node$0[3];
     node$0 = node$1;
    }
   }
   function fold_left$0(f, a, node){
    var a$0 = a, node$0 = node;
    for(;;){
     var match = node$0[3][1];
     if(! match) return a$0;
     var c = match[1], node$1 = node$0[3], a$1 = caml_call2(f, a$0, c);
     a$0 = a$1;
     node$0 = node$1;
    }
   }
   var
    Clist =
      [0,
       make$0,
       create,
       insert,
       remove,
       value,
       in_list,
       is_empty$0,
       iter$2,
       fold_left$0],
    compare$0 = runtime.caml_compare,
    Table = caml_call1(Stdlib_Map[1], [0, compare$0]),
    Int = [0, Table],
    make$1 = Stdlib_String[1],
    init$0 = Stdlib_String[2],
    empty = Stdlib_String[3],
    of_bytes = Stdlib_String[4],
    to_bytes = Stdlib_String[5],
    blit = Stdlib_String[6],
    concat$0 = Stdlib_String[7],
    cat = Stdlib_String[8],
    equal$0 = Stdlib_String[9],
    compare$1 = Stdlib_String[10],
    starts_with = Stdlib_String[11],
    ends_with = Stdlib_String[12],
    contains_from = Stdlib_String[13],
    rcontains_from = Stdlib_String[14],
    contains = Stdlib_String[15],
    sub = Stdlib_String[16],
    split_on_char = Stdlib_String[17],
    map$2 = Stdlib_String[18],
    mapi$0 = Stdlib_String[19],
    fold_left$1 = Stdlib_String[20],
    fold_right$0 = Stdlib_String[21],
    for_all$0 = Stdlib_String[22],
    exists$0 = Stdlib_String[23],
    trim = Stdlib_String[24],
    escaped = Stdlib_String[25],
    uppercase_ascii = Stdlib_String[26],
    lowercase_ascii = Stdlib_String[27],
    capitalize_ascii = Stdlib_String[28],
    uncapitalize_ascii = Stdlib_String[29],
    iter$3 = Stdlib_String[30],
    iteri$0 = Stdlib_String[31],
    index_from = Stdlib_String[32],
    index_from_opt = Stdlib_String[33],
    rindex_from = Stdlib_String[34],
    rindex_from_opt = Stdlib_String[35],
    index = Stdlib_String[36],
    index_opt = Stdlib_String[37],
    rindex = Stdlib_String[38],
    rindex_opt = Stdlib_String[39],
    to_seq$0 = Stdlib_String[40],
    to_seqi = Stdlib_String[41],
    of_seq$0 = Stdlib_String[42],
    get_utf_8_uchar = Stdlib_String[43],
    is_valid_utf_8 = Stdlib_String[44],
    get_utf_16be_uchar = Stdlib_String[45],
    is_valid_utf_16be = Stdlib_String[46],
    get_utf_16le_uchar = Stdlib_String[47],
    is_valid_utf_16le = Stdlib_String[48],
    get_uint8 = Stdlib_String[49],
    get_int8 = Stdlib_String[50],
    get_uint16_ne = Stdlib_String[51],
    get_uint16_be = Stdlib_String[52],
    get_uint16_le = Stdlib_String[53],
    get_int16_ne = Stdlib_String[54],
    get_int16_be = Stdlib_String[55],
    get_int16_le = Stdlib_String[56],
    get_int32_ne = Stdlib_String[57],
    hash = Stdlib_String[58],
    seeded_hash = Stdlib_String[59],
    get_int32_be = Stdlib_String[60],
    get_int32_le = Stdlib_String[61],
    get_int64_ne = Stdlib_String[62],
    get_int64_be = Stdlib_String[63],
    get_int64_le = Stdlib_String[64];
   function remove_spaces(s, beg, endd){
    function find_not_space(s, i, step){
     var i$0 = i;
     for(;;){
      if(endd >= i$0 && i$0 >= beg){
       if(32 !== caml_string_get(s, i$0)) return i$0;
       var i$1 = i$0 + step | 0;
       i$0 = i$1;
       continue;
      }
      return i$0;
     }
    }
    var first = find_not_space(s, beg, 1), last = find_not_space(s, endd, -1);
    return first <= last
            ? caml_call3
              (Stdlib_String[16], s, first, (1 + last | 0) - first | 0)
            : cst;
   }
   function basic_sep(char$0, s){
    try{
     var
      seppos = caml_call2(Stdlib_String[36], s, char$0),
      _U_ =
        caml_call3
         (Stdlib_String[16],
          s,
          seppos + 1 | 0,
          (caml_ml_string_length(s) - seppos | 0) - 1 | 0),
      _V_ = [0, caml_call3(Stdlib_String[16], s, 0, seppos), _U_];
     return _V_;
    }
    catch(_W_){
     var _T_ = caml_wrap_exception(_W_);
     if(_T_[1] === Stdlib[6]) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     throw caml_maybe_attach_backtrace(_T_, 0);
    }
   }
   function sep(char$0, s){
    var
     len = caml_ml_string_length(s),
     seppos = caml_call2(Stdlib_String[36], s, char$0),
     _S_ = remove_spaces(s, seppos + 1 | 0, len - 1 | 0);
    return [0, remove_spaces(s, 0, seppos - 1 | 0), _S_];
   }
   function split$0(opt, char$0, s){
    var multisep = opt ? opt[1] : 0, longueur = caml_ml_string_length(s);
    function aux(deb){
     if(longueur <= deb) return 0;
     try{
      var firstsep = caml_call3(Stdlib_String[32], s, deb, char$0);
      a:
      {
       if(multisep && firstsep === deb){var _P_ = aux(deb + 1 | 0); break a;}
       var
        _Q_ = aux(firstsep + 1 | 0),
        _P_ = [0, remove_spaces(s, deb, firstsep - 1 | 0), _Q_];
      }
      return _P_;
     }
     catch(_R_){
      var _O_ = caml_wrap_exception(_R_);
      if(_O_ === Stdlib[8])
       return [0, remove_spaces(s, deb, longueur - 1 | 0), 0];
      throw caml_maybe_attach_backtrace(_O_, 0);
     }
    }
    return aux(0);
   }
   function may_append(s1, sep, s2){
    if(s2 === cst$5) return s1;
    var _N_ = caml_call2(Stdlib[28], sep, s2);
    return caml_call2(Stdlib[28], s1, _N_);
   }
   function may_concat(s1, sep, s2){
    return s2 !== cst$5
            ? s1
              !== cst$5
              ? caml_call2(Stdlib_String[7], sep, [0, s1, [0, s2, 0]])
              : s2
            : s1;
   }
   function first_diff(s1, s2, n, last){
    try{
     var
      _K_ = caml_string_get(s2, n),
      _L_ =
        caml_string_get(s1, n) === _K_
         ? n === last ? last + 1 | 0 : first_diff(s1, s2, n + 1 | 0, last)
         : n;
     return _L_;
    }
    catch(_M_){
     var _J_ = caml_wrap_exception(_M_);
     if(_J_[1] === Stdlib[6]) return n;
     throw caml_maybe_attach_backtrace(_J_, 0);
    }
   }
   var
    Table$0 = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]),
    Set = caml_call1(Stdlib_Set[1], [0, Stdlib_String[10]]),
    Map = caml_call1(Stdlib_Map[1], [0, Stdlib_String[10]]),
    String_base =
      [0,
       make$1,
       init$0,
       empty,
       of_bytes,
       to_bytes,
       blit,
       concat$0,
       cat,
       equal$0,
       compare$1,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map$2,
       mapi$0,
       fold_left$1,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter$3,
       iteri$0,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq$0,
       to_seqi,
       of_seq$0,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       hash,
       seeded_hash,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       remove_spaces,
       basic_sep,
       sep,
       split$0,
       may_append,
       may_concat,
       first_diff,
       Table$0,
       Set,
       Map],
    cst_https = "https://",
    cst_http = "http://",
    _b_ = [0, cst$5, 0],
    _c_ = [0, cst$5, 0],
    _d_ = [0, cst$5, 0],
    _e_ = [0, cst$5, 0],
    _f_ = [0, cst$5, 0],
    _g_ = [0, cst$5, 0],
    _h_ = [0, cst$5, 0],
    _i_ = [0, cst$5, 0],
    _j_ = [0, cst$6, [0, cst$5, 0]],
    _k_ = [0, cst$5, 0];
   function make_absolute_url(https, host, port, uri){
    a:
    {
     b:
     {
      if(80 === port && ! https) break b;
      if(https && 443 === port) break b;
      var
       _I_ = caml_call1(Stdlib[33], port),
       _E_ = caml_call2(Stdlib[28], cst$1, _I_);
      break a;
     }
     var _E_ = cst$0;
    }
    var
     _F_ = caml_call2(Stdlib[28], _E_, uri),
     _G_ = caml_call2(Stdlib[28], host, _F_),
     _H_ = https ? cst_https : cst_http;
    return caml_call2(Stdlib[28], _H_, _G_);
   }
   function aux(l){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var a = l$0[1];
     if(a !== cst$5){
      if(a === cst$6){var l$2 = l$0[2]; l$0 = l$2; continue;}
     }
     else if(! l$0[2]) return l$0;
     var l$1 = l$0[2];
     return [0, a, aux(l$1)];
    }
   }
   function remove_dotdot(l){
    if(! l) return 0;
    if(l[1] !== cst$5) return aux(l);
    var l$0 = l[2];
    return [0, cst$2, aux(l$0)];
   }
   function remove_end_slash(s){
    try{
     var
      _C_ =
        47 === caml_string_get(s, caml_ml_string_length(s) - 1 | 0)
         ? caml_call3
           (Stdlib_String[16], s, 0, caml_ml_string_length(s) - 1 | 0)
         : s;
     return _C_;
    }
    catch(_D_){
     var _B_ = caml_wrap_exception(_D_);
     if(_B_[1] === Stdlib[6]) return s;
     throw caml_maybe_attach_backtrace(_B_, 0);
    }
   }
   function remove_internal_slash(u){
    function aux(param){
     var param$0 = param;
     for(;;){
      if(! param$0) return 0;
      var a = param$0[1];
      if(! param$0[2]) return [0, a, 0];
      if(a !== cst$5){var l = param$0[2]; return [0, a, aux(l)];}
      var l$0 = param$0[2];
      param$0 = l$0;
     }
    }
    if(! u) return 0;
    var l = u[2], a = u[1];
    return [0, a, aux(l)];
   }
   function change_empty_list(l){return l ? l : _b_;}
   function add_end_slash_if_missing(a){
    if(! a) return _c_;
    var a$0 = a[1];
    if(a$0 === cst$5 && ! a[2]) return a;
    var l = a[2];
    return [0, a$0, add_end_slash_if_missing(l)];
   }
   function remove_slash_at_end(param){
    a:
    if(param){
     var a = param[1];
     if(a === cst$5 && ! param[2]) break a;
     var l = param[2];
     return [0, a, remove_slash_at_end(l)];
    }
    return 0;
   }
   function remove_slash_at_beginning(l){
    if(! l) return 0;
    if(l[1] !== cst$5) return l;
    var l$0 = l[2];
    return l$0 ? l$0 : _d_;
   }
   function is_prefix_skip_end_slash(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     a:
     if(l1$0){
      var a = l1$0[1];
      if(a === cst$5 && ! l1$0[2]) break a;
      if(l2$0){
       var ll2 = l2$0[2], b = l2$0[1], ll1 = l1$0[2];
       if(a === b){l1$0 = ll1; l2$0 = ll2; continue;}
      }
      return 0;
     }
     return 1;
    }
   }
   function split_fragment(s){
    try{
     var
      pos = caml_call2(Stdlib_String[36], s, 35),
      _y_ =
        [0,
         caml_call3
          (Stdlib_String[16],
           s,
           pos + 1 | 0,
           (caml_ml_string_length(s) - 1 | 0) - pos | 0)],
      _z_ = [0, caml_call3(Stdlib_String[16], s, 0, pos), _y_];
     return _z_;
    }
    catch(_A_){
     var _x_ = caml_wrap_exception(_A_);
     if(_x_ === Stdlib[8]) return [0, s, 0];
     throw caml_maybe_attach_backtrace(_x_, 0);
    }
   }
   function join_path(l){
    if(l && l[1] === cst$5 && ! l[2]) return cst$4;
    return caml_call2(Stdlib_String[7], cst$3, l);
   }
   function split_path(s){
    var l = caml_ml_string_length(s);
    function collect_words(k){
     try{var _v_ = caml_call3(Stdlib_String[32], s, k, 47), k$0 = _v_;}
     catch(_w_){
      var _u_ = caml_wrap_exception(_w_);
      if(_u_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_u_, 0);
      var k$0 = l;
     }
     var word = caml_call3(Stdlib_String[16], s, k, k$0 - k | 0);
     return l <= k$0 ? [0, word, 0] : [0, word, collect_words(k$0 + 1 | 0)];
    }
    var other = collect_words(0);
    if(other && other[1] === cst$5){
     var _t_ = other[2];
     if(! _t_) return 0;
     if(_t_[1] === cst$5 && ! _t_[2]) return _e_;
    }
    return other;
   }
   function norm_path(l){
    function remove_slash_slash(l, first){
     var l$0 = l, first$0 = first;
     for(;;){
      if(! l$0) return 0;
      var x = l$0[1];
      if(x === cst$5){
       var l$2 = l$0[2];
       if(! l$2) return _g_;
       if(l$2[1] === cst$5 && ! l$2[2] && first$0) return _f_;
       if(! first$0){l$0 = l$2; first$0 = 0; continue;}
      }
      var l$1 = l$0[2];
      return [0, x, remove_slash_slash(l$1, 0)];
     }
    }
    function remove_dot(l, first){
     var l$0 = l, first$0 = first;
     for(;;){
      if(! l$0) return 0;
      var x = l$0[1];
      if(x !== "."){var l$1 = l$0[2]; return [0, x, remove_dot(l$1, 0)];}
      var match = l$0[2];
      a:
      if(match){
       var x$0 = match[1];
       if(x$0 === cst$5 && ! match[2]) break a;
       var l$2 = match[2], l$3 = [0, x$0, l$2];
       l$0 = l$3;
       first$0 = 0;
       continue;
      }
      return first$0 ? 0 : _h_;
     }
    }
    function remove_dot_dot_once(l, first){
     if(! l) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var x = l[1], _s_ = l[2];
     if(_s_ && _s_[1] === cst$6){
      var l$1 = _s_[2];
      if(! l$1 && x !== cst$5 && x !== cst$6 && ! first) return _i_;
      if(x !== cst$5 && x !== cst$6) return l$1;
     }
     var l$0 = l[2];
     return [0, x, remove_dot_dot_once(l$0, 0)];
    }
    function remove_dot_dot(l){
     try{
      var l$0 = remove_dot_dot_once(l, 1), _q_ = remove_dot_dot(l$0);
      return _q_;
     }
     catch(_r_){
      var _p_ = caml_wrap_exception(_r_);
      if(_p_ === Stdlib[8]) return l;
      throw caml_maybe_attach_backtrace(_p_, 0);
     }
    }
    var l$0 = remove_dot_dot(remove_dot(remove_slash_slash(l, 1), 1));
    if(l$0){
     var _n_ = l$0[1];
     if(_n_ !== cst$5){
      if(_n_ === cst$6 && ! l$0[2]) return _j_;
     }
     else{
      var _o_ = l$0[2];
      if(_o_ && _o_[1] === cst$5 && ! _o_[2]) return _k_;
     }
    }
    return l$0;
   }
   var
    Url_base =
      [0,
       make_absolute_url,
       remove_dotdot,
       remove_end_slash,
       remove_internal_slash,
       change_empty_list,
       add_end_slash_if_missing,
       remove_slash_at_end,
       remove_slash_at_beginning,
       is_prefix_skip_end_slash,
       split_fragment,
       join_path,
       split_path,
       norm_path],
    debug = Stdlib[53],
    Ocsigen_lib_base =
      [0,
       Ocsigen_Internal_Error,
       Input_is_too_large,
       Ocsigen_Bad_Request,
       Ocsigen_Request_too_long,
       symbol_bind,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       comp,
       curry,
       uncurry,
       Tuple3,
       function(_m_){return _m_;},
       function(_l_){return _l_;},
       advert,
       Option,
       [0,
        length,
        compare_lengths,
        compare_length_with,
        is_empty,
        cons,
        hd,
        tl,
        nth,
        nth_opt,
        rev,
        init,
        append,
        rev_append,
        concat,
        flatten,
        equal,
        compare,
        iter$1,
        iteri,
        map$1,
        mapi,
        rev_map,
        filter_map,
        concat_map,
        fold_left_map,
        fold_left,
        fold_right,
        iter2,
        map2,
        rev_map2,
        fold_left2,
        fold_right2,
        for_all,
        exists,
        for_all2,
        exists2,
        mem,
        memq,
        find,
        find_opt,
        find_index,
        find_map,
        find_mapi,
        filter,
        find_all,
        filteri,
        partition,
        partition_map,
        assoc,
        assoc_opt,
        assq,
        assq_opt,
        mem_assoc,
        mem_assq,
        remove_assoc,
        remove_assq,
        split,
        combine,
        sort,
        stable_sort,
        fast_sort,
        sort_uniq,
        merge,
        to_seq,
        of_seq,
        map_filter,
        last,
        assoc_remove,
        remove_first_if_any,
        remove_first_if_any_q,
        remove_first,
        remove_first_q,
        remove_all,
        remove_all_q,
        remove_all_assoc,
        remove_all_assoc_q,
        is_prefix,
        chop,
        split_at],
       Clist,
       Int,
       String_base,
       Url_base,
       debug];
   runtime.caml_register_global(58, Ocsigen_lib_base, "Ocsigen_lib_base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NzaWdlbl9saWJfYmFzZS5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NzaWdlbl9saWJfYmFzZS5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9lcXVhbCIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ19nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiYWR2ZXJ0IiwiU3RkbGliIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9MaXN0IiwiTHd0IiwiQ2FtbGludGVybmFsTGF6eSIsIlN0ZGxpYl9NYXAiLCJTdGRsaWJfU2V0IiwiT2NzaWdlbl9JbnRlcm5hbF9FcnJvciIsIklucHV0X2lzX3Rvb19sYXJnZSIsIk9jc2lnZW5fQmFkX1JlcXVlc3QiLCJPY3NpZ2VuX1JlcXVlc3RfdG9vX2xvbmciLCJzeW1ib2xfYmluZCIsInN5bWJvbCIsIngiLCJjb21wIiwiZyIsImN1cnJ5IiwieSIsInVuY3VycnkiLCJwYXJhbSIsImZzdCIsImEiLCJzbmQiLCJ0aGQiLCJUdXBsZTMiLCJtYXAiLCJnZXQiLCJpdGVyIiwicmV0dXJuIiwiYmluZCIsIm9wdCIsImsiLCJ0b19saXN0IiwidiIsIk9wdGlvbiIsImxlbmd0aCIsImNvbXBhcmVfbGVuZ3RocyIsImNvbXBhcmVfbGVuZ3RoX3dpdGgiLCJpc19lbXB0eSIsImNvbnMiLCJoZCIsInRsIiwibnRoIiwibnRoX29wdCIsInJldiIsImluaXQiLCJhcHBlbmQiLCJyZXZfYXBwZW5kIiwiY29uY2F0IiwiZmxhdHRlbiIsImVxdWFsIiwiY29tcGFyZSIsIml0ZXJpIiwibWFwaSIsInJldl9tYXAiLCJmaWx0ZXJfbWFwIiwiY29uY2F0X21hcCIsImZvbGRfbGVmdF9tYXAiLCJmb2xkX2xlZnQiLCJmb2xkX3JpZ2h0IiwiaXRlcjIiLCJtYXAyIiwicmV2X21hcDIiLCJmb2xkX2xlZnQyIiwiZm9sZF9yaWdodDIiLCJmb3JfYWxsIiwiZXhpc3RzIiwiZm9yX2FsbDIiLCJleGlzdHMyIiwibWVtIiwibWVtcSIsImZpbmQiLCJmaW5kX29wdCIsImZpbmRfaW5kZXgiLCJmaW5kX21hcCIsImZpbmRfbWFwaSIsImZpbHRlciIsImZpbmRfYWxsIiwiZmlsdGVyaSIsInBhcnRpdGlvbiIsInBhcnRpdGlvbl9tYXAiLCJhc3NvYyIsImFzc29jX29wdCIsImFzc3EiLCJhc3NxX29wdCIsIm1lbV9hc3NvYyIsIm1lbV9hc3NxIiwicmVtb3ZlX2Fzc29jIiwicmVtb3ZlX2Fzc3EiLCJzcGxpdCIsImNvbWJpbmUiLCJzb3J0Iiwic3RhYmxlX3NvcnQiLCJmYXN0X3NvcnQiLCJzb3J0X3VuaXEiLCJtZXJnZSIsInRvX3NlcSIsIm9mX3NlcSIsImNzdF9DbGlzdF92YWx1ZSIsIm1hcF9maWx0ZXIiLCJsIiwiYWNjIiwicSIsInQiLCJtYXRjaCIsInIiLCJyZW1vdmVfZmlyc3RfaWZfYW55IiwiYiIsInJlbW92ZV9maXJzdF9pZl9hbnlfcSIsInJlbW92ZV9maXJzdCIsInJlbW92ZV9maXJzdF9xIiwicmVtb3ZlX2FsbCIsInJlbW92ZV9hbGxfcSIsInJlbW92ZV9hbGxfYXNzb2MiLCJyZW1vdmVfYWxsX2Fzc29jX3EiLCJsYXN0IiwiYXNzb2NfcmVtb3ZlIiwiYyIsImxsIiwiaXNfcHJlZml4IiwibDEiLCJsMiIsImxsMiIsImxsMSIsImNob3AiLCJuIiwieHMiLCJzcGxpdF9hdCIsIm1ha2UiLCJjcmVhdGUiLCJpbnNlcnQiLCJwIiwicmVtb3ZlIiwiaW5fbGlzdCIsInNldCIsInZhbHVlIiwibm9kZSIsIkNsaXN0IiwiVGFibGUiLCJJbnQiLCJlbXB0eSIsIm9mX2J5dGVzIiwidG9fYnl0ZXMiLCJibGl0IiwiY2F0Iiwic3RhcnRzX3dpdGgiLCJlbmRzX3dpdGgiLCJjb250YWluc19mcm9tIiwicmNvbnRhaW5zX2Zyb20iLCJjb250YWlucyIsInN1YiIsInNwbGl0X29uX2NoYXIiLCJ0cmltIiwiZXNjYXBlZCIsInVwcGVyY2FzZV9hc2NpaSIsImxvd2VyY2FzZV9hc2NpaSIsImNhcGl0YWxpemVfYXNjaWkiLCJ1bmNhcGl0YWxpemVfYXNjaWkiLCJpbmRleF9mcm9tIiwiaW5kZXhfZnJvbV9vcHQiLCJyaW5kZXhfZnJvbSIsInJpbmRleF9mcm9tX29wdCIsImluZGV4IiwiaW5kZXhfb3B0IiwicmluZGV4IiwicmluZGV4X29wdCIsInRvX3NlcWkiLCJnZXRfdXRmXzhfdWNoYXIiLCJpc192YWxpZF91dGZfOCIsImdldF91dGZfMTZiZV91Y2hhciIsImlzX3ZhbGlkX3V0Zl8xNmJlIiwiZ2V0X3V0Zl8xNmxlX3VjaGFyIiwiaXNfdmFsaWRfdXRmXzE2bGUiLCJnZXRfdWludDgiLCJnZXRfaW50OCIsImdldF91aW50MTZfbmUiLCJnZXRfdWludDE2X2JlIiwiZ2V0X3VpbnQxNl9sZSIsImdldF9pbnQxNl9uZSIsImdldF9pbnQxNl9iZSIsImdldF9pbnQxNl9sZSIsImdldF9pbnQzMl9uZSIsImhhc2giLCJzZWVkZWRfaGFzaCIsImdldF9pbnQzMl9iZSIsImdldF9pbnQzMl9sZSIsImdldF9pbnQ2NF9uZSIsImdldF9pbnQ2NF9iZSIsImdldF9pbnQ2NF9sZSIsInJlbW92ZV9zcGFjZXMiLCJzIiwiYmVnIiwiZW5kZCIsImZpbmRfbm90X3NwYWNlIiwiaSIsInN0ZXAiLCJmaXJzdCIsImJhc2ljX3NlcCIsImNoYXIiLCJzZXBwb3MiLCJzZXAiLCJsZW4iLCJtdWx0aXNlcCIsImxvbmd1ZXVyIiwiYXV4IiwiZGViIiwiZmlyc3RzZXAiLCJtYXlfYXBwZW5kIiwiczEiLCJzMiIsIm1heV9jb25jYXQiLCJmaXJzdF9kaWZmIiwiU2V0IiwiTWFwIiwiU3RyaW5nX2Jhc2UiLCJjc3RfaHR0cHMiLCJjc3RfaHR0cCIsIm1ha2VfYWJzb2x1dGVfdXJsIiwiaHR0cHMiLCJob3N0IiwicG9ydCIsInVyaSIsInJlbW92ZV9kb3Rkb3QiLCJyZW1vdmVfZW5kX3NsYXNoIiwicmVtb3ZlX2ludGVybmFsX3NsYXNoIiwidSIsImNoYW5nZV9lbXB0eV9saXN0IiwiYWRkX2VuZF9zbGFzaF9pZl9taXNzaW5nIiwicmVtb3ZlX3NsYXNoX2F0X2VuZCIsInJlbW92ZV9zbGFzaF9hdF9iZWdpbm5pbmciLCJpc19wcmVmaXhfc2tpcF9lbmRfc2xhc2giLCJzcGxpdF9mcmFnbWVudCIsInBvcyIsImpvaW5fcGF0aCIsInNwbGl0X3BhdGgiLCJjb2xsZWN0X3dvcmRzIiwid29yZCIsIm90aGVyIiwibm9ybV9wYXRoIiwicmVtb3ZlX3NsYXNoX3NsYXNoIiwicmVtb3ZlX2RvdCIsInJlbW92ZV9kb3RfZG90X29uY2UiLCJyZW1vdmVfZG90X2RvdCIsIlVybF9iYXNlIiwiZGVidWciLCJPY3NpZ2VuX2xpYl9iYXNlIl0sInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvaG9tZS9iZWVsaWd1bC8ub3BhbS9vY2FtbC01LjIuMC9saWIvb2NzaWdlbnNlcnZlci9iYXNlbGliL2Jhc2Uvb2NzaWdlbl9saWJfYmFzZS5tbCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FB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QUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0MwVUk7QUFBQTtBQUFBLEVEMVVKIiwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBPY3NpZ2VuXG4gKiBDb3B5cmlnaHQgKEMpIDIwMDUtMjAwOCBWaW5jZW50IEJhbGF0LCBTdMOpcGhhbmUgR2xvbmR1XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbmV4Y2VwdGlvbiBPY3NpZ2VuX0ludGVybmFsX0Vycm9yIG9mIHN0cmluZ1xuZXhjZXB0aW9uIElucHV0X2lzX3Rvb19sYXJnZVxuZXhjZXB0aW9uIE9jc2lnZW5fQmFkX1JlcXVlc3RcbmV4Y2VwdGlvbiBPY3NpZ2VuX1JlcXVlc3RfdG9vX2xvbmdcblxuZXh0ZXJuYWwgaWQgOiAnYSAtPiAnYSA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggPj49ICkgPSBMd3QuYmluZFxubGV0ICggPnw9ICkgPSBMd3QuKCA+fD0gKVxubGV0ICggISEgKSA9IExhenkuZm9yY2VcbmxldCAoIHw+ICkgeCBmID0gZiB4XG5sZXQgKCBAQCApIGYgeCA9IGYgeFxubGV0IGNvbXAgZiBnIHggPSBmIChnIHgpXG5sZXQgY3VycnkgZiB4IHkgPSBmICh4LCB5KVxubGV0IHVuY3VycnkgZiAoeCwgeSkgPSBmIHggeVxuXG50eXBlIHBvbHlcblxuZXh0ZXJuYWwgdG9fcG9seSA6ICdhIC0+IHBvbHkgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBmcm9tX3BvbHkgOiBwb2x5IC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuXG5tb2R1bGUgVHVwbGUzID0gc3RydWN0XG4gIGxldCBmc3QgKGEsIF8sIF8pID0gYVxuICBsZXQgc25kIChfLCBhLCBfKSA9IGFcbiAgbGV0IHRoZCAoXywgXywgYSkgPSBhXG5lbmRcblxudHlwZSB5ZXNub21heWJlID0gWWVzIHwgTm8gfCBNYXliZVxudHlwZSAoJ2EsICdiKSBsZWZ0cmlnaHQgPSBMZWZ0IG9mICdhIHwgUmlnaHQgb2YgJ2JcblxubGV0IGFkdmVydCA9XG4gIFwiUGFnZSBnZW5lcmF0ZWQgYnkgT0NhbWwgd2l0aCBPY3NpZ2VuLlxuU2VlIGh0dHA6Ly9vY3NpZ2VuLm9yZy8gYW5kIGh0dHA6Ly9jYW1sLmlucmlhLmZyLyBmb3IgaW5mb3JtYXRpb25cIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSBPcHRpb24gPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IG1hcCBmID0gZnVuY3Rpb24gU29tZSB4IC0+IFNvbWUgKGYgeCkgfCBOb25lIC0+IE5vbmVcbiAgbGV0IGdldCBmID0gZnVuY3Rpb24gU29tZSB4IC0+IHggfCBOb25lIC0+IGYgKClcbiAgbGV0IGdldCcgYSA9IGZ1bmN0aW9uIFNvbWUgeCAtPiB4IHwgTm9uZSAtPiBhXG4gIGxldCBpdGVyIGYgPSBmdW5jdGlvbiBTb21lIHggLT4gZiB4IHwgTm9uZSAtPiAoKVxuICBsZXQgcmV0dXJuIHggPSBTb21lIHhcbiAgbGV0IGJpbmQgb3B0IGsgPSBtYXRjaCBvcHQgd2l0aCBTb21lIHggLT4gayB4IHwgTm9uZSAtPiBOb25lXG4gIGxldCB0b19saXN0ID0gZnVuY3Rpb24gTm9uZSAtPiBbXSB8IFNvbWUgdiAtPiBbdl1cblxuICBtb2R1bGUgTHd0ID0gc3RydWN0XG4gICAgbGV0IG1hcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgU29tZSB4IC0+IGYgeCA+Pj0gZnVuIHYgLT4gTHd0LnJldHVybiAoU29tZSB2KVxuICAgICAgfCBOb25lIC0+IEx3dC5yZXR1cm4gTm9uZVxuXG4gICAgbGV0IGdldCBmID0gZnVuY3Rpb24gU29tZSB4IC0+IEx3dC5yZXR1cm4geCB8IE5vbmUgLT4gZiAoKVxuICAgIGxldCBnZXQnIGEgPSBmdW5jdGlvbiBTb21lIHggLT4gTHd0LnJldHVybiB4IHwgTm9uZSAtPiBhXG4gICAgbGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgeCAtPiBmIHggfCBOb25lIC0+IEx3dC5yZXR1cm4gKClcbiAgICBsZXQgYmluZCBvcHQgayA9IG1hdGNoIG9wdCB3aXRoIFNvbWUgeCAtPiBrIHggfCBOb25lIC0+IEx3dC5yZXR1cm4gTm9uZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIExpc3RcblxuICBsZXQgbWFwX2ZpbHRlciBmIGwgPVxuICAgIGxldCByZWMgYXV4IGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IGFjY1xuICAgICAgfCB0IDo6IHEgLT4gKFxuICAgICAgICBtYXRjaCBmIHQgd2l0aCBOb25lIC0+IGF1eCBhY2MgcSB8IFNvbWUgciAtPiBhdXggKHIgOjogYWNjKSBxKVxuICAgIGluXG4gICAgTGlzdC5yZXYgKGF1eCBbXSBsKVxuXG4gIGxldCByZWMgcmVtb3ZlX2ZpcnN0X2lmX2FueSBhID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCBiIDo6IGwgd2hlbiBhID0gYiAtPiBsXG4gICAgfCBiIDo6IGwgLT4gYiA6OiByZW1vdmVfZmlyc3RfaWZfYW55IGEgbFxuXG4gIGxldCByZWMgcmVtb3ZlX2ZpcnN0X2lmX2FueV9xIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IGIgOjogbCB3aGVuIGEgPT0gYiAtPiBsXG4gICAgfCBiIDo6IGwgLT4gYiA6OiByZW1vdmVfZmlyc3RfaWZfYW55X3EgYSBsXG5cbiAgbGV0IHJlYyByZW1vdmVfZmlyc3QgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IGIgOjogbCB3aGVuIGEgPSBiIC0+IGxcbiAgICB8IGIgOjogbCAtPiBiIDo6IHJlbW92ZV9maXJzdCBhIGxcblxuICBsZXQgcmVjIHJlbW92ZV9maXJzdF9xIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCBiIDo6IGwgd2hlbiBhID09IGIgLT4gbFxuICAgIHwgYiA6OiBsIC0+IGIgOjogcmVtb3ZlX2ZpcnN0X3EgYSBsXG5cbiAgbGV0IHJlYyByZW1vdmVfYWxsIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IGIgOjogbCB3aGVuIGEgPSBiIC0+IHJlbW92ZV9hbGwgYSBsXG4gICAgfCBiIDo6IGwgLT4gYiA6OiByZW1vdmVfYWxsIGEgbFxuXG4gIGxldCByZWMgcmVtb3ZlX2FsbF9xIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IGIgOjogbCB3aGVuIGEgPT0gYiAtPiByZW1vdmVfYWxsX3EgYSBsXG4gICAgfCBiIDo6IGwgLT4gYiA6OiByZW1vdmVfYWxsX3EgYSBsXG5cbiAgbGV0IHJlYyByZW1vdmVfYWxsX2Fzc29jIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IChiLCBfKSA6OiBsIHdoZW4gYSA9IGIgLT4gcmVtb3ZlX2FsbF9hc3NvYyBhIGxcbiAgICB8IGIgOjogbCAtPiBiIDo6IHJlbW92ZV9hbGxfYXNzb2MgYSBsXG5cbiAgbGV0IHJlYyByZW1vdmVfYWxsX2Fzc29jX3EgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgKGIsIF8pIDo6IGwgd2hlbiBhID09IGIgLT4gcmVtb3ZlX2FsbF9hc3NvY19xIGEgbFxuICAgIHwgYiA6OiBsIC0+IGIgOjogcmVtb3ZlX2FsbF9hc3NvY19xIGEgbFxuXG4gIGxldCByZWMgbGFzdCA9IGZ1bmN0aW9uIFtdIC0+IHJhaXNlIE5vdF9mb3VuZCB8IFtiXSAtPiBiIHwgXyA6OiBsIC0+IGxhc3QgbFxuXG4gIGxldCByZWMgYXNzb2NfcmVtb3ZlIGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCAoYiwgYykgOjogbCB3aGVuIGEgPSBiIC0+IGMsIGxcbiAgICB8IGIgOjogbCAtPlxuICAgICAgICBsZXQgdiwgbGwgPSBhc3NvY19yZW1vdmUgYSBsIGluXG4gICAgICAgIHYsIGIgOjogbGxcblxuICBsZXQgcmVjIGlzX3ByZWZpeCBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBfIC0+IHRydWVcbiAgICB8IGEgOjogbGwxLCBiIDo6IGxsMiB3aGVuIGEgPSBiIC0+IGlzX3ByZWZpeCBsbDEgbGwyXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IHJlYyBjaG9wIG4geHMgPVxuICAgIGlmIG4gPD0gMFxuICAgIHRoZW4geHNcbiAgICBlbHNlIG1hdGNoIHhzIHdpdGggW10gLT4gW10gfCBfeCA6OiB4cyAtPiBjaG9wIChuIC0gMSkgeHNcblxuICBsZXQgcmVjIHNwbGl0X2F0IG4geHMgPVxuICAgIGlmIG4gPD0gMFxuICAgIHRoZW4gW10sIHhzXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggeHMgd2l0aFxuICAgICAgfCBbXSAtPiBbXSwgW11cbiAgICAgIHwgeCA6OiB4cyAtPlxuICAgICAgICAgIGxldCBsLCByID0gc3BsaXRfYXQgKG4gLSAxKSB4cyBpblxuICAgICAgICAgIHggOjogbCwgclxuZW5kXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogY2lyY3VsYXIgbGlzdHMgKilcbm1vZHVsZSBDbGlzdCA6IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnYSBub2RlXG5cbiAgdmFsIG1ha2UgOiAnYSAtPiAnYSBub2RlXG4gIHZhbCBjcmVhdGUgOiB1bml0IC0+ICdhIHRcbiAgdmFsIGluc2VydCA6ICdhIHQgLT4gJ2Egbm9kZSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiAnYSBub2RlIC0+IHVuaXRcbiAgdmFsIHZhbHVlIDogJ2Egbm9kZSAtPiAnYVxuICB2YWwgaW5fbGlzdCA6ICdhIG5vZGUgLT4gYm9vbFxuICB2YWwgaXNfZW1wdHkgOiAnYSB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gIHZhbCBmb2xkX2xlZnQgOiAoJ2EgLT4gJ2IgLT4gJ2EpIC0+ICdhIC0+ICdiIHQgLT4gJ2FcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIG5vZGUgPVxuICAgIHtjb250ZW50IDogJ2Egb3B0aW9uOyBtdXRhYmxlIHByZXYgOiAnYSBub2RlOyBtdXRhYmxlIG5leHQgOiAnYSBub2RlfVxuXG4gIHR5cGUgJ2EgdCA9ICdhIG5vZGVcblxuICBsZXQgbWFrZScgYyA9XG4gICAgbGV0IHJlYyB4ID0ge2NvbnRlbnQgPSBjOyBwcmV2ID0geDsgbmV4dCA9IHh9IGluXG4gICAgeFxuXG4gIGxldCBtYWtlIGMgPSBtYWtlJyAoU29tZSBjKVxuICBsZXQgY3JlYXRlICgpID0gbWFrZScgTm9uZVxuXG4gIGxldCBpbnNlcnQgcCB4ID1cbiAgICBsZXQgbiA9IHAubmV4dCBpblxuICAgIHAubmV4dCA8LSB4O1xuICAgIHgucHJldiA8LSBwO1xuICAgIHgubmV4dCA8LSBuO1xuICAgIG4ucHJldiA8LSB4XG5cbiAgbGV0IHJlbW92ZSB4ID1cbiAgICBsZXQgcCA9IHgucHJldiBpblxuICAgIGxldCBuID0geC5uZXh0IGluXG4gICAgcC5uZXh0IDwtIG47XG4gICAgbi5wcmV2IDwtIHA7XG4gICAgeC5uZXh0IDwtIHg7XG4gICAgeC5wcmV2IDwtIHhcblxuICBsZXQgaW5fbGlzdCB4ID0geC5uZXh0ICE9IHhcbiAgbGV0IGlzX2VtcHR5IHNldCA9IHNldC5uZXh0ID09IHNldFxuXG4gIGxldCB2YWx1ZSBjID1cbiAgICBtYXRjaCBjLmNvbnRlbnQgd2l0aCBOb25lIC0+IGZhaWx3aXRoIFwiQ2xpc3QudmFsdWVcIiB8IFNvbWUgYyAtPiBjXG5cbiAgbGV0IHJlYyBpdGVyIGYgKG5vZGUgOiAnYSB0KSA9XG4gICAgbWF0Y2ggbm9kZS5uZXh0LmNvbnRlbnQgd2l0aCBTb21lIGMgLT4gZiBjOyBpdGVyIGYgbm9kZS5uZXh0IHwgTm9uZSAtPiAoKVxuXG4gIGxldCByZWMgZm9sZF9sZWZ0IGYgYSAobm9kZSA6ICdhIHQpID1cbiAgICBtYXRjaCBub2RlLm5leHQuY29udGVudCB3aXRoXG4gICAgfCBTb21lIGMgLT4gZm9sZF9sZWZ0IGYgKGYgYSBjKSBub2RlLm5leHRcbiAgICB8IE5vbmUgLT4gYVxuZW5kXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICBtb2R1bGUgVGFibGUgPSBNYXAuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBpbnRcblxuICAgICAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG4gICAgZW5kKVxuZW5kXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIFN0cmluZ19iYXNlID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5cbiAgKCogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHN0cmluZyBmcm9tIGJlZyB0byBlbmRkLFxuICAgICByZW1vdmluZyBzcGFjZXMgYXQgdGhlIGJlZ2lubmluZyBhbmQgYXQgdGhlIGVuZCAqKVxuICBsZXQgcmVtb3ZlX3NwYWNlcyBzIGJlZyBlbmRkID1cbiAgICBsZXQgcmVjIGZpbmRfbm90X3NwYWNlIHMgaSBzdGVwID1cbiAgICAgIGlmIGkgPiBlbmRkIHx8IGJlZyA+IGlcbiAgICAgIHRoZW4gaVxuICAgICAgZWxzZSBpZiBzLltpXSA9ICcgJ1xuICAgICAgdGhlbiBmaW5kX25vdF9zcGFjZSBzIChpICsgc3RlcCkgc3RlcFxuICAgICAgZWxzZSBpXG4gICAgaW5cbiAgICBsZXQgZmlyc3QgPSBmaW5kX25vdF9zcGFjZSBzIGJlZyAxIGluXG4gICAgbGV0IGxhc3QgPSBmaW5kX25vdF9zcGFjZSBzIGVuZGQgKC0xKSBpblxuICAgIGlmIGxhc3QgPj0gZmlyc3QgdGhlbiBTdHJpbmcuc3ViIHMgZmlyc3QgKDEgKyBsYXN0IC0gZmlyc3QpIGVsc2UgXCJcIlxuXG4gICgqIEN1dCBhIHN0cmluZyB0byB0aGUgbmV4dCBzZXBhcmF0b3IgKilcbiAgbGV0IGJhc2ljX3NlcCBjaGFyIHMgPVxuICAgIHRyeVxuICAgICAgbGV0IHNlcHBvcyA9IFN0cmluZy5pbmRleCBzIGNoYXIgaW5cbiAgICAgICggU3RyaW5nLnN1YiBzIDAgc2VwcG9zXG4gICAgICAsIFN0cmluZy5zdWIgcyAoc2VwcG9zICsgMSkgKFN0cmluZy5sZW5ndGggcyAtIHNlcHBvcyAtIDEpIClcbiAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiByYWlzZSBOb3RfZm91bmRcblxuICAoKiBDdXQgYSBzdHJpbmcgdG8gdGhlIG5leHQgc2VwYXJhdG9yLCByZW1vdmluZyBzcGFjZXMuXG4gICAgIFJhaXNlcyBOb3RfZm91bmQgaWYgdGhlIHNlcGFyYXRvciBjYW5ub3QgYmUgZm91bmQuXG4gICopXG4gIGxldCBzZXAgY2hhciBzID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IHNlcHBvcyA9IFN0cmluZy5pbmRleCBzIGNoYXIgaW5cbiAgICByZW1vdmVfc3BhY2VzIHMgMCAoc2VwcG9zIC0gMSksIHJlbW92ZV9zcGFjZXMgcyAoc2VwcG9zICsgMSkgKGxlbiAtIDEpXG5cbiAgKCogc3BsaXRzIGEgc3RyaW5nLCBmb3IgZXggXCJhemVydCwgICBzZGZtbHNrZGYsICAgIGRmZHNmc1wiICopXG4gIGxldCBzcGxpdCA/KG11bHRpc2VwID0gZmFsc2UpIGNoYXIgcyA9XG4gICAgbGV0IGxvbmd1ZXVyID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IHJlYyBhdXggZGViID1cbiAgICAgIGlmIGRlYiA+PSBsb25ndWV1clxuICAgICAgdGhlbiBbXVxuICAgICAgZWxzZVxuICAgICAgICB0cnlcbiAgICAgICAgICBsZXQgZmlyc3RzZXAgPSBTdHJpbmcuaW5kZXhfZnJvbSBzIGRlYiBjaGFyIGluXG4gICAgICAgICAgaWYgbXVsdGlzZXAgJiYgZmlyc3RzZXAgPSBkZWJcbiAgICAgICAgICB0aGVuIGF1eCAoZGViICsgMSlcbiAgICAgICAgICBlbHNlIHJlbW92ZV9zcGFjZXMgcyBkZWIgKGZpcnN0c2VwIC0gMSkgOjogYXV4IChmaXJzdHNlcCArIDEpXG4gICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IFtyZW1vdmVfc3BhY2VzIHMgZGViIChsb25ndWV1ciAtIDEpXVxuICAgIGluXG4gICAgYXV4IDBcblxuICBsZXQgbWF5X2FwcGVuZCBzMSB+c2VwID0gZnVuY3Rpb24gXCJcIiAtPiBzMSB8IHMyIC0+IHMxIF4gc2VwIF4gczJcblxuICBsZXQgbWF5X2NvbmNhdCBzMSB+c2VwIHMyID1cbiAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgIHwgXywgXCJcIiAtPiBzMVxuICAgIHwgXCJcIiwgXyAtPiBzMlxuICAgIHwgXyAtPiBTdHJpbmcuY29uY2F0IHNlcCBbczE7IHMyXVxuXG4gICgqIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkaWZmZXJlbmNlIGJldHdlZW4gczEgYW5kIHMyLFxuICAgICBzdGFydGluZyBmcm9tIG4gYW5kIGVuZGluZyBhdCBsYXN0LlxuICAgICByZXR1cm5zIChsYXN0ICsgMSkgaWYgbm8gZGlmZmVyZW5jZSBpcyBmb3VuZC5cbiAgKilcbiAgbGV0IHJlYyBmaXJzdF9kaWZmIHMxIHMyIG4gbGFzdCA9XG4gICAgdHJ5XG4gICAgICBpZiBzMS5bbl0gPSBzMi5bbl1cbiAgICAgIHRoZW4gaWYgbiA9IGxhc3QgdGhlbiBsYXN0ICsgMSBlbHNlIGZpcnN0X2RpZmYgczEgczIgKG4gKyAxKSBsYXN0XG4gICAgICBlbHNlIG5cbiAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBuXG5cbiAgbW9kdWxlIFRhYmxlID0gTWFwLk1ha2UgKFN0cmluZylcbiAgbW9kdWxlIFNldCA9IFNldC5NYWtlIChTdHJpbmcpXG4gIG1vZHVsZSBNYXAgPSBNYXAuTWFrZSAoU3RyaW5nKVxuZW5kXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIFVybF9iYXNlID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZ1xuICB0eXBlIHVyaSA9IHN0cmluZ1xuICB0eXBlIHBhdGggPSBzdHJpbmcgbGlzdFxuXG4gIGxldCBtYWtlX2Fic29sdXRlX3VybCB+aHR0cHMgfmhvc3QgfnBvcnQgdXJpID1cbiAgICAoaWYgaHR0cHMgdGhlbiBcImh0dHBzOi8vXCIgZWxzZSBcImh0dHA6Ly9cIilcbiAgICBeIGhvc3RcbiAgICBeIChpZiAocG9ydCA9IDgwICYmIG5vdCBodHRwcykgfHwgKGh0dHBzICYmIHBvcnQgPSA0NDMpXG4gICAgICAgdGhlbiBcIlwiXG4gICAgICAgZWxzZSBcIjpcIiBeIHN0cmluZ19vZl9pbnQgcG9ydClcbiAgICBeIHVyaVxuXG4gIGxldCByZW1vdmVfZG90ZG90ID1cbiAgICAoKiByZW1vdmVzIFwiLi4vXCIgKilcbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IFtdXG4gICAgICB8IFtcIlwiXSBhcyBsIC0+XG4gICAgICAgICAgbFxuICAgICAgICAgICgqICAgIHwgXCJcIjo6bCAtPiBhdXggbCAqKVxuICAgICAgICAgICgqIHdlIGRvIG5vdCByZW1vdmUgXCIvL1wiIGFueSBtb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWNhdXNlIG9mIG9wdGlvbmFsIHN1ZmZpeGVzIGluIEVsaW9tICopXG4gICAgICB8IFwiLi5cIiA6OiBsIC0+IGF1eCBsXG4gICAgICB8IGEgOjogbCAtPiBhIDo6IGF1eCBsXG4gICAgaW5cbiAgICBmdW5jdGlvbiBbXSAtPiBbXSB8IFwiXCIgOjogbCAtPiBcIlwiIDo6IGF1eCBsIHwgbCAtPiBhdXggbFxuXG4gIGxldCByZW1vdmVfZW5kX3NsYXNoIHMgPVxuICAgIHRyeVxuICAgICAgaWYgcy5bU3RyaW5nLmxlbmd0aCBzIC0gMV0gPSAnLydcbiAgICAgIHRoZW4gU3RyaW5nLnN1YiBzIDAgKFN0cmluZy5sZW5ndGggcyAtIDEpXG4gICAgICBlbHNlIHNcbiAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBzXG5cbiAgbGV0IHJlbW92ZV9pbnRlcm5hbF9zbGFzaCB1ID1cbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IFtdXG4gICAgICB8IFthXSAtPiBbYV1cbiAgICAgIHwgXCJcIiA6OiBsIC0+IGF1eCBsXG4gICAgICB8IGEgOjogbCAtPiBhIDo6IGF1eCBsXG4gICAgaW5cbiAgICBtYXRjaCB1IHdpdGggW10gLT4gW10gfCBhIDo6IGwgLT4gYSA6OiBhdXggbFxuXG4gIGxldCBjaGFuZ2VfZW1wdHlfbGlzdCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXCJcIl0gKCogSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlZ2lzdGVyIGFuIGVtcHR5IFVSTCAqKVxuICAgIHwgbCAtPiBsXG5cbiAgbGV0IHJlYyBhZGRfZW5kX3NsYXNoX2lmX21pc3NpbmcgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW1wiXCJdXG4gICAgfCBbXCJcIl0gYXMgYSAtPiBhXG4gICAgfCBhIDo6IGwgLT4gYSA6OiBhZGRfZW5kX3NsYXNoX2lmX21pc3NpbmcgbFxuXG4gIGxldCByZWMgcmVtb3ZlX3NsYXNoX2F0X2VuZCA9IGZ1bmN0aW9uXG4gICAgfCBbXSB8IFtcIlwiXSAtPiBbXVxuICAgIHwgYSA6OiBsIC0+IGEgOjogcmVtb3ZlX3NsYXNoX2F0X2VuZCBsXG5cbiAgbGV0IHJlbW92ZV9zbGFzaF9hdF9iZWdpbm5pbmcgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IFtcIlwiXSAtPiBbXCJcIl1cbiAgICB8IFwiXCIgOjogbCAtPiBsXG4gICAgfCBsIC0+IGxcblxuICBsZXQgcmVjIGlzX3ByZWZpeF9za2lwX2VuZF9zbGFzaCBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtcIlwiXSwgXyB8IFtdLCBfIC0+IHRydWVcbiAgICB8IGEgOjogbGwxLCBiIDo6IGxsMiB3aGVuIGEgPSBiIC0+IGlzX3ByZWZpeF9za2lwX2VuZF9zbGFzaCBsbDEgbGwyXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IHNwbGl0X2ZyYWdtZW50IHMgPVxuICAgIHRyeVxuICAgICAgbGV0IHBvcyA9IFN0cmluZy5pbmRleCBzICcjJyBpblxuICAgICAgKCBTdHJpbmcuc3ViIHMgMCBwb3NcbiAgICAgICwgU29tZSAoU3RyaW5nLnN1YiBzIChwb3MgKyAxKSAoU3RyaW5nLmxlbmd0aCBzIC0gMSAtIHBvcykpIClcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBzLCBOb25lXG5cbiAgbGV0IGpvaW5fcGF0aCA9IGZ1bmN0aW9uIFtcIlwiXSAtPiBcIi9cIiB8IGwgLT4gU3RyaW5nLmNvbmNhdCBcIi9cIiBsXG5cbiAgKCogVGFrZW4gZnJvbSBPY2FtbG5ldCA0LjEuMiAqKVxuICBsZXQgc3BsaXRfcGF0aCBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCByZWMgY29sbGVjdF93b3JkcyBrID1cbiAgICAgIGxldCBrJyA9IHRyeSBTdHJpbmcuaW5kZXhfZnJvbSBzIGsgJy8nIHdpdGggTm90X2ZvdW5kIC0+IGwgaW5cbiAgICAgIGxldCB3b3JkID0gU3RyaW5nLnN1YiBzIGsgKGsnIC0gaykgaW5cbiAgICAgIGlmIGsnID49IGwgdGhlbiBbd29yZF0gZWxzZSB3b3JkIDo6IGNvbGxlY3Rfd29yZHMgKGsnICsgMSlcbiAgICBpblxuICAgIG1hdGNoIGNvbGxlY3Rfd29yZHMgMCB3aXRoIFtcIlwiXSAtPiBbXSB8IFtcIlwiOyBcIlwiXSAtPiBbXCJcIl0gfCBvdGhlciAtPiBvdGhlclxuXG4gICgqIFRha2VuIGZyb20gT2NhbWxuZXQgNC4xLjIgKilcbiAgbGV0IG5vcm1fcGF0aCBsID1cbiAgICBsZXQgcmVjIHJlbW92ZV9zbGFzaF9zbGFzaCBsIGZpcnN0ID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXCJcIl0gLT4gW1wiXCJdXG4gICAgICB8IFtcIlwiOyBcIlwiXSB3aGVuIGZpcnN0IC0+IFtcIlwiXVxuICAgICAgfCBcIlwiIDo6IGwnIHdoZW4gbm90IGZpcnN0IC0+IHJlbW92ZV9zbGFzaF9zbGFzaCBsJyBmYWxzZVxuICAgICAgfCB4IDo6IGwnIC0+IHggOjogcmVtb3ZlX3NsYXNoX3NsYXNoIGwnIGZhbHNlXG4gICAgICB8IFtdIC0+IFtdXG4gICAgaW5cbiAgICBsZXQgcmVjIHJlbW92ZV9kb3QgbCBmaXJzdCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW1wiLlwiXSB8IFtcIi5cIjsgXCJcIl0gLT4gaWYgZmlyc3QgdGhlbiBbXSBlbHNlIFtcIlwiXVxuICAgICAgfCBcIi5cIiA6OiB4IDo6IGwnIC0+IHJlbW92ZV9kb3QgKHggOjogbCcpIGZhbHNlXG4gICAgICB8IHggOjogbCcgLT4geCA6OiByZW1vdmVfZG90IGwnIGZhbHNlXG4gICAgICB8IFtdIC0+IFtdXG4gICAgaW5cbiAgICBsZXQgcmVjIHJlbW92ZV9kb3RfZG90X29uY2UgbCBmaXJzdCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW3g7IFwiLi5cIl0gd2hlbiB4IDw+IFwiXCIgJiYgeCA8PiBcIi4uXCIgJiYgbm90IGZpcnN0IC0+IFtcIlwiXVxuICAgICAgfCB4IDo6IFwiLi5cIiA6OiBsJyB3aGVuIHggPD4gXCJcIiAmJiB4IDw+IFwiLi5cIiAtPiBsJ1xuICAgICAgfCB4IDo6IGwnIC0+IHggOjogcmVtb3ZlX2RvdF9kb3Rfb25jZSBsJyBmYWxzZVxuICAgICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICBpblxuICAgIGxldCByZWMgcmVtb3ZlX2RvdF9kb3QgbCA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IGwnID0gcmVtb3ZlX2RvdF9kb3Rfb25jZSBsIHRydWUgaW5cbiAgICAgICAgcmVtb3ZlX2RvdF9kb3QgbCdcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+IGxcbiAgICBpblxuICAgIGxldCBsJyA9IHJlbW92ZV9kb3RfZG90IChyZW1vdmVfZG90IChyZW1vdmVfc2xhc2hfc2xhc2ggbCB0cnVlKSB0cnVlKSBpblxuICAgIG1hdGNoIGwnIHdpdGggW1wiLi5cIl0gLT4gW1wiLi5cIjsgXCJcIl0gfCBbXCJcIjsgXCJcIl0gLT4gW1wiXCJdIHwgXyAtPiBsJ1xuZW5kXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGRlYnVnID0gcHJlcnJfZW5kbGluZVxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
