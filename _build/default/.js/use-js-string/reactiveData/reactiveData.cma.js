// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: ReactiveData
//# unitInfo: Requires: React, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Int, Stdlib__List, Stdlib__Map, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_ReactiveData_Rlist_merge$3 = "ReactiveData.Rlist.merge",
    cst_merge_invalid_index$1 = "merge: invalid index",
    cst_src_reactiveData_ml = "src/reactiveData.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    React = global_data.React,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Set = global_data.Stdlib__Set;
   function Make(D){
    var merge = D[1], map_patch = D[2], map_data = D[3], empty = [0, D[4]];
    function create(l){
     var
      match = caml_call1(React[1][2], 0),
      send = match[2],
      initial_event = match[1],
      current = [0, l],
      event =
        caml_call2
         (React[1][10],
          function(msg){
           if(0 === msg[0]){
            var p = msg[1];
            current[1] = caml_call2(merge, p, current[1]);
           }
           else{var l = msg[1]; current[1] = l;}
           return msg;
          },
          initial_event);
     return [0, [1, [0, current, event]], send];
    }
    function from_event(l, initial_event){
     var
      current = [0, l],
      event =
        caml_call2
         (React[1][10],
          function(msg){
           if(0 === msg[0]){
            var p = msg[1];
            current[1] = caml_call2(merge, p, current[1]);
           }
           else{var l = msg[1]; current[1] = l;}
           return msg;
          },
          initial_event);
     return [1, [0, current, event]];
    }
    function const$0(x){return [0, x];}
    function map_msg(f, param){
     if(0 === param[0]){
      var p = param[1];
      return [0, caml_call2(map_patch, f, p)];
     }
     var l = param[1];
     return [1, caml_call2(map_data, f, l)];
    }
    function map(f, s){
     if(0 === s[0]){var x = s[1]; return [0, caml_call2(map_data, f, x)];}
     var
      s$0 = s[1],
      current = [0, caml_call2(map_data, f, s$0[1][1])],
      event =
        caml_call2
         (React[1][10],
          function(msg){
           var msg$0 = map_msg(f, msg);
           if(0 === msg$0[0]){
            var p = msg$0[1];
            current[1] = caml_call2(merge, p, current[1]);
           }
           else{var l = msg$0[1]; current[1] = l;}
           return msg$0;
          },
          s$0[2]);
     return [1, [0, current, event]];
    }
    function value(s){
     if(0 === s[0]){var c = s[1]; return c;}
     var s$0 = s[1];
     return s$0[1][1];
    }
    function event(s){
     if(0 === s[0]) return React[1][1];
     var s$0 = s[1];
     return s$0[2];
    }
    function patch(s, p){return caml_call2(s, 0, [0, p]);}
    function set(s, p){return caml_call2(s, 0, [1, p]);}
    function fold(f, s, acc){
     if(0 === s[0]){
      var c = s[1], _aD_ = caml_call2(f, acc, [1, c]);
      return caml_call1(React[2][1], _aD_);
     }
     var s$0 = s[1], acc$0 = caml_call2(f, acc, [1, s$0[1][1]]);
     return caml_call4(React[2][21], 0, f, acc$0, s$0[2]);
    }
    function signal(opt, s){
     var eq = opt ? opt[1] : caml_equal;
     if(0 === s[0]){var c = s[1]; return caml_call1(React[2][1], c);}
     var
      s$0 = s[1],
      _aA_ = s$0[2],
      _aB_ = s$0[1][1],
      _aC_ = [0, caml_call1(D[5], eq)];
     return caml_call4
             (React[2][21],
              _aC_,
              function(l, msg){
               if(0 === msg[0]){
                var p = msg[1];
                return caml_call2(merge, p, l);
               }
               var l$0 = msg[1];
               return l$0;
              },
              _aB_,
              _aA_);
    }
    function from_signal(opt, s){
     var eq = opt ? opt[1] : caml_equal;
     function f(d$0, d){return [0, caml_call3(D[6], eq, d, d$0)];}
     var _az_ = caml_call2(React[2][14], f, s);
     return from_event(caml_call1(React[2][3], s), _az_);
    }
    return [0,
            empty,
            create,
            from_event,
            from_signal,
            const$0,
            patch,
            set,
            map_msg,
            map,
            value,
            fold,
            signal,
            event];
   }
   var
    map_data = Stdlib_List[20],
    cst_ReactiveData_Rlist_merge = cst_ReactiveData_Rlist_merge$3,
    cst_ReactiveData_Rlist_merge$0 = cst_ReactiveData_Rlist_merge$3,
    cst_ReactiveData_Rlist_merge$1 = cst_ReactiveData_Rlist_merge$3,
    cst_ReactiveData_Rlist_merge$2 = cst_ReactiveData_Rlist_merge$3,
    cst_invalid_index = "invalid index",
    _a_ = [0, cst_src_reactiveData_ml, 207, 4],
    cst_merge_invalid_index = cst_merge_invalid_index$1,
    cst_merge_invalid_index$0 = cst_merge_invalid_index$1,
    cst_linear_merge_X_not_support = "linear_merge: X not supported",
    _b_ = [0, cst_src_reactiveData_ml, 233, 4];
   function map_patch(f){
    return caml_call1
            (Stdlib_List[20],
             function(param){
              switch(param[0]){
                case 0:
                 var x = param[2], i = param[1];
                 return [0, i, caml_call1(f, x)];
                case 1:
                 var i$0 = param[1]; return [1, i$0];
                case 2:
                 var x$0 = param[2], i$1 = param[1];
                 return [2, i$1, caml_call1(f, x$0)];
                default: var j = param[2], i$2 = param[1]; return [3, i$2, j];
              }
             });
   }
   function merge(p$5, l$7){
    a:
    {
     b:
     c:
     {
      var n = 0, p$3 = p$5;
      for(;;){
       if(0 > n)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
       if(! p$3) break;
       var match$1 = p$3[1];
       if(3 === match$1[0]) break b;
       var i$3 = match$1[1], p$4 = p$3[2];
       if(n > i$3) break c;
       n = i$3;
       p$3 = p$4;
      }
      var _ao_ = 1;
      break a;
     }
     var _ao_ = 0;
    }
    if(! _ao_)
     return caml_call3
             (Stdlib_List[26],
              function(l$2, op){
               switch(op[0]){
                 case 0:
                  var
                   x = op[2],
                   i = op[1],
                   i$0 =
                     0 <= i
                      ? i
                      : (caml_call1(Stdlib_List[1], l$2) + 1 | 0) + i | 0,
                   acc = 0,
                   n = i$0,
                   l = l$2;
                  for(;;){
                   if(0 === n)
                    return caml_call2(Stdlib_List[13], acc, [0, x, l]);
                   if(! l)
                    return caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge);
                   var
                    xs = l[2],
                    x$0 = l[1],
                    n$0 = n - 1 | 0,
                    acc$0 = [0, x$0, acc];
                   acc = acc$0;
                   n = n$0;
                   l = xs;
                  }
                  break;
                 case 1:
                  var
                   i$1 = op[1],
                   i$2 =
                     0 <= i$1 ? i$1 : caml_call1(Stdlib_List[1], l$2) + i$1 | 0,
                   acc$1 = 0,
                   n$1 = i$2,
                   l$0 = l$2;
                  for(;;){
                   if(0 === n$1 && l$0){
                    var l$1 = l$0[2];
                    return caml_call2(Stdlib_List[13], acc$1, l$1);
                   }
                   if(! l$0)
                    return caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge$0);
                   var
                    xs$0 = l$0[2],
                    x$1 = l$0[1],
                    n$2 = n$1 - 1 | 0,
                    acc$2 = [0, x$1, acc$1];
                   acc$1 = acc$2;
                   n$1 = n$2;
                   l$0 = xs$0;
                  }
                  break;
                 case 2:
                  var
                   x$2 = op[2],
                   i$3 = op[1],
                   i$4 =
                     0 <= i$3 ? i$3 : caml_call1(Stdlib_List[1], l$2) + i$3 | 0,
                   a = caml_call1(Stdlib_Array[11], l$2);
                  caml_check_bound(a, i$4)[1 + i$4] = x$2;
                  return caml_call1(Stdlib_Array[10], a);
                 default:
                  var
                   offset = op[2],
                   i$5 = op[1],
                   a$0 = caml_call1(Stdlib_Array[11], l$2),
                   len = a$0.length - 1,
                   i$6 = 0 <= i$5 ? i$5 : len + i$5 | 0,
                   v = caml_check_bound(a$0, i$6)[1 + i$6];
                  if(0 < offset){
                   if(len <= (i$6 + offset | 0))
                    caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge$1);
                   var _ap_ = (i$6 + offset | 0) - 1 | 0;
                   if(_ap_ >= i$6){
                    var j = i$6;
                    for(;;){
                     var
                      _ar_ = j + 1 | 0,
                      _as_ = caml_check_bound(a$0, _ar_)[1 + _ar_];
                     caml_check_bound(a$0, j)[1 + j] = _as_;
                     var _at_ = j + 1 | 0;
                     if(_ap_ === j) break;
                     j = _at_;
                    }
                   }
                   var _aq_ = i$6 + offset | 0;
                   caml_check_bound(a$0, _aq_)[1 + _aq_] = v;
                  }
                  else{
                   if((i$6 + offset | 0) < 0)
                    caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge$2);
                   var _au_ = (i$6 + offset | 0) + 1 | 0;
                   if(i$6 >= _au_){
                    var j$0 = i$6;
                    for(;;){
                     var
                      _aw_ = j$0 - 1 | 0,
                      _ax_ = caml_check_bound(a$0, _aw_)[1 + _aw_];
                     caml_check_bound(a$0, j$0)[1 + j$0] = _ax_;
                     var _ay_ = j$0 - 1 | 0;
                     if(_au_ === j$0) break;
                     j$0 = _ay_;
                    }
                   }
                   var _av_ = i$6 + offset | 0;
                   caml_check_bound(a$0, _av_)[1 + _av_] = v;
                  }
                  return caml_call1(Stdlib_Array[10], a$0);
               }
              },
              l$7,
              p$5);
    var acc$1 = 0, i0 = 0, p = p$5, l$1 = l$7;
    for(;;){
     a:
     {
      if(p){
       var match = p[1];
       if(3 !== match[0]){
        var i$1 = match[1];
        if(i0 < i$1){
         var i$2 = i$1 - i0 | 0;
         b:
         {
          c:
          {
           var acc = acc$1, i = i$2, l = l$1;
           for(;;){
            if(0 > i)
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
            if(0 >= i) break;
            if(! l) break c;
            var l$0 = l[2], h = l[1], acc$0 = [0, h, acc], i$0 = i - 1 | 0;
            acc = acc$0;
            i = i$0;
            l = l$0;
           }
           var _an_ = [0, l, acc];
           break b;
          }
          var _an_ = caml_call1(Stdlib[1], cst_invalid_index);
         }
         var acc$2 = _an_[2], l$2 = _an_[1];
         break a;
        }
       }
      }
      var acc$2 = acc$1, l$2 = l$1;
     }
     if(! p) return caml_call2(Stdlib_List[13], acc$2, l$2);
     var match$0 = p[1];
     switch(match$0[0]){
       case 0:
        var p$0 = p[2], x = match$0[2], i0$0 = match$0[1], l$3 = [0, x, l$2];
        acc$1 = acc$2;
        i0 = i0$0;
        p = p$0;
        l$1 = l$3;
        break;
       case 1:
        var p$1 = p[2], i0$1 = match$0[1];
        if(! l$2) return caml_call1(Stdlib[1], cst_merge_invalid_index);
        var l$4 = l$2[2];
        acc$1 = acc$2;
        i0 = i0$1;
        p = p$1;
        l$1 = l$4;
        break;
       case 2:
        var p$2 = p[2], x$0 = match$0[2], i0$2 = match$0[1];
        if(! l$2) return caml_call1(Stdlib[1], cst_merge_invalid_index$0);
        var l$5 = l$2[2], l$6 = [0, x$0, l$5];
        acc$1 = acc$2;
        i0 = i0$2;
        p = p$2;
        l$1 = l$6;
        break;
       default: return caml_call1(Stdlib[2], cst_linear_merge_X_not_support);
     }
    }
   }
   function equal(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var x2 = l2$0[1], l1$1 = l1$0[2], x1 = l1$0[1], l2$1 = l2$0[2];
       if(caml_call2(f, x1, x2)){l1$0 = l1$1; l2$0 = l2$1; continue;}
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function mem(l){
    var hash = Stdlib_Hashtbl[28];
    function equal(_am_, _al_){return _am_ === _al_ ? 1 : 0;}
    var
     H = caml_call1(Stdlib_Hashtbl[26], [0, equal, hash]),
     h = caml_call1(H[1], 16);
    caml_call2
     (Stdlib_List[18], function(x){return caml_call3(H[5], h, x, 0);}, l);
    return caml_call1(H[11], h);
   }
   function diff(eq, lx$1, ly$3){
    function add(acc, i, v){return [0, [0, i, v], acc];}
    function remove(acc, i){return [0, [1, i], acc];}
    var
     memx = mem(lx$1),
     memy = mem(ly$3),
     acc = 0,
     left = 1,
     lx = lx$1,
     ly = ly$3,
     n = 0;
    for(;;)
     if(lx){
      var lx$0 = lx[2], x = lx[1];
      if(ly){
       var y = ly[1], ly$0 = ly[2];
       if(caml_call2(eq, x, y)){
        var n$0 = n + 1 | 0;
        lx = lx$0;
        ly = ly$0;
        n = n$0;
       }
       else if(caml_call1(memy, x))
        if(caml_call1(memx, y))
         if(left){
          var acc$0 = remove(acc, n);
          acc = acc$0;
          left = 0;
          lx = lx$0;
         }
         else{
          var ly$1 = ly[2], acc$1 = add(acc, n, y), n$1 = n + 1 | 0;
          acc = acc$1;
          left = 1;
          ly = ly$1;
          n = n$1;
         }
        else{
         var acc$2 = add(acc, n, y), n$2 = n + 1 | 0;
         acc = acc$2;
         ly = ly$0;
         n = n$2;
        }
       else{var acc$3 = remove(acc, n); acc = acc$3; lx = lx$0;}
      }
      else{var acc$4 = remove(acc, n); acc = acc$4; lx = lx$0; ly = 0;}
     }
     else{
      if(! ly) break;
      var
       ly$2 = ly[2],
       y$0 = ly[1],
       acc$5 = add(acc, n, y$0),
       n$3 = n + 1 | 0;
      acc = acc$5;
      lx = 0;
      ly = ly$2;
      n = n$3;
     }
    var opt = 0, param = acc;
    for(;;){
     var acc$6 = opt ? opt[1] : 0;
     if(! param) return acc$6;
     var
      t = param[2],
      h = param[1],
      acc$7 = [0, h, acc$6],
      opt$0 = [0, acc$7];
     opt = opt$0;
     param = t;
    }
   }
   var
    include = Make([0, merge, map_patch, map_data, 0, equal, diff]),
    empty = include[1],
    create = include[2],
    from_event = include[3],
    from_signal = include[4],
    const$0 = include[5],
    patch = include[6],
    set = include[7],
    map_msg = include[8],
    map = include[9],
    value = include[10],
    fold = include[11],
    signal = include[12],
    event = include[13],
    _c_ = [0, 0, 0],
    _d_ = [0, cst_src_reactiveData_ml, 410, 17],
    _e_ = [0, cst_src_reactiveData_ml, 447, 26],
    _f_ = [0, cst_src_reactiveData_ml, 547, 6];
   function cons(x, s){return caml_call2(patch, s, [0, [0, 0, x], 0]);}
   function snoc(x, s){return caml_call2(patch, s, [0, [0, -1, x], 0]);}
   function insert(x, i, s){return caml_call2(patch, s, [0, [0, i, x], 0]);}
   function update(x, i, s){return caml_call2(patch, s, [0, [2, i, x], 0]);}
   function move(i, j, s){return caml_call2(patch, s, [0, [3, i, j], 0]);}
   function remove(i, s){return caml_call2(patch, s, [0, [1, i], 0]);}
   function index(opt, l, x){
    var eq = opt ? opt[1] : caml_equal, n = 0, param = l;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var hd = param[1];
     if(caml_call2(eq, hd, x)) return n;
     var tl = param[2], n$0 = n + 1 | 0;
     n = n$0;
     param = tl;
    }
   }
   function update_eq(eq, param, x, y){
    var
     handle = param[2],
     data = param[1],
     i = index(eq, caml_call1(value, data), x);
    return update(y, i, handle);
   }
   function remove_last(param){
    var handle = param[2], data = param[1], _ak_ = caml_call1(value, data);
    return remove(caml_call1(Stdlib_List[1], _ak_) - 1 | 0, handle);
   }
   function remove_eq(eq, param, x){
    var
     handle = param[2],
     data = param[1],
     i = index(eq, caml_call1(value, data), x);
    return remove(i, handle);
   }
   function singleton(x){return caml_call1(const$0, [0, x, 0]);}
   function singleton_s(s){
    var
     first = [0, 1],
     match = caml_call1(React[1][2], 0),
     send = match[2],
     e = match[1],
     result = caml_call2(from_event, 0, e),
     s$0 =
       caml_call3
        (React[2][11],
         0,
         function(x){
          return first[1]
                  ? (first
                     [1]
                    = 0,
                    caml_call2(send, 0, [0, [0, [0, 0, x], 0]]))
                  : caml_call2(send, 0, [0, [0, [2, 0, x], 0]]);
         },
         s);
    caml_call2
     (React[1][3],
      e,
      function(param){caml_call1(React[2][3], s$0); return 0;});
    return result;
   }
   function concat(x, y){
    var
     v1 = caml_call1(value, x),
     v2 = caml_call1(value, y),
     size1 = [0, 0],
     size2 = [0, 0];
    function size_with_patch(sizex, param){
     switch(param[0]){
       case 0:
        sizex[1]++; return;
       case 1:
        sizex[1]--; return;
       default: return;
     }
    }
    function size_with_set(sizex, l){
     sizex[1] = caml_call1(Stdlib_List[1], l);
    }
    size_with_set(size1, v1);
    size_with_set(size2, v2);
    var
     update_patch1 =
       caml_call1
        (Stdlib_List[20],
         function(p){
          switch(p[0]){
            case 0:
             var
              x = p[2],
              pos = p[1],
              i = 0 <= pos ? pos : pos - size2[1] | 0,
              m = [0, i, x];
             break;
            case 1:
             var
              pos$0 = p[1],
              pos$1 = 0 <= pos$0 ? pos$0 : pos$0 - size2[1] | 0,
              m = [1, pos$1];
             break;
            case 2:
             var
              x$0 = p[2],
              pos$2 = p[1],
              pos$3 = 0 <= pos$2 ? pos$2 : pos$2 - size2[1] | 0,
              m = [2, pos$3, x$0];
             break;
            default:
             var
              j = p[2],
              i$0 = p[1],
              i$1 = 0 <= i$0 ? i$0 : i$0 - size2[1] | 0,
              m = [3, i$1, j];
          }
          size_with_patch(size1, m);
          return m;
         }),
     update_patch2 =
       caml_call1
        (Stdlib_List[20],
         function(p){
          switch(p[0]){
            case 0:
             var
              x = p[2],
              pos = p[1],
              _ag_ = 0 <= pos ? size1[1] + pos | 0 : pos,
              m = [0, _ag_, x];
             break;
            case 1:
             var
              pos$0 = p[1],
              _ah_ = 0 <= pos$0 ? size1[1] + pos$0 | 0 : pos$0,
              m = [1, _ah_];
             break;
            case 2:
             var
              x$0 = p[2],
              pos$1 = p[1],
              _ai_ = 0 <= pos$1 ? size1[1] + pos$1 | 0 : pos$1,
              m = [2, _ai_, x$0];
             break;
            default:
             var
              j = p[2],
              i = p[1],
              _aj_ = 0 <= i ? size1[1] + i | 0 : i,
              m = [3, _aj_, j];
          }
          size_with_patch(size2, m);
          return m;
         }),
     _X_ = caml_call1(event, y),
     _Y_ =
       [0,
        caml_call2(React[1][10], function(e){return [0, 15437, e];}, _X_),
        0],
     _Z_ = caml_call1(event, x),
     ___ =
       [0,
        caml_call2(React[1][10], function(e){return [0, 15436, e];}, _Z_),
        _Y_],
     tuple_ev =
       caml_call3
        (React[1][23],
         function(acc, x){
          var p1 = acc[1];
          if(! p1 && typeof x !== "number" && 15436 === x[1]){
           var x$1 = x[2], p2 = acc[2];
           return [0, [0, x$1], p2];
          }
          if(! acc[2] && typeof x !== "number" && 15437 === x[1]){var x$0 = x[2]; return [0, p1, [0, x$0]];}
          throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
         },
         _c_,
         ___),
     merged_ev =
       caml_call2
        (React[1][10],
         function(p){
          var _$_ = p[1];
          if(! _$_){
           var _ae_ = p[2];
           if(! _ae_)
            throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
           var match$1 = _ae_[1];
           if(0 === match$1[0]){
            var p2$2 = match$1[1];
            return [0, caml_call1(update_patch2, p2$2)];
           }
           var p2$3 = match$1[1];
           size_with_set(size2, p2$3);
           var _af_ = caml_call1(value, x);
           return [1, caml_call2(Stdlib[37], _af_, p2$3)];
          }
          var _aa_ = _$_[1];
          if(0 === _aa_[0]){
           var _ab_ = p[2], p1 = _aa_[1];
           if(! _ab_) return [0, caml_call1(update_patch1, p1)];
           var match = _ab_[1];
           if(0 === match[0]){
            var
             p2 = match[1],
             p1$0 = caml_call1(update_patch1, p1),
             p2$0 = caml_call1(update_patch2, p2);
            return [0, caml_call2(Stdlib[37], p1$0, p2$0)];
           }
           var s2 = match[1], s1 = caml_call1(value, x);
           size_with_set(size1, s1);
           size_with_set(size2, s2);
           return [1, caml_call2(Stdlib[37], s1, s2)];
          }
          var _ac_ = p[2], p1$1 = _aa_[1];
          if(! _ac_){
           size_with_set(size1, p1$1);
           var _ad_ = caml_call1(value, y);
           return [1, caml_call2(Stdlib[37], p1$1, _ad_)];
          }
          var match$0 = _ac_[1];
          if(0 === match$0[0]){
           size_with_set(size1, p1$1);
           var s2$0 = caml_call1(value, y);
           size_with_set(size2, s2$0);
           return [1, caml_call2(Stdlib[37], p1$1, s2$0)];
          }
          var p2$1 = match$0[1];
          size_with_set(size1, p1$1);
          size_with_set(size2, p2$1);
          return [1, caml_call2(Stdlib[37], p1$1, p2$1)];
         },
         tuple_ev);
    return caml_call2(from_event, caml_call2(Stdlib[37], v1, v2), merged_ev);
   }
   function inverse(param){
    switch(param[0]){
      case 0:
       var x = param[2], i = param[1]; return [0, (- i | 0) - 1 | 0, x];
      case 1:
       var i$0 = param[1]; return [1, (- i$0 | 0) - 1 | 0];
      case 2:
       var x$0 = param[2], i$1 = param[1];
       return [2, (- i$1 | 0) - 1 | 0, x$0];
      default:
       var j = param[2], i$2 = param[1];
       return [3, (- i$2 | 0) - 1 | 0, - j | 0];
    }
   }
   function rev(t){
    var
     _V_ = caml_call1(event, t),
     e =
       caml_call2
        (React[1][10],
         function(param){
          if(0 === param[0]){
           var p = param[1];
           return [0, caml_call2(Stdlib_List[20], inverse, p)];
          }
          var l = param[1];
          return [1, caml_call1(Stdlib_List[10], l)];
         },
         _V_),
     _W_ = caml_call1(value, t);
    return caml_call2(from_event, caml_call1(Stdlib_List[10], _W_), e);
   }
   function filter(pred, l){
    var
     IntMap = caml_call1(Stdlib_Map[1], [0, Stdlib_Int[9]]),
     index = [0, IntMap[1]],
     size = [0, 0];
    function filter_list(l){
     size[1] = caml_call1(Stdlib_List[1], l);
     index[1] = IntMap[1];
     var l$0 = l, res = 0, their_i = 0, my_i = -1;
     for(;;){
      if(! l$0) return caml_call1(Stdlib_List[10], res);
      var xs = l$0[2], x = l$0[1];
      if(caml_call1(pred, x)){
       index[1] = caml_call3(IntMap[2], their_i, my_i + 1 | 0, index[1]);
       var
        my_i$0 = my_i + 1 | 0,
        their_i$0 = their_i + 1 | 0,
        res$0 = [0, x, res];
       l$0 = xs;
       res = res$0;
       their_i = their_i$0;
       my_i = my_i$0;
      }
      else{var their_i$1 = their_i + 1 | 0; l$0 = xs; their_i = their_i$1;}
     }
    }
    function normalise(i){return 0 <= i ? i : (size[1] + 1 | 0) + i | 0;}
    function update_index_insert(insert_pos_full_list, visible){
     var
      insert_pos_full_list$0 = normalise(insert_pos_full_list),
      match = caml_call2(IntMap[30], insert_pos_full_list$0, index[1]),
      updatables = match[3],
      displaced = match[2],
      left_alone = match[1];
     if(displaced)
      var
       displaced_in_filtered = displaced[1],
       updatables$0 =
         caml_call3
          (IntMap[2],
           insert_pos_full_list$0,
           displaced_in_filtered,
           updatables);
     else
      var updatables$0 = updatables;
     function update_j(j_full_list, j_filtered_list){
      var
       new_j_filtered = visible ? j_filtered_list + 1 | 0 : j_filtered_list;
      index[1] =
       caml_call3(IntMap[2], j_full_list + 1 | 0, new_j_filtered, index[1]);
      return 0;
     }
     caml_call2(IntMap[23], update_j, updatables$0);
     var
      insert_pos_filtered =
        caml_call1(IntMap[31], left_alone)
         ? 0
         : caml_call1(IntMap[13], left_alone)[2] + 1 | 0;
     if(visible)
      index[1] =
       caml_call3
        (IntMap[2], insert_pos_full_list$0, insert_pos_filtered, index[1]);
     size[1]++;
     return insert_pos_filtered;
    }
    function update_index_move(from_full_list, to_full_list, to_filtered){
     var
      was_visible = to_filtered ? 1 : 0,
      forward = from_full_list < to_full_list ? 1 : 0;
     if(forward){
      var _N_ = from_full_list + 1 | 0;
      if(to_full_list >= _N_){
       var i_full = _N_;
       for(;;){
        var delta = was_visible ? -1 : 0;
        try{
         var
          i_filtered = caml_call2(IntMap[17], i_full, index[1]),
          new_val = i_filtered + delta | 0;
         index[1] = caml_call3(IntMap[2], i_full - 1 | 0, new_val, index[1]);
        }
        catch(_T_){
         var _O_ = caml_wrap_exception(_T_);
         if(_O_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_O_, 0);
        }
        var _P_ = i_full + 1 | 0;
        if(to_full_list === i_full) break;
        i_full = _P_;
       }
      }
     }
     else{
      var _Q_ = from_full_list - 1 | 0;
      if(_Q_ >= to_full_list){
       var i_full$0 = _Q_;
       for(;;){
        try{
         var
          delta$0 = was_visible ? 1 : 0,
          i_filtered$0 = caml_call2(IntMap[17], i_full$0, index[1]),
          new_val$0 = i_filtered$0 + delta$0 | 0;
         index[1] =
          caml_call3(IntMap[2], i_full$0 + 1 | 0, new_val$0, index[1]);
        }
        catch(_U_){
         var _R_ = caml_wrap_exception(_U_);
         if(_R_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_R_, 0);
        }
        var _S_ = i_full$0 - 1 | 0;
        if(to_full_list === i_full$0) break;
        i_full$0 = _S_;
       }
      }
     }
     if(to_filtered){
      var to_filtered$0 = to_filtered[1];
      index[1] = caml_call3(IntMap[2], to_full_list, to_filtered$0, index[1]);
      return;
     }
     index[1] = caml_call2(IntMap[6], to_full_list, index[1]);
    }
    function convert_p(param){
     switch(param[0]){
       case 0:
        var x = param[2], i = param[1];
        if(caml_call1(pred, x)){
         var my_i = update_index_insert(i, 1);
         return [0, [0, my_i, x], 0];
        }
        update_index_insert(i, 0);
        return 0;
       case 1:
        var i$0 = param[1], remove_pos_full_list = normalise(i$0);
        try{
         var
          j = caml_call2(IntMap[17], remove_pos_full_list, index[1]),
          _A_ = [0, [1, j], 0],
          ret = _A_;
        }
        catch(_M_){
         var _z_ = caml_wrap_exception(_M_);
         if(_z_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_z_, 0);
         var ret = 0;
        }
        var
         was_visible = caml_call2(IntMap[32], remove_pos_full_list, index[1]),
         updatables =
           caml_call2(IntMap[30], remove_pos_full_list, index[1])[3],
         update_j =
           function(j_full_list, j_filtered_list){
            var
             new_j = was_visible ? j_filtered_list : j_filtered_list - 1 | 0;
            index[1] =
             caml_call3(IntMap[2], j_full_list - 1 | 0, new_j, index[1]);
            return 0;
           };
        if(! caml_call1(IntMap[31], index[1])){
         var last_i = caml_call1(IntMap[13], index[1])[1];
         index[1] = caml_call2(IntMap[6], last_i, index[1]);
        }
        size[1]--;
        caml_call2(IntMap[23], update_j, updatables);
        return ret;
       case 2:
        var
         x$0 = param[2],
         i$1 = param[1],
         update_pos_full_list = normalise(i$1);
        try{
         var old_j = caml_call2(IntMap[17], update_pos_full_list, index[1]);
         if(caml_call1(pred, x$0))
          var _C_ = [0, [2, old_j, x$0], 0];
         else{
          var
           updatables$0 =
             caml_call2(IntMap[30], update_pos_full_list, index[1])[3],
           update_j$0 =
             function(j_full_list, j_filtered_list){
              index[1] =
               caml_call3
                (IntMap[2], j_full_list, j_filtered_list - 1 | 0, index[1]);
              return 0;
             };
          index[1] = caml_call2(IntMap[6], update_pos_full_list, index[1]);
          caml_call2(IntMap[23], update_j$0, updatables$0);
          var _C_ = [0, [1, old_j], 0];
         }
         return _C_;
        }
        catch(_K_){
         var _B_ = caml_wrap_exception(_K_);
         if(_B_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_B_, 0);
         if(! caml_call1(pred, x$0)) return 0;
         var
          match = caml_call2(IntMap[30], update_pos_full_list, index[1]),
          updatables$1 = match[3],
          none = match[2],
          left_alone = match[1];
         if(0 !== none)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
         var
          update_j$1 =
            function(j_full_list, j_filtered_list){
             index[1] =
              caml_call3
               (IntMap[2], j_full_list, j_filtered_list + 1 | 0, index[1]);
             return 0;
            };
         try{
          var
           _y_ = caml_call1(IntMap[13], left_alone)[2],
           previous_pos_filtered = _y_;
         }
         catch(_L_){
          var _x_ = caml_wrap_exception(_L_);
          if(_x_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_x_, 0);
          var previous_pos_filtered = -1;
         }
         var new_pos_filtered_list = previous_pos_filtered + 1 | 0;
         index[1] =
          caml_call3
           (IntMap[2], update_pos_full_list, new_pos_filtered_list, index[1]);
         caml_call2(IntMap[23], update_j$1, updatables$1);
         return [0, [0, new_pos_filtered_list, x$0], 0];
        }
       default:
        var
         offset_full = param[2],
         origin_full = param[1],
         origin_full$0 = normalise(origin_full),
         dest_full = origin_full$0 + offset_full | 0;
        try{
         var
          origin_filtered = caml_call2(IntMap[17], origin_full$0, index[1]);
         try{
          var
           _H_ = caml_call2(IntMap[17], dest_full, index[1]),
           dest_filtered = _H_;
         }
         catch(_J_){
          var _E_ = caml_wrap_exception(_J_);
          if(_E_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_E_, 0);
          var
           small_ones = caml_call2(IntMap[30], origin_full$0, index[1])[1],
           _F_ =
             caml_call1(IntMap[31], small_ones)
              ? 0
              : caml_call1(IntMap[13], small_ones)[2] + 1 | 0,
           dest_filtered = _F_;
         }
         update_index_move(origin_full$0, dest_full, [0, dest_filtered]);
         var
          _G_ =
            dest_filtered !== origin_filtered
             ? [0,
               [3, origin_filtered, dest_filtered - origin_filtered | 0],
               0]
             : 0;
         return _G_;
        }
        catch(_I_){
         var _D_ = caml_wrap_exception(_I_);
         if(_D_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_D_, 0);
         update_index_move(origin_full$0, dest_full, 0);
         return 0;
        }
     }
    }
    function filter_e(param){
     if(0 === param[0]){
      var p = param[1], _w_ = caml_call2(Stdlib_List[20], convert_p, p);
      return [0, caml_call1(Stdlib_List[14], _w_)];
     }
     var l = param[1];
     return [1, filter_list(l)];
    }
    var
     _v_ = caml_call1(event, l),
     e = caml_call2(React[1][10], filter_e, _v_);
    return caml_call2(from_event, filter_list(caml_call1(value, l)), e);
   }
   var IntSet = caml_call1(Stdlib_Set[1], [0, Stdlib_Int[9]]), _g_ = [0, 68];
   function for_all(fn, data){
    function maybe_update(acc, i, v){
     return caml_call1(fn, v) ? acc : caml_call2(IntSet[2], i, acc);
    }
    var acc = IntSet[1], i = 0;
    function init(param$0){
     var i$0 = i, acc$0 = acc, param = param$0;
     for(;;){
      if(! param) return acc$0;
      var
       tl = param[2],
       v = param[1],
       acc$1 = maybe_update(acc$0, i$0, v),
       i$1 = i$0 + 1 | 0;
      i$0 = i$1;
      acc$0 = acc$1;
      param = tl;
     }
    }
    function update_idx_after(i, f, acc){
     return caml_call2
             (IntSet[25],
              function(i$0){return i <= i$0 ? caml_call2(f, i$0, 1) : i$0;},
              acc);
    }
    function f(acc, param){
     if(0 === param[0]){
      var updates = param[1];
      return caml_call3
              (Stdlib_List[26],
               function(acc, param){
                switch(param[0]){
                  case 0:
                   var
                    v = param[2],
                    i = param[1],
                    acc$0 =
                      update_idx_after
                       (i, function(_u_, _t_){return _u_ + _t_ | 0;}, acc);
                   return maybe_update(acc$0, i, v);
                  case 1:
                   var i$0 = param[1];
                   return update_idx_after
                           (i$0,
                            function(_s_, _r_){return _s_ - _r_ | 0;},
                            caml_call2(IntSet[4], i$0, acc));
                  case 2:
                   var v$0 = param[2], i$1 = param[1];
                   return maybe_update
                           (caml_call2(IntSet[4], i$1, acc), i$1, v$0);
                  default:
                   var
                    i$2 = param[2],
                    i$3 = param[1],
                    _o_ = caml_call2(IntSet[31], i$2, acc);
                   if(caml_call2(IntSet[31], i$3, acc) === _o_) return acc;
                   if(caml_call2(IntSet[31], i$3, acc)){
                    var _p_ = caml_call2(IntSet[4], i$3, acc);
                    return caml_call2(IntSet[2], i$2, _p_);
                   }
                   var _q_ = caml_call2(IntSet[4], i$2, acc);
                   return caml_call2(IntSet[2], i$3, _q_);
                }
               },
               acc,
               updates);
     }
     var x = param[1];
     return init(x);
    }
    var
     _l_ = caml_call1(event, data),
     _m_ = init(caml_call1(value, data)),
     _n_ = caml_call4(React[2][21], 0, f, _m_, _l_);
    return caml_call1(caml_call2(React[2][11], 0, IntSet[30]), _n_);
   }
   var
    ReactiveData =
      [0,
       [0,
        empty,
        create,
        from_event,
        from_signal,
        const$0,
        patch,
        set,
        map_msg,
        map,
        value,
        fold,
        signal,
        event,
        cons,
        snoc,
        insert,
        remove,
        remove_last,
        remove_eq,
        update,
        update_eq,
        move,
        singleton,
        singleton_s,
        concat,
        rev,
        filter,
        for_all],
       function(M){
        function merge(p, acc){
         return caml_call3
                 (Stdlib_List[26],
                  function(acc, p){
                   if(3404203 <= p[1]){
                    var k = p[2];
                    return caml_call2(M[6], k, acc);
                   }
                   var match = p[2], a = match[2], k$0 = match[1];
                   return caml_call3(M[2], k$0, a, acc);
                  },
                  acc,
                  p);
        }
        function map_patch(f){
         return caml_call1
                 (Stdlib_List[20],
                  function(param){
                   if(3404203 <= param[1]){
                    var k = param[2];
                    return [0, 3404203, k];
                   }
                   var match = param[2], a = match[2], k$0 = match[1];
                   return [0, 3254785, [0, k$0, caml_call1(f, a)]];
                  });
        }
        function map_data(f, d){return caml_call2(M[25], f, d);}
        var empty = M[1];
        function equal(f){return caml_call1(M[33], f);}
        function diff(eq, x, y){
         function g(key, v, w){
          if(v){
           var v$0 = v[1];
           if(! w) return _g_;
           var w$0 = w[1];
           return caml_call2(eq, v$0, w$0) ? 0 : [0, [0, 85, w$0]];
          }
          if(! w) return 0;
          var v$1 = w[1];
          return [0, [0, 65, v$1]];
         }
         var m = caml_call3(M[7], g, x, y);
         function g$0(key, x, acc){
          if(typeof x === "number") return [0, [0, 3404203, key], acc];
          if(85 <= x[1]){
           var v = x[2];
           return [0, [0, 3404203, key], [0, [0, 3254785, [0, key, v]], acc]];
          }
          var v$0 = x[2];
          return [0, [0, 3254785, [0, key, v$0]], acc];
         }
         var _k_ = caml_call3(M[24], g$0, m, 0);
         return caml_call1(Stdlib_List[10], _k_);
        }
        var
         include = Make([0, merge, map_patch, map_data, empty, equal, diff]),
         empty$0 = include[1],
         create = include[2],
         from_event = include[3],
         from_signal = include[4],
         const$0 = include[5],
         patch = include[6],
         set = include[7],
         map_msg = include[8],
         map = include[9],
         value = include[10],
         fold = include[11],
         signal = include[12],
         event = include[13];
        function filter(pred, m){
         function convert_p(param){
          if(3404203 <= param[1]){
           var k = param[2];
           return [0, [0, 3404203, k], 0];
          }
          var match = param[2], v = match[2], k$0 = match[1];
          return caml_call2(pred, k$0, v)
                  ? [0, [0, 3254785, [0, k$0, v]], 0]
                  : 0;
         }
         function filter_e(param){
          if(0 === param[0]){
           var p = param[1], _j_ = caml_call2(Stdlib_List[20], convert_p, p);
           return [0, caml_call1(Stdlib_List[14], _j_)];
          }
          var m = param[1];
          return [1, caml_call2(M[27], pred, m)];
         }
         var
          _h_ = caml_call1(event, m),
          e = caml_call2(React[1][10], filter_e, _h_),
          _i_ = caml_call1(value, m);
         return caml_call2(from_event, caml_call2(M[27], pred, _i_), e);
        }
        return [0,
                empty$0,
                create,
                from_event,
                from_signal,
                const$0,
                patch,
                set,
                map_msg,
                map,
                value,
                fold,
                signal,
                event,
                filter];
       },
       Make];
   runtime.caml_register_global(24, ReactiveData, "ReactiveData");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVhY3RpdmVEYXRhLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJyZWFjdGl2ZURhdGEuY21hLmpzIiwibmFtZXMiOlsicnVudGltZSIsImNzdF9SZWFjdGl2ZURhdGFfUmxpc3RfbWVyZ2UiLCJjc3RfbWVyZ2VfaW52YWxpZF9pbmRleCIsImNzdF9zcmNfcmVhY3RpdmVEYXRhX21sIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfZXF1YWwiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImR1bW15IiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfTGlzdCIsIlJlYWN0IiwiU3RkbGliIiwiQXNzZXJ0X2ZhaWx1cmUiLCJTdGRsaWJfSW50IiwiU3RkbGliX01hcCIsIlN0ZGxpYl9IYXNodGJsIiwiU3RkbGliX0FycmF5IiwiU3RkbGliX1NldCIsIk1ha2UiLCJEIiwibWVyZ2UiLCJtYXBfcGF0Y2giLCJtYXBfZGF0YSIsImVtcHR5IiwiY3JlYXRlIiwibCIsIm1hdGNoIiwic2VuZCIsImluaXRpYWxfZXZlbnQiLCJjdXJyZW50IiwiZXZlbnQiLCJtc2ciLCJwIiwiZnJvbV9ldmVudCIsImNvbnN0IiwieCIsIm1hcF9tc2ciLCJwYXJhbSIsIm1hcCIsInMiLCJ2YWx1ZSIsImMiLCJwYXRjaCIsInNldCIsImZvbGQiLCJhY2MiLCJzaWduYWwiLCJvcHQiLCJlcSIsImZyb21fc2lnbmFsIiwiZCIsImNzdF9pbnZhbGlkX2luZGV4IiwiY3N0X2xpbmVhcl9tZXJnZV9YX25vdF9zdXBwb3J0IiwiaSIsImoiLCJuIiwib3AiLCJ4cyIsImEiLCJvZmZzZXQiLCJsZW4iLCJ2IiwiaTAiLCJoIiwiZXF1YWwiLCJsMSIsImwyIiwieDIiLCJ4MSIsIm1lbSIsImhhc2giLCJIIiwiZGlmZiIsImx4IiwibHkiLCJhZGQiLCJyZW1vdmUiLCJtZW14IiwibWVteSIsImxlZnQiLCJ5IiwidCIsImluY2x1ZGUiLCJjb25zIiwic25vYyIsImluc2VydCIsInVwZGF0ZSIsIm1vdmUiLCJpbmRleCIsImhkIiwidGwiLCJ1cGRhdGVfZXEiLCJoYW5kbGUiLCJkYXRhIiwicmVtb3ZlX2xhc3QiLCJyZW1vdmVfZXEiLCJzaW5nbGV0b24iLCJzaW5nbGV0b25fcyIsImZpcnN0IiwiZSIsInJlc3VsdCIsImNvbmNhdCIsInYxIiwidjIiLCJzaXplMSIsInNpemUyIiwic2l6ZV93aXRoX3BhdGNoIiwic2l6ZXgiLCJzaXplX3dpdGhfc2V0IiwidXBkYXRlX3BhdGNoMSIsInBvcyIsIm0iLCJ1cGRhdGVfcGF0Y2gyIiwidHVwbGVfZXYiLCJwMSIsInAyIiwibWVyZ2VkX2V2IiwiczIiLCJzMSIsImludmVyc2UiLCJyZXYiLCJmaWx0ZXIiLCJwcmVkIiwiSW50TWFwIiwic2l6ZSIsImZpbHRlcl9saXN0IiwicmVzIiwidGhlaXJfaSIsIm15X2kiLCJub3JtYWxpc2UiLCJ1cGRhdGVfaW5kZXhfaW5zZXJ0IiwiaW5zZXJ0X3Bvc19mdWxsX2xpc3QiLCJ2aXNpYmxlIiwidXBkYXRhYmxlcyIsImRpc3BsYWNlZCIsImxlZnRfYWxvbmUiLCJkaXNwbGFjZWRfaW5fZmlsdGVyZWQiLCJ1cGRhdGVfaiIsImpfZnVsbF9saXN0Iiwial9maWx0ZXJlZF9saXN0IiwibmV3X2pfZmlsdGVyZWQiLCJpbnNlcnRfcG9zX2ZpbHRlcmVkIiwidXBkYXRlX2luZGV4X21vdmUiLCJmcm9tX2Z1bGxfbGlzdCIsInRvX2Z1bGxfbGlzdCIsInRvX2ZpbHRlcmVkIiwid2FzX3Zpc2libGUiLCJmb3J3YXJkIiwiaV9mdWxsIiwiZGVsdGEiLCJpX2ZpbHRlcmVkIiwibmV3X3ZhbCIsImNvbnZlcnRfcCIsInJlbW92ZV9wb3NfZnVsbF9saXN0IiwicmV0IiwibmV3X2oiLCJsYXN0X2kiLCJ1cGRhdGVfcG9zX2Z1bGxfbGlzdCIsIm9sZF9qIiwibm9uZSIsInByZXZpb3VzX3Bvc19maWx0ZXJlZCIsIm5ld19wb3NfZmlsdGVyZWRfbGlzdCIsIm9mZnNldF9mdWxsIiwib3JpZ2luX2Z1bGwiLCJkZXN0X2Z1bGwiLCJvcmlnaW5fZmlsdGVyZWQiLCJkZXN0X2ZpbHRlcmVkIiwic21hbGxfb25lcyIsImZpbHRlcl9lIiwiSW50U2V0IiwiZm9yX2FsbCIsImZuIiwibWF5YmVfdXBkYXRlIiwiaW5pdCIsInVwZGF0ZV9pZHhfYWZ0ZXIiLCJ1cGRhdGVzIiwiUmVhY3RpdmVEYXRhIiwiTSIsImsiLCJnIiwia2V5IiwidyJdLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL2hvbWUvYmVlbGlndWwvLm9wYW0vb2NhbWwtNS4yLjAvbGliL3JlYWN0aXZlRGF0YS9yZWFjdGl2ZURhdGEubWwiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLDBCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFB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LGdDQUEyQjtBQUFBO0FBQUEsUUQvdEIxQyIsInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwiKCogUmVhY3RpdmVEYXRhXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaGh1Z28vcmVhY3RpdmVEYXRhXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTQgSHVnbyBIZXV6YXJkXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG5cbm1vZHVsZSB0eXBlIERBVEEgPSBzaWdcbiAgdHlwZSAnYSBkYXRhXG4gIHR5cGUgJ2EgcGF0Y2hcblxuICB2YWwgbWVyZ2UgOiAnYSBwYXRjaCAtPiAnYSBkYXRhIC0+ICdhIGRhdGFcbiAgdmFsIG1hcF9wYXRjaCA6ICgnYSAtPiAnYikgLT4gJ2EgcGF0Y2ggLT4gJ2IgcGF0Y2hcbiAgdmFsIG1hcF9kYXRhIDogKCdhIC0+ICdiKSAtPiAnYSBkYXRhIC0+ICdiIGRhdGFcbiAgdmFsIGVtcHR5IDogJ2EgZGF0YVxuICB2YWwgZXF1YWwgOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgZGF0YSAtPiAnYSBkYXRhIC0+IGJvb2xcbiAgdmFsIGRpZmYgOiBlcTooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgZGF0YSAtPiAnYSBkYXRhIC0+ICdhIHBhdGNoXG5lbmRcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnYSBkYXRhXG4gIHR5cGUgJ2EgcGF0Y2hcbiAgdHlwZSAnYSBtc2cgPSBQYXRjaCBvZiAnYSBwYXRjaCB8IFNldCBvZiAnYSBkYXRhXG4gIHR5cGUgJ2EgaGFuZGxlXG5cbiAgdmFsIGVtcHR5IDogJ2EgdFxuICB2YWwgY3JlYXRlIDogJ2EgZGF0YSAtPiAnYSB0ICogJ2EgaGFuZGxlXG4gIHZhbCBmcm9tX2V2ZW50IDogJ2EgZGF0YSAtPiAnYSBtc2cgUmVhY3QuRS50IC0+ICdhIHRcbiAgdmFsIGZyb21fc2lnbmFsIDogP2VxOignYSAtPiAnYSAtPiBib29sKSAtPiAnYSBkYXRhIFJlYWN0LlMudCAtPiAnYSB0XG4gIHZhbCBjb25zdCA6ICdhIGRhdGEgLT4gJ2EgdFxuICB2YWwgcGF0Y2ggOiAnYSBoYW5kbGUgLT4gJ2EgcGF0Y2ggLT4gdW5pdFxuICB2YWwgc2V0IDogJ2EgaGFuZGxlIC0+ICdhIGRhdGEgLT4gdW5pdFxuICB2YWwgbWFwX21zZyA6ICgnYSAtPiAnYikgLT4gJ2EgbXNnIC0+ICdiIG1zZ1xuICB2YWwgbWFwIDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgdmFsIHZhbHVlIDogJ2EgdCAtPiAnYSBkYXRhXG4gIHZhbCBmb2xkIDogKCdhIC0+ICdiIG1zZyAtPiAnYSkgLT4gJ2IgdCAtPiAnYSAtPiAnYSBSZWFjdC5zaWduYWxcbiAgdmFsIHNpZ25hbCA6ID9lcTooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSBkYXRhIFJlYWN0LlMudFxuICB2YWwgZXZlbnQgOiAnYSB0IC0+ICdhIG1zZyBSZWFjdC5FLnRcbmVuZFxuXG5tb2R1bGUgTWFrZSAoRCA6IERBVEEpIDpcbiAgUyB3aXRoIHR5cGUgJ2EgZGF0YSA9ICdhIEQuZGF0YSBhbmQgdHlwZSAnYSBwYXRjaCA9ICdhIEQucGF0Y2ggPSBzdHJ1Y3RcbiAgdHlwZSAnYSBkYXRhID0gJ2EgRC5kYXRhXG4gIHR5cGUgJ2EgcGF0Y2ggPSAnYSBELnBhdGNoXG5cbiAgbGV0IG1lcmdlID0gRC5tZXJnZVxuICBsZXQgbWFwX3BhdGNoID0gRC5tYXBfcGF0Y2hcbiAgbGV0IG1hcF9kYXRhID0gRC5tYXBfZGF0YVxuXG4gIHR5cGUgJ2EgbXNnID0gUGF0Y2ggb2YgJ2EgcGF0Y2ggfCBTZXQgb2YgJ2EgZGF0YVxuICB0eXBlICdhIGhhbmRsZSA9ID9zdGVwOlJlYWN0LnN0ZXAgLT4gJ2EgbXNnIC0+IHVuaXRcbiAgdHlwZSAnYSBtdXQgPSB7IGN1cnJlbnQgOiAnYSBkYXRhIHJlZjsgZXZlbnQgOiAnYSBtc2cgUmVhY3QuRS50IH1cbiAgdHlwZSAnYSB0ID0gQ29uc3Qgb2YgJ2EgZGF0YSB8IE11dCBvZiAnYSBtdXRcblxuICBsZXQgZW1wdHkgPSBDb25zdCBELmVtcHR5XG5cbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBsZXQgaW5pdGlhbF9ldmVudCwgc2VuZCA9IFJlYWN0LkUuY3JlYXRlICgpIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgbCBpblxuICAgIGxldCBldmVudCA9XG4gICAgICBSZWFjdC5FLm1hcFxuICAgICAgICAoZnVuIG1zZyAtPlxuICAgICAgICAgIChtYXRjaCBtc2cgd2l0aFxuICAgICAgICAgIHwgU2V0IGwgLT4gY3VycmVudCA6PSBsXG4gICAgICAgICAgfCBQYXRjaCBwIC0+IGN1cnJlbnQgOj0gbWVyZ2UgcCAhY3VycmVudCk7XG4gICAgICAgICAgbXNnKVxuICAgICAgICBpbml0aWFsX2V2ZW50XG4gICAgaW5cbiAgICAoTXV0IHsgY3VycmVudDsgZXZlbnQgfSwgc2VuZClcblxuICBsZXQgZnJvbV9ldmVudCBsIGluaXRpYWxfZXZlbnQgPVxuICAgIGxldCBjdXJyZW50ID0gcmVmIGwgaW5cbiAgICBsZXQgZXZlbnQgPVxuICAgICAgUmVhY3QuRS5tYXBcbiAgICAgICAgKGZ1biBtc2cgLT5cbiAgICAgICAgICAobWF0Y2ggbXNnIHdpdGhcbiAgICAgICAgICB8IFNldCBsIC0+IGN1cnJlbnQgOj0gbFxuICAgICAgICAgIHwgUGF0Y2ggcCAtPiBjdXJyZW50IDo9IG1lcmdlIHAgIWN1cnJlbnQpO1xuICAgICAgICAgIG1zZylcbiAgICAgICAgaW5pdGlhbF9ldmVudFxuICAgIGluXG4gICAgTXV0IHsgY3VycmVudDsgZXZlbnQgfVxuXG4gIGxldCBjb25zdCB4ID0gQ29uc3QgeFxuXG4gIGxldCBtYXBfbXNnIChmIDogJ2EgLT4gJ2IpIDogJ2EgbXNnIC0+ICdiIG1zZyA9IGZ1bmN0aW9uXG4gICAgfCBTZXQgbCAtPiBTZXQgKG1hcF9kYXRhIGYgbClcbiAgICB8IFBhdGNoIHAgLT4gUGF0Y2ggKG1hcF9wYXRjaCBmIHApXG5cbiAgbGV0IG1hcCBmIHMgPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgQ29uc3QgeCAtPiBDb25zdCAobWFwX2RhdGEgZiB4KVxuICAgIHwgTXV0IHMgLT5cbiAgICAgICAgbGV0IGN1cnJlbnQgPSByZWYgKG1hcF9kYXRhIGYgIShzLmN1cnJlbnQpKSBpblxuICAgICAgICBsZXQgZXZlbnQgPVxuICAgICAgICAgIFJlYWN0LkUubWFwXG4gICAgICAgICAgICAoZnVuIG1zZyAtPlxuICAgICAgICAgICAgICBsZXQgbXNnID0gbWFwX21zZyBmIG1zZyBpblxuICAgICAgICAgICAgICAobWF0Y2ggbXNnIHdpdGhcbiAgICAgICAgICAgICAgfCBTZXQgbCAtPiBjdXJyZW50IDo9IGxcbiAgICAgICAgICAgICAgfCBQYXRjaCBwIC0+IGN1cnJlbnQgOj0gbWVyZ2UgcCAhY3VycmVudCk7XG4gICAgICAgICAgICAgIG1zZylcbiAgICAgICAgICAgIHMuZXZlbnRcbiAgICAgICAgaW5cbiAgICAgICAgTXV0IHsgY3VycmVudDsgZXZlbnQgfVxuXG4gIGxldCB2YWx1ZSBzID0gbWF0Y2ggcyB3aXRoIENvbnN0IGMgLT4gYyB8IE11dCBzIC0+ICEocy5jdXJyZW50KVxuICBsZXQgZXZlbnQgcyA9IG1hdGNoIHMgd2l0aCBDb25zdCBfIC0+IFJlYWN0LkUubmV2ZXIgfCBNdXQgcyAtPiBzLmV2ZW50XG4gIGxldCBwYXRjaCAocyA6ICdhIGhhbmRsZSkgcCA9IHMgKFBhdGNoIHApXG4gIGxldCBzZXQgKHMgOiAnYSBoYW5kbGUpIHAgPSBzIChTZXQgcClcblxuICBsZXQgZm9sZCBmIHMgYWNjID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IENvbnN0IGMgLT4gUmVhY3QuUy5jb25zdCAoZiBhY2MgKFNldCBjKSlcbiAgICB8IE11dCBzIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyAoU2V0ICEocy5jdXJyZW50KSkgaW5cbiAgICAgICAgUmVhY3QuUy5mb2xkIGYgYWNjIHMuZXZlbnRcblxuICBsZXQgc2lnbmFsID8oZXEgPSAoID0gKSkgKHMgOiAnYSB0KSA6ICdhIGRhdGEgUmVhY3QuUy50ID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IENvbnN0IGMgLT4gUmVhY3QuUy5jb25zdCBjXG4gICAgfCBNdXQgcyAtPlxuICAgICAgICBSZWFjdC5TLmZvbGQgfmVxOihELmVxdWFsIGVxKVxuICAgICAgICAgIChmdW4gbCBtc2cgLT4gbWF0Y2ggbXNnIHdpdGggU2V0IGwgLT4gbCB8IFBhdGNoIHAgLT4gbWVyZ2UgcCBsKVxuICAgICAgICAgICEocy5jdXJyZW50KSBzLmV2ZW50XG5cbiAgbGV0IGZyb21fc2lnbmFsID8oZXEgPSAoID0gKSkgcyA9XG4gICAgbGV0IGYgZCcgZCA9IFBhdGNoIChELmRpZmYgfmVxIGQgZCcpIGluXG4gICAgZnJvbV9ldmVudCAoUmVhY3QuUy52YWx1ZSBzKSAoUmVhY3QuUy5kaWZmIGYgcylcbmVuZFxuXG5tb2R1bGUgRGF0YUxpc3QgPSBzdHJ1Y3RcbiAgdHlwZSAnYSBkYXRhID0gJ2EgbGlzdFxuICB0eXBlICdhIHAgPSBJIG9mIGludCAqICdhIHwgUiBvZiBpbnQgfCBVIG9mIGludCAqICdhIHwgWCBvZiBpbnQgKiBpbnRcbiAgdHlwZSAnYSBwYXRjaCA9ICdhIHAgbGlzdFxuXG4gIGxldCBlbXB0eSA9IFtdXG4gIGxldCBtYXBfZGF0YSA9IExpc3QubWFwXG5cbiAgbGV0IG1hcF9wYXRjaCBmID0gZnVuY3Rpb25cbiAgICB8IEkgKGksIHgpIC0+IEkgKGksIGYgeClcbiAgICB8IFIgaSAtPiBSIGlcbiAgICB8IFggKGksIGopIC0+IFggKGksIGopXG4gICAgfCBVIChpLCB4KSAtPiBVIChpLCBmIHgpXG5cbiAgbGV0IG1hcF9wYXRjaCBmID0gTGlzdC5tYXAgKG1hcF9wYXRjaCBmKVxuXG4gIGxldCBtZXJnZV9wIG9wIGwgPVxuICAgIG1hdGNoIG9wIHdpdGhcbiAgICB8IEkgKGknLCB4KSAtPlxuICAgICAgICBsZXQgaSA9IGlmIGknIDwgMCB0aGVuIExpc3QubGVuZ3RoIGwgKyAxICsgaScgZWxzZSBpJyBpblxuICAgICAgICBsZXQgcmVjIGF1eCBhY2MgbiBsID1cbiAgICAgICAgICBtYXRjaCAobiwgbCkgd2l0aFxuICAgICAgICAgIHwgMCwgbCAtPiBMaXN0LnJldl9hcHBlbmQgYWNjICh4IDo6IGwpXG4gICAgICAgICAgfCBfLCBbXSAtPiBmYWlsd2l0aCBcIlJlYWN0aXZlRGF0YS5SbGlzdC5tZXJnZVwiXG4gICAgICAgICAgfCBuLCB4IDo6IHhzIC0+IGF1eCAoeCA6OiBhY2MpIChwcmVkIG4pIHhzXG4gICAgICAgIGluXG4gICAgICAgIGF1eCBbXSBpIGxcbiAgICB8IFIgaScgLT5cbiAgICAgICAgbGV0IGkgPSBpZiBpJyA8IDAgdGhlbiBMaXN0Lmxlbmd0aCBsICsgaScgZWxzZSBpJyBpblxuICAgICAgICBsZXQgcmVjIGF1eCBhY2MgbiBsID1cbiAgICAgICAgICBtYXRjaCAobiwgbCkgd2l0aFxuICAgICAgICAgIHwgMCwgXyA6OiBsIC0+IExpc3QucmV2X2FwcGVuZCBhY2MgbFxuICAgICAgICAgIHwgXywgW10gLT4gZmFpbHdpdGggXCJSZWFjdGl2ZURhdGEuUmxpc3QubWVyZ2VcIlxuICAgICAgICAgIHwgbiwgeCA6OiB4cyAtPiBhdXggKHggOjogYWNjKSAocHJlZCBuKSB4c1xuICAgICAgICBpblxuICAgICAgICBhdXggW10gaSBsXG4gICAgfCBVIChpJywgeCkgLT5cbiAgICAgICAgbGV0IGkgPSBpZiBpJyA8IDAgdGhlbiBMaXN0Lmxlbmd0aCBsICsgaScgZWxzZSBpJyBpblxuICAgICAgICBsZXQgYSA9IEFycmF5Lm9mX2xpc3QgbCBpblxuICAgICAgICBhLihpKSA8LSB4O1xuICAgICAgICBBcnJheS50b19saXN0IGFcbiAgICB8IFggKGknLCBvZmZzZXQpIC0+XG4gICAgICAgIGxldCBhID0gQXJyYXkub2ZfbGlzdCBsIGluXG4gICAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggYSBpblxuICAgICAgICBsZXQgaSA9IGlmIGknIDwgMCB0aGVuIGxlbiArIGknIGVsc2UgaScgaW5cbiAgICAgICAgbGV0IHYgPSBhLihpKSBpblxuICAgICAgICBpZiBvZmZzZXQgPiAwIHRoZW4gKFxuICAgICAgICAgIGlmIGkgKyBvZmZzZXQgPj0gbGVuIHRoZW4gZmFpbHdpdGggXCJSZWFjdGl2ZURhdGEuUmxpc3QubWVyZ2VcIjtcbiAgICAgICAgICBmb3IgaiA9IGkgdG8gaSArIG9mZnNldCAtIDEgZG9cbiAgICAgICAgICAgIGEuKGopIDwtIGEuKGogKyAxKVxuICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgYS4oaSArIG9mZnNldCkgPC0gdilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgaWYgaSArIG9mZnNldCA8IDAgdGhlbiBmYWlsd2l0aCBcIlJlYWN0aXZlRGF0YS5SbGlzdC5tZXJnZVwiO1xuICAgICAgICAgIGZvciBqID0gaSBkb3dudG8gaSArIG9mZnNldCArIDEgZG9cbiAgICAgICAgICAgIGEuKGopIDwtIGEuKGogLSAxKVxuICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgYS4oaSArIG9mZnNldCkgPC0gdik7XG4gICAgICAgIEFycmF5LnRvX2xpc3QgYVxuXG4gICgqIGFjY3VtdWxhdGVzIGludG8gYWNjIGkgdW5tb2RpZmllZCBlbGVtZW50cyBmcm9tIGwgKilcbiAgbGV0IHJlYyBsaW5lYXJfbWVyZ2VfZndkIH5hY2MgaSBsID1cbiAgICBhc3NlcnQgKGkgPj0gMCk7XG4gICAgaWYgaSA+IDAgdGhlblxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IGggOjogbCAtPlxuICAgICAgICAgIGxldCBhY2MgPSBoIDo6IGFjYyBpblxuICAgICAgICAgIGxpbmVhcl9tZXJnZV9md2QgfmFjYyAoaSAtIDEpIGxcbiAgICAgIHwgW10gLT4gaW52YWxpZF9hcmcgXCJpbnZhbGlkIGluZGV4XCJcbiAgICBlbHNlIChsLCBhY2MpXG5cbiAgbGV0IHJlYyBsaW5lYXJfbWVyZ2UgfmFjYyBpMCBwIGwgPVxuICAgIGxldCBsLCBhY2MgPVxuICAgICAgbWF0Y2ggcCB3aXRoXG4gICAgICB8IChJIChpLCBfKSB8IFIgaSB8IFUgKGksIF8pKSA6OiBfIHdoZW4gaSA+IGkwIC0+XG4gICAgICAgICAgbGluZWFyX21lcmdlX2Z3ZCB+YWNjIChpIC0gaTApIGxcbiAgICAgIHwgXyAtPiAobCwgYWNjKVxuICAgIGluXG4gICAgbWF0Y2ggKHAsIGwpIHdpdGhcbiAgICB8IEkgKGksIHgpIDo6IHAsIF8gLT4gbGluZWFyX21lcmdlIH5hY2MgaSBwICh4IDo6IGwpXG4gICAgfCBSIGkgOjogcCwgXyA6OiBsIC0+IGxpbmVhcl9tZXJnZSB+YWNjIGkgcCBsXG4gICAgfCBSIF8gOjogXywgW10gLT4gaW52YWxpZF9hcmcgXCJtZXJnZTogaW52YWxpZCBpbmRleFwiXG4gICAgfCBVIChpLCB4KSA6OiBwLCBfIDo6IGwgLT4gbGluZWFyX21lcmdlIH5hY2MgaSBwICh4IDo6IGwpXG4gICAgfCBVIChfLCBfKSA6OiBfLCBbXSAtPiBpbnZhbGlkX2FyZyBcIm1lcmdlOiBpbnZhbGlkIGluZGV4XCJcbiAgICB8IFtdLCBsIC0+IExpc3QucmV2X2FwcGVuZCBhY2MgbFxuICAgIHwgWCAoXywgXykgOjogXywgXyAtPiBmYWlsd2l0aCBcImxpbmVhcl9tZXJnZTogWCBub3Qgc3VwcG9ydGVkXCJcblxuICBsZXQgcmVjIGxpbmVhcl9tZXJnZWFibGUgfm4gcCA9XG4gICAgYXNzZXJ0IChuID49IDApO1xuICAgIG1hdGNoIHAgd2l0aFxuICAgIHwgKEkgKGksIF8pIHwgUiBpIHwgVSAoaSwgXykpIDo6IHAgd2hlbiBpID49IG4gLT5cbiAgICAgICAgKCogbmVnYXRpdmUgaSdzIHJ1bGVkIG91dCAoYW1vbmcgb3RoZXJzKSAqKVxuICAgICAgICBsaW5lYXJfbWVyZ2VhYmxlIH5uOmkgcFxuICAgIHwgXyA6OiBfIC0+IGZhbHNlXG4gICAgfCBbXSAtPiB0cnVlXG5cbiAgbGV0IG1lcmdlIHAgbCA9XG4gICAgaWYgbGluZWFyX21lcmdlYWJsZSB+bjowIHAgdGhlbiBsaW5lYXJfbWVyZ2UgfmFjYzpbXSAwIHAgbFxuICAgIGVsc2UgTGlzdC5mb2xkX2xlZnQgKGZ1biBsIHggLT4gbWVyZ2VfcCB4IGwpIGwgcFxuXG4gIGxldCByZWMgZXF1YWwgZiBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgeDEgOjogbDEsIHgyIDo6IGwyIHdoZW4gZiB4MSB4MiAtPiBlcXVhbCBmIGwxIGwyXG4gICAgfCBbXSwgW10gLT4gdHJ1ZVxuICAgIHwgXyA6OiBfLCBfIDo6IF8gfCBfIDo6IF8sIFtdIHwgW10sIF8gOjogXyAtPiBmYWxzZVxuXG4gIGxldCBtZW0gKHR5cGUgdSkgbCA9XG4gICAgbGV0IG1vZHVsZSBIID0gSGFzaHRibC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IHVcblxuICAgICAgbGV0IGhhc2ggPSBIYXNodGJsLmhhc2hcbiAgICAgIGxldCBlcXVhbCA9ICggPT0gKVxuICAgIGVuZCkgaW5cbiAgICBsZXQgaCA9IEguY3JlYXRlIDE2IGluXG4gICAgTGlzdC5pdGVyIChmdW4geCAtPiBILmFkZCBoIHggKCkpIGw7XG4gICAgSC5tZW0gaFxuXG4gIGxldCBmb2xkX2RpZmYgPyhlcSA9ICggPSApKSB+YWNjIH5yZW1vdmUgfmFkZCBseCBseSA9XG4gICAgbGV0IG1lbXggPSBtZW0gbHggYW5kIG1lbXkgPSBtZW0gbHkgaW5cbiAgICBsZXQgcmVjIGYgfmFjYyB+bGVmdCBseCBseSBuID1cbiAgICAgIG1hdGNoIChseCwgbHkpIHdpdGhcbiAgICAgICgqIHRyYWlsaW5nIGVsZW1lbnRzIHRvIGJlIHJlbW92ZWQgKilcbiAgICAgIHwgXyA6OiBseCwgW10gLT5cbiAgICAgICAgICBsZXQgYWNjID0gcmVtb3ZlIGFjYyBuIGluXG4gICAgICAgICAgZiB+YWNjIH5sZWZ0IGx4IFtdIG5cbiAgICAgICgqIHRyYWlsaW5nIGVsZW1lbnRzIHRvIGJlIGFkZGVkICopXG4gICAgICB8IFtdLCB5IDo6IGx5IC0+XG4gICAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgbiB5IGluXG4gICAgICAgICAgZiB+YWNjIH5sZWZ0IFtdIGx5IChuICsgMSlcbiAgICAgICgqIGRvbmUhICopXG4gICAgICB8IFtdLCBbXSAtPiBhY2NcbiAgICAgICgqIHNhbWUgKilcbiAgICAgIHwgeCA6OiBseCwgeSA6OiBseSB3aGVuIGVxIHggeSAtPiBmIH5hY2MgfmxlZnQgbHggbHkgKG4gKyAxKVxuICAgICAgKCogeCBuZWVkcyB0byBiZSByZW1vdmVkIGZvciBzdXJlICopXG4gICAgICB8IHggOjogbHgsIF8gOjogXyB3aGVuIG5vdCAobWVteSB4KSAtPlxuICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIG4gaW5cbiAgICAgICAgICBmIH5hY2MgfmxlZnQgbHggbHkgblxuICAgICAgKCogeSBuZWVkcyB0byBiZSBhZGRlZCBmb3Igc3VyZSAqKVxuICAgICAgfCBfIDo6IF8sIHkgOjogbHkgd2hlbiBub3QgKG1lbXggeSkgLT5cbiAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBuIHkgaW5cbiAgICAgICAgICBmIH5hY2MgfmxlZnQgbHggbHkgKG4gKyAxKVxuICAgICAgKCogbm8gbW9yZSBjZXJ0YWludHksIH5sZWZ0IGRlY2lkZXMgd2hhdCB0byByZWN1ciBvbiAqKVxuICAgICAgfCBfIDo6IGx4LCBfIDo6IF8gd2hlbiBsZWZ0IC0+XG4gICAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgbiBpblxuICAgICAgICAgIGYgfmFjYyB+bGVmdDpmYWxzZSBseCBseSBuXG4gICAgICB8IF8gOjogXywgeSA6OiBseSAtPlxuICAgICAgICAgIGxldCBhY2MgPSBhZGQgYWNjIG4geSBpblxuICAgICAgICAgIGYgfmFjYyB+bGVmdDp0cnVlIGx4IGx5IChuICsgMSlcbiAgICBpblxuICAgIGYgfmFjYyB+bGVmdDp0cnVlIGx4IGx5IDBcblxuICBsZXQgcmVjIGxpc3RfcmV2ID8oYWNjID0gW10pID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgICBsZXQgYWNjID0gaCA6OiBhY2MgaW5cbiAgICAgICAgbGlzdF9yZXYgfmFjYyB0XG4gICAgfCBbXSAtPiBhY2NcblxuICBsZXQgZGlmZiB+ZXEgeCB5ID1cbiAgICBsZXQgYWRkIGFjYyBpIHYgPSBJIChpLCB2KSA6OiBhY2NcbiAgICBhbmQgcmVtb3ZlIGFjYyBpID0gUiBpIDo6IGFjY1xuICAgIGFuZCBhY2MgPSBbXSBpblxuICAgIGxpc3RfcmV2IChmb2xkX2RpZmYgfmVxIH5hY2MgfmFkZCB+cmVtb3ZlIHggeSlcbmVuZFxuXG5tb2R1bGUgUkxpc3QgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlIChEYXRhTGlzdClcbiAgbW9kdWxlIEQgPSBEYXRhTGlzdFxuXG4gIHR5cGUgJ2EgcCA9ICdhIEQucCA9XG4gICAgfCBJIG9mIGludCAqICdhXG4gICAgfCBSIG9mIGludFxuICAgIHwgVSBvZiBpbnQgKiAnYVxuICAgIHwgWCBvZiBpbnQgKiBpbnRcblxuICBsZXQgY29ucyB4IHMgPSBwYXRjaCBzIFsgRC5JICgwLCB4KSBdXG4gIGxldCBzbm9jIHggcyA9IHBhdGNoIHMgWyBELkkgKC0xLCB4KSBdXG4gIGxldCBpbnNlcnQgeCBpIHMgPSBwYXRjaCBzIFsgRC5JIChpLCB4KSBdXG4gIGxldCB1cGRhdGUgeCBpIHMgPSBwYXRjaCBzIFsgRC5VIChpLCB4KSBdXG4gIGxldCBtb3ZlIGkgaiBzID0gcGF0Y2ggcyBbIEQuWCAoaSwgaikgXVxuICBsZXQgcmVtb3ZlIGkgcyA9IHBhdGNoIHMgWyBELlIgaSBdXG5cbiAgbGV0IGluZGV4ID8oZXEgPSAoID0gKSkgbCB4ID1cbiAgICBsZXQgcmVjIGYgbiA9IGZ1bmN0aW9uXG4gICAgICB8IGhkIDo6IF8gd2hlbiBlcSBoZCB4IC0+IG5cbiAgICAgIHwgXyA6OiB0bCAtPiBmIChuICsgMSkgdGxcbiAgICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgaW5cbiAgICBmIDAgbFxuXG4gIGxldCB1cGRhdGVfZXEgP2VxIChkYXRhLCBoYW5kbGUpIHggeSA9XG4gICAgbGV0IGkgPSBpbmRleCA/ZXEgKHZhbHVlIGRhdGEpIHggaW5cbiAgICB1cGRhdGUgeSBpIGhhbmRsZVxuXG4gIGxldCByZW1vdmVfbGFzdCAoZGF0YSwgaGFuZGxlKSA9IHJlbW92ZSAoTGlzdC5sZW5ndGggKHZhbHVlIGRhdGEpIC0gMSkgaGFuZGxlXG5cbiAgbGV0IHJlbW92ZV9lcSA/ZXEgKGRhdGEsIGhhbmRsZSkgeCA9XG4gICAgbGV0IGkgPSBpbmRleCA/ZXEgKHZhbHVlIGRhdGEpIHggaW5cbiAgICByZW1vdmUgaSBoYW5kbGVcblxuICBsZXQgc2luZ2xldG9uIHggPSBjb25zdCBbIHggXVxuXG4gIGxldCBzaW5nbGV0b25fcyBzID1cbiAgICBsZXQgZmlyc3QgPSByZWYgdHJ1ZSBpblxuICAgIGxldCBlLCBzZW5kID0gUmVhY3QuRS5jcmVhdGUgKCkgaW5cbiAgICBsZXQgcmVzdWx0ID0gZnJvbV9ldmVudCBbXSBlIGluXG4gICAgbGV0IChgUiBfKSA9XG4gICAgICBsZXQgcycgPVxuICAgICAgICBSZWFjdC5TLm1hcFxuICAgICAgICAgIChmdW4geCAtPlxuICAgICAgICAgICAgaWYgIWZpcnN0IHRoZW4gKFxuICAgICAgICAgICAgICBmaXJzdCA6PSBmYWxzZTtcbiAgICAgICAgICAgICAgc2VuZCAoUGF0Y2ggWyBJICgwLCB4KSBdKSlcbiAgICAgICAgICAgIGVsc2Ugc2VuZCAoUGF0Y2ggWyBVICgwLCB4KSBdKSlcbiAgICAgICAgICBzXG4gICAgICBpblxuICAgICAgUmVhY3QuRS5yZXRhaW4gZSAoZnVuICgpIC0+IGlnbm9yZSAoUmVhY3QuUy52YWx1ZSBzJykpXG4gICAgaW5cbiAgICByZXN1bHRcblxuICBsZXQgY29uY2F0IDogJ2EgdCAtPiAnYSB0IC0+ICdhIHQgPVxuICAgZnVuIHggeSAtPlxuICAgIGxldCB2MSA9IHZhbHVlIHggYW5kIHYyID0gdmFsdWUgeSBpblxuICAgIGxldCBzaXplMSA9IHJlZiAwIGFuZCBzaXplMiA9IHJlZiAwIGluXG4gICAgbGV0IHNpemVfd2l0aF9wYXRjaCBzaXpleCA6ICdhIEQucCAtPiB1bml0ID0gZnVuY3Rpb25cbiAgICAgIHwgRC5JIF8gLT4gaW5jciBzaXpleFxuICAgICAgfCBELlIgXyAtPiBkZWNyIHNpemV4XG4gICAgICB8IEQuWCBfIHwgRC5VIF8gLT4gKClcbiAgICBpblxuICAgIGxldCBzaXplX3dpdGhfc2V0IHNpemV4IGwgPSBzaXpleCA6PSBMaXN0Lmxlbmd0aCBsIGluXG5cbiAgICBzaXplX3dpdGhfc2V0IHNpemUxIHYxO1xuICAgIHNpemVfd2l0aF9zZXQgc2l6ZTIgdjI7XG5cbiAgICBsZXQgdXBkYXRlX3BhdGNoMSA9XG4gICAgICBMaXN0Lm1hcCAoZnVuIHAgLT5cbiAgICAgICAgICBsZXQgbSA9XG4gICAgICAgICAgICBtYXRjaCBwIHdpdGhcbiAgICAgICAgICAgIHwgRC5JIChwb3MsIHgpIC0+XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBpZiBwb3MgPCAwIHRoZW4gcG9zIC0gIXNpemUyIGVsc2UgcG9zIGluXG4gICAgICAgICAgICAgICAgRC5JIChpLCB4KVxuICAgICAgICAgICAgfCBELlIgcG9zIC0+IEQuUiAoaWYgcG9zIDwgMCB0aGVuIHBvcyAtICFzaXplMiBlbHNlIHBvcylcbiAgICAgICAgICAgIHwgRC5VIChwb3MsIHgpIC0+IEQuVSAoKGlmIHBvcyA8IDAgdGhlbiBwb3MgLSAhc2l6ZTIgZWxzZSBwb3MpLCB4KVxuICAgICAgICAgICAgfCBELlggKGksIGopIC0+IEQuWCAoKGlmIGkgPCAwIHRoZW4gaSAtICFzaXplMiBlbHNlIGkpLCBqKVxuICAgICAgICAgIGluXG4gICAgICAgICAgc2l6ZV93aXRoX3BhdGNoIHNpemUxIG07XG4gICAgICAgICAgbSlcbiAgICBpblxuICAgIGxldCB1cGRhdGVfcGF0Y2gyID1cbiAgICAgIExpc3QubWFwIChmdW4gcCAtPlxuICAgICAgICAgIGxldCBtID1cbiAgICAgICAgICAgIG1hdGNoIHAgd2l0aFxuICAgICAgICAgICAgfCBELkkgKHBvcywgeCkgLT4gRC5JICgoaWYgcG9zIDwgMCB0aGVuIHBvcyBlbHNlICFzaXplMSArIHBvcyksIHgpXG4gICAgICAgICAgICB8IEQuUiBwb3MgLT4gRC5SIChpZiBwb3MgPCAwIHRoZW4gcG9zIGVsc2UgIXNpemUxICsgcG9zKVxuICAgICAgICAgICAgfCBELlUgKHBvcywgeCkgLT4gRC5VICgoaWYgcG9zIDwgMCB0aGVuIHBvcyBlbHNlICFzaXplMSArIHBvcyksIHgpXG4gICAgICAgICAgICB8IEQuWCAoaSwgaikgLT4gRC5YICgoaWYgaSA8IDAgdGhlbiBpIGVsc2UgIXNpemUxICsgaSksIGopXG4gICAgICAgICAgaW5cbiAgICAgICAgICBzaXplX3dpdGhfcGF0Y2ggc2l6ZTIgbTtcbiAgICAgICAgICBtKVxuICAgIGluXG4gICAgbGV0IHR1cGxlX2V2ID1cbiAgICAgIFJlYWN0LkUubWVyZ2VcbiAgICAgICAgKGZ1biBhY2MgeCAtPlxuICAgICAgICAgIG1hdGNoIChhY2MsIHgpIHdpdGhcbiAgICAgICAgICB8IChOb25lLCBwMiksIGBFMSB4IC0+IChTb21lIHgsIHAyKVxuICAgICAgICAgIHwgKHAxLCBOb25lKSwgYEUyIHggLT4gKHAxLCBTb21lIHgpXG4gICAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgICAgICAgKE5vbmUsIE5vbmUpXG4gICAgICAgIFtcbiAgICAgICAgICBSZWFjdC5FLm1hcCAoZnVuIGUgLT4gYEUxIGUpIChldmVudCB4KTtcbiAgICAgICAgICBSZWFjdC5FLm1hcCAoZnVuIGUgLT4gYEUyIGUpIChldmVudCB5KTtcbiAgICAgICAgXVxuICAgIGluXG4gICAgbGV0IG1lcmdlZF9ldiA9XG4gICAgICBSZWFjdC5FLm1hcFxuICAgICAgICAoZnVuIHAgLT5cbiAgICAgICAgICBtYXRjaCBwIHdpdGhcbiAgICAgICAgICB8IFNvbWUgKFNldCBwMSksIFNvbWUgKFNldCBwMikgLT5cbiAgICAgICAgICAgICAgc2l6ZV93aXRoX3NldCBzaXplMSBwMTtcbiAgICAgICAgICAgICAgc2l6ZV93aXRoX3NldCBzaXplMiBwMjtcbiAgICAgICAgICAgICAgU2V0IChwMSBAIHAyKVxuICAgICAgICAgIHwgU29tZSAoU2V0IHAxKSwgTm9uZSAtPlxuICAgICAgICAgICAgICBzaXplX3dpdGhfc2V0IHNpemUxIHAxO1xuICAgICAgICAgICAgICBTZXQgKHAxIEAgdmFsdWUgeSlcbiAgICAgICAgICB8IE5vbmUsIFNvbWUgKFNldCBwMikgLT5cbiAgICAgICAgICAgICAgc2l6ZV93aXRoX3NldCBzaXplMiBwMjtcbiAgICAgICAgICAgICAgU2V0ICh2YWx1ZSB4IEAgcDIpXG4gICAgICAgICAgfCBTb21lIChQYXRjaCBwMSksIFNvbWUgKFBhdGNoIHAyKSAtPlxuICAgICAgICAgICAgICBsZXQgcDEgPSB1cGRhdGVfcGF0Y2gxIHAxIGluXG4gICAgICAgICAgICAgIGxldCBwMiA9IHVwZGF0ZV9wYXRjaDIgcDIgaW5cbiAgICAgICAgICAgICAgUGF0Y2ggKHAxIEAgcDIpXG4gICAgICAgICAgfCBTb21lIChQYXRjaCBwMSksIE5vbmUgLT4gUGF0Y2ggKHVwZGF0ZV9wYXRjaDEgcDEpXG4gICAgICAgICAgfCBOb25lLCBTb21lIChQYXRjaCBwMikgLT4gUGF0Y2ggKHVwZGF0ZV9wYXRjaDIgcDIpXG4gICAgICAgICAgfCBTb21lIChQYXRjaCBfKSwgU29tZSAoU2V0IHMyKSAtPlxuICAgICAgICAgICAgICBsZXQgczEgPSB2YWx1ZSB4IGluXG4gICAgICAgICAgICAgIHNpemVfd2l0aF9zZXQgc2l6ZTEgczE7XG4gICAgICAgICAgICAgIHNpemVfd2l0aF9zZXQgc2l6ZTIgczI7XG4gICAgICAgICAgICAgIFNldCAoczEgQCBzMilcbiAgICAgICAgICB8IFNvbWUgKFNldCBzMSksIFNvbWUgKFBhdGNoIF8pIC0+XG4gICAgICAgICAgICAgIHNpemVfd2l0aF9zZXQgc2l6ZTEgczE7XG4gICAgICAgICAgICAgIGxldCBzMiA9IHZhbHVlIHkgaW5cbiAgICAgICAgICAgICAgc2l6ZV93aXRoX3NldCBzaXplMiBzMjtcbiAgICAgICAgICAgICAgU2V0IChzMSBAIHMyKVxuICAgICAgICAgIHwgTm9uZSwgTm9uZSAtPiBhc3NlcnQgZmFsc2UpXG4gICAgICAgIHR1cGxlX2V2XG4gICAgaW5cbiAgICBmcm9tX2V2ZW50ICh2MSBAIHYyKSBtZXJnZWRfZXZcblxuICBsZXQgaW52ZXJzZSA6ICdhLiAnYSBwIC0+ICdhIHAgPSBmdW5jdGlvblxuICAgIHwgSSAoaSwgeCkgLT4gSSAoLWkgLSAxLCB4KVxuICAgIHwgVSAoaSwgeCkgLT4gVSAoLWkgLSAxLCB4KVxuICAgIHwgUiBpIC0+IFIgKC1pIC0gMSlcbiAgICB8IFggKGksIGopIC0+IFggKC1pIC0gMSwgLWopXG5cbiAgbGV0IHJldiB0ID1cbiAgICBsZXQgZSA9XG4gICAgICBSZWFjdC5FLm1hcFxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICB8IFNldCBsIC0+IFNldCAoTGlzdC5yZXYgbCkgfCBQYXRjaCBwIC0+IFBhdGNoIChMaXN0Lm1hcCBpbnZlcnNlIHApKVxuICAgICAgICAoZXZlbnQgdClcbiAgICBpblxuICAgIGZyb21fZXZlbnQgKExpc3QucmV2ICh2YWx1ZSB0KSkgZVxuXG4gIGxldCBmaWx0ZXIgcHJlZCBsID1cbiAgICBsZXQgbW9kdWxlIEludE1hcCA9IE1hcC5NYWtlIChJbnQpIGluXG4gICAgbGV0IGluZGV4ID0gcmVmIEludE1hcC5lbXB0eSBpblxuICAgIGxldCBzaXplID0gcmVmIDAgaW5cblxuICAgIGxldCBmaWx0ZXJfbGlzdCBsID1cbiAgICAgIGxldCByZWMgYXV4IChsIDogJ2EgbGlzdCkgcmVzIHRoZWlyX2kgbXlfaSA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+IHJlc1xuICAgICAgICB8IHggOjogeHMgLT5cbiAgICAgICAgICAgIGlmIHByZWQgeCB0aGVuIChcbiAgICAgICAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCB0aGVpcl9pIChteV9pICsgMSkgIWluZGV4O1xuICAgICAgICAgICAgICBhdXggeHMgKHggOjogcmVzKSAodGhlaXJfaSArIDEpIChteV9pICsgMSkpXG4gICAgICAgICAgICBlbHNlIGF1eCB4cyByZXMgKHRoZWlyX2kgKyAxKSBteV9pXG4gICAgICBpblxuICAgICAgc2l6ZSA6PSBMaXN0Lmxlbmd0aCBsO1xuICAgICAgaW5kZXggOj0gSW50TWFwLmVtcHR5O1xuICAgICAgTGlzdC5yZXYgKGF1eCBsIFtdIDAgKC0xKSlcbiAgICBpblxuXG4gICAgbGV0IG5vcm1hbGlzZSBpID0gaWYgaSA8IDAgdGhlbiAhc2l6ZSArIDEgKyBpIGVsc2UgaSBpblxuXG4gICAgbGV0IHVwZGF0ZV9pbmRleF9pbnNlcnQgaW5zZXJ0X3Bvc19mdWxsX2xpc3QgdmlzaWJsZSA9XG4gICAgICBsZXQgaW5zZXJ0X3Bvc19mdWxsX2xpc3QgPSBub3JtYWxpc2UgaW5zZXJ0X3Bvc19mdWxsX2xpc3QgaW5cbiAgICAgIGxldCBsZWZ0X2Fsb25lLCBkaXNwbGFjZWQsIHVwZGF0YWJsZXMgPVxuICAgICAgICBJbnRNYXAuc3BsaXQgaW5zZXJ0X3Bvc19mdWxsX2xpc3QgIWluZGV4XG4gICAgICBpblxuICAgICAgbGV0IHVwZGF0YWJsZXMgPVxuICAgICAgICBtYXRjaCBkaXNwbGFjZWQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdXBkYXRhYmxlc1xuICAgICAgICB8IFNvbWUgZGlzcGxhY2VkX2luX2ZpbHRlcmVkIC0+XG4gICAgICAgICAgICBJbnRNYXAuYWRkIGluc2VydF9wb3NfZnVsbF9saXN0IGRpc3BsYWNlZF9pbl9maWx0ZXJlZCB1cGRhdGFibGVzXG4gICAgICBpblxuICAgICAgbGV0IHVwZGF0ZV9qIGpfZnVsbF9saXN0IGpfZmlsdGVyZWRfbGlzdCA9XG4gICAgICAgIGxldCBuZXdfal9maWx0ZXJlZCA9XG4gICAgICAgICAgaWYgdmlzaWJsZSB0aGVuIGpfZmlsdGVyZWRfbGlzdCArIDEgZWxzZSBqX2ZpbHRlcmVkX2xpc3RcbiAgICAgICAgaW5cbiAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCAoal9mdWxsX2xpc3QgKyAxKSBuZXdfal9maWx0ZXJlZCAhaW5kZXhcbiAgICAgIGluXG4gICAgICBsZXQgKCkgPSBJbnRNYXAuaXRlciB1cGRhdGVfaiB1cGRhdGFibGVzIGluXG4gICAgICBsZXQgaW5zZXJ0X3Bvc19maWx0ZXJlZCA9XG4gICAgICAgIGlmIEludE1hcC5pc19lbXB0eSBsZWZ0X2Fsb25lIHRoZW4gMFxuICAgICAgICBlbHNlIHNuZCAoSW50TWFwLm1heF9iaW5kaW5nIGxlZnRfYWxvbmUpICsgMVxuICAgICAgaW5cbiAgICAgIGlmIHZpc2libGUgdGhlblxuICAgICAgICBpbmRleCA6PSBJbnRNYXAuYWRkIGluc2VydF9wb3NfZnVsbF9saXN0IGluc2VydF9wb3NfZmlsdGVyZWQgIWluZGV4O1xuICAgICAgaW5jciBzaXplO1xuICAgICAgaW5zZXJ0X3Bvc19maWx0ZXJlZFxuICAgIGluXG5cbiAgICBsZXQgdXBkYXRlX2luZGV4X3JlbW92ZSByZW1vdmVfcG9zX2Z1bGxfbGlzdCA9XG4gICAgICBsZXQgd2FzX3Zpc2libGUgPSBJbnRNYXAubWVtIHJlbW92ZV9wb3NfZnVsbF9saXN0ICFpbmRleCBpblxuICAgICAgbGV0IF8sIF8sIHVwZGF0YWJsZXMgPSBJbnRNYXAuc3BsaXQgcmVtb3ZlX3Bvc19mdWxsX2xpc3QgIWluZGV4IGluXG4gICAgICBsZXQgdXBkYXRlX2ogal9mdWxsX2xpc3Qgal9maWx0ZXJlZF9saXN0ID1cbiAgICAgICAgbGV0IG5ld19qID1cbiAgICAgICAgICBpZiB3YXNfdmlzaWJsZSB0aGVuIGpfZmlsdGVyZWRfbGlzdCBlbHNlIGpfZmlsdGVyZWRfbGlzdCAtIDFcbiAgICAgICAgaW5cbiAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCAoal9mdWxsX2xpc3QgLSAxKSBuZXdfaiAhaW5kZXhcbiAgICAgIGluXG4gICAgICBpZiBub3QgKEludE1hcC5pc19lbXB0eSAhaW5kZXgpIHRoZW5cbiAgICAgICAgbGV0IGxhc3RfaSwgXyA9IEludE1hcC5tYXhfYmluZGluZyAhaW5kZXggaW5cbiAgICAgICAgaW5kZXggOj0gSW50TWFwLnJlbW92ZSBsYXN0X2kgIWluZGV4XG4gICAgICBlbHNlICgpO1xuICAgICAgZGVjciBzaXplO1xuICAgICAgSW50TWFwLml0ZXIgdXBkYXRlX2ogdXBkYXRhYmxlc1xuICAgIGluXG5cbiAgICBsZXQgdXBkYXRlX2luZGV4X3VwZGF0ZV9kZWxldGUgdXBkYXRlX3Bvc19mdWxsX2xpc3QgPVxuICAgICAgbGV0IF8sIF8sIHVwZGF0YWJsZXMgPSBJbnRNYXAuc3BsaXQgdXBkYXRlX3Bvc19mdWxsX2xpc3QgIWluZGV4IGluXG4gICAgICBsZXQgdXBkYXRlX2ogal9mdWxsX2xpc3Qgal9maWx0ZXJlZF9saXN0ID1cbiAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCBqX2Z1bGxfbGlzdCAoal9maWx0ZXJlZF9saXN0IC0gMSkgIWluZGV4XG4gICAgICBpblxuICAgICAgaW5kZXggOj0gSW50TWFwLnJlbW92ZSB1cGRhdGVfcG9zX2Z1bGxfbGlzdCAhaW5kZXg7XG4gICAgICBJbnRNYXAuaXRlciB1cGRhdGVfaiB1cGRhdGFibGVzXG4gICAgaW5cblxuICAgIGxldCB1cGRhdGVfaW5kZXhfdXBkYXRlX2luc2VydCB1cGRhdGVfcG9zX2Z1bGxfbGlzdCA9XG4gICAgICBsZXQgbGVmdF9hbG9uZSwgbm9uZSwgdXBkYXRhYmxlcyA9XG4gICAgICAgIEludE1hcC5zcGxpdCB1cGRhdGVfcG9zX2Z1bGxfbGlzdCAhaW5kZXhcbiAgICAgIGluXG4gICAgICBhc3NlcnQgKG5vbmUgPSBOb25lKTtcbiAgICAgIGxldCB1cGRhdGVfaiBqX2Z1bGxfbGlzdCBqX2ZpbHRlcmVkX2xpc3QgPVxuICAgICAgICBpbmRleCA6PSBJbnRNYXAuYWRkIGpfZnVsbF9saXN0IChqX2ZpbHRlcmVkX2xpc3QgKyAxKSAhaW5kZXhcbiAgICAgIGluXG4gICAgICBsZXQgbmV3X3Bvc19maWx0ZXJlZF9saXN0ID1cbiAgICAgICAgbGV0IHByZXZpb3VzX3Bvc19maWx0ZXJlZCA9XG4gICAgICAgICAgdHJ5IHNuZCAoSW50TWFwLm1heF9iaW5kaW5nIGxlZnRfYWxvbmUpIHdpdGggTm90X2ZvdW5kIC0+IC0xXG4gICAgICAgIGluXG4gICAgICAgIHByZXZpb3VzX3Bvc19maWx0ZXJlZCArIDFcbiAgICAgIGluXG4gICAgICBpbmRleCA6PSBJbnRNYXAuYWRkIHVwZGF0ZV9wb3NfZnVsbF9saXN0IG5ld19wb3NfZmlsdGVyZWRfbGlzdCAhaW5kZXg7XG4gICAgICBJbnRNYXAuaXRlciB1cGRhdGVfaiB1cGRhdGFibGVzO1xuICAgICAgbmV3X3Bvc19maWx0ZXJlZF9saXN0XG4gICAgaW5cblxuICAgIGxldCB1cGRhdGVfaW5kZXhfbW92ZSBmcm9tX2Z1bGxfbGlzdCB0b19mdWxsX2xpc3QgdG9fZmlsdGVyZWQgPVxuICAgICAgbGV0IHdhc192aXNpYmxlID1cbiAgICAgICAgbWF0Y2ggdG9fZmlsdGVyZWQgd2l0aCBTb21lIF8gLT4gdHJ1ZSB8IE5vbmUgLT4gZmFsc2VcbiAgICAgIGluXG4gICAgICBsZXQgZm9yd2FyZCA9IGZyb21fZnVsbF9saXN0IDwgdG9fZnVsbF9saXN0IGluXG4gICAgICBpZiBmb3J3YXJkIHRoZW5cbiAgICAgICAgZm9yIGlfZnVsbCA9IGZyb21fZnVsbF9saXN0ICsgMSB0byB0b19mdWxsX2xpc3QgZG9cbiAgICAgICAgICBsZXQgZGVsdGEgPSBpZiB3YXNfdmlzaWJsZSB0aGVuIC0xIGVsc2UgMCBpblxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGlfZmlsdGVyZWQgPSBJbnRNYXAuZmluZCBpX2Z1bGwgIWluZGV4IGluXG4gICAgICAgICAgICBsZXQgbmV3X3ZhbCA9IGlfZmlsdGVyZWQgKyBkZWx0YSBpblxuICAgICAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCAoaV9mdWxsIC0gMSkgbmV3X3ZhbCAhaW5kZXhcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiAoKVxuICAgICAgICBkb25lXG4gICAgICBlbHNlXG4gICAgICAgIGZvciBpX2Z1bGwgPSBmcm9tX2Z1bGxfbGlzdCAtIDEgZG93bnRvIHRvX2Z1bGxfbGlzdCBkb1xuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGRlbHRhID0gaWYgd2FzX3Zpc2libGUgdGhlbiAxIGVsc2UgMCBpblxuICAgICAgICAgICAgbGV0IGlfZmlsdGVyZWQgPSBJbnRNYXAuZmluZCBpX2Z1bGwgIWluZGV4IGluXG4gICAgICAgICAgICBsZXQgbmV3X3ZhbCA9IGlfZmlsdGVyZWQgKyBkZWx0YSBpblxuICAgICAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCAoaV9mdWxsICsgMSkgbmV3X3ZhbCAhaW5kZXhcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiAoKVxuICAgICAgICBkb25lO1xuICAgICAgbWF0Y2ggdG9fZmlsdGVyZWQgd2l0aFxuICAgICAgfCBTb21lIHRvX2ZpbHRlcmVkIC0+IGluZGV4IDo9IEludE1hcC5hZGQgdG9fZnVsbF9saXN0IHRvX2ZpbHRlcmVkICFpbmRleFxuICAgICAgfCBOb25lIC0+IGluZGV4IDo9IEludE1hcC5yZW1vdmUgdG9fZnVsbF9saXN0ICFpbmRleFxuICAgIGluXG5cbiAgICBsZXQgY29udmVydF9wID0gZnVuY3Rpb25cbiAgICAgIHwgSSAoaSwgeCkgLT5cbiAgICAgICAgICBpZiBwcmVkIHggdGhlblxuICAgICAgICAgICAgbGV0IG15X2kgPSB1cGRhdGVfaW5kZXhfaW5zZXJ0IGkgdHJ1ZSBpblxuICAgICAgICAgICAgWyBJIChteV9pLCB4KSBdXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBpZ25vcmUgKHVwZGF0ZV9pbmRleF9pbnNlcnQgaSBmYWxzZSk7XG4gICAgICAgICAgICBbXSlcbiAgICAgIHwgUiBpIC0+XG4gICAgICAgICAgbGV0IGkgPSBub3JtYWxpc2UgaSBpblxuICAgICAgICAgIGxldCByZXQgPVxuICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgIGxldCBqID0gSW50TWFwLmZpbmQgaSAhaW5kZXggaW5cbiAgICAgICAgICAgICAgWyBSIGogXVxuICAgICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gW11cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCAoKSA9IHVwZGF0ZV9pbmRleF9yZW1vdmUgaSBpblxuICAgICAgICAgIHJldFxuICAgICAgfCBVIChpLCB4KSAtPiAoXG4gICAgICAgICAgbGV0IGkgPSBub3JtYWxpc2UgaSBpblxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IG9sZF9qID0gSW50TWFwLmZpbmQgaSAhaW5kZXggaW5cbiAgICAgICAgICAgIGlmIHByZWQgeCB0aGVuIFsgVSAob2xkX2osIHgpIF1cbiAgICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgICB1cGRhdGVfaW5kZXhfdXBkYXRlX2RlbGV0ZSBpO1xuICAgICAgICAgICAgICBbIFIgb2xkX2ogXSlcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgaWYgcHJlZCB4IHRoZW5cbiAgICAgICAgICAgICAgbGV0IG5ld19qID0gdXBkYXRlX2luZGV4X3VwZGF0ZV9pbnNlcnQgaSBpblxuICAgICAgICAgICAgICBbIEkgKG5ld19qLCB4KSBdXG4gICAgICAgICAgICBlbHNlIFtdKVxuICAgICAgfCBYIChvcmlnaW5fZnVsbCwgb2Zmc2V0X2Z1bGwpIC0+IChcbiAgICAgICAgICBsZXQgb3JpZ2luX2Z1bGwgPSBub3JtYWxpc2Ugb3JpZ2luX2Z1bGwgaW5cbiAgICAgICAgICBsZXQgZGVzdF9mdWxsID0gb3JpZ2luX2Z1bGwgKyBvZmZzZXRfZnVsbCBpblxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IG9yaWdpbl9maWx0ZXJlZCA9IEludE1hcC5maW5kIG9yaWdpbl9mdWxsICFpbmRleCBpblxuICAgICAgICAgICAgbGV0IGRlc3RfZmlsdGVyZWQgPVxuICAgICAgICAgICAgICB0cnkgSW50TWFwLmZpbmQgZGVzdF9mdWxsICFpbmRleFxuICAgICAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgICAgIGxldCBzbWFsbF9vbmVzLCBfLCBfID0gSW50TWFwLnNwbGl0IG9yaWdpbl9mdWxsICFpbmRleCBpblxuICAgICAgICAgICAgICAgIGlmIEludE1hcC5pc19lbXB0eSBzbWFsbF9vbmVzIHRoZW4gMFxuICAgICAgICAgICAgICAgIGVsc2Ugc25kIChJbnRNYXAubWF4X2JpbmRpbmcgc21hbGxfb25lcykgKyAxXG4gICAgICAgICAgICBpblxuICAgICAgICAgICAgdXBkYXRlX2luZGV4X21vdmUgb3JpZ2luX2Z1bGwgZGVzdF9mdWxsIChTb21lIGRlc3RfZmlsdGVyZWQpO1xuICAgICAgICAgICAgaWYgZGVzdF9maWx0ZXJlZCAhPSBvcmlnaW5fZmlsdGVyZWQgdGhlblxuICAgICAgICAgICAgICBbIFggKG9yaWdpbl9maWx0ZXJlZCwgZGVzdF9maWx0ZXJlZCAtIG9yaWdpbl9maWx0ZXJlZCkgXVxuICAgICAgICAgICAgZWxzZSBbXVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAoKiBtb3ZpbmcgYW4gZWxlbWVudCB0aGF0IHdhcyBmaWx0ZXJlZCBvdXQgKilcbiAgICAgICAgICAgIHVwZGF0ZV9pbmRleF9tb3ZlIG9yaWdpbl9mdWxsIGRlc3RfZnVsbCBOb25lO1xuICAgICAgICAgICAgW10pXG4gICAgaW5cblxuICAgIGxldCBmaWx0ZXJfZSA9IGZ1bmN0aW9uXG4gICAgICB8IFNldCBsIC0+IFNldCAoZmlsdGVyX2xpc3QgbClcbiAgICAgIHwgUGF0Y2ggcCAtPiBQYXRjaCAoTGlzdC5jb25jYXQgKExpc3QubWFwIGNvbnZlcnRfcCBwKSlcbiAgICBpblxuICAgIGxldCBlID0gUmVhY3QuRS5tYXAgZmlsdGVyX2UgKGV2ZW50IGwpIGluXG4gICAgZnJvbV9ldmVudCAoZmlsdGVyX2xpc3QgKHZhbHVlIGwpKSBlXG5cbiAgbW9kdWxlIEludFNldCA9IFNldC5NYWtlIChJbnQpXG5cbiAgbGV0IGZvcl9hbGwgZm4gZGF0YSA9XG4gICAgbGV0IG1heWJlX3VwZGF0ZSBhY2MgaSB2ID0gaWYgZm4gdiB0aGVuIGFjYyBlbHNlIEludFNldC5hZGQgaSBhY2MgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBsZXQgcmVjIGZvbGQgaSBhY2MgPSBmdW5jdGlvblxuICAgICAgICB8IHYgOjogdGwgLT4gZm9sZCAoaSArIDEpIChtYXliZV91cGRhdGUgYWNjIGkgdikgdGxcbiAgICAgICAgfCBbXSAtPiBhY2NcbiAgICAgIGluXG4gICAgICBmb2xkIDAgSW50U2V0LmVtcHR5XG4gICAgaW5cbiAgICBsZXQgdXBkYXRlX2lkeF9hZnRlciBpIGYgYWNjID1cbiAgICAgIEludFNldC5tYXAgKGZ1biBpJyAtPiBpZiBpJyA+PSBpIHRoZW4gZiBpJyAxIGVsc2UgaScpIGFjY1xuICAgIGluXG4gICAgbGV0IGYgPVxuICAgICBmdW4gYWNjIC0+IGZ1bmN0aW9uXG4gICAgICAgfCBTZXQgeCAtPiBpbml0IHhcbiAgICAgICB8IFBhdGNoIHVwZGF0ZXMgLT5cbiAgICAgICAgICAgTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgICAgICAoZnVuIGFjYyAtPiBmdW5jdGlvblxuICAgICAgICAgICAgICAgfCBYIChpLCBpJykgLT5cbiAgICAgICAgICAgICAgICAgICBpZiBJbnRTZXQubWVtIGkgYWNjID0gSW50U2V0Lm1lbSBpJyBhY2MgdGhlbiBhY2NcbiAgICAgICAgICAgICAgICAgICBlbHNlIGlmIEludFNldC5tZW0gaSBhY2MgdGhlblxuICAgICAgICAgICAgICAgICAgICAgSW50U2V0LmFkZCBpJyAoSW50U2V0LnJlbW92ZSBpIGFjYylcbiAgICAgICAgICAgICAgICAgICBlbHNlIEludFNldC5hZGQgaSAoSW50U2V0LnJlbW92ZSBpJyBhY2MpXG4gICAgICAgICAgICAgICB8IFIgaSAtPiB1cGRhdGVfaWR4X2FmdGVyIGkgKCAtICkgKEludFNldC5yZW1vdmUgaSBhY2MpXG4gICAgICAgICAgICAgICB8IEkgKGksIHYpIC0+XG4gICAgICAgICAgICAgICAgICAgbGV0IGFjYyA9IHVwZGF0ZV9pZHhfYWZ0ZXIgaSAoICsgKSBhY2MgaW5cbiAgICAgICAgICAgICAgICAgICBtYXliZV91cGRhdGUgYWNjIGkgdlxuICAgICAgICAgICAgICAgfCBVIChpLCB2KSAtPiBtYXliZV91cGRhdGUgKEludFNldC5yZW1vdmUgaSBhY2MpIGkgdilcbiAgICAgICAgICAgICBhY2MgdXBkYXRlc1xuICAgIGluXG4gICAgUmVhY3QuUy5mb2xkIGYgKGluaXQgKHZhbHVlIGRhdGEpKSAoZXZlbnQgZGF0YSlcbiAgICB8PiBSZWFjdC5TLm1hcCBJbnRTZXQuaXNfZW1wdHlcbmVuZFxuXG5tb2R1bGUgUk1hcCAoTSA6IE1hcC5TKSA9IHN0cnVjdFxuICBtb2R1bGUgRGF0YSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgZGF0YSA9ICdhIE0udFxuICAgIHR5cGUgJ2EgcCA9IFsgYEFkZCBvZiBNLmtleSAqICdhIHwgYERlbCBvZiBNLmtleSBdXG4gICAgdHlwZSAnYSBwYXRjaCA9ICdhIHAgbGlzdFxuXG4gICAgbGV0IG1lcmdlX3AgcCBzID1cbiAgICAgIG1hdGNoIHAgd2l0aCBgQWRkIChrLCBhKSAtPiBNLmFkZCBrIGEgcyB8IGBEZWwgayAtPiBNLnJlbW92ZSBrIHNcblxuICAgIGxldCBtZXJnZSBwIGFjYyA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYWNjIHAgLT4gbWVyZ2VfcCBwIGFjYykgYWNjIHBcbiAgICBsZXQgbWFwX3AgZiA9IGZ1bmN0aW9uIGBBZGQgKGssIGEpIC0+IGBBZGQgKGssIGYgYSkgfCBgRGVsIGsgLT4gYERlbCBrXG4gICAgbGV0IG1hcF9wYXRjaCBmID0gTGlzdC5tYXAgKG1hcF9wIGYpXG4gICAgbGV0IG1hcF9kYXRhIGYgZCA9IE0ubWFwIGYgZFxuICAgIGxldCBlbXB0eSA9IE0uZW1wdHlcbiAgICBsZXQgZXF1YWwgZiA9IE0uZXF1YWwgZlxuXG4gICAgbGV0IGRpZmYgfmVxIHggeSA9XG4gICAgICBsZXQgbSA9XG4gICAgICAgIGxldCBnIF9rZXkgdiB3ID1cbiAgICAgICAgICBtYXRjaCAodiwgdykgd2l0aFxuICAgICAgICAgIHwgU29tZSB2LCBTb21lIHcgd2hlbiBlcSB2IHcgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBfLCBTb21lIHcgLT4gU29tZSAoYFUgdylcbiAgICAgICAgICB8IFNvbWUgXywgTm9uZSAtPiBTb21lIGBEXG4gICAgICAgICAgfCBOb25lLCBTb21lIHYgLT4gU29tZSAoYEEgdilcbiAgICAgICAgICB8IE5vbmUsIE5vbmUgLT4gTm9uZVxuICAgICAgICBpblxuICAgICAgICBNLm1lcmdlIGcgeCB5XG4gICAgICBhbmQgZyBrZXkgeCBhY2MgPVxuICAgICAgICBtYXRjaCB4IHdpdGhcbiAgICAgICAgfCBgVSB2IC0+IGBEZWwga2V5IDo6IGBBZGQgKGtleSwgdikgOjogYWNjXG4gICAgICAgIHwgYEQgLT4gYERlbCBrZXkgOjogYWNjXG4gICAgICAgIHwgYEEgdiAtPiBgQWRkIChrZXksIHYpIDo6IGFjY1xuICAgICAgYW5kIGFjYyA9IFtdIGluXG4gICAgICBMaXN0LnJldiAoTS5mb2xkIGcgbSBhY2MpXG4gIGVuZFxuXG4gIGluY2x1ZGUgTWFrZSAoRGF0YSlcblxuICBsZXQgZmlsdGVyIHByZWQgbSA9XG4gICAgbGV0IGNvbnZlcnRfcCA9IGZ1bmN0aW9uXG4gICAgICB8IGBBZGQgKGssIHYpIC0+IGlmIHByZWQgayB2IHRoZW4gWyBgQWRkIChrLCB2KSBdIGVsc2UgW11cbiAgICAgIHwgYERlbCBrIC0+IFsgYERlbCBrIF1cbiAgICBpblxuXG4gICAgbGV0IGZpbHRlcl9lID0gZnVuY3Rpb25cbiAgICAgIHwgU2V0IG0gLT4gU2V0IChNLmZpbHRlciBwcmVkIG0pXG4gICAgICB8IFBhdGNoIHAgLT4gUGF0Y2ggKExpc3QuY29uY2F0IChMaXN0Lm1hcCBjb252ZXJ0X3AgcCkpXG4gICAgaW5cblxuICAgIGxldCBlID0gUmVhY3QuRS5tYXAgZmlsdGVyX2UgKGV2ZW50IG0pIGluXG4gICAgZnJvbV9ldmVudCAoTS5maWx0ZXIgcHJlZCAodmFsdWUgbSkpIGVcbmVuZFxuIl0sImlnbm9yZUxpc3QiOlswXX19XX0=
