// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.9.1

//# unitInfo: Provides: Polytables
//# unitInfo: Requires: Stdlib, Stdlib__Map
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Map = global_data.Stdlib__Map,
    compare = runtime.caml_compare,
    T = caml_call1(Stdlib_Map[1], [0, compare]);
   function create(param){return [0, T[1]];}
   var c = [0, -1], cst_Polytables_get = "Polytables.get";
   function make_key(param){c[1] = c[1] + 1 | 0; return [0, c[1], [0, 0]];}
   function set(table, param, value){
    var r = param[2], k = param[1];
    table[1] =
     caml_call3
      (T[2], k, function(param){r[1] = [0, value]; return 0;}, table[1]);
    return 0;
   }
   function get(table, param){
    var r = param[2], k = param[1];
    caml_call1(caml_call2(T[17], k, table[1]), 0);
    var match = r[1];
    if(! match) return caml_call1(Stdlib[2], cst_Polytables_get);
    var v = match[1];
    r[1] = 0;
    return v;
   }
   function remove(table, param){
    var k = param[1];
    table[1] = caml_call2(T[6], k, table[1]);
    return 0;
   }
   function clear(table){table[1] = T[1]; return 0;}
   var Polytables = [0, create, make_key, set, get, remove, clear];
   runtime.caml_register_global(3, Polytables, "Polytables");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9seXRhYmxlcy5jbWEuanMiLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9seXRhYmxlcy5jbWEuanMiLCJuYW1lcyI6WyJydW50aW1lIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwiU3RkbGliIiwiU3RkbGliX01hcCIsImNvbXBhcmUiLCJUIiwiY3JlYXRlIiwicGFyYW0iLCJjIiwiY3N0X1BvbHl0YWJsZXNfZ2V0IiwibWFrZV9rZXkiLCJzZXQiLCJ0YWJsZSIsInZhbHVlIiwiciIsImsiLCJnZXQiLCJtYXRjaCIsInYiLCJyZW1vdmUiLCJjbGVhciIsIlBvbHl0YWJsZXMiXSwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9ob21lL2JlZWxpZ3VsLy5vcGFtL29jYW1sLTUuMi4wL2xpYi9vY3NpZ2Vuc2VydmVyL3BvbHl0YWJsZXMvcG9seXRhYmxlcy5tbCJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxJQUFBO0FBQUEsWUFBQUMsT0FBQUMsT0NnQ2dCLGlCQUFXO0FBQUEsT0FBQUMsSURoQzNCLFNBQUFDLHFCQUFBO0FBQUEsWUFBQUMsU0FBQUgsT0NvQ0UscUJBQ0EseUJBQVk7QUFBQSxZQUFBSSxJQUFBQyxPQUFBTCxPQUFBTTtBQUFBQSxRQUFBQyxJQUVOLFVBQUFDLElBQUE7QUFBQSxJQUNHO0FBQUE7QUFBQSx5QkFBQVIsT0FBbUIsNEJBQWU7QUFBQSxJQUFRO0FBQUE7QUFBQSxZQUFBUyxJQUFBSixPQUFBTDtBQUFBQSxRQUFBTyxJQUU3QyxVQUFBQyxJQUFBO0FBQUEsSUFDTjtBQUFBLFFBQUFFLFFBQW9CO0FBQUEsZ0JBS1YsZ0RBQXlCO0FBQUEsUUFBQUMsSUFMZjtBQUFBLElBR2hCO0FBQUEsSUFDQTtBQUFBLEdBQytCO0FBQUEsWUFBQUMsT0FBQVAsT0FBQUw7QUFBQUEsUUFBQVEsSUFFMUI7QUFBQSxJQUFnRDtBQUFBLElBQWlCO0FBQUE7QUFBQSxZQUFBSyxNQUFBUixPQUNuRCwwQkFBZ0I7QUFBQSxPQUFBUyxhRG5EekMiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqIE9jc2lnZW5cbiAqIENvcHlyaWdodCAoQykgMjAwOVxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxuKCoqXG4gICBAYXV0aG9yIFZpbmNlbnQgQmFsYXRcbiAgIEBhdXRob3IgSsOpcsO0bWUgVm91aWxsb25cbiopXG5cbnR5cGUgJ2Ega2V5ID0gaW50ICogJ2Egb3B0aW9uIHJlZlxuXG5tb2R1bGUgVCA9IE1hcC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICBlbmQpXG5cbnR5cGUgdCA9ICh1bml0IC0+IHVuaXQpIFQudCByZWZcblxubGV0IGNyZWF0ZSAoKSA9IHJlZiBULmVtcHR5XG5sZXQgYyA9IHJlZiAoLTEpXG5cbmxldCBtYWtlX2tleSAoKSA9XG4gIGMgOj0gIWMgKyAxO1xuICAhYywgcmVmIE5vbmVcblxubGV0IHNldCB+KHRhYmxlIDogdCkgfmtleTooKGssIHIpIDogJ2Ega2V5KSB+KHZhbHVlIDogJ2EpID1cbiAgdGFibGUgOj0gVC5hZGQgayAoZnVuICgpIC0+IHIgOj0gU29tZSB2YWx1ZSkgIXRhYmxlXG5cbmxldCBnZXQgfih0YWJsZSA6IHQpIH5rZXk6KChrLCByKSA6ICdhIGtleSkgPVxuICAoVC5maW5kIGsgIXRhYmxlKSAoKTtcbiAgbWF0Y2ggIXIgd2l0aFxuICB8IFNvbWUgdiAtPlxuICAgICAgciA6PSBOb25lO1xuICAgICAgdlxuICB8IE5vbmUgLT4gZmFpbHdpdGggXCJQb2x5dGFibGVzLmdldFwiXG5cbmxldCByZW1vdmUgfih0YWJsZSA6IHQpIH5rZXk6KChrLCBfcikgOiAnYSBrZXkpID0gdGFibGUgOj0gVC5yZW1vdmUgayAhdGFibGVcbmxldCBjbGVhciB+KHRhYmxlIDogdCkgPSB0YWJsZSA6PSBULmVtcHR5XG4iXSwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
